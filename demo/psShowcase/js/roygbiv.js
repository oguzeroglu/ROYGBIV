/*! jQuery v3.2.1 | (c) JS Foundation and other contributors | jquery.org/license */
!function(a,b){"use strict";"object"==typeof module&&"object"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error("jQuery requires a window with a document");return b(a)}:b(a)}("undefined"!=typeof window?window:this,function(a,b){"use strict";var c=[],d=a.document,e=Object.getPrototypeOf,f=c.slice,g=c.concat,h=c.push,i=c.indexOf,j={},k=j.toString,l=j.hasOwnProperty,m=l.toString,n=m.call(Object),o={};function p(a,b){b=b||d;var c=b.createElement("script");c.text=a,b.head.appendChild(c).parentNode.removeChild(c)}var q="3.2.1",r=function(a,b){return new r.fn.init(a,b)},s=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,t=/^-ms-/,u=/-([a-z])/g,v=function(a,b){return b.toUpperCase()};r.fn=r.prototype={jquery:q,constructor:r,length:0,toArray:function(){return f.call(this)},get:function(a){return null==a?f.call(this):a<0?this[a+this.length]:this[a]},pushStack:function(a){var b=r.merge(this.constructor(),a);return b.prevObject=this,b},each:function(a){return r.each(this,a)},map:function(a){return this.pushStack(r.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(f.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(a<0?b:0);return this.pushStack(c>=0&&c<b?[this[c]]:[])},end:function(){return this.prevObject||this.constructor()},push:h,sort:c.sort,splice:c.splice},r.extend=r.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for("boolean"==typeof g&&(j=g,g=arguments[h]||{},h++),"object"==typeof g||r.isFunction(g)||(g={}),h===i&&(g=this,h--);h<i;h++)if(null!=(a=arguments[h]))for(b in a)c=g[b],d=a[b],g!==d&&(j&&d&&(r.isPlainObject(d)||(e=Array.isArray(d)))?(e?(e=!1,f=c&&Array.isArray(c)?c:[]):f=c&&r.isPlainObject(c)?c:{},g[b]=r.extend(j,f,d)):void 0!==d&&(g[b]=d));return g},r.extend({expando:"jQuery"+(q+Math.random()).replace(/\D/g,""),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return"function"===r.type(a)},isWindow:function(a){return null!=a&&a===a.window},isNumeric:function(a){var b=r.type(a);return("number"===b||"string"===b)&&!isNaN(a-parseFloat(a))},isPlainObject:function(a){var b,c;return!(!a||"[object Object]"!==k.call(a))&&(!(b=e(a))||(c=l.call(b,"constructor")&&b.constructor,"function"==typeof c&&m.call(c)===n))},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},type:function(a){return null==a?a+"":"object"==typeof a||"function"==typeof a?j[k.call(a)]||"object":typeof a},globalEval:function(a){p(a)},camelCase:function(a){return a.replace(t,"ms-").replace(u,v)},each:function(a,b){var c,d=0;if(w(a)){for(c=a.length;d<c;d++)if(b.call(a[d],d,a[d])===!1)break}else for(d in a)if(b.call(a[d],d,a[d])===!1)break;return a},trim:function(a){return null==a?"":(a+"").replace(s,"")},makeArray:function(a,b){var c=b||[];return null!=a&&(w(Object(a))?r.merge(c,"string"==typeof a?[a]:a):h.call(c,a)),c},inArray:function(a,b,c){return null==b?-1:i.call(b,a,c)},merge:function(a,b){for(var c=+b.length,d=0,e=a.length;d<c;d++)a[e++]=b[d];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;f<g;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,e,f=0,h=[];if(w(a))for(d=a.length;f<d;f++)e=b(a[f],f,c),null!=e&&h.push(e);else for(f in a)e=b(a[f],f,c),null!=e&&h.push(e);return g.apply([],h)},guid:1,proxy:function(a,b){var c,d,e;if("string"==typeof b&&(c=a[b],b=a,a=c),r.isFunction(a))return d=f.call(arguments,2),e=function(){return a.apply(b||this,d.concat(f.call(arguments)))},e.guid=a.guid=a.guid||r.guid++,e},now:Date.now,support:o}),"function"==typeof Symbol&&(r.fn[Symbol.iterator]=c[Symbol.iterator]),r.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),function(a,b){j["[object "+b+"]"]=b.toLowerCase()});function w(a){var b=!!a&&"length"in a&&a.length,c=r.type(a);return"function"!==c&&!r.isWindow(a)&&("array"===c||0===b||"number"==typeof b&&b>0&&b-1 in a)}var x=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u="sizzle"+1*new Date,v=a.document,w=0,x=0,y=ha(),z=ha(),A=ha(),B=function(a,b){return a===b&&(l=!0),0},C={}.hasOwnProperty,D=[],E=D.pop,F=D.push,G=D.push,H=D.slice,I=function(a,b){for(var c=0,d=a.length;c<d;c++)if(a[c]===b)return c;return-1},J="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",K="[\\x20\\t\\r\\n\\f]",L="(?:\\\\.|[\\w-]|[^\0-\\xa0])+",M="\\["+K+"*("+L+")(?:"+K+"*([*^$|!~]?=)"+K+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+L+"))|)"+K+"*\\]",N=":("+L+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+M+")*)|.*)\\)|)",O=new RegExp(K+"+","g"),P=new RegExp("^"+K+"+|((?:^|[^\\\\])(?:\\\\.)*)"+K+"+$","g"),Q=new RegExp("^"+K+"*,"+K+"*"),R=new RegExp("^"+K+"*([>+~]|"+K+")"+K+"*"),S=new RegExp("="+K+"*([^\\]'\"]*?)"+K+"*\\]","g"),T=new RegExp(N),U=new RegExp("^"+L+"$"),V={ID:new RegExp("^#("+L+")"),CLASS:new RegExp("^\\.("+L+")"),TAG:new RegExp("^("+L+"|[*])"),ATTR:new RegExp("^"+M),PSEUDO:new RegExp("^"+N),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+K+"*(even|odd|(([+-]|)(\\d*)n|)"+K+"*(?:([+-]|)"+K+"*(\\d+)|))"+K+"*\\)|)","i"),bool:new RegExp("^(?:"+J+")$","i"),needsContext:new RegExp("^"+K+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+K+"*((?:-\\d)?\\d*)"+K+"*\\)|)(?=[^-]|$)","i")},W=/^(?:input|select|textarea|button)$/i,X=/^h\d$/i,Y=/^[^{]+\{\s*\[native \w/,Z=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,$=/[+~]/,_=new RegExp("\\\\([\\da-f]{1,6}"+K+"?|("+K+")|.)","ig"),aa=function(a,b,c){var d="0x"+b-65536;return d!==d||c?b:d<0?String.fromCharCode(d+65536):String.fromCharCode(d>>10|55296,1023&d|56320)},ba=/([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,ca=function(a,b){return b?"\0"===a?"\ufffd":a.slice(0,-1)+"\\"+a.charCodeAt(a.length-1).toString(16)+" ":"\\"+a},da=function(){m()},ea=ta(function(a){return a.disabled===!0&&("form"in a||"label"in a)},{dir:"parentNode",next:"legend"});try{G.apply(D=H.call(v.childNodes),v.childNodes),D[v.childNodes.length].nodeType}catch(fa){G={apply:D.length?function(a,b){F.apply(a,H.call(b))}:function(a,b){var c=a.length,d=0;while(a[c++]=b[d++]);a.length=c-1}}}function ga(a,b,d,e){var f,h,j,k,l,o,r,s=b&&b.ownerDocument,w=b?b.nodeType:9;if(d=d||[],"string"!=typeof a||!a||1!==w&&9!==w&&11!==w)return d;if(!e&&((b?b.ownerDocument||b:v)!==n&&m(b),b=b||n,p)){if(11!==w&&(l=Z.exec(a)))if(f=l[1]){if(9===w){if(!(j=b.getElementById(f)))return d;if(j.id===f)return d.push(j),d}else if(s&&(j=s.getElementById(f))&&t(b,j)&&j.id===f)return d.push(j),d}else{if(l[2])return G.apply(d,b.getElementsByTagName(a)),d;if((f=l[3])&&c.getElementsByClassName&&b.getElementsByClassName)return G.apply(d,b.getElementsByClassName(f)),d}if(c.qsa&&!A[a+" "]&&(!q||!q.test(a))){if(1!==w)s=b,r=a;else if("object"!==b.nodeName.toLowerCase()){(k=b.getAttribute("id"))?k=k.replace(ba,ca):b.setAttribute("id",k=u),o=g(a),h=o.length;while(h--)o[h]="#"+k+" "+sa(o[h]);r=o.join(","),s=$.test(a)&&qa(b.parentNode)||b}if(r)try{return G.apply(d,s.querySelectorAll(r)),d}catch(x){}finally{k===u&&b.removeAttribute("id")}}}return i(a.replace(P,"$1"),b,d,e)}function ha(){var a=[];function b(c,e){return a.push(c+" ")>d.cacheLength&&delete b[a.shift()],b[c+" "]=e}return b}function ia(a){return a[u]=!0,a}function ja(a){var b=n.createElement("fieldset");try{return!!a(b)}catch(c){return!1}finally{b.parentNode&&b.parentNode.removeChild(b),b=null}}function ka(a,b){var c=a.split("|"),e=c.length;while(e--)d.attrHandle[c[e]]=b}function la(a,b){var c=b&&a,d=c&&1===a.nodeType&&1===b.nodeType&&a.sourceIndex-b.sourceIndex;if(d)return d;if(c)while(c=c.nextSibling)if(c===b)return-1;return a?1:-1}function ma(a){return function(b){var c=b.nodeName.toLowerCase();return"input"===c&&b.type===a}}function na(a){return function(b){var c=b.nodeName.toLowerCase();return("input"===c||"button"===c)&&b.type===a}}function oa(a){return function(b){return"form"in b?b.parentNode&&b.disabled===!1?"label"in b?"label"in b.parentNode?b.parentNode.disabled===a:b.disabled===a:b.isDisabled===a||b.isDisabled!==!a&&ea(b)===a:b.disabled===a:"label"in b&&b.disabled===a}}function pa(a){return ia(function(b){return b=+b,ia(function(c,d){var e,f=a([],c.length,b),g=f.length;while(g--)c[e=f[g]]&&(c[e]=!(d[e]=c[e]))})})}function qa(a){return a&&"undefined"!=typeof a.getElementsByTagName&&a}c=ga.support={},f=ga.isXML=function(a){var b=a&&(a.ownerDocument||a).documentElement;return!!b&&"HTML"!==b.nodeName},m=ga.setDocument=function(a){var b,e,g=a?a.ownerDocument||a:v;return g!==n&&9===g.nodeType&&g.documentElement?(n=g,o=n.documentElement,p=!f(n),v!==n&&(e=n.defaultView)&&e.top!==e&&(e.addEventListener?e.addEventListener("unload",da,!1):e.attachEvent&&e.attachEvent("onunload",da)),c.attributes=ja(function(a){return a.className="i",!a.getAttribute("className")}),c.getElementsByTagName=ja(function(a){return a.appendChild(n.createComment("")),!a.getElementsByTagName("*").length}),c.getElementsByClassName=Y.test(n.getElementsByClassName),c.getById=ja(function(a){return o.appendChild(a).id=u,!n.getElementsByName||!n.getElementsByName(u).length}),c.getById?(d.filter.ID=function(a){var b=a.replace(_,aa);return function(a){return a.getAttribute("id")===b}},d.find.ID=function(a,b){if("undefined"!=typeof b.getElementById&&p){var c=b.getElementById(a);return c?[c]:[]}}):(d.filter.ID=function(a){var b=a.replace(_,aa);return function(a){var c="undefined"!=typeof a.getAttributeNode&&a.getAttributeNode("id");return c&&c.value===b}},d.find.ID=function(a,b){if("undefined"!=typeof b.getElementById&&p){var c,d,e,f=b.getElementById(a);if(f){if(c=f.getAttributeNode("id"),c&&c.value===a)return[f];e=b.getElementsByName(a),d=0;while(f=e[d++])if(c=f.getAttributeNode("id"),c&&c.value===a)return[f]}return[]}}),d.find.TAG=c.getElementsByTagName?function(a,b){return"undefined"!=typeof b.getElementsByTagName?b.getElementsByTagName(a):c.qsa?b.querySelectorAll(a):void 0}:function(a,b){var c,d=[],e=0,f=b.getElementsByTagName(a);if("*"===a){while(c=f[e++])1===c.nodeType&&d.push(c);return d}return f},d.find.CLASS=c.getElementsByClassName&&function(a,b){if("undefined"!=typeof b.getElementsByClassName&&p)return b.getElementsByClassName(a)},r=[],q=[],(c.qsa=Y.test(n.querySelectorAll))&&(ja(function(a){o.appendChild(a).innerHTML="<a id='"+u+"'></a><select id='"+u+"-\r\\' msallowcapture=''><option selected=''></option></select>",a.querySelectorAll("[msallowcapture^='']").length&&q.push("[*^$]="+K+"*(?:''|\"\")"),a.querySelectorAll("[selected]").length||q.push("\\["+K+"*(?:value|"+J+")"),a.querySelectorAll("[id~="+u+"-]").length||q.push("~="),a.querySelectorAll(":checked").length||q.push(":checked"),a.querySelectorAll("a#"+u+"+*").length||q.push(".#.+[+~]")}),ja(function(a){a.innerHTML="<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";var b=n.createElement("input");b.setAttribute("type","hidden"),a.appendChild(b).setAttribute("name","D"),a.querySelectorAll("[name=d]").length&&q.push("name"+K+"*[*^$|!~]?="),2!==a.querySelectorAll(":enabled").length&&q.push(":enabled",":disabled"),o.appendChild(a).disabled=!0,2!==a.querySelectorAll(":disabled").length&&q.push(":enabled",":disabled"),a.querySelectorAll("*,:x"),q.push(",.*:")})),(c.matchesSelector=Y.test(s=o.matches||o.webkitMatchesSelector||o.mozMatchesSelector||o.oMatchesSelector||o.msMatchesSelector))&&ja(function(a){c.disconnectedMatch=s.call(a,"*"),s.call(a,"[s!='']:x"),r.push("!=",N)}),q=q.length&&new RegExp(q.join("|")),r=r.length&&new RegExp(r.join("|")),b=Y.test(o.compareDocumentPosition),t=b||Y.test(o.contains)?function(a,b){var c=9===a.nodeType?a.documentElement:a,d=b&&b.parentNode;return a===d||!(!d||1!==d.nodeType||!(c.contains?c.contains(d):a.compareDocumentPosition&&16&a.compareDocumentPosition(d)))}:function(a,b){if(b)while(b=b.parentNode)if(b===a)return!0;return!1},B=b?function(a,b){if(a===b)return l=!0,0;var d=!a.compareDocumentPosition-!b.compareDocumentPosition;return d?d:(d=(a.ownerDocument||a)===(b.ownerDocument||b)?a.compareDocumentPosition(b):1,1&d||!c.sortDetached&&b.compareDocumentPosition(a)===d?a===n||a.ownerDocument===v&&t(v,a)?-1:b===n||b.ownerDocument===v&&t(v,b)?1:k?I(k,a)-I(k,b):0:4&d?-1:1)}:function(a,b){if(a===b)return l=!0,0;var c,d=0,e=a.parentNode,f=b.parentNode,g=[a],h=[b];if(!e||!f)return a===n?-1:b===n?1:e?-1:f?1:k?I(k,a)-I(k,b):0;if(e===f)return la(a,b);c=a;while(c=c.parentNode)g.unshift(c);c=b;while(c=c.parentNode)h.unshift(c);while(g[d]===h[d])d++;return d?la(g[d],h[d]):g[d]===v?-1:h[d]===v?1:0},n):n},ga.matches=function(a,b){return ga(a,null,null,b)},ga.matchesSelector=function(a,b){if((a.ownerDocument||a)!==n&&m(a),b=b.replace(S,"='$1']"),c.matchesSelector&&p&&!A[b+" "]&&(!r||!r.test(b))&&(!q||!q.test(b)))try{var d=s.call(a,b);if(d||c.disconnectedMatch||a.document&&11!==a.document.nodeType)return d}catch(e){}return ga(b,n,null,[a]).length>0},ga.contains=function(a,b){return(a.ownerDocument||a)!==n&&m(a),t(a,b)},ga.attr=function(a,b){(a.ownerDocument||a)!==n&&m(a);var e=d.attrHandle[b.toLowerCase()],f=e&&C.call(d.attrHandle,b.toLowerCase())?e(a,b,!p):void 0;return void 0!==f?f:c.attributes||!p?a.getAttribute(b):(f=a.getAttributeNode(b))&&f.specified?f.value:null},ga.escape=function(a){return(a+"").replace(ba,ca)},ga.error=function(a){throw new Error("Syntax error, unrecognized expression: "+a)},ga.uniqueSort=function(a){var b,d=[],e=0,f=0;if(l=!c.detectDuplicates,k=!c.sortStable&&a.slice(0),a.sort(B),l){while(b=a[f++])b===a[f]&&(e=d.push(f));while(e--)a.splice(d[e],1)}return k=null,a},e=ga.getText=function(a){var b,c="",d=0,f=a.nodeType;if(f){if(1===f||9===f||11===f){if("string"==typeof a.textContent)return a.textContent;for(a=a.firstChild;a;a=a.nextSibling)c+=e(a)}else if(3===f||4===f)return a.nodeValue}else while(b=a[d++])c+=e(b);return c},d=ga.selectors={cacheLength:50,createPseudo:ia,match:V,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(a){return a[1]=a[1].replace(_,aa),a[3]=(a[3]||a[4]||a[5]||"").replace(_,aa),"~="===a[2]&&(a[3]=" "+a[3]+" "),a.slice(0,4)},CHILD:function(a){return a[1]=a[1].toLowerCase(),"nth"===a[1].slice(0,3)?(a[3]||ga.error(a[0]),a[4]=+(a[4]?a[5]+(a[6]||1):2*("even"===a[3]||"odd"===a[3])),a[5]=+(a[7]+a[8]||"odd"===a[3])):a[3]&&ga.error(a[0]),a},PSEUDO:function(a){var b,c=!a[6]&&a[2];return V.CHILD.test(a[0])?null:(a[3]?a[2]=a[4]||a[5]||"":c&&T.test(c)&&(b=g(c,!0))&&(b=c.indexOf(")",c.length-b)-c.length)&&(a[0]=a[0].slice(0,b),a[2]=c.slice(0,b)),a.slice(0,3))}},filter:{TAG:function(a){var b=a.replace(_,aa).toLowerCase();return"*"===a?function(){return!0}:function(a){return a.nodeName&&a.nodeName.toLowerCase()===b}},CLASS:function(a){var b=y[a+" "];return b||(b=new RegExp("(^|"+K+")"+a+"("+K+"|$)"))&&y(a,function(a){return b.test("string"==typeof a.className&&a.className||"undefined"!=typeof a.getAttribute&&a.getAttribute("class")||"")})},ATTR:function(a,b,c){return function(d){var e=ga.attr(d,a);return null==e?"!="===b:!b||(e+="","="===b?e===c:"!="===b?e!==c:"^="===b?c&&0===e.indexOf(c):"*="===b?c&&e.indexOf(c)>-1:"$="===b?c&&e.slice(-c.length)===c:"~="===b?(" "+e.replace(O," ")+" ").indexOf(c)>-1:"|="===b&&(e===c||e.slice(0,c.length+1)===c+"-"))}},CHILD:function(a,b,c,d,e){var f="nth"!==a.slice(0,3),g="last"!==a.slice(-4),h="of-type"===b;return 1===d&&0===e?function(a){return!!a.parentNode}:function(b,c,i){var j,k,l,m,n,o,p=f!==g?"nextSibling":"previousSibling",q=b.parentNode,r=h&&b.nodeName.toLowerCase(),s=!i&&!h,t=!1;if(q){if(f){while(p){m=b;while(m=m[p])if(h?m.nodeName.toLowerCase()===r:1===m.nodeType)return!1;o=p="only"===a&&!o&&"nextSibling"}return!0}if(o=[g?q.firstChild:q.lastChild],g&&s){m=q,l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),j=k[a]||[],n=j[0]===w&&j[1],t=n&&j[2],m=n&&q.childNodes[n];while(m=++n&&m&&m[p]||(t=n=0)||o.pop())if(1===m.nodeType&&++t&&m===b){k[a]=[w,n,t];break}}else if(s&&(m=b,l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),j=k[a]||[],n=j[0]===w&&j[1],t=n),t===!1)while(m=++n&&m&&m[p]||(t=n=0)||o.pop())if((h?m.nodeName.toLowerCase()===r:1===m.nodeType)&&++t&&(s&&(l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),k[a]=[w,t]),m===b))break;return t-=e,t===d||t%d===0&&t/d>=0}}},PSEUDO:function(a,b){var c,e=d.pseudos[a]||d.setFilters[a.toLowerCase()]||ga.error("unsupported pseudo: "+a);return e[u]?e(b):e.length>1?(c=[a,a,"",b],d.setFilters.hasOwnProperty(a.toLowerCase())?ia(function(a,c){var d,f=e(a,b),g=f.length;while(g--)d=I(a,f[g]),a[d]=!(c[d]=f[g])}):function(a){return e(a,0,c)}):e}},pseudos:{not:ia(function(a){var b=[],c=[],d=h(a.replace(P,"$1"));return d[u]?ia(function(a,b,c,e){var f,g=d(a,null,e,[]),h=a.length;while(h--)(f=g[h])&&(a[h]=!(b[h]=f))}):function(a,e,f){return b[0]=a,d(b,null,f,c),b[0]=null,!c.pop()}}),has:ia(function(a){return function(b){return ga(a,b).length>0}}),contains:ia(function(a){return a=a.replace(_,aa),function(b){return(b.textContent||b.innerText||e(b)).indexOf(a)>-1}}),lang:ia(function(a){return U.test(a||"")||ga.error("unsupported lang: "+a),a=a.replace(_,aa).toLowerCase(),function(b){var c;do if(c=p?b.lang:b.getAttribute("xml:lang")||b.getAttribute("lang"))return c=c.toLowerCase(),c===a||0===c.indexOf(a+"-");while((b=b.parentNode)&&1===b.nodeType);return!1}}),target:function(b){var c=a.location&&a.location.hash;return c&&c.slice(1)===b.id},root:function(a){return a===o},focus:function(a){return a===n.activeElement&&(!n.hasFocus||n.hasFocus())&&!!(a.type||a.href||~a.tabIndex)},enabled:oa(!1),disabled:oa(!0),checked:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&!!a.checked||"option"===b&&!!a.selected},selected:function(a){return a.parentNode&&a.parentNode.selectedIndex,a.selected===!0},empty:function(a){for(a=a.firstChild;a;a=a.nextSibling)if(a.nodeType<6)return!1;return!0},parent:function(a){return!d.pseudos.empty(a)},header:function(a){return X.test(a.nodeName)},input:function(a){return W.test(a.nodeName)},button:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&"button"===a.type||"button"===b},text:function(a){var b;return"input"===a.nodeName.toLowerCase()&&"text"===a.type&&(null==(b=a.getAttribute("type"))||"text"===b.toLowerCase())},first:pa(function(){return[0]}),last:pa(function(a,b){return[b-1]}),eq:pa(function(a,b,c){return[c<0?c+b:c]}),even:pa(function(a,b){for(var c=0;c<b;c+=2)a.push(c);return a}),odd:pa(function(a,b){for(var c=1;c<b;c+=2)a.push(c);return a}),lt:pa(function(a,b,c){for(var d=c<0?c+b:c;--d>=0;)a.push(d);return a}),gt:pa(function(a,b,c){for(var d=c<0?c+b:c;++d<b;)a.push(d);return a})}},d.pseudos.nth=d.pseudos.eq;for(b in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})d.pseudos[b]=ma(b);for(b in{submit:!0,reset:!0})d.pseudos[b]=na(b);function ra(){}ra.prototype=d.filters=d.pseudos,d.setFilters=new ra,g=ga.tokenize=function(a,b){var c,e,f,g,h,i,j,k=z[a+" "];if(k)return b?0:k.slice(0);h=a,i=[],j=d.preFilter;while(h){c&&!(e=Q.exec(h))||(e&&(h=h.slice(e[0].length)||h),i.push(f=[])),c=!1,(e=R.exec(h))&&(c=e.shift(),f.push({value:c,type:e[0].replace(P," ")}),h=h.slice(c.length));for(g in d.filter)!(e=V[g].exec(h))||j[g]&&!(e=j[g](e))||(c=e.shift(),f.push({value:c,type:g,matches:e}),h=h.slice(c.length));if(!c)break}return b?h.length:h?ga.error(a):z(a,i).slice(0)};function sa(a){for(var b=0,c=a.length,d="";b<c;b++)d+=a[b].value;return d}function ta(a,b,c){var d=b.dir,e=b.next,f=e||d,g=c&&"parentNode"===f,h=x++;return b.first?function(b,c,e){while(b=b[d])if(1===b.nodeType||g)return a(b,c,e);return!1}:function(b,c,i){var j,k,l,m=[w,h];if(i){while(b=b[d])if((1===b.nodeType||g)&&a(b,c,i))return!0}else while(b=b[d])if(1===b.nodeType||g)if(l=b[u]||(b[u]={}),k=l[b.uniqueID]||(l[b.uniqueID]={}),e&&e===b.nodeName.toLowerCase())b=b[d]||b;else{if((j=k[f])&&j[0]===w&&j[1]===h)return m[2]=j[2];if(k[f]=m,m[2]=a(b,c,i))return!0}return!1}}function ua(a){return a.length>1?function(b,c,d){var e=a.length;while(e--)if(!a[e](b,c,d))return!1;return!0}:a[0]}function va(a,b,c){for(var d=0,e=b.length;d<e;d++)ga(a,b[d],c);return c}function wa(a,b,c,d,e){for(var f,g=[],h=0,i=a.length,j=null!=b;h<i;h++)(f=a[h])&&(c&&!c(f,d,e)||(g.push(f),j&&b.push(h)));return g}function xa(a,b,c,d,e,f){return d&&!d[u]&&(d=xa(d)),e&&!e[u]&&(e=xa(e,f)),ia(function(f,g,h,i){var j,k,l,m=[],n=[],o=g.length,p=f||va(b||"*",h.nodeType?[h]:h,[]),q=!a||!f&&b?p:wa(p,m,a,h,i),r=c?e||(f?a:o||d)?[]:g:q;if(c&&c(q,r,h,i),d){j=wa(r,n),d(j,[],h,i),k=j.length;while(k--)(l=j[k])&&(r[n[k]]=!(q[n[k]]=l))}if(f){if(e||a){if(e){j=[],k=r.length;while(k--)(l=r[k])&&j.push(q[k]=l);e(null,r=[],j,i)}k=r.length;while(k--)(l=r[k])&&(j=e?I(f,l):m[k])>-1&&(f[j]=!(g[j]=l))}}else r=wa(r===g?r.splice(o,r.length):r),e?e(null,g,r,i):G.apply(g,r)})}function ya(a){for(var b,c,e,f=a.length,g=d.relative[a[0].type],h=g||d.relative[" "],i=g?1:0,k=ta(function(a){return a===b},h,!0),l=ta(function(a){return I(b,a)>-1},h,!0),m=[function(a,c,d){var e=!g&&(d||c!==j)||((b=c).nodeType?k(a,c,d):l(a,c,d));return b=null,e}];i<f;i++)if(c=d.relative[a[i].type])m=[ta(ua(m),c)];else{if(c=d.filter[a[i].type].apply(null,a[i].matches),c[u]){for(e=++i;e<f;e++)if(d.relative[a[e].type])break;return xa(i>1&&ua(m),i>1&&sa(a.slice(0,i-1).concat({value:" "===a[i-2].type?"*":""})).replace(P,"$1"),c,i<e&&ya(a.slice(i,e)),e<f&&ya(a=a.slice(e)),e<f&&sa(a))}m.push(c)}return ua(m)}function za(a,b){var c=b.length>0,e=a.length>0,f=function(f,g,h,i,k){var l,o,q,r=0,s="0",t=f&&[],u=[],v=j,x=f||e&&d.find.TAG("*",k),y=w+=null==v?1:Math.random()||.1,z=x.length;for(k&&(j=g===n||g||k);s!==z&&null!=(l=x[s]);s++){if(e&&l){o=0,g||l.ownerDocument===n||(m(l),h=!p);while(q=a[o++])if(q(l,g||n,h)){i.push(l);break}k&&(w=y)}c&&((l=!q&&l)&&r--,f&&t.push(l))}if(r+=s,c&&s!==r){o=0;while(q=b[o++])q(t,u,g,h);if(f){if(r>0)while(s--)t[s]||u[s]||(u[s]=E.call(i));u=wa(u)}G.apply(i,u),k&&!f&&u.length>0&&r+b.length>1&&ga.uniqueSort(i)}return k&&(w=y,j=v),t};return c?ia(f):f}return h=ga.compile=function(a,b){var c,d=[],e=[],f=A[a+" "];if(!f){b||(b=g(a)),c=b.length;while(c--)f=ya(b[c]),f[u]?d.push(f):e.push(f);f=A(a,za(e,d)),f.selector=a}return f},i=ga.select=function(a,b,c,e){var f,i,j,k,l,m="function"==typeof a&&a,n=!e&&g(a=m.selector||a);if(c=c||[],1===n.length){if(i=n[0]=n[0].slice(0),i.length>2&&"ID"===(j=i[0]).type&&9===b.nodeType&&p&&d.relative[i[1].type]){if(b=(d.find.ID(j.matches[0].replace(_,aa),b)||[])[0],!b)return c;m&&(b=b.parentNode),a=a.slice(i.shift().value.length)}f=V.needsContext.test(a)?0:i.length;while(f--){if(j=i[f],d.relative[k=j.type])break;if((l=d.find[k])&&(e=l(j.matches[0].replace(_,aa),$.test(i[0].type)&&qa(b.parentNode)||b))){if(i.splice(f,1),a=e.length&&sa(i),!a)return G.apply(c,e),c;break}}}return(m||h(a,n))(e,b,!p,c,!b||$.test(a)&&qa(b.parentNode)||b),c},c.sortStable=u.split("").sort(B).join("")===u,c.detectDuplicates=!!l,m(),c.sortDetached=ja(function(a){return 1&a.compareDocumentPosition(n.createElement("fieldset"))}),ja(function(a){return a.innerHTML="<a href='#'></a>","#"===a.firstChild.getAttribute("href")})||ka("type|href|height|width",function(a,b,c){if(!c)return a.getAttribute(b,"type"===b.toLowerCase()?1:2)}),c.attributes&&ja(function(a){return a.innerHTML="<input/>",a.firstChild.setAttribute("value",""),""===a.firstChild.getAttribute("value")})||ka("value",function(a,b,c){if(!c&&"input"===a.nodeName.toLowerCase())return a.defaultValue}),ja(function(a){return null==a.getAttribute("disabled")})||ka(J,function(a,b,c){var d;if(!c)return a[b]===!0?b.toLowerCase():(d=a.getAttributeNode(b))&&d.specified?d.value:null}),ga}(a);r.find=x,r.expr=x.selectors,r.expr[":"]=r.expr.pseudos,r.uniqueSort=r.unique=x.uniqueSort,r.text=x.getText,r.isXMLDoc=x.isXML,r.contains=x.contains,r.escapeSelector=x.escape;var y=function(a,b,c){var d=[],e=void 0!==c;while((a=a[b])&&9!==a.nodeType)if(1===a.nodeType){if(e&&r(a).is(c))break;d.push(a)}return d},z=function(a,b){for(var c=[];a;a=a.nextSibling)1===a.nodeType&&a!==b&&c.push(a);return c},A=r.expr.match.needsContext;function B(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()}var C=/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i,D=/^.[^:#\[\.,]*$/;function E(a,b,c){return r.isFunction(b)?r.grep(a,function(a,d){return!!b.call(a,d,a)!==c}):b.nodeType?r.grep(a,function(a){return a===b!==c}):"string"!=typeof b?r.grep(a,function(a){return i.call(b,a)>-1!==c}):D.test(b)?r.filter(b,a,c):(b=r.filter(b,a),r.grep(a,function(a){return i.call(b,a)>-1!==c&&1===a.nodeType}))}r.filter=function(a,b,c){var d=b[0];return c&&(a=":not("+a+")"),1===b.length&&1===d.nodeType?r.find.matchesSelector(d,a)?[d]:[]:r.find.matches(a,r.grep(b,function(a){return 1===a.nodeType}))},r.fn.extend({find:function(a){var b,c,d=this.length,e=this;if("string"!=typeof a)return this.pushStack(r(a).filter(function(){for(b=0;b<d;b++)if(r.contains(e[b],this))return!0}));for(c=this.pushStack([]),b=0;b<d;b++)r.find(a,e[b],c);return d>1?r.uniqueSort(c):c},filter:function(a){return this.pushStack(E(this,a||[],!1))},not:function(a){return this.pushStack(E(this,a||[],!0))},is:function(a){return!!E(this,"string"==typeof a&&A.test(a)?r(a):a||[],!1).length}});var F,G=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,H=r.fn.init=function(a,b,c){var e,f;if(!a)return this;if(c=c||F,"string"==typeof a){if(e="<"===a[0]&&">"===a[a.length-1]&&a.length>=3?[null,a,null]:G.exec(a),!e||!e[1]&&b)return!b||b.jquery?(b||c).find(a):this.constructor(b).find(a);if(e[1]){if(b=b instanceof r?b[0]:b,r.merge(this,r.parseHTML(e[1],b&&b.nodeType?b.ownerDocument||b:d,!0)),C.test(e[1])&&r.isPlainObject(b))for(e in b)r.isFunction(this[e])?this[e](b[e]):this.attr(e,b[e]);return this}return f=d.getElementById(e[2]),f&&(this[0]=f,this.length=1),this}return a.nodeType?(this[0]=a,this.length=1,this):r.isFunction(a)?void 0!==c.ready?c.ready(a):a(r):r.makeArray(a,this)};H.prototype=r.fn,F=r(d);var I=/^(?:parents|prev(?:Until|All))/,J={children:!0,contents:!0,next:!0,prev:!0};r.fn.extend({has:function(a){var b=r(a,this),c=b.length;return this.filter(function(){for(var a=0;a<c;a++)if(r.contains(this,b[a]))return!0})},closest:function(a,b){var c,d=0,e=this.length,f=[],g="string"!=typeof a&&r(a);if(!A.test(a))for(;d<e;d++)for(c=this[d];c&&c!==b;c=c.parentNode)if(c.nodeType<11&&(g?g.index(c)>-1:1===c.nodeType&&r.find.matchesSelector(c,a))){f.push(c);break}return this.pushStack(f.length>1?r.uniqueSort(f):f)},index:function(a){return a?"string"==typeof a?i.call(r(a),this[0]):i.call(this,a.jquery?a[0]:a):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(a,b){return this.pushStack(r.uniqueSort(r.merge(this.get(),r(a,b))))},addBack:function(a){return this.add(null==a?this.prevObject:this.prevObject.filter(a))}});function K(a,b){while((a=a[b])&&1!==a.nodeType);return a}r.each({parent:function(a){var b=a.parentNode;return b&&11!==b.nodeType?b:null},parents:function(a){return y(a,"parentNode")},parentsUntil:function(a,b,c){return y(a,"parentNode",c)},next:function(a){return K(a,"nextSibling")},prev:function(a){return K(a,"previousSibling")},nextAll:function(a){return y(a,"nextSibling")},prevAll:function(a){return y(a,"previousSibling")},nextUntil:function(a,b,c){return y(a,"nextSibling",c)},prevUntil:function(a,b,c){return y(a,"previousSibling",c)},siblings:function(a){return z((a.parentNode||{}).firstChild,a)},children:function(a){return z(a.firstChild)},contents:function(a){return B(a,"iframe")?a.contentDocument:(B(a,"template")&&(a=a.content||a),r.merge([],a.childNodes))}},function(a,b){r.fn[a]=function(c,d){var e=r.map(this,b,c);return"Until"!==a.slice(-5)&&(d=c),d&&"string"==typeof d&&(e=r.filter(d,e)),this.length>1&&(J[a]||r.uniqueSort(e),I.test(a)&&e.reverse()),this.pushStack(e)}});var L=/[^\x20\t\r\n\f]+/g;function M(a){var b={};return r.each(a.match(L)||[],function(a,c){b[c]=!0}),b}r.Callbacks=function(a){a="string"==typeof a?M(a):r.extend({},a);var b,c,d,e,f=[],g=[],h=-1,i=function(){for(e=e||a.once,d=b=!0;g.length;h=-1){c=g.shift();while(++h<f.length)f[h].apply(c[0],c[1])===!1&&a.stopOnFalse&&(h=f.length,c=!1)}a.memory||(c=!1),b=!1,e&&(f=c?[]:"")},j={add:function(){return f&&(c&&!b&&(h=f.length-1,g.push(c)),function d(b){r.each(b,function(b,c){r.isFunction(c)?a.unique&&j.has(c)||f.push(c):c&&c.length&&"string"!==r.type(c)&&d(c)})}(arguments),c&&!b&&i()),this},remove:function(){return r.each(arguments,function(a,b){var c;while((c=r.inArray(b,f,c))>-1)f.splice(c,1),c<=h&&h--}),this},has:function(a){return a?r.inArray(a,f)>-1:f.length>0},empty:function(){return f&&(f=[]),this},disable:function(){return e=g=[],f=c="",this},disabled:function(){return!f},lock:function(){return e=g=[],c||b||(f=c=""),this},locked:function(){return!!e},fireWith:function(a,c){return e||(c=c||[],c=[a,c.slice?c.slice():c],g.push(c),b||i()),this},fire:function(){return j.fireWith(this,arguments),this},fired:function(){return!!d}};return j};function N(a){return a}function O(a){throw a}function P(a,b,c,d){var e;try{a&&r.isFunction(e=a.promise)?e.call(a).done(b).fail(c):a&&r.isFunction(e=a.then)?e.call(a,b,c):b.apply(void 0,[a].slice(d))}catch(a){c.apply(void 0,[a])}}r.extend({Deferred:function(b){var c=[["notify","progress",r.Callbacks("memory"),r.Callbacks("memory"),2],["resolve","done",r.Callbacks("once memory"),r.Callbacks("once memory"),0,"resolved"],["reject","fail",r.Callbacks("once memory"),r.Callbacks("once memory"),1,"rejected"]],d="pending",e={state:function(){return d},always:function(){return f.done(arguments).fail(arguments),this},"catch":function(a){return e.then(null,a)},pipe:function(){var a=arguments;return r.Deferred(function(b){r.each(c,function(c,d){var e=r.isFunction(a[d[4]])&&a[d[4]];f[d[1]](function(){var a=e&&e.apply(this,arguments);a&&r.isFunction(a.promise)?a.promise().progress(b.notify).done(b.resolve).fail(b.reject):b[d[0]+"With"](this,e?[a]:arguments)})}),a=null}).promise()},then:function(b,d,e){var f=0;function g(b,c,d,e){return function(){var h=this,i=arguments,j=function(){var a,j;if(!(b<f)){if(a=d.apply(h,i),a===c.promise())throw new TypeError("Thenable self-resolution");j=a&&("object"==typeof a||"function"==typeof a)&&a.then,r.isFunction(j)?e?j.call(a,g(f,c,N,e),g(f,c,O,e)):(f++,j.call(a,g(f,c,N,e),g(f,c,O,e),g(f,c,N,c.notifyWith))):(d!==N&&(h=void 0,i=[a]),(e||c.resolveWith)(h,i))}},k=e?j:function(){try{j()}catch(a){r.Deferred.exceptionHook&&r.Deferred.exceptionHook(a,k.stackTrace),b+1>=f&&(d!==O&&(h=void 0,i=[a]),c.rejectWith(h,i))}};b?k():(r.Deferred.getStackHook&&(k.stackTrace=r.Deferred.getStackHook()),a.setTimeout(k))}}return r.Deferred(function(a){c[0][3].add(g(0,a,r.isFunction(e)?e:N,a.notifyWith)),c[1][3].add(g(0,a,r.isFunction(b)?b:N)),c[2][3].add(g(0,a,r.isFunction(d)?d:O))}).promise()},promise:function(a){return null!=a?r.extend(a,e):e}},f={};return r.each(c,function(a,b){var g=b[2],h=b[5];e[b[1]]=g.add,h&&g.add(function(){d=h},c[3-a][2].disable,c[0][2].lock),g.add(b[3].fire),f[b[0]]=function(){return f[b[0]+"With"](this===f?void 0:this,arguments),this},f[b[0]+"With"]=g.fireWith}),e.promise(f),b&&b.call(f,f),f},when:function(a){var b=arguments.length,c=b,d=Array(c),e=f.call(arguments),g=r.Deferred(),h=function(a){return function(c){d[a]=this,e[a]=arguments.length>1?f.call(arguments):c,--b||g.resolveWith(d,e)}};if(b<=1&&(P(a,g.done(h(c)).resolve,g.reject,!b),"pending"===g.state()||r.isFunction(e[c]&&e[c].then)))return g.then();while(c--)P(e[c],h(c),g.reject);return g.promise()}});var Q=/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;r.Deferred.exceptionHook=function(b,c){a.console&&a.console.warn&&b&&Q.test(b.name)&&a.console.warn("jQuery.Deferred exception: "+b.message,b.stack,c)},r.readyException=function(b){a.setTimeout(function(){throw b})};var R=r.Deferred();r.fn.ready=function(a){return R.then(a)["catch"](function(a){r.readyException(a)}),this},r.extend({isReady:!1,readyWait:1,ready:function(a){(a===!0?--r.readyWait:r.isReady)||(r.isReady=!0,a!==!0&&--r.readyWait>0||R.resolveWith(d,[r]))}}),r.ready.then=R.then;function S(){d.removeEventListener("DOMContentLoaded",S),
a.removeEventListener("load",S),r.ready()}"complete"===d.readyState||"loading"!==d.readyState&&!d.documentElement.doScroll?a.setTimeout(r.ready):(d.addEventListener("DOMContentLoaded",S),a.addEventListener("load",S));var T=function(a,b,c,d,e,f,g){var h=0,i=a.length,j=null==c;if("object"===r.type(c)){e=!0;for(h in c)T(a,b,h,c[h],!0,f,g)}else if(void 0!==d&&(e=!0,r.isFunction(d)||(g=!0),j&&(g?(b.call(a,d),b=null):(j=b,b=function(a,b,c){return j.call(r(a),c)})),b))for(;h<i;h++)b(a[h],c,g?d:d.call(a[h],h,b(a[h],c)));return e?a:j?b.call(a):i?b(a[0],c):f},U=function(a){return 1===a.nodeType||9===a.nodeType||!+a.nodeType};function V(){this.expando=r.expando+V.uid++}V.uid=1,V.prototype={cache:function(a){var b=a[this.expando];return b||(b={},U(a)&&(a.nodeType?a[this.expando]=b:Object.defineProperty(a,this.expando,{value:b,configurable:!0}))),b},set:function(a,b,c){var d,e=this.cache(a);if("string"==typeof b)e[r.camelCase(b)]=c;else for(d in b)e[r.camelCase(d)]=b[d];return e},get:function(a,b){return void 0===b?this.cache(a):a[this.expando]&&a[this.expando][r.camelCase(b)]},access:function(a,b,c){return void 0===b||b&&"string"==typeof b&&void 0===c?this.get(a,b):(this.set(a,b,c),void 0!==c?c:b)},remove:function(a,b){var c,d=a[this.expando];if(void 0!==d){if(void 0!==b){Array.isArray(b)?b=b.map(r.camelCase):(b=r.camelCase(b),b=b in d?[b]:b.match(L)||[]),c=b.length;while(c--)delete d[b[c]]}(void 0===b||r.isEmptyObject(d))&&(a.nodeType?a[this.expando]=void 0:delete a[this.expando])}},hasData:function(a){var b=a[this.expando];return void 0!==b&&!r.isEmptyObject(b)}};var W=new V,X=new V,Y=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,Z=/[A-Z]/g;function $(a){return"true"===a||"false"!==a&&("null"===a?null:a===+a+""?+a:Y.test(a)?JSON.parse(a):a)}function _(a,b,c){var d;if(void 0===c&&1===a.nodeType)if(d="data-"+b.replace(Z,"-$&").toLowerCase(),c=a.getAttribute(d),"string"==typeof c){try{c=$(c)}catch(e){}X.set(a,b,c)}else c=void 0;return c}r.extend({hasData:function(a){return X.hasData(a)||W.hasData(a)},data:function(a,b,c){return X.access(a,b,c)},removeData:function(a,b){X.remove(a,b)},_data:function(a,b,c){return W.access(a,b,c)},_removeData:function(a,b){W.remove(a,b)}}),r.fn.extend({data:function(a,b){var c,d,e,f=this[0],g=f&&f.attributes;if(void 0===a){if(this.length&&(e=X.get(f),1===f.nodeType&&!W.get(f,"hasDataAttrs"))){c=g.length;while(c--)g[c]&&(d=g[c].name,0===d.indexOf("data-")&&(d=r.camelCase(d.slice(5)),_(f,d,e[d])));W.set(f,"hasDataAttrs",!0)}return e}return"object"==typeof a?this.each(function(){X.set(this,a)}):T(this,function(b){var c;if(f&&void 0===b){if(c=X.get(f,a),void 0!==c)return c;if(c=_(f,a),void 0!==c)return c}else this.each(function(){X.set(this,a,b)})},null,b,arguments.length>1,null,!0)},removeData:function(a){return this.each(function(){X.remove(this,a)})}}),r.extend({queue:function(a,b,c){var d;if(a)return b=(b||"fx")+"queue",d=W.get(a,b),c&&(!d||Array.isArray(c)?d=W.access(a,b,r.makeArray(c)):d.push(c)),d||[]},dequeue:function(a,b){b=b||"fx";var c=r.queue(a,b),d=c.length,e=c.shift(),f=r._queueHooks(a,b),g=function(){r.dequeue(a,b)};"inprogress"===e&&(e=c.shift(),d--),e&&("fx"===b&&c.unshift("inprogress"),delete f.stop,e.call(a,g,f)),!d&&f&&f.empty.fire()},_queueHooks:function(a,b){var c=b+"queueHooks";return W.get(a,c)||W.access(a,c,{empty:r.Callbacks("once memory").add(function(){W.remove(a,[b+"queue",c])})})}}),r.fn.extend({queue:function(a,b){var c=2;return"string"!=typeof a&&(b=a,a="fx",c--),arguments.length<c?r.queue(this[0],a):void 0===b?this:this.each(function(){var c=r.queue(this,a,b);r._queueHooks(this,a),"fx"===a&&"inprogress"!==c[0]&&r.dequeue(this,a)})},dequeue:function(a){return this.each(function(){r.dequeue(this,a)})},clearQueue:function(a){return this.queue(a||"fx",[])},promise:function(a,b){var c,d=1,e=r.Deferred(),f=this,g=this.length,h=function(){--d||e.resolveWith(f,[f])};"string"!=typeof a&&(b=a,a=void 0),a=a||"fx";while(g--)c=W.get(f[g],a+"queueHooks"),c&&c.empty&&(d++,c.empty.add(h));return h(),e.promise(b)}});var aa=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,ba=new RegExp("^(?:([+-])=|)("+aa+")([a-z%]*)$","i"),ca=["Top","Right","Bottom","Left"],da=function(a,b){return a=b||a,"none"===a.style.display||""===a.style.display&&r.contains(a.ownerDocument,a)&&"none"===r.css(a,"display")},ea=function(a,b,c,d){var e,f,g={};for(f in b)g[f]=a.style[f],a.style[f]=b[f];e=c.apply(a,d||[]);for(f in b)a.style[f]=g[f];return e};function fa(a,b,c,d){var e,f=1,g=20,h=d?function(){return d.cur()}:function(){return r.css(a,b,"")},i=h(),j=c&&c[3]||(r.cssNumber[b]?"":"px"),k=(r.cssNumber[b]||"px"!==j&&+i)&&ba.exec(r.css(a,b));if(k&&k[3]!==j){j=j||k[3],c=c||[],k=+i||1;do f=f||".5",k/=f,r.style(a,b,k+j);while(f!==(f=h()/i)&&1!==f&&--g)}return c&&(k=+k||+i||0,e=c[1]?k+(c[1]+1)*c[2]:+c[2],d&&(d.unit=j,d.start=k,d.end=e)),e}var ga={};function ha(a){var b,c=a.ownerDocument,d=a.nodeName,e=ga[d];return e?e:(b=c.body.appendChild(c.createElement(d)),e=r.css(b,"display"),b.parentNode.removeChild(b),"none"===e&&(e="block"),ga[d]=e,e)}function ia(a,b){for(var c,d,e=[],f=0,g=a.length;f<g;f++)d=a[f],d.style&&(c=d.style.display,b?("none"===c&&(e[f]=W.get(d,"display")||null,e[f]||(d.style.display="")),""===d.style.display&&da(d)&&(e[f]=ha(d))):"none"!==c&&(e[f]="none",W.set(d,"display",c)));for(f=0;f<g;f++)null!=e[f]&&(a[f].style.display=e[f]);return a}r.fn.extend({show:function(){return ia(this,!0)},hide:function(){return ia(this)},toggle:function(a){return"boolean"==typeof a?a?this.show():this.hide():this.each(function(){da(this)?r(this).show():r(this).hide()})}});var ja=/^(?:checkbox|radio)$/i,ka=/<([a-z][^\/\0>\x20\t\r\n\f]+)/i,la=/^$|\/(?:java|ecma)script/i,ma={option:[1,"<select multiple='multiple'>","</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};ma.optgroup=ma.option,ma.tbody=ma.tfoot=ma.colgroup=ma.caption=ma.thead,ma.th=ma.td;function na(a,b){var c;return c="undefined"!=typeof a.getElementsByTagName?a.getElementsByTagName(b||"*"):"undefined"!=typeof a.querySelectorAll?a.querySelectorAll(b||"*"):[],void 0===b||b&&B(a,b)?r.merge([a],c):c}function oa(a,b){for(var c=0,d=a.length;c<d;c++)W.set(a[c],"globalEval",!b||W.get(b[c],"globalEval"))}var pa=/<|&#?\w+;/;function qa(a,b,c,d,e){for(var f,g,h,i,j,k,l=b.createDocumentFragment(),m=[],n=0,o=a.length;n<o;n++)if(f=a[n],f||0===f)if("object"===r.type(f))r.merge(m,f.nodeType?[f]:f);else if(pa.test(f)){g=g||l.appendChild(b.createElement("div")),h=(ka.exec(f)||["",""])[1].toLowerCase(),i=ma[h]||ma._default,g.innerHTML=i[1]+r.htmlPrefilter(f)+i[2],k=i[0];while(k--)g=g.lastChild;r.merge(m,g.childNodes),g=l.firstChild,g.textContent=""}else m.push(b.createTextNode(f));l.textContent="",n=0;while(f=m[n++])if(d&&r.inArray(f,d)>-1)e&&e.push(f);else if(j=r.contains(f.ownerDocument,f),g=na(l.appendChild(f),"script"),j&&oa(g),c){k=0;while(f=g[k++])la.test(f.type||"")&&c.push(f)}return l}!function(){var a=d.createDocumentFragment(),b=a.appendChild(d.createElement("div")),c=d.createElement("input");c.setAttribute("type","radio"),c.setAttribute("checked","checked"),c.setAttribute("name","t"),b.appendChild(c),o.checkClone=b.cloneNode(!0).cloneNode(!0).lastChild.checked,b.innerHTML="<textarea>x</textarea>",o.noCloneChecked=!!b.cloneNode(!0).lastChild.defaultValue}();var ra=d.documentElement,sa=/^key/,ta=/^(?:mouse|pointer|contextmenu|drag|drop)|click/,ua=/^([^.]*)(?:\.(.+)|)/;function va(){return!0}function wa(){return!1}function xa(){try{return d.activeElement}catch(a){}}function ya(a,b,c,d,e,f){var g,h;if("object"==typeof b){"string"!=typeof c&&(d=d||c,c=void 0);for(h in b)ya(a,h,c,d,b[h],f);return a}if(null==d&&null==e?(e=c,d=c=void 0):null==e&&("string"==typeof c?(e=d,d=void 0):(e=d,d=c,c=void 0)),e===!1)e=wa;else if(!e)return a;return 1===f&&(g=e,e=function(a){return r().off(a),g.apply(this,arguments)},e.guid=g.guid||(g.guid=r.guid++)),a.each(function(){r.event.add(this,b,e,d,c)})}r.event={global:{},add:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,n,o,p,q=W.get(a);if(q){c.handler&&(f=c,c=f.handler,e=f.selector),e&&r.find.matchesSelector(ra,e),c.guid||(c.guid=r.guid++),(i=q.events)||(i=q.events={}),(g=q.handle)||(g=q.handle=function(b){return"undefined"!=typeof r&&r.event.triggered!==b.type?r.event.dispatch.apply(a,arguments):void 0}),b=(b||"").match(L)||[""],j=b.length;while(j--)h=ua.exec(b[j])||[],n=p=h[1],o=(h[2]||"").split(".").sort(),n&&(l=r.event.special[n]||{},n=(e?l.delegateType:l.bindType)||n,l=r.event.special[n]||{},k=r.extend({type:n,origType:p,data:d,handler:c,guid:c.guid,selector:e,needsContext:e&&r.expr.match.needsContext.test(e),namespace:o.join(".")},f),(m=i[n])||(m=i[n]=[],m.delegateCount=0,l.setup&&l.setup.call(a,d,o,g)!==!1||a.addEventListener&&a.addEventListener(n,g)),l.add&&(l.add.call(a,k),k.handler.guid||(k.handler.guid=c.guid)),e?m.splice(m.delegateCount++,0,k):m.push(k),r.event.global[n]=!0)}},remove:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,n,o,p,q=W.hasData(a)&&W.get(a);if(q&&(i=q.events)){b=(b||"").match(L)||[""],j=b.length;while(j--)if(h=ua.exec(b[j])||[],n=p=h[1],o=(h[2]||"").split(".").sort(),n){l=r.event.special[n]||{},n=(d?l.delegateType:l.bindType)||n,m=i[n]||[],h=h[2]&&new RegExp("(^|\\.)"+o.join("\\.(?:.*\\.|)")+"(\\.|$)"),g=f=m.length;while(f--)k=m[f],!e&&p!==k.origType||c&&c.guid!==k.guid||h&&!h.test(k.namespace)||d&&d!==k.selector&&("**"!==d||!k.selector)||(m.splice(f,1),k.selector&&m.delegateCount--,l.remove&&l.remove.call(a,k));g&&!m.length&&(l.teardown&&l.teardown.call(a,o,q.handle)!==!1||r.removeEvent(a,n,q.handle),delete i[n])}else for(n in i)r.event.remove(a,n+b[j],c,d,!0);r.isEmptyObject(i)&&W.remove(a,"handle events")}},dispatch:function(a){var b=r.event.fix(a),c,d,e,f,g,h,i=new Array(arguments.length),j=(W.get(this,"events")||{})[b.type]||[],k=r.event.special[b.type]||{};for(i[0]=b,c=1;c<arguments.length;c++)i[c]=arguments[c];if(b.delegateTarget=this,!k.preDispatch||k.preDispatch.call(this,b)!==!1){h=r.event.handlers.call(this,b,j),c=0;while((f=h[c++])&&!b.isPropagationStopped()){b.currentTarget=f.elem,d=0;while((g=f.handlers[d++])&&!b.isImmediatePropagationStopped())b.rnamespace&&!b.rnamespace.test(g.namespace)||(b.handleObj=g,b.data=g.data,e=((r.event.special[g.origType]||{}).handle||g.handler).apply(f.elem,i),void 0!==e&&(b.result=e)===!1&&(b.preventDefault(),b.stopPropagation()))}return k.postDispatch&&k.postDispatch.call(this,b),b.result}},handlers:function(a,b){var c,d,e,f,g,h=[],i=b.delegateCount,j=a.target;if(i&&j.nodeType&&!("click"===a.type&&a.button>=1))for(;j!==this;j=j.parentNode||this)if(1===j.nodeType&&("click"!==a.type||j.disabled!==!0)){for(f=[],g={},c=0;c<i;c++)d=b[c],e=d.selector+" ",void 0===g[e]&&(g[e]=d.needsContext?r(e,this).index(j)>-1:r.find(e,this,null,[j]).length),g[e]&&f.push(d);f.length&&h.push({elem:j,handlers:f})}return j=this,i<b.length&&h.push({elem:j,handlers:b.slice(i)}),h},addProp:function(a,b){Object.defineProperty(r.Event.prototype,a,{enumerable:!0,configurable:!0,get:r.isFunction(b)?function(){if(this.originalEvent)return b(this.originalEvent)}:function(){if(this.originalEvent)return this.originalEvent[a]},set:function(b){Object.defineProperty(this,a,{enumerable:!0,configurable:!0,writable:!0,value:b})}})},fix:function(a){return a[r.expando]?a:new r.Event(a)},special:{load:{noBubble:!0},focus:{trigger:function(){if(this!==xa()&&this.focus)return this.focus(),!1},delegateType:"focusin"},blur:{trigger:function(){if(this===xa()&&this.blur)return this.blur(),!1},delegateType:"focusout"},click:{trigger:function(){if("checkbox"===this.type&&this.click&&B(this,"input"))return this.click(),!1},_default:function(a){return B(a.target,"a")}},beforeunload:{postDispatch:function(a){void 0!==a.result&&a.originalEvent&&(a.originalEvent.returnValue=a.result)}}}},r.removeEvent=function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c)},r.Event=function(a,b){return this instanceof r.Event?(a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||void 0===a.defaultPrevented&&a.returnValue===!1?va:wa,this.target=a.target&&3===a.target.nodeType?a.target.parentNode:a.target,this.currentTarget=a.currentTarget,this.relatedTarget=a.relatedTarget):this.type=a,b&&r.extend(this,b),this.timeStamp=a&&a.timeStamp||r.now(),void(this[r.expando]=!0)):new r.Event(a,b)},r.Event.prototype={constructor:r.Event,isDefaultPrevented:wa,isPropagationStopped:wa,isImmediatePropagationStopped:wa,isSimulated:!1,preventDefault:function(){var a=this.originalEvent;this.isDefaultPrevented=va,a&&!this.isSimulated&&a.preventDefault()},stopPropagation:function(){var a=this.originalEvent;this.isPropagationStopped=va,a&&!this.isSimulated&&a.stopPropagation()},stopImmediatePropagation:function(){var a=this.originalEvent;this.isImmediatePropagationStopped=va,a&&!this.isSimulated&&a.stopImmediatePropagation(),this.stopPropagation()}},r.each({altKey:!0,bubbles:!0,cancelable:!0,changedTouches:!0,ctrlKey:!0,detail:!0,eventPhase:!0,metaKey:!0,pageX:!0,pageY:!0,shiftKey:!0,view:!0,"char":!0,charCode:!0,key:!0,keyCode:!0,button:!0,buttons:!0,clientX:!0,clientY:!0,offsetX:!0,offsetY:!0,pointerId:!0,pointerType:!0,screenX:!0,screenY:!0,targetTouches:!0,toElement:!0,touches:!0,which:function(a){var b=a.button;return null==a.which&&sa.test(a.type)?null!=a.charCode?a.charCode:a.keyCode:!a.which&&void 0!==b&&ta.test(a.type)?1&b?1:2&b?3:4&b?2:0:a.which}},r.event.addProp),r.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(a,b){r.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c,d=this,e=a.relatedTarget,f=a.handleObj;return e&&(e===d||r.contains(d,e))||(a.type=f.origType,c=f.handler.apply(this,arguments),a.type=b),c}}}),r.fn.extend({on:function(a,b,c,d){return ya(this,a,b,c,d)},one:function(a,b,c,d){return ya(this,a,b,c,d,1)},off:function(a,b,c){var d,e;if(a&&a.preventDefault&&a.handleObj)return d=a.handleObj,r(a.delegateTarget).off(d.namespace?d.origType+"."+d.namespace:d.origType,d.selector,d.handler),this;if("object"==typeof a){for(e in a)this.off(e,b,a[e]);return this}return b!==!1&&"function"!=typeof b||(c=b,b=void 0),c===!1&&(c=wa),this.each(function(){r.event.remove(this,a,c,b)})}});var za=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,Aa=/<script|<style|<link/i,Ba=/checked\s*(?:[^=]|=\s*.checked.)/i,Ca=/^true\/(.*)/,Da=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;function Ea(a,b){return B(a,"table")&&B(11!==b.nodeType?b:b.firstChild,"tr")?r(">tbody",a)[0]||a:a}function Fa(a){return a.type=(null!==a.getAttribute("type"))+"/"+a.type,a}function Ga(a){var b=Ca.exec(a.type);return b?a.type=b[1]:a.removeAttribute("type"),a}function Ha(a,b){var c,d,e,f,g,h,i,j;if(1===b.nodeType){if(W.hasData(a)&&(f=W.access(a),g=W.set(b,f),j=f.events)){delete g.handle,g.events={};for(e in j)for(c=0,d=j[e].length;c<d;c++)r.event.add(b,e,j[e][c])}X.hasData(a)&&(h=X.access(a),i=r.extend({},h),X.set(b,i))}}function Ia(a,b){var c=b.nodeName.toLowerCase();"input"===c&&ja.test(a.type)?b.checked=a.checked:"input"!==c&&"textarea"!==c||(b.defaultValue=a.defaultValue)}function Ja(a,b,c,d){b=g.apply([],b);var e,f,h,i,j,k,l=0,m=a.length,n=m-1,q=b[0],s=r.isFunction(q);if(s||m>1&&"string"==typeof q&&!o.checkClone&&Ba.test(q))return a.each(function(e){var f=a.eq(e);s&&(b[0]=q.call(this,e,f.html())),Ja(f,b,c,d)});if(m&&(e=qa(b,a[0].ownerDocument,!1,a,d),f=e.firstChild,1===e.childNodes.length&&(e=f),f||d)){for(h=r.map(na(e,"script"),Fa),i=h.length;l<m;l++)j=e,l!==n&&(j=r.clone(j,!0,!0),i&&r.merge(h,na(j,"script"))),c.call(a[l],j,l);if(i)for(k=h[h.length-1].ownerDocument,r.map(h,Ga),l=0;l<i;l++)j=h[l],la.test(j.type||"")&&!W.access(j,"globalEval")&&r.contains(k,j)&&(j.src?r._evalUrl&&r._evalUrl(j.src):p(j.textContent.replace(Da,""),k))}return a}function Ka(a,b,c){for(var d,e=b?r.filter(b,a):a,f=0;null!=(d=e[f]);f++)c||1!==d.nodeType||r.cleanData(na(d)),d.parentNode&&(c&&r.contains(d.ownerDocument,d)&&oa(na(d,"script")),d.parentNode.removeChild(d));return a}r.extend({htmlPrefilter:function(a){return a.replace(za,"<$1></$2>")},clone:function(a,b,c){var d,e,f,g,h=a.cloneNode(!0),i=r.contains(a.ownerDocument,a);if(!(o.noCloneChecked||1!==a.nodeType&&11!==a.nodeType||r.isXMLDoc(a)))for(g=na(h),f=na(a),d=0,e=f.length;d<e;d++)Ia(f[d],g[d]);if(b)if(c)for(f=f||na(a),g=g||na(h),d=0,e=f.length;d<e;d++)Ha(f[d],g[d]);else Ha(a,h);return g=na(h,"script"),g.length>0&&oa(g,!i&&na(a,"script")),h},cleanData:function(a){for(var b,c,d,e=r.event.special,f=0;void 0!==(c=a[f]);f++)if(U(c)){if(b=c[W.expando]){if(b.events)for(d in b.events)e[d]?r.event.remove(c,d):r.removeEvent(c,d,b.handle);c[W.expando]=void 0}c[X.expando]&&(c[X.expando]=void 0)}}}),r.fn.extend({detach:function(a){return Ka(this,a,!0)},remove:function(a){return Ka(this,a)},text:function(a){return T(this,function(a){return void 0===a?r.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=a)})},null,a,arguments.length)},append:function(){return Ja(this,arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=Ea(this,a);b.appendChild(a)}})},prepend:function(){return Ja(this,arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=Ea(this,a);b.insertBefore(a,b.firstChild)}})},before:function(){return Ja(this,arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this)})},after:function(){return Ja(this,arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this.nextSibling)})},empty:function(){for(var a,b=0;null!=(a=this[b]);b++)1===a.nodeType&&(r.cleanData(na(a,!1)),a.textContent="");return this},clone:function(a,b){return a=null!=a&&a,b=null==b?a:b,this.map(function(){return r.clone(this,a,b)})},html:function(a){return T(this,function(a){var b=this[0]||{},c=0,d=this.length;if(void 0===a&&1===b.nodeType)return b.innerHTML;if("string"==typeof a&&!Aa.test(a)&&!ma[(ka.exec(a)||["",""])[1].toLowerCase()]){a=r.htmlPrefilter(a);try{for(;c<d;c++)b=this[c]||{},1===b.nodeType&&(r.cleanData(na(b,!1)),b.innerHTML=a);b=0}catch(e){}}b&&this.empty().append(a)},null,a,arguments.length)},replaceWith:function(){var a=[];return Ja(this,arguments,function(b){var c=this.parentNode;r.inArray(this,a)<0&&(r.cleanData(na(this)),c&&c.replaceChild(b,this))},a)}}),r.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){r.fn[a]=function(a){for(var c,d=[],e=r(a),f=e.length-1,g=0;g<=f;g++)c=g===f?this:this.clone(!0),r(e[g])[b](c),h.apply(d,c.get());return this.pushStack(d)}});var La=/^margin/,Ma=new RegExp("^("+aa+")(?!px)[a-z%]+$","i"),Na=function(b){var c=b.ownerDocument.defaultView;return c&&c.opener||(c=a),c.getComputedStyle(b)};!function(){function b(){if(i){i.style.cssText="box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%",i.innerHTML="",ra.appendChild(h);var b=a.getComputedStyle(i);c="1%"!==b.top,g="2px"===b.marginLeft,e="4px"===b.width,i.style.marginRight="50%",f="4px"===b.marginRight,ra.removeChild(h),i=null}}var c,e,f,g,h=d.createElement("div"),i=d.createElement("div");i.style&&(i.style.backgroundClip="content-box",i.cloneNode(!0).style.backgroundClip="",o.clearCloneStyle="content-box"===i.style.backgroundClip,h.style.cssText="border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute",h.appendChild(i),r.extend(o,{pixelPosition:function(){return b(),c},boxSizingReliable:function(){return b(),e},pixelMarginRight:function(){return b(),f},reliableMarginLeft:function(){return b(),g}}))}();function Oa(a,b,c){var d,e,f,g,h=a.style;return c=c||Na(a),c&&(g=c.getPropertyValue(b)||c[b],""!==g||r.contains(a.ownerDocument,a)||(g=r.style(a,b)),!o.pixelMarginRight()&&Ma.test(g)&&La.test(b)&&(d=h.width,e=h.minWidth,f=h.maxWidth,h.minWidth=h.maxWidth=h.width=g,g=c.width,h.width=d,h.minWidth=e,h.maxWidth=f)),void 0!==g?g+"":g}function Pa(a,b){return{get:function(){return a()?void delete this.get:(this.get=b).apply(this,arguments)}}}var Qa=/^(none|table(?!-c[ea]).+)/,Ra=/^--/,Sa={position:"absolute",visibility:"hidden",display:"block"},Ta={letterSpacing:"0",fontWeight:"400"},Ua=["Webkit","Moz","ms"],Va=d.createElement("div").style;function Wa(a){if(a in Va)return a;var b=a[0].toUpperCase()+a.slice(1),c=Ua.length;while(c--)if(a=Ua[c]+b,a in Va)return a}function Xa(a){var b=r.cssProps[a];return b||(b=r.cssProps[a]=Wa(a)||a),b}function Ya(a,b,c){var d=ba.exec(b);return d?Math.max(0,d[2]-(c||0))+(d[3]||"px"):b}function Za(a,b,c,d,e){var f,g=0;for(f=c===(d?"border":"content")?4:"width"===b?1:0;f<4;f+=2)"margin"===c&&(g+=r.css(a,c+ca[f],!0,e)),d?("content"===c&&(g-=r.css(a,"padding"+ca[f],!0,e)),"margin"!==c&&(g-=r.css(a,"border"+ca[f]+"Width",!0,e))):(g+=r.css(a,"padding"+ca[f],!0,e),"padding"!==c&&(g+=r.css(a,"border"+ca[f]+"Width",!0,e)));return g}function $a(a,b,c){var d,e=Na(a),f=Oa(a,b,e),g="border-box"===r.css(a,"boxSizing",!1,e);return Ma.test(f)?f:(d=g&&(o.boxSizingReliable()||f===a.style[b]),"auto"===f&&(f=a["offset"+b[0].toUpperCase()+b.slice(1)]),f=parseFloat(f)||0,f+Za(a,b,c||(g?"border":"content"),d,e)+"px")}r.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=Oa(a,"opacity");return""===c?"1":c}}}},cssNumber:{animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":"cssFloat"},style:function(a,b,c,d){if(a&&3!==a.nodeType&&8!==a.nodeType&&a.style){var e,f,g,h=r.camelCase(b),i=Ra.test(b),j=a.style;return i||(b=Xa(h)),g=r.cssHooks[b]||r.cssHooks[h],void 0===c?g&&"get"in g&&void 0!==(e=g.get(a,!1,d))?e:j[b]:(f=typeof c,"string"===f&&(e=ba.exec(c))&&e[1]&&(c=fa(a,b,e),f="number"),null!=c&&c===c&&("number"===f&&(c+=e&&e[3]||(r.cssNumber[h]?"":"px")),o.clearCloneStyle||""!==c||0!==b.indexOf("background")||(j[b]="inherit"),g&&"set"in g&&void 0===(c=g.set(a,c,d))||(i?j.setProperty(b,c):j[b]=c)),void 0)}},css:function(a,b,c,d){var e,f,g,h=r.camelCase(b),i=Ra.test(b);return i||(b=Xa(h)),g=r.cssHooks[b]||r.cssHooks[h],g&&"get"in g&&(e=g.get(a,!0,c)),void 0===e&&(e=Oa(a,b,d)),"normal"===e&&b in Ta&&(e=Ta[b]),""===c||c?(f=parseFloat(e),c===!0||isFinite(f)?f||0:e):e}}),r.each(["height","width"],function(a,b){r.cssHooks[b]={get:function(a,c,d){if(c)return!Qa.test(r.css(a,"display"))||a.getClientRects().length&&a.getBoundingClientRect().width?$a(a,b,d):ea(a,Sa,function(){return $a(a,b,d)})},set:function(a,c,d){var e,f=d&&Na(a),g=d&&Za(a,b,d,"border-box"===r.css(a,"boxSizing",!1,f),f);return g&&(e=ba.exec(c))&&"px"!==(e[3]||"px")&&(a.style[b]=c,c=r.css(a,b)),Ya(a,c,g)}}}),r.cssHooks.marginLeft=Pa(o.reliableMarginLeft,function(a,b){if(b)return(parseFloat(Oa(a,"marginLeft"))||a.getBoundingClientRect().left-ea(a,{marginLeft:0},function(){return a.getBoundingClientRect().left}))+"px"}),r.each({margin:"",padding:"",border:"Width"},function(a,b){r.cssHooks[a+b]={expand:function(c){for(var d=0,e={},f="string"==typeof c?c.split(" "):[c];d<4;d++)e[a+ca[d]+b]=f[d]||f[d-2]||f[0];return e}},La.test(a)||(r.cssHooks[a+b].set=Ya)}),r.fn.extend({css:function(a,b){return T(this,function(a,b,c){var d,e,f={},g=0;if(Array.isArray(b)){for(d=Na(a),e=b.length;g<e;g++)f[b[g]]=r.css(a,b[g],!1,d);return f}return void 0!==c?r.style(a,b,c):r.css(a,b)},a,b,arguments.length>1)}});function _a(a,b,c,d,e){return new _a.prototype.init(a,b,c,d,e)}r.Tween=_a,_a.prototype={constructor:_a,init:function(a,b,c,d,e,f){this.elem=a,this.prop=c,this.easing=e||r.easing._default,this.options=b,this.start=this.now=this.cur(),this.end=d,this.unit=f||(r.cssNumber[c]?"":"px")},cur:function(){var a=_a.propHooks[this.prop];return a&&a.get?a.get(this):_a.propHooks._default.get(this)},run:function(a){var b,c=_a.propHooks[this.prop];return this.options.duration?this.pos=b=r.easing[this.easing](a,this.options.duration*a,0,1,this.options.duration):this.pos=b=a,this.now=(this.end-this.start)*b+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),c&&c.set?c.set(this):_a.propHooks._default.set(this),this}},_a.prototype.init.prototype=_a.prototype,_a.propHooks={_default:{get:function(a){var b;return 1!==a.elem.nodeType||null!=a.elem[a.prop]&&null==a.elem.style[a.prop]?a.elem[a.prop]:(b=r.css(a.elem,a.prop,""),b&&"auto"!==b?b:0)},set:function(a){r.fx.step[a.prop]?r.fx.step[a.prop](a):1!==a.elem.nodeType||null==a.elem.style[r.cssProps[a.prop]]&&!r.cssHooks[a.prop]?a.elem[a.prop]=a.now:r.style(a.elem,a.prop,a.now+a.unit)}}},_a.propHooks.scrollTop=_a.propHooks.scrollLeft={set:function(a){a.elem.nodeType&&a.elem.parentNode&&(a.elem[a.prop]=a.now)}},r.easing={linear:function(a){return a},swing:function(a){return.5-Math.cos(a*Math.PI)/2},_default:"swing"},r.fx=_a.prototype.init,r.fx.step={};var ab,bb,cb=/^(?:toggle|show|hide)$/,db=/queueHooks$/;function eb(){bb&&(d.hidden===!1&&a.requestAnimationFrame?a.requestAnimationFrame(eb):a.setTimeout(eb,r.fx.interval),r.fx.tick())}function fb(){return a.setTimeout(function(){ab=void 0}),ab=r.now()}function gb(a,b){var c,d=0,e={height:a};for(b=b?1:0;d<4;d+=2-b)c=ca[d],e["margin"+c]=e["padding"+c]=a;return b&&(e.opacity=e.width=a),e}function hb(a,b,c){for(var d,e=(kb.tweeners[b]||[]).concat(kb.tweeners["*"]),f=0,g=e.length;f<g;f++)if(d=e[f].call(c,b,a))return d}function ib(a,b,c){var d,e,f,g,h,i,j,k,l="width"in b||"height"in b,m=this,n={},o=a.style,p=a.nodeType&&da(a),q=W.get(a,"fxshow");c.queue||(g=r._queueHooks(a,"fx"),null==g.unqueued&&(g.unqueued=0,h=g.empty.fire,g.empty.fire=function(){g.unqueued||h()}),g.unqueued++,m.always(function(){m.always(function(){g.unqueued--,r.queue(a,"fx").length||g.empty.fire()})}));for(d in b)if(e=b[d],cb.test(e)){if(delete b[d],f=f||"toggle"===e,e===(p?"hide":"show")){if("show"!==e||!q||void 0===q[d])continue;p=!0}n[d]=q&&q[d]||r.style(a,d)}if(i=!r.isEmptyObject(b),i||!r.isEmptyObject(n)){l&&1===a.nodeType&&(c.overflow=[o.overflow,o.overflowX,o.overflowY],j=q&&q.display,null==j&&(j=W.get(a,"display")),k=r.css(a,"display"),"none"===k&&(j?k=j:(ia([a],!0),j=a.style.display||j,k=r.css(a,"display"),ia([a]))),("inline"===k||"inline-block"===k&&null!=j)&&"none"===r.css(a,"float")&&(i||(m.done(function(){o.display=j}),null==j&&(k=o.display,j="none"===k?"":k)),o.display="inline-block")),c.overflow&&(o.overflow="hidden",m.always(function(){o.overflow=c.overflow[0],o.overflowX=c.overflow[1],o.overflowY=c.overflow[2]})),i=!1;for(d in n)i||(q?"hidden"in q&&(p=q.hidden):q=W.access(a,"fxshow",{display:j}),f&&(q.hidden=!p),p&&ia([a],!0),m.done(function(){p||ia([a]),W.remove(a,"fxshow");for(d in n)r.style(a,d,n[d])})),i=hb(p?q[d]:0,d,m),d in q||(q[d]=i.start,p&&(i.end=i.start,i.start=0))}}function jb(a,b){var c,d,e,f,g;for(c in a)if(d=r.camelCase(c),e=b[d],f=a[c],Array.isArray(f)&&(e=f[1],f=a[c]=f[0]),c!==d&&(a[d]=f,delete a[c]),g=r.cssHooks[d],g&&"expand"in g){f=g.expand(f),delete a[d];for(c in f)c in a||(a[c]=f[c],b[c]=e)}else b[d]=e}function kb(a,b,c){var d,e,f=0,g=kb.prefilters.length,h=r.Deferred().always(function(){delete i.elem}),i=function(){if(e)return!1;for(var b=ab||fb(),c=Math.max(0,j.startTime+j.duration-b),d=c/j.duration||0,f=1-d,g=0,i=j.tweens.length;g<i;g++)j.tweens[g].run(f);return h.notifyWith(a,[j,f,c]),f<1&&i?c:(i||h.notifyWith(a,[j,1,0]),h.resolveWith(a,[j]),!1)},j=h.promise({elem:a,props:r.extend({},b),opts:r.extend(!0,{specialEasing:{},easing:r.easing._default},c),originalProperties:b,originalOptions:c,startTime:ab||fb(),duration:c.duration,tweens:[],createTween:function(b,c){var d=r.Tween(a,j.opts,b,c,j.opts.specialEasing[b]||j.opts.easing);return j.tweens.push(d),d},stop:function(b){var c=0,d=b?j.tweens.length:0;if(e)return this;for(e=!0;c<d;c++)j.tweens[c].run(1);return b?(h.notifyWith(a,[j,1,0]),h.resolveWith(a,[j,b])):h.rejectWith(a,[j,b]),this}}),k=j.props;for(jb(k,j.opts.specialEasing);f<g;f++)if(d=kb.prefilters[f].call(j,a,k,j.opts))return r.isFunction(d.stop)&&(r._queueHooks(j.elem,j.opts.queue).stop=r.proxy(d.stop,d)),d;return r.map(k,hb,j),r.isFunction(j.opts.start)&&j.opts.start.call(a,j),j.progress(j.opts.progress).done(j.opts.done,j.opts.complete).fail(j.opts.fail).always(j.opts.always),r.fx.timer(r.extend(i,{elem:a,anim:j,queue:j.opts.queue})),j}r.Animation=r.extend(kb,{tweeners:{"*":[function(a,b){var c=this.createTween(a,b);return fa(c.elem,a,ba.exec(b),c),c}]},tweener:function(a,b){r.isFunction(a)?(b=a,a=["*"]):a=a.match(L);for(var c,d=0,e=a.length;d<e;d++)c=a[d],kb.tweeners[c]=kb.tweeners[c]||[],kb.tweeners[c].unshift(b)},prefilters:[ib],prefilter:function(a,b){b?kb.prefilters.unshift(a):kb.prefilters.push(a)}}),r.speed=function(a,b,c){var d=a&&"object"==typeof a?r.extend({},a):{complete:c||!c&&b||r.isFunction(a)&&a,duration:a,easing:c&&b||b&&!r.isFunction(b)&&b};return r.fx.off?d.duration=0:"number"!=typeof d.duration&&(d.duration in r.fx.speeds?d.duration=r.fx.speeds[d.duration]:d.duration=r.fx.speeds._default),null!=d.queue&&d.queue!==!0||(d.queue="fx"),d.old=d.complete,d.complete=function(){r.isFunction(d.old)&&d.old.call(this),d.queue&&r.dequeue(this,d.queue)},d},r.fn.extend({fadeTo:function(a,b,c,d){return this.filter(da).css("opacity",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){var e=r.isEmptyObject(a),f=r.speed(b,c,d),g=function(){var b=kb(this,r.extend({},a),f);(e||W.get(this,"finish"))&&b.stop(!0)};return g.finish=g,e||f.queue===!1?this.each(g):this.queue(f.queue,g)},stop:function(a,b,c){var d=function(a){var b=a.stop;delete a.stop,b(c)};return"string"!=typeof a&&(c=b,b=a,a=void 0),b&&a!==!1&&this.queue(a||"fx",[]),this.each(function(){var b=!0,e=null!=a&&a+"queueHooks",f=r.timers,g=W.get(this);if(e)g[e]&&g[e].stop&&d(g[e]);else for(e in g)g[e]&&g[e].stop&&db.test(e)&&d(g[e]);for(e=f.length;e--;)f[e].elem!==this||null!=a&&f[e].queue!==a||(f[e].anim.stop(c),b=!1,f.splice(e,1));!b&&c||r.dequeue(this,a)})},finish:function(a){return a!==!1&&(a=a||"fx"),this.each(function(){var b,c=W.get(this),d=c[a+"queue"],e=c[a+"queueHooks"],f=r.timers,g=d?d.length:0;for(c.finish=!0,r.queue(this,a,[]),e&&e.stop&&e.stop.call(this,!0),b=f.length;b--;)f[b].elem===this&&f[b].queue===a&&(f[b].anim.stop(!0),f.splice(b,1));for(b=0;b<g;b++)d[b]&&d[b].finish&&d[b].finish.call(this);delete c.finish})}}),r.each(["toggle","show","hide"],function(a,b){var c=r.fn[b];r.fn[b]=function(a,d,e){return null==a||"boolean"==typeof a?c.apply(this,arguments):this.animate(gb(b,!0),a,d,e)}}),r.each({slideDown:gb("show"),slideUp:gb("hide"),slideToggle:gb("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){r.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),r.timers=[],r.fx.tick=function(){var a,b=0,c=r.timers;for(ab=r.now();b<c.length;b++)a=c[b],a()||c[b]!==a||c.splice(b--,1);c.length||r.fx.stop(),ab=void 0},r.fx.timer=function(a){r.timers.push(a),r.fx.start()},r.fx.interval=13,r.fx.start=function(){bb||(bb=!0,eb())},r.fx.stop=function(){bb=null},r.fx.speeds={slow:600,fast:200,_default:400},r.fn.delay=function(b,c){return b=r.fx?r.fx.speeds[b]||b:b,c=c||"fx",this.queue(c,function(c,d){var e=a.setTimeout(c,b);d.stop=function(){a.clearTimeout(e)}})},function(){var a=d.createElement("input"),b=d.createElement("select"),c=b.appendChild(d.createElement("option"));a.type="checkbox",o.checkOn=""!==a.value,o.optSelected=c.selected,a=d.createElement("input"),a.value="t",a.type="radio",o.radioValue="t"===a.value}();var lb,mb=r.expr.attrHandle;r.fn.extend({attr:function(a,b){return T(this,r.attr,a,b,arguments.length>1)},removeAttr:function(a){return this.each(function(){r.removeAttr(this,a)})}}),r.extend({attr:function(a,b,c){var d,e,f=a.nodeType;if(3!==f&&8!==f&&2!==f)return"undefined"==typeof a.getAttribute?r.prop(a,b,c):(1===f&&r.isXMLDoc(a)||(e=r.attrHooks[b.toLowerCase()]||(r.expr.match.bool.test(b)?lb:void 0)),void 0!==c?null===c?void r.removeAttr(a,b):e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:(a.setAttribute(b,c+""),c):e&&"get"in e&&null!==(d=e.get(a,b))?d:(d=r.find.attr(a,b),
null==d?void 0:d))},attrHooks:{type:{set:function(a,b){if(!o.radioValue&&"radio"===b&&B(a,"input")){var c=a.value;return a.setAttribute("type",b),c&&(a.value=c),b}}}},removeAttr:function(a,b){var c,d=0,e=b&&b.match(L);if(e&&1===a.nodeType)while(c=e[d++])a.removeAttribute(c)}}),lb={set:function(a,b,c){return b===!1?r.removeAttr(a,c):a.setAttribute(c,c),c}},r.each(r.expr.match.bool.source.match(/\w+/g),function(a,b){var c=mb[b]||r.find.attr;mb[b]=function(a,b,d){var e,f,g=b.toLowerCase();return d||(f=mb[g],mb[g]=e,e=null!=c(a,b,d)?g:null,mb[g]=f),e}});var nb=/^(?:input|select|textarea|button)$/i,ob=/^(?:a|area)$/i;r.fn.extend({prop:function(a,b){return T(this,r.prop,a,b,arguments.length>1)},removeProp:function(a){return this.each(function(){delete this[r.propFix[a]||a]})}}),r.extend({prop:function(a,b,c){var d,e,f=a.nodeType;if(3!==f&&8!==f&&2!==f)return 1===f&&r.isXMLDoc(a)||(b=r.propFix[b]||b,e=r.propHooks[b]),void 0!==c?e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:a[b]=c:e&&"get"in e&&null!==(d=e.get(a,b))?d:a[b]},propHooks:{tabIndex:{get:function(a){var b=r.find.attr(a,"tabindex");return b?parseInt(b,10):nb.test(a.nodeName)||ob.test(a.nodeName)&&a.href?0:-1}}},propFix:{"for":"htmlFor","class":"className"}}),o.optSelected||(r.propHooks.selected={get:function(a){var b=a.parentNode;return b&&b.parentNode&&b.parentNode.selectedIndex,null},set:function(a){var b=a.parentNode;b&&(b.selectedIndex,b.parentNode&&b.parentNode.selectedIndex)}}),r.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){r.propFix[this.toLowerCase()]=this});function pb(a){var b=a.match(L)||[];return b.join(" ")}function qb(a){return a.getAttribute&&a.getAttribute("class")||""}r.fn.extend({addClass:function(a){var b,c,d,e,f,g,h,i=0;if(r.isFunction(a))return this.each(function(b){r(this).addClass(a.call(this,b,qb(this)))});if("string"==typeof a&&a){b=a.match(L)||[];while(c=this[i++])if(e=qb(c),d=1===c.nodeType&&" "+pb(e)+" "){g=0;while(f=b[g++])d.indexOf(" "+f+" ")<0&&(d+=f+" ");h=pb(d),e!==h&&c.setAttribute("class",h)}}return this},removeClass:function(a){var b,c,d,e,f,g,h,i=0;if(r.isFunction(a))return this.each(function(b){r(this).removeClass(a.call(this,b,qb(this)))});if(!arguments.length)return this.attr("class","");if("string"==typeof a&&a){b=a.match(L)||[];while(c=this[i++])if(e=qb(c),d=1===c.nodeType&&" "+pb(e)+" "){g=0;while(f=b[g++])while(d.indexOf(" "+f+" ")>-1)d=d.replace(" "+f+" "," ");h=pb(d),e!==h&&c.setAttribute("class",h)}}return this},toggleClass:function(a,b){var c=typeof a;return"boolean"==typeof b&&"string"===c?b?this.addClass(a):this.removeClass(a):r.isFunction(a)?this.each(function(c){r(this).toggleClass(a.call(this,c,qb(this),b),b)}):this.each(function(){var b,d,e,f;if("string"===c){d=0,e=r(this),f=a.match(L)||[];while(b=f[d++])e.hasClass(b)?e.removeClass(b):e.addClass(b)}else void 0!==a&&"boolean"!==c||(b=qb(this),b&&W.set(this,"__className__",b),this.setAttribute&&this.setAttribute("class",b||a===!1?"":W.get(this,"__className__")||""))})},hasClass:function(a){var b,c,d=0;b=" "+a+" ";while(c=this[d++])if(1===c.nodeType&&(" "+pb(qb(c))+" ").indexOf(b)>-1)return!0;return!1}});var rb=/\r/g;r.fn.extend({val:function(a){var b,c,d,e=this[0];{if(arguments.length)return d=r.isFunction(a),this.each(function(c){var e;1===this.nodeType&&(e=d?a.call(this,c,r(this).val()):a,null==e?e="":"number"==typeof e?e+="":Array.isArray(e)&&(e=r.map(e,function(a){return null==a?"":a+""})),b=r.valHooks[this.type]||r.valHooks[this.nodeName.toLowerCase()],b&&"set"in b&&void 0!==b.set(this,e,"value")||(this.value=e))});if(e)return b=r.valHooks[e.type]||r.valHooks[e.nodeName.toLowerCase()],b&&"get"in b&&void 0!==(c=b.get(e,"value"))?c:(c=e.value,"string"==typeof c?c.replace(rb,""):null==c?"":c)}}}),r.extend({valHooks:{option:{get:function(a){var b=r.find.attr(a,"value");return null!=b?b:pb(r.text(a))}},select:{get:function(a){var b,c,d,e=a.options,f=a.selectedIndex,g="select-one"===a.type,h=g?null:[],i=g?f+1:e.length;for(d=f<0?i:g?f:0;d<i;d++)if(c=e[d],(c.selected||d===f)&&!c.disabled&&(!c.parentNode.disabled||!B(c.parentNode,"optgroup"))){if(b=r(c).val(),g)return b;h.push(b)}return h},set:function(a,b){var c,d,e=a.options,f=r.makeArray(b),g=e.length;while(g--)d=e[g],(d.selected=r.inArray(r.valHooks.option.get(d),f)>-1)&&(c=!0);return c||(a.selectedIndex=-1),f}}}}),r.each(["radio","checkbox"],function(){r.valHooks[this]={set:function(a,b){if(Array.isArray(b))return a.checked=r.inArray(r(a).val(),b)>-1}},o.checkOn||(r.valHooks[this].get=function(a){return null===a.getAttribute("value")?"on":a.value})});var sb=/^(?:focusinfocus|focusoutblur)$/;r.extend(r.event,{trigger:function(b,c,e,f){var g,h,i,j,k,m,n,o=[e||d],p=l.call(b,"type")?b.type:b,q=l.call(b,"namespace")?b.namespace.split("."):[];if(h=i=e=e||d,3!==e.nodeType&&8!==e.nodeType&&!sb.test(p+r.event.triggered)&&(p.indexOf(".")>-1&&(q=p.split("."),p=q.shift(),q.sort()),k=p.indexOf(":")<0&&"on"+p,b=b[r.expando]?b:new r.Event(p,"object"==typeof b&&b),b.isTrigger=f?2:3,b.namespace=q.join("."),b.rnamespace=b.namespace?new RegExp("(^|\\.)"+q.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,b.result=void 0,b.target||(b.target=e),c=null==c?[b]:r.makeArray(c,[b]),n=r.event.special[p]||{},f||!n.trigger||n.trigger.apply(e,c)!==!1)){if(!f&&!n.noBubble&&!r.isWindow(e)){for(j=n.delegateType||p,sb.test(j+p)||(h=h.parentNode);h;h=h.parentNode)o.push(h),i=h;i===(e.ownerDocument||d)&&o.push(i.defaultView||i.parentWindow||a)}g=0;while((h=o[g++])&&!b.isPropagationStopped())b.type=g>1?j:n.bindType||p,m=(W.get(h,"events")||{})[b.type]&&W.get(h,"handle"),m&&m.apply(h,c),m=k&&h[k],m&&m.apply&&U(h)&&(b.result=m.apply(h,c),b.result===!1&&b.preventDefault());return b.type=p,f||b.isDefaultPrevented()||n._default&&n._default.apply(o.pop(),c)!==!1||!U(e)||k&&r.isFunction(e[p])&&!r.isWindow(e)&&(i=e[k],i&&(e[k]=null),r.event.triggered=p,e[p](),r.event.triggered=void 0,i&&(e[k]=i)),b.result}},simulate:function(a,b,c){var d=r.extend(new r.Event,c,{type:a,isSimulated:!0});r.event.trigger(d,null,b)}}),r.fn.extend({trigger:function(a,b){return this.each(function(){r.event.trigger(a,b,this)})},triggerHandler:function(a,b){var c=this[0];if(c)return r.event.trigger(a,b,c,!0)}}),r.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),function(a,b){r.fn[b]=function(a,c){return arguments.length>0?this.on(b,null,a,c):this.trigger(b)}}),r.fn.extend({hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)}}),o.focusin="onfocusin"in a,o.focusin||r.each({focus:"focusin",blur:"focusout"},function(a,b){var c=function(a){r.event.simulate(b,a.target,r.event.fix(a))};r.event.special[b]={setup:function(){var d=this.ownerDocument||this,e=W.access(d,b);e||d.addEventListener(a,c,!0),W.access(d,b,(e||0)+1)},teardown:function(){var d=this.ownerDocument||this,e=W.access(d,b)-1;e?W.access(d,b,e):(d.removeEventListener(a,c,!0),W.remove(d,b))}}});var tb=a.location,ub=r.now(),vb=/\?/;r.parseXML=function(b){var c;if(!b||"string"!=typeof b)return null;try{c=(new a.DOMParser).parseFromString(b,"text/xml")}catch(d){c=void 0}return c&&!c.getElementsByTagName("parsererror").length||r.error("Invalid XML: "+b),c};var wb=/\[\]$/,xb=/\r?\n/g,yb=/^(?:submit|button|image|reset|file)$/i,zb=/^(?:input|select|textarea|keygen)/i;function Ab(a,b,c,d){var e;if(Array.isArray(b))r.each(b,function(b,e){c||wb.test(a)?d(a,e):Ab(a+"["+("object"==typeof e&&null!=e?b:"")+"]",e,c,d)});else if(c||"object"!==r.type(b))d(a,b);else for(e in b)Ab(a+"["+e+"]",b[e],c,d)}r.param=function(a,b){var c,d=[],e=function(a,b){var c=r.isFunction(b)?b():b;d[d.length]=encodeURIComponent(a)+"="+encodeURIComponent(null==c?"":c)};if(Array.isArray(a)||a.jquery&&!r.isPlainObject(a))r.each(a,function(){e(this.name,this.value)});else for(c in a)Ab(c,a[c],b,e);return d.join("&")},r.fn.extend({serialize:function(){return r.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var a=r.prop(this,"elements");return a?r.makeArray(a):this}).filter(function(){var a=this.type;return this.name&&!r(this).is(":disabled")&&zb.test(this.nodeName)&&!yb.test(a)&&(this.checked||!ja.test(a))}).map(function(a,b){var c=r(this).val();return null==c?null:Array.isArray(c)?r.map(c,function(a){return{name:b.name,value:a.replace(xb,"\r\n")}}):{name:b.name,value:c.replace(xb,"\r\n")}}).get()}});var Bb=/%20/g,Cb=/#.*$/,Db=/([?&])_=[^&]*/,Eb=/^(.*?):[ \t]*([^\r\n]*)$/gm,Fb=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,Gb=/^(?:GET|HEAD)$/,Hb=/^\/\//,Ib={},Jb={},Kb="*/".concat("*"),Lb=d.createElement("a");Lb.href=tb.href;function Mb(a){return function(b,c){"string"!=typeof b&&(c=b,b="*");var d,e=0,f=b.toLowerCase().match(L)||[];if(r.isFunction(c))while(d=f[e++])"+"===d[0]?(d=d.slice(1)||"*",(a[d]=a[d]||[]).unshift(c)):(a[d]=a[d]||[]).push(c)}}function Nb(a,b,c,d){var e={},f=a===Jb;function g(h){var i;return e[h]=!0,r.each(a[h]||[],function(a,h){var j=h(b,c,d);return"string"!=typeof j||f||e[j]?f?!(i=j):void 0:(b.dataTypes.unshift(j),g(j),!1)}),i}return g(b.dataTypes[0])||!e["*"]&&g("*")}function Ob(a,b){var c,d,e=r.ajaxSettings.flatOptions||{};for(c in b)void 0!==b[c]&&((e[c]?a:d||(d={}))[c]=b[c]);return d&&r.extend(!0,a,d),a}function Pb(a,b,c){var d,e,f,g,h=a.contents,i=a.dataTypes;while("*"===i[0])i.shift(),void 0===d&&(d=a.mimeType||b.getResponseHeader("Content-Type"));if(d)for(e in h)if(h[e]&&h[e].test(d)){i.unshift(e);break}if(i[0]in c)f=i[0];else{for(e in c){if(!i[0]||a.converters[e+" "+i[0]]){f=e;break}g||(g=e)}f=f||g}if(f)return f!==i[0]&&i.unshift(f),c[f]}function Qb(a,b,c,d){var e,f,g,h,i,j={},k=a.dataTypes.slice();if(k[1])for(g in a.converters)j[g.toLowerCase()]=a.converters[g];f=k.shift();while(f)if(a.responseFields[f]&&(c[a.responseFields[f]]=b),!i&&d&&a.dataFilter&&(b=a.dataFilter(b,a.dataType)),i=f,f=k.shift())if("*"===f)f=i;else if("*"!==i&&i!==f){if(g=j[i+" "+f]||j["* "+f],!g)for(e in j)if(h=e.split(" "),h[1]===f&&(g=j[i+" "+h[0]]||j["* "+h[0]])){g===!0?g=j[e]:j[e]!==!0&&(f=h[0],k.unshift(h[1]));break}if(g!==!0)if(g&&a["throws"])b=g(b);else try{b=g(b)}catch(l){return{state:"parsererror",error:g?l:"No conversion from "+i+" to "+f}}}return{state:"success",data:b}}r.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:tb.href,type:"GET",isLocal:Fb.test(tb.protocol),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":Kb,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/\bxml\b/,html:/\bhtml/,json:/\bjson\b/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":JSON.parse,"text xml":r.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(a,b){return b?Ob(Ob(a,r.ajaxSettings),b):Ob(r.ajaxSettings,a)},ajaxPrefilter:Mb(Ib),ajaxTransport:Mb(Jb),ajax:function(b,c){"object"==typeof b&&(c=b,b=void 0),c=c||{};var e,f,g,h,i,j,k,l,m,n,o=r.ajaxSetup({},c),p=o.context||o,q=o.context&&(p.nodeType||p.jquery)?r(p):r.event,s=r.Deferred(),t=r.Callbacks("once memory"),u=o.statusCode||{},v={},w={},x="canceled",y={readyState:0,getResponseHeader:function(a){var b;if(k){if(!h){h={};while(b=Eb.exec(g))h[b[1].toLowerCase()]=b[2]}b=h[a.toLowerCase()]}return null==b?null:b},getAllResponseHeaders:function(){return k?g:null},setRequestHeader:function(a,b){return null==k&&(a=w[a.toLowerCase()]=w[a.toLowerCase()]||a,v[a]=b),this},overrideMimeType:function(a){return null==k&&(o.mimeType=a),this},statusCode:function(a){var b;if(a)if(k)y.always(a[y.status]);else for(b in a)u[b]=[u[b],a[b]];return this},abort:function(a){var b=a||x;return e&&e.abort(b),A(0,b),this}};if(s.promise(y),o.url=((b||o.url||tb.href)+"").replace(Hb,tb.protocol+"//"),o.type=c.method||c.type||o.method||o.type,o.dataTypes=(o.dataType||"*").toLowerCase().match(L)||[""],null==o.crossDomain){j=d.createElement("a");try{j.href=o.url,j.href=j.href,o.crossDomain=Lb.protocol+"//"+Lb.host!=j.protocol+"//"+j.host}catch(z){o.crossDomain=!0}}if(o.data&&o.processData&&"string"!=typeof o.data&&(o.data=r.param(o.data,o.traditional)),Nb(Ib,o,c,y),k)return y;l=r.event&&o.global,l&&0===r.active++&&r.event.trigger("ajaxStart"),o.type=o.type.toUpperCase(),o.hasContent=!Gb.test(o.type),f=o.url.replace(Cb,""),o.hasContent?o.data&&o.processData&&0===(o.contentType||"").indexOf("application/x-www-form-urlencoded")&&(o.data=o.data.replace(Bb,"+")):(n=o.url.slice(f.length),o.data&&(f+=(vb.test(f)?"&":"?")+o.data,delete o.data),o.cache===!1&&(f=f.replace(Db,"$1"),n=(vb.test(f)?"&":"?")+"_="+ub++ +n),o.url=f+n),o.ifModified&&(r.lastModified[f]&&y.setRequestHeader("If-Modified-Since",r.lastModified[f]),r.etag[f]&&y.setRequestHeader("If-None-Match",r.etag[f])),(o.data&&o.hasContent&&o.contentType!==!1||c.contentType)&&y.setRequestHeader("Content-Type",o.contentType),y.setRequestHeader("Accept",o.dataTypes[0]&&o.accepts[o.dataTypes[0]]?o.accepts[o.dataTypes[0]]+("*"!==o.dataTypes[0]?", "+Kb+"; q=0.01":""):o.accepts["*"]);for(m in o.headers)y.setRequestHeader(m,o.headers[m]);if(o.beforeSend&&(o.beforeSend.call(p,y,o)===!1||k))return y.abort();if(x="abort",t.add(o.complete),y.done(o.success),y.fail(o.error),e=Nb(Jb,o,c,y)){if(y.readyState=1,l&&q.trigger("ajaxSend",[y,o]),k)return y;o.async&&o.timeout>0&&(i=a.setTimeout(function(){y.abort("timeout")},o.timeout));try{k=!1,e.send(v,A)}catch(z){if(k)throw z;A(-1,z)}}else A(-1,"No Transport");function A(b,c,d,h){var j,m,n,v,w,x=c;k||(k=!0,i&&a.clearTimeout(i),e=void 0,g=h||"",y.readyState=b>0?4:0,j=b>=200&&b<300||304===b,d&&(v=Pb(o,y,d)),v=Qb(o,v,y,j),j?(o.ifModified&&(w=y.getResponseHeader("Last-Modified"),w&&(r.lastModified[f]=w),w=y.getResponseHeader("etag"),w&&(r.etag[f]=w)),204===b||"HEAD"===o.type?x="nocontent":304===b?x="notmodified":(x=v.state,m=v.data,n=v.error,j=!n)):(n=x,!b&&x||(x="error",b<0&&(b=0))),y.status=b,y.statusText=(c||x)+"",j?s.resolveWith(p,[m,x,y]):s.rejectWith(p,[y,x,n]),y.statusCode(u),u=void 0,l&&q.trigger(j?"ajaxSuccess":"ajaxError",[y,o,j?m:n]),t.fireWith(p,[y,x]),l&&(q.trigger("ajaxComplete",[y,o]),--r.active||r.event.trigger("ajaxStop")))}return y},getJSON:function(a,b,c){return r.get(a,b,c,"json")},getScript:function(a,b){return r.get(a,void 0,b,"script")}}),r.each(["get","post"],function(a,b){r[b]=function(a,c,d,e){return r.isFunction(c)&&(e=e||d,d=c,c=void 0),r.ajax(r.extend({url:a,type:b,dataType:e,data:c,success:d},r.isPlainObject(a)&&a))}}),r._evalUrl=function(a){return r.ajax({url:a,type:"GET",dataType:"script",cache:!0,async:!1,global:!1,"throws":!0})},r.fn.extend({wrapAll:function(a){var b;return this[0]&&(r.isFunction(a)&&(a=a.call(this[0])),b=r(a,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstElementChild)a=a.firstElementChild;return a}).append(this)),this},wrapInner:function(a){return r.isFunction(a)?this.each(function(b){r(this).wrapInner(a.call(this,b))}):this.each(function(){var b=r(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=r.isFunction(a);return this.each(function(c){r(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(a){return this.parent(a).not("body").each(function(){r(this).replaceWith(this.childNodes)}),this}}),r.expr.pseudos.hidden=function(a){return!r.expr.pseudos.visible(a)},r.expr.pseudos.visible=function(a){return!!(a.offsetWidth||a.offsetHeight||a.getClientRects().length)},r.ajaxSettings.xhr=function(){try{return new a.XMLHttpRequest}catch(b){}};var Rb={0:200,1223:204},Sb=r.ajaxSettings.xhr();o.cors=!!Sb&&"withCredentials"in Sb,o.ajax=Sb=!!Sb,r.ajaxTransport(function(b){var c,d;if(o.cors||Sb&&!b.crossDomain)return{send:function(e,f){var g,h=b.xhr();if(h.open(b.type,b.url,b.async,b.username,b.password),b.xhrFields)for(g in b.xhrFields)h[g]=b.xhrFields[g];b.mimeType&&h.overrideMimeType&&h.overrideMimeType(b.mimeType),b.crossDomain||e["X-Requested-With"]||(e["X-Requested-With"]="XMLHttpRequest");for(g in e)h.setRequestHeader(g,e[g]);c=function(a){return function(){c&&(c=d=h.onload=h.onerror=h.onabort=h.onreadystatechange=null,"abort"===a?h.abort():"error"===a?"number"!=typeof h.status?f(0,"error"):f(h.status,h.statusText):f(Rb[h.status]||h.status,h.statusText,"text"!==(h.responseType||"text")||"string"!=typeof h.responseText?{binary:h.response}:{text:h.responseText},h.getAllResponseHeaders()))}},h.onload=c(),d=h.onerror=c("error"),void 0!==h.onabort?h.onabort=d:h.onreadystatechange=function(){4===h.readyState&&a.setTimeout(function(){c&&d()})},c=c("abort");try{h.send(b.hasContent&&b.data||null)}catch(i){if(c)throw i}},abort:function(){c&&c()}}}),r.ajaxPrefilter(function(a){a.crossDomain&&(a.contents.script=!1)}),r.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/\b(?:java|ecma)script\b/},converters:{"text script":function(a){return r.globalEval(a),a}}}),r.ajaxPrefilter("script",function(a){void 0===a.cache&&(a.cache=!1),a.crossDomain&&(a.type="GET")}),r.ajaxTransport("script",function(a){if(a.crossDomain){var b,c;return{send:function(e,f){b=r("<script>").prop({charset:a.scriptCharset,src:a.url}).on("load error",c=function(a){b.remove(),c=null,a&&f("error"===a.type?404:200,a.type)}),d.head.appendChild(b[0])},abort:function(){c&&c()}}}});var Tb=[],Ub=/(=)\?(?=&|$)|\?\?/;r.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var a=Tb.pop()||r.expando+"_"+ub++;return this[a]=!0,a}}),r.ajaxPrefilter("json jsonp",function(b,c,d){var e,f,g,h=b.jsonp!==!1&&(Ub.test(b.url)?"url":"string"==typeof b.data&&0===(b.contentType||"").indexOf("application/x-www-form-urlencoded")&&Ub.test(b.data)&&"data");if(h||"jsonp"===b.dataTypes[0])return e=b.jsonpCallback=r.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,h?b[h]=b[h].replace(Ub,"$1"+e):b.jsonp!==!1&&(b.url+=(vb.test(b.url)?"&":"?")+b.jsonp+"="+e),b.converters["script json"]=function(){return g||r.error(e+" was not called"),g[0]},b.dataTypes[0]="json",f=a[e],a[e]=function(){g=arguments},d.always(function(){void 0===f?r(a).removeProp(e):a[e]=f,b[e]&&(b.jsonpCallback=c.jsonpCallback,Tb.push(e)),g&&r.isFunction(f)&&f(g[0]),g=f=void 0}),"script"}),o.createHTMLDocument=function(){var a=d.implementation.createHTMLDocument("").body;return a.innerHTML="<form></form><form></form>",2===a.childNodes.length}(),r.parseHTML=function(a,b,c){if("string"!=typeof a)return[];"boolean"==typeof b&&(c=b,b=!1);var e,f,g;return b||(o.createHTMLDocument?(b=d.implementation.createHTMLDocument(""),e=b.createElement("base"),e.href=d.location.href,b.head.appendChild(e)):b=d),f=C.exec(a),g=!c&&[],f?[b.createElement(f[1])]:(f=qa([a],b,g),g&&g.length&&r(g).remove(),r.merge([],f.childNodes))},r.fn.load=function(a,b,c){var d,e,f,g=this,h=a.indexOf(" ");return h>-1&&(d=pb(a.slice(h)),a=a.slice(0,h)),r.isFunction(b)?(c=b,b=void 0):b&&"object"==typeof b&&(e="POST"),g.length>0&&r.ajax({url:a,type:e||"GET",dataType:"html",data:b}).done(function(a){f=arguments,g.html(d?r("<div>").append(r.parseHTML(a)).find(d):a)}).always(c&&function(a,b){g.each(function(){c.apply(this,f||[a.responseText,b,a])})}),this},r.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(a,b){r.fn[b]=function(a){return this.on(b,a)}}),r.expr.pseudos.animated=function(a){return r.grep(r.timers,function(b){return a===b.elem}).length},r.offset={setOffset:function(a,b,c){var d,e,f,g,h,i,j,k=r.css(a,"position"),l=r(a),m={};"static"===k&&(a.style.position="relative"),h=l.offset(),f=r.css(a,"top"),i=r.css(a,"left"),j=("absolute"===k||"fixed"===k)&&(f+i).indexOf("auto")>-1,j?(d=l.position(),g=d.top,e=d.left):(g=parseFloat(f)||0,e=parseFloat(i)||0),r.isFunction(b)&&(b=b.call(a,c,r.extend({},h))),null!=b.top&&(m.top=b.top-h.top+g),null!=b.left&&(m.left=b.left-h.left+e),"using"in b?b.using.call(a,m):l.css(m)}},r.fn.extend({offset:function(a){if(arguments.length)return void 0===a?this:this.each(function(b){r.offset.setOffset(this,a,b)});var b,c,d,e,f=this[0];if(f)return f.getClientRects().length?(d=f.getBoundingClientRect(),b=f.ownerDocument,c=b.documentElement,e=b.defaultView,{top:d.top+e.pageYOffset-c.clientTop,left:d.left+e.pageXOffset-c.clientLeft}):{top:0,left:0}},position:function(){if(this[0]){var a,b,c=this[0],d={top:0,left:0};return"fixed"===r.css(c,"position")?b=c.getBoundingClientRect():(a=this.offsetParent(),b=this.offset(),B(a[0],"html")||(d=a.offset()),d={top:d.top+r.css(a[0],"borderTopWidth",!0),left:d.left+r.css(a[0],"borderLeftWidth",!0)}),{top:b.top-d.top-r.css(c,"marginTop",!0),left:b.left-d.left-r.css(c,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var a=this.offsetParent;while(a&&"static"===r.css(a,"position"))a=a.offsetParent;return a||ra})}}),r.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(a,b){var c="pageYOffset"===b;r.fn[a]=function(d){return T(this,function(a,d,e){var f;return r.isWindow(a)?f=a:9===a.nodeType&&(f=a.defaultView),void 0===e?f?f[b]:a[d]:void(f?f.scrollTo(c?f.pageXOffset:e,c?e:f.pageYOffset):a[d]=e)},a,d,arguments.length)}}),r.each(["top","left"],function(a,b){r.cssHooks[b]=Pa(o.pixelPosition,function(a,c){if(c)return c=Oa(a,b),Ma.test(c)?r(a).position()[b]+"px":c})}),r.each({Height:"height",Width:"width"},function(a,b){r.each({padding:"inner"+a,content:b,"":"outer"+a},function(c,d){r.fn[d]=function(e,f){var g=arguments.length&&(c||"boolean"!=typeof e),h=c||(e===!0||f===!0?"margin":"border");return T(this,function(b,c,e){var f;return r.isWindow(b)?0===d.indexOf("outer")?b["inner"+a]:b.document.documentElement["client"+a]:9===b.nodeType?(f=b.documentElement,Math.max(b.body["scroll"+a],f["scroll"+a],b.body["offset"+a],f["offset"+a],f["client"+a])):void 0===e?r.css(b,c,h):r.style(b,c,e,h)},b,g?e:void 0,g)}})}),r.fn.extend({bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return 1===arguments.length?this.off(a,"**"):this.off(b,a||"**",c)}}),r.holdReady=function(a){a?r.readyWait++:r.ready(!0)},r.isArray=Array.isArray,r.parseJSON=JSON.parse,r.nodeName=B,"function"==typeof define&&define.amd&&define("jquery",[],function(){return r});var Vb=a.jQuery,Wb=a.$;return r.noConflict=function(b){return a.$===r&&(a.$=Wb),b&&a.jQuery===r&&(a.jQuery=Vb),r},b||(a.jQuery=a.$=r),r});

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.Stats = factory());
}(this, (function () { 'use strict';

/**
 * @author mrdoob / http://mrdoob.com/
 */

var Stats = function () {

	var mode = 0;

	var container = document.createElement( 'div' );
	container.style.cssText = 'position:fixed;bottom:0;left:0;cursor:pointer;opacity:0.9;z-index:10000';
	container.addEventListener( 'click', function ( event ) {

		event.preventDefault();
		showPanel( ++ mode % container.children.length );

	}, false );

	//

	function addPanel( panel ) {

		container.appendChild( panel.dom );
		return panel;

	}

	function showPanel( id ) {

		for ( var i = 0; i < container.children.length; i ++ ) {

			container.children[ i ].style.display = i === id ? 'block' : 'none';

		}

		mode = id;

	}

	//

	var beginTime = ( performance || Date ).now(), prevTime = beginTime, frames = 0;

	var fpsPanel = addPanel( new Stats.Panel( 'FPS', 'lime', 'black' ) );

	showPanel( 0 );

	return {

		REVISION: 16,

		dom: container,

		addPanel: addPanel,
		showPanel: showPanel,

		begin: function () {

			beginTime = ( performance || Date ).now();

		},

		end: function () {

			frames ++;

			var time = ( performance || Date ).now();

			if ( time > prevTime + 1000 ) {

				fpsPanel.update( ( frames * 1000 ) / ( time - prevTime ), 100 );
				prevTime = time;
				frames = 0;

			}

			return time;

		},

		update: function () {

			beginTime = this.end();

		},

		// Backwards Compatibility

		domElement: container,
		setMode: showPanel

	};

};

Stats.Panel = function ( name, fg, bg ) {

	var min = Infinity, max = 0, round = Math.round;
	var PR = round( window.devicePixelRatio || 1 );

	var WIDTH = 80 * PR, HEIGHT = 48 * PR,
			TEXT_X = 3 * PR, TEXT_Y = 2 * PR,
			GRAPH_X = 3 * PR, GRAPH_Y = 15 * PR,
			GRAPH_WIDTH = 74 * PR, GRAPH_HEIGHT = 30 * PR;

	var canvas = document.createElement( 'canvas' );
	canvas.width = WIDTH;
	canvas.height = HEIGHT;
	canvas.style.cssText = 'width:80px;height:48px';

	var context = canvas.getContext( '2d' );
	context.font = 'bold ' + ( 9 * PR ) + 'px Helvetica,Arial,sans-serif';
	context.textBaseline = 'top';

	context.fillStyle = bg;
	context.fillRect( 0, 0, WIDTH, HEIGHT );

	context.fillStyle = fg;
	context.fillText( name, TEXT_X, TEXT_Y );
	context.fillRect( GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT );

	context.fillStyle = bg;
	context.globalAlpha = 0.9;
	context.fillRect( GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT );

	return {

		dom: canvas,

		update: function ( value, maxValue ) {

			var valueRounded = round(value);
			window.fpsHandler.onUpdate(valueRounded);
			
			min = Math.min( min, value );
			max = Math.max( max, value );

			context.fillStyle = bg;
			context.globalAlpha = 1;
			context.fillRect( 0, 0, WIDTH, GRAPH_Y );
			context.fillStyle = fg;
			context.fillText( valueRounded + ' ' + name + ' (' + round( min ) + '-' + round( max ) + ')', TEXT_X, TEXT_Y );

			context.drawImage( canvas, GRAPH_X + PR, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT, GRAPH_X, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT );

			context.fillRect( GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, GRAPH_HEIGHT );

			context.fillStyle = bg;
			context.globalAlpha = 0.9;
			context.fillRect( GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, round( ( 1 - ( value / maxValue ) ) * GRAPH_HEIGHT ) );

		}

	};

};

return Stats;

})));

(function(c){function g(a){var b=a||window.event,i=[].slice.call(arguments,1),e=0,h=0,f=0;a=c.event.fix(b);a.type="mousewheel";if(b.wheelDelta)e=b.wheelDelta/120;if(b.detail)e=-b.detail/3;f=e;if(b.axis!==undefined&&b.axis===b.HORIZONTAL_AXIS){f=0;h=-1*e}if(b.wheelDeltaY!==undefined)f=b.wheelDeltaY/120;if(b.wheelDeltaX!==undefined)h=-1*b.wheelDeltaX/120;i.unshift(a,e,h,f);return(c.event.dispatch||c.event.handle).apply(this,i)}var d=["DOMMouseScroll","mousewheel"];if(c.event.fixHooks)for(var j=d.length;j;)c.event.fixHooks[d[--j]]=
c.event.mouseHooks;c.event.special.mousewheel={setup:function(){if(this.addEventListener)for(var a=d.length;a;)this.addEventListener(d[--a],g,false);else this.onmousewheel=g},teardown:function(){if(this.removeEventListener)for(var a=d.length;a;)this.removeEventListener(d[--a],g,false);else this.onmousewheel=null}};c.fn.extend({mousewheel:function(a){return a?this.bind("mousewheel",a):this.trigger("mousewheel")},unmousewheel:function(a){return this.unbind("mousewheel",a)}})})(jQuery);

function dragElement(elmnt) {
  var pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;

  elmnt.onmousedown = dragMouseDown;

  function dragMouseDown(e) {
    e = e || window.event;
    pos3 = e.clientX;
    pos4 = e.clientY;
    document.onmouseup = closeDragElement;
    document.onmousemove = elementDrag;
  }

  function elementDrag(e) {
    cliIsBeingDragged = true;
    e = e || window.event;
    pos1 = pos3 - e.clientX;
    pos2 = pos4 - e.clientY;
    pos3 = e.clientX;
    pos4 = e.clientY;
    elmnt.style.top = (elmnt.offsetTop - pos2) + "px";
    elmnt.style.left = (elmnt.offsetLeft - pos1) + "px";
  }

  function closeDragElement() {
    cliIsBeingDragged = false;
    document.onmouseup = null;
    document.onmousemove = null;
  }
}

!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e(t.THREE={})}(this,function(t){"use strict";function e(){}void 0===Number.EPSILON&&(Number.EPSILON=Math.pow(2,-52)),void 0===Number.isInteger&&(Number.isInteger=function(t){return"number"==typeof t&&isFinite(t)&&Math.floor(t)===t}),void 0===Math.sign&&(Math.sign=function(t){return t<0?-1:0<t?1:+t}),"name"in Function.prototype==!1&&Object.defineProperty(Function.prototype,"name",{get:function(){return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]}}),void 0===Object.assign&&(Object.assign=function(t){if(null==t)throw new TypeError("Cannot convert undefined or null to object");for(var e=Object(t),i=1;i<arguments.length;i++){var n=arguments[i];if(null!=n)for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e}),Object.assign(e.prototype,{addEventListener:function(t,e){void 0===this._listeners&&(this._listeners={});var i=this._listeners;void 0===i[t]&&(i[t]=[]),-1===i[t].indexOf(e)&&i[t].push(e)},hasEventListener:function(t,e){if(void 0===this._listeners)return!1;var i=this._listeners;return void 0!==i[t]&&-1!==i[t].indexOf(e)},removeEventListener:function(t,e){if(void 0!==this._listeners){var i=this._listeners[t];if(void 0!==i){var n=i.indexOf(e);-1!==n&&i.splice(n,1)}}},dispatchEvent:function(t){if(void 0!==this._listeners){var e=this._listeners[t.type];if(void 0!==e){t.target=this;for(var i=e.slice(0),n=0,r=i.length;n<r;n++)i[n].call(this,t)}}}});var i,n,l,u,r,a,o,s,h,c,d,p,f,m,g,v,y,x,b,_,j=0,W=1,X=2,B=1,F=2,U=0,At=1,Z=2,Lt=0,w=2,q=0,Y=1,J=2,Q=3,K=4,$=5,M=100,E=101,T=102,S=103,A=104,L=200,R=201,C=202,P=203,O=204,I=205,N=206,D=207,z=208,G=209,H=210,tt=0,et=1,it=2,nt=3,rt=4,at=5,ot=6,st=7,V=0,k=1,ht=2,ct=0,Rt=1,lt=2,ut=3,dt=4,pt=301,ft=302,mt=303,gt=304,vt=305,yt=306,xt=307,bt=1e3,_t=1001,wt=1002,Mt=1003,Et=1004,Tt=1005,St=1006,Ct=1007,Pt=1008,Ot=1009,It=1010,Nt=1011,Ut=1012,Dt=1013,Bt=1014,Ft=1015,zt=1016,Gt=1017,Ht=1018,Vt=1019,kt=1020,jt=1021,Wt=1022,Xt=1023,qt=1024,Yt=1025,Zt=Xt,Jt=1026,Qt=1027,Kt=33776,$t=33777,te=33778,ee=33779,ie=35840,ne=35841,re=35842,ae=35843,oe=36196,se=37808,he=37809,ce=37810,le=37811,ue=37812,de=37813,pe=37814,fe=37815,me=37816,ge=37817,ve=37818,ye=37819,xe=37820,be=37821,_e=2300,we=2301,Me=2400,Ee=2401,Te=2402,Se=0,Ae=3e3,Le=3001,Re=3007,Ce=3002,Pe=3004,Oe=3005,Ie=3006,Ne=3200,Ue=3201,De={DEG2RAD:Math.PI/180,RAD2DEG:180/Math.PI,generateUUID:function(){for(var r=[],t=0;t<256;t++)r[t]=(t<16?"0":"")+t.toString(16);return function(){var t=4294967295*Math.random()|0,e=4294967295*Math.random()|0,i=4294967295*Math.random()|0,n=4294967295*Math.random()|0;return(r[255&t]+r[t>>8&255]+r[t>>16&255]+r[t>>24&255]+"-"+r[255&e]+r[e>>8&255]+"-"+r[e>>16&15|64]+r[e>>24&255]+"-"+r[63&i|128]+r[i>>8&255]+"-"+r[i>>16&255]+r[i>>24&255]+r[255&n]+r[n>>8&255]+r[n>>16&255]+r[n>>24&255]).toUpperCase()}}(),clamp:function(t,e,i){return Math.max(e,Math.min(i,t))},euclideanModulo:function(t,e){return(t%e+e)%e},mapLinear:function(t,e,i,n,r){return n+(t-e)*(r-n)/(i-e)},lerp:function(t,e,i){return(1-i)*t+i*e},smoothstep:function(t,e,i){return t<=e?0:i<=t?1:(t=(t-e)/(i-e))*t*(3-2*t)},smootherstep:function(t,e,i){return t<=e?0:i<=t?1:(t=(t-e)/(i-e))*t*t*(t*(6*t-15)+10)},randInt:function(t,e){return t+Math.floor(Math.random()*(e-t+1))},randFloat:function(t,e){return t+Math.random()*(e-t)},randFloatSpread:function(t){return t*(.5-Math.random())},degToRad:function(t){return t*De.DEG2RAD},radToDeg:function(t){return t*De.RAD2DEG},isPowerOfTwo:function(t){return 0==(t&t-1)&&0!==t},ceilPowerOfTwo:function(t){return Math.pow(2,Math.ceil(Math.log(t)/Math.LN2))},floorPowerOfTwo:function(t){return Math.pow(2,Math.floor(Math.log(t)/Math.LN2))}};function Be(t,e){this.x=t||0,this.y=e||0}function Fe(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],0<arguments.length&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}function ze(t,e,i,n){this._x=t||0,this._y=e||0,this._z=i||0,this._w=void 0!==n?n:1}function Ge(t,e,i){this.x=t||0,this.y=e||0,this.z=i||0}function He(){this.elements=[1,0,0,0,1,0,0,0,1],0<arguments.length&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}Object.defineProperties(Be.prototype,{width:{get:function(){return this.x},set:function(t){this.x=t}},height:{get:function(){return this.y},set:function(t){this.y=t}}}),Object.assign(Be.prototype,{isVector2:!0,set:function(t,e){return this.x=t,this.y=e,this},setScalar:function(t){return this.x=t,this.y=t,this},setX:function(t){return this.x=t,this},setY:function(t){return this.y=t,this},setComponent:function(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this},getComponent:function(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}},clone:function(){return new this.constructor(this.x,this.y)},copy:function(t){return this.x=t.x,this.y=t.y,this},add:function(t,e){return void 0!==e?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this)},addScalar:function(t){return this.x+=t,this.y+=t,this},addVectors:function(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this},addScaledVector:function(t,e){return this.x+=t.x*e,this.y+=t.y*e,this},sub:function(t,e){return void 0!==e?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this)},subScalar:function(t){return this.x-=t,this.y-=t,this},subVectors:function(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this},multiply:function(t){return this.x*=t.x,this.y*=t.y,this},multiplyScalar:function(t){return this.x*=t,this.y*=t,this},divide:function(t){return this.x/=t.x,this.y/=t.y,this},divideScalar:function(t){return this.multiplyScalar(1/t)},applyMatrix3:function(t){var e=this.x,i=this.y,n=t.elements;return this.x=n[0]*e+n[3]*i+n[6],this.y=n[1]*e+n[4]*i+n[7],this},min:function(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this},max:function(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this},clamp:function(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this},clampScalar:(i=new Be,n=new Be,function(t,e){return i.set(t,t),n.set(e,e),this.clamp(i,n)}),clampLength:function(t,e){var i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(e,i)))},floor:function(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this},ceil:function(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this},round:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this},roundToZero:function(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this},negate:function(){return this.x=-this.x,this.y=-this.y,this},dot:function(t){return this.x*t.x+this.y*t.y},lengthSq:function(){return this.x*this.x+this.y*this.y},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y)},manhattanLength:function(){return Math.abs(this.x)+Math.abs(this.y)},normalize:function(){return this.divideScalar(this.length()||1)},angle:function(){var t=Math.atan2(this.y,this.x);return t<0&&(t+=2*Math.PI),t},distanceTo:function(t){return Math.sqrt(this.distanceToSquared(t))},distanceToSquared:function(t){var e=this.x-t.x,i=this.y-t.y;return e*e+i*i},manhattanDistanceTo:function(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)},setLength:function(t){return this.normalize().multiplyScalar(t)},lerp:function(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this},lerpVectors:function(t,e,i){return this.subVectors(e,t).multiplyScalar(i).add(t)},equals:function(t){return t.x===this.x&&t.y===this.y},fromArray:function(t,e){return void 0===e&&(e=0),this.x=t[e],this.y=t[e+1],this},toArray:function(t,e){return void 0===t&&(t=[]),void 0===e&&(e=0),t[e]=this.x,t[e+1]=this.y,t},fromBufferAttribute:function(t,e,i){return void 0!==i&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this},rotateAround:function(t,e){var i=Math.cos(e),n=Math.sin(e),r=this.x-t.x,a=this.y-t.y;return this.x=r*i-a*n+t.x,this.y=r*n+a*i+t.y,this}}),Object.assign(Fe.prototype,{isMatrix4:!0,set:function(t,e,i,n,r,a,o,s,h,c,l,u,d,p,f,m){var g=this.elements;return g[0]=t,g[4]=e,g[8]=i,g[12]=n,g[1]=r,g[5]=a,g[9]=o,g[13]=s,g[2]=h,g[6]=c,g[10]=l,g[14]=u,g[3]=d,g[7]=p,g[11]=f,g[15]=m,this},identity:function(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this},clone:function(){return(new Fe).fromArray(this.elements)},copy:function(t){var e=this.elements,i=t.elements;return e[0]=i[0],e[1]=i[1],e[2]=i[2],e[3]=i[3],e[4]=i[4],e[5]=i[5],e[6]=i[6],e[7]=i[7],e[8]=i[8],e[9]=i[9],e[10]=i[10],e[11]=i[11],e[12]=i[12],e[13]=i[13],e[14]=i[14],e[15]=i[15],this},copyPosition:function(t){var e=this.elements,i=t.elements;return e[12]=i[12],e[13]=i[13],e[14]=i[14],this},extractBasis:function(t,e,i){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),i.setFromMatrixColumn(this,2),this},makeBasis:function(t,e,i){return this.set(t.x,e.x,i.x,0,t.y,e.y,i.y,0,t.z,e.z,i.z,0,0,0,0,1),this},extractRotation:(h=new Ge,function(t){var e=this.elements,i=t.elements,n=1/h.setFromMatrixColumn(t,0).length(),r=1/h.setFromMatrixColumn(t,1).length(),a=1/h.setFromMatrixColumn(t,2).length();return e[0]=i[0]*n,e[1]=i[1]*n,e[2]=i[2]*n,e[4]=i[4]*r,e[5]=i[5]*r,e[6]=i[6]*r,e[8]=i[8]*a,e[9]=i[9]*a,e[10]=i[10]*a,this}),makeRotationFromEuler:function(t){t&&t.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");var e=this.elements,i=t.x,n=t.y,r=t.z,a=Math.cos(i),o=Math.sin(i),s=Math.cos(n),h=Math.sin(n),c=Math.cos(r),l=Math.sin(r);if("XYZ"===t.order){var u=a*c,d=a*l,p=o*c,f=o*l;e[0]=s*c,e[4]=-s*l,e[8]=h,e[1]=d+p*h,e[5]=u-f*h,e[9]=-o*s,e[2]=f-u*h,e[6]=p+d*h,e[10]=a*s}else if("YXZ"===t.order){var m=s*c,g=s*l,v=h*c,y=h*l;e[0]=m+y*o,e[4]=v*o-g,e[8]=a*h,e[1]=a*l,e[5]=a*c,e[9]=-o,e[2]=g*o-v,e[6]=y+m*o,e[10]=a*s}else if("ZXY"===t.order){m=s*c,g=s*l,v=h*c,y=h*l;e[0]=m-y*o,e[4]=-a*l,e[8]=v+g*o,e[1]=g+v*o,e[5]=a*c,e[9]=y-m*o,e[2]=-a*h,e[6]=o,e[10]=a*s}else if("ZYX"===t.order){u=a*c,d=a*l,p=o*c,f=o*l;e[0]=s*c,e[4]=p*h-d,e[8]=u*h+f,e[1]=s*l,e[5]=f*h+u,e[9]=d*h-p,e[2]=-h,e[6]=o*s,e[10]=a*s}else if("YZX"===t.order){var x=a*s,b=a*h,_=o*s,w=o*h;e[0]=s*c,e[4]=w-x*l,e[8]=_*l+b,e[1]=l,e[5]=a*c,e[9]=-o*c,e[2]=-h*c,e[6]=b*l+_,e[10]=x-w*l}else if("XZY"===t.order){x=a*s,b=a*h,_=o*s,w=o*h;e[0]=s*c,e[4]=-l,e[8]=h*c,e[1]=x*l+w,e[5]=a*c,e[9]=b*l-_,e[2]=_*l-b,e[6]=o*c,e[10]=w*l+x}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this},makeRotationFromQuaternion:function(t){var e=this.elements,i=t._x,n=t._y,r=t._z,a=t._w,o=i+i,s=n+n,h=r+r,c=i*o,l=i*s,u=i*h,d=n*s,p=n*h,f=r*h,m=a*o,g=a*s,v=a*h;return e[0]=1-(d+f),e[4]=l-v,e[8]=u+g,e[1]=l+v,e[5]=1-(c+f),e[9]=p-m,e[2]=u-g,e[6]=p+m,e[10]=1-(c+d),e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this},lookAt:(a=new Ge,o=new Ge,s=new Ge,function(t,e,i){var n=this.elements;return s.subVectors(t,e),0===s.lengthSq()&&(s.z=1),s.normalize(),a.crossVectors(i,s),0===a.lengthSq()&&(1===Math.abs(i.z)?s.x+=1e-4:s.z+=1e-4,s.normalize(),a.crossVectors(i,s)),a.normalize(),o.crossVectors(s,a),n[0]=a.x,n[4]=o.x,n[8]=s.x,n[1]=a.y,n[5]=o.y,n[9]=s.y,n[2]=a.z,n[6]=o.z,n[10]=s.z,this}),multiply:function(t,e){return void 0!==e?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(t,e)):this.multiplyMatrices(this,t)},premultiply:function(t){return this.multiplyMatrices(t,this)},multiplyMatrices:function(t,e){var i=t.elements,n=e.elements,r=this.elements,a=i[0],o=i[4],s=i[8],h=i[12],c=i[1],l=i[5],u=i[9],d=i[13],p=i[2],f=i[6],m=i[10],g=i[14],v=i[3],y=i[7],x=i[11],b=i[15],_=n[0],w=n[4],M=n[8],E=n[12],T=n[1],S=n[5],A=n[9],L=n[13],R=n[2],C=n[6],P=n[10],O=n[14],I=n[3],N=n[7],U=n[11],D=n[15];return r[0]=a*_+o*T+s*R+h*I,r[4]=a*w+o*S+s*C+h*N,r[8]=a*M+o*A+s*P+h*U,r[12]=a*E+o*L+s*O+h*D,r[1]=c*_+l*T+u*R+d*I,r[5]=c*w+l*S+u*C+d*N,r[9]=c*M+l*A+u*P+d*U,r[13]=c*E+l*L+u*O+d*D,r[2]=p*_+f*T+m*R+g*I,r[6]=p*w+f*S+m*C+g*N,r[10]=p*M+f*A+m*P+g*U,r[14]=p*E+f*L+m*O+g*D,r[3]=v*_+y*T+x*R+b*I,r[7]=v*w+y*S+x*C+b*N,r[11]=v*M+y*A+x*P+b*U,r[15]=v*E+y*L+x*O+b*D,this},multiplyScalar:function(t){var e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this},applyToBufferAttribute:(r=new Ge,function(t){for(var e=0,i=t.count;e<i;e++)r.x=t.getX(e),r.y=t.getY(e),r.z=t.getZ(e),r.applyMatrix4(this),t.setXYZ(e,r.x,r.y,r.z);return t}),determinant:function(){var t=this.elements,e=t[0],i=t[4],n=t[8],r=t[12],a=t[1],o=t[5],s=t[9],h=t[13],c=t[2],l=t[6],u=t[10],d=t[14];return t[3]*(+r*s*l-n*h*l-r*o*u+i*h*u+n*o*d-i*s*d)+t[7]*(+e*s*d-e*h*u+r*a*u-n*a*d+n*h*c-r*s*c)+t[11]*(+e*h*l-e*o*d-r*a*l+i*a*d+r*o*c-i*h*c)+t[15]*(-n*o*c-e*s*l+e*o*u+n*a*l-i*a*u+i*s*c)},transpose:function(){var t,e=this.elements;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this},setPosition:function(t){var e=this.elements;return e[12]=t.x,e[13]=t.y,e[14]=t.z,this},getInverse:function(t,e){var i=this.elements,n=t.elements,r=n[0],a=n[1],o=n[2],s=n[3],h=n[4],c=n[5],l=n[6],u=n[7],d=n[8],p=n[9],f=n[10],m=n[11],g=n[12],v=n[13],y=n[14],x=n[15],b=p*y*u-v*f*u+v*l*m-c*y*m-p*l*x+c*f*x,_=g*f*u-d*y*u-g*l*m+h*y*m+d*l*x-h*f*x,w=d*v*u-g*p*u+g*c*m-h*v*m-d*c*x+h*p*x,M=g*p*l-d*v*l-g*c*f+h*v*f+d*c*y-h*p*y,E=r*b+a*_+o*w+s*M;if(0===E){var T="THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";if(!0===e)throw new Error(T);return console.warn(T),this.identity()}var S=1/E;return i[0]=b*S,i[1]=(v*f*s-p*y*s-v*o*m+a*y*m+p*o*x-a*f*x)*S,i[2]=(c*y*s-v*l*s+v*o*u-a*y*u-c*o*x+a*l*x)*S,i[3]=(p*l*s-c*f*s-p*o*u+a*f*u+c*o*m-a*l*m)*S,i[4]=_*S,i[5]=(d*y*s-g*f*s+g*o*m-r*y*m-d*o*x+r*f*x)*S,i[6]=(g*l*s-h*y*s-g*o*u+r*y*u+h*o*x-r*l*x)*S,i[7]=(h*f*s-d*l*s+d*o*u-r*f*u-h*o*m+r*l*m)*S,i[8]=w*S,i[9]=(g*p*s-d*v*s-g*a*m+r*v*m+d*a*x-r*p*x)*S,i[10]=(h*v*s-g*c*s+g*a*u-r*v*u-h*a*x+r*c*x)*S,i[11]=(d*c*s-h*p*s-d*a*u+r*p*u+h*a*m-r*c*m)*S,i[12]=M*S,i[13]=(d*v*o-g*p*o+g*a*f-r*v*f-d*a*y+r*p*y)*S,i[14]=(g*c*o-h*v*o-g*a*l+r*v*l+h*a*y-r*c*y)*S,i[15]=(h*p*o-d*c*o+d*a*l-r*p*l-h*a*f+r*c*f)*S,this},scale:function(t){var e=this.elements,i=t.x,n=t.y,r=t.z;return e[0]*=i,e[4]*=n,e[8]*=r,e[1]*=i,e[5]*=n,e[9]*=r,e[2]*=i,e[6]*=n,e[10]*=r,e[3]*=i,e[7]*=n,e[11]*=r,this},getMaxScaleOnAxis:function(){var t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],i=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],n=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,i,n))},makeTranslation:function(t,e,i){return this.set(1,0,0,t,0,1,0,e,0,0,1,i,0,0,0,1),this},makeRotationX:function(t){var e=Math.cos(t),i=Math.sin(t);return this.set(1,0,0,0,0,e,-i,0,0,i,e,0,0,0,0,1),this},makeRotationY:function(t){var e=Math.cos(t),i=Math.sin(t);return this.set(e,0,i,0,0,1,0,0,-i,0,e,0,0,0,0,1),this},makeRotationZ:function(t){var e=Math.cos(t),i=Math.sin(t);return this.set(e,-i,0,0,i,e,0,0,0,0,1,0,0,0,0,1),this},makeRotationAxis:function(t,e){var i=Math.cos(e),n=Math.sin(e),r=1-i,a=t.x,o=t.y,s=t.z,h=r*a,c=r*o;return this.set(h*a+i,h*o-n*s,h*s+n*o,0,h*o+n*s,c*o+i,c*s-n*a,0,h*s-n*o,c*s+n*a,r*s*s+i,0,0,0,0,1),this},makeScale:function(t,e,i){return this.set(t,0,0,0,0,e,0,0,0,0,i,0,0,0,0,1),this},makeShear:function(t,e,i){return this.set(1,e,i,0,t,1,i,0,t,e,1,0,0,0,0,1),this},compose:function(t,e,i){return this.makeRotationFromQuaternion(e),this.scale(i),this.setPosition(t),this},decompose:(l=new Ge,u=new Fe,function(t,e,i){var n=this.elements,r=l.set(n[0],n[1],n[2]).length(),a=l.set(n[4],n[5],n[6]).length(),o=l.set(n[8],n[9],n[10]).length();this.determinant()<0&&(r=-r),t.x=n[12],t.y=n[13],t.z=n[14],u.copy(this);var s=1/r,h=1/a,c=1/o;return u.elements[0]*=s,u.elements[1]*=s,u.elements[2]*=s,u.elements[4]*=h,u.elements[5]*=h,u.elements[6]*=h,u.elements[8]*=c,u.elements[9]*=c,u.elements[10]*=c,e.setFromRotationMatrix(u),i.x=r,i.y=a,i.z=o,this}),makePerspective:function(t,e,i,n,r,a){void 0===a&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");var o=this.elements,s=2*r/(e-t),h=2*r/(i-n),c=(e+t)/(e-t),l=(i+n)/(i-n),u=-(a+r)/(a-r),d=-2*a*r/(a-r);return o[0]=s,o[4]=0,o[8]=c,o[12]=0,o[1]=0,o[5]=h,o[9]=l,o[13]=0,o[2]=0,o[6]=0,o[10]=u,o[14]=d,o[3]=0,o[7]=0,o[11]=-1,o[15]=0,this},makeOrthographic:function(t,e,i,n,r,a){var o=this.elements,s=1/(e-t),h=1/(i-n),c=1/(a-r),l=(e+t)*s,u=(i+n)*h,d=(a+r)*c;return o[0]=2*s,o[4]=0,o[8]=0,o[12]=-l,o[1]=0,o[5]=2*h,o[9]=0,o[13]=-u,o[2]=0,o[6]=0,o[10]=-2*c,o[14]=-d,o[3]=0,o[7]=0,o[11]=0,o[15]=1,this},equals:function(t){for(var e=this.elements,i=t.elements,n=0;n<16;n++)if(e[n]!==i[n])return!1;return!0},fromArray:function(t,e){void 0===e&&(e=0);for(var i=0;i<16;i++)this.elements[i]=t[i+e];return this},toArray:function(t,e){void 0===t&&(t=[]),void 0===e&&(e=0);var i=this.elements;return t[e]=i[0],t[e+1]=i[1],t[e+2]=i[2],t[e+3]=i[3],t[e+4]=i[4],t[e+5]=i[5],t[e+6]=i[6],t[e+7]=i[7],t[e+8]=i[8],t[e+9]=i[9],t[e+10]=i[10],t[e+11]=i[11],t[e+12]=i[12],t[e+13]=i[13],t[e+14]=i[14],t[e+15]=i[15],t}}),Object.assign(ze,{slerp:function(t,e,i,n){return i.copy(t).slerp(e,n)},slerpFlat:function(t,e,i,n,r,a,o){var s=i[n+0],h=i[n+1],c=i[n+2],l=i[n+3],u=r[a+0],d=r[a+1],p=r[a+2],f=r[a+3];if(l!==f||s!==u||h!==d||c!==p){var m=1-o,g=s*u+h*d+c*p+l*f,v=0<=g?1:-1,y=1-g*g;if(y>Number.EPSILON){var x=Math.sqrt(y),b=Math.atan2(x,g*v);m=Math.sin(m*b)/x,o=Math.sin(o*b)/x}var _=o*v;if(s=s*m+u*_,h=h*m+d*_,c=c*m+p*_,l=l*m+f*_,m===1-o){var w=1/Math.sqrt(s*s+h*h+c*c+l*l);s*=w,h*=w,c*=w,l*=w}}t[e]=s,t[e+1]=h,t[e+2]=c,t[e+3]=l}}),Object.defineProperties(ze.prototype,{x:{get:function(){return this._x},set:function(t){this._x=t,this.onChangeCallback()}},y:{get:function(){return this._y},set:function(t){this._y=t,this.onChangeCallback()}},z:{get:function(){return this._z},set:function(t){this._z=t,this.onChangeCallback()}},w:{get:function(){return this._w},set:function(t){this._w=t,this.onChangeCallback()}}}),Object.assign(ze.prototype,{set:function(t,e,i,n){return this._x=t,this._y=e,this._z=i,this._w=n,this.onChangeCallback(),this},clone:function(){return new this.constructor(this._x,this._y,this._z,this._w)},copy:function(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this.onChangeCallback(),this},setFromEuler:function(t,e){if(!t||!t.isEuler)throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");var i=t._x,n=t._y,r=t._z,a=t.order,o=Math.cos,s=Math.sin,h=o(i/2),c=o(n/2),l=o(r/2),u=s(i/2),d=s(n/2),p=s(r/2);return"XYZ"===a?(this._x=u*c*l+h*d*p,this._y=h*d*l-u*c*p,this._z=h*c*p+u*d*l,this._w=h*c*l-u*d*p):"YXZ"===a?(this._x=u*c*l+h*d*p,this._y=h*d*l-u*c*p,this._z=h*c*p-u*d*l,this._w=h*c*l+u*d*p):"ZXY"===a?(this._x=u*c*l-h*d*p,this._y=h*d*l+u*c*p,this._z=h*c*p+u*d*l,this._w=h*c*l-u*d*p):"ZYX"===a?(this._x=u*c*l-h*d*p,this._y=h*d*l+u*c*p,this._z=h*c*p-u*d*l,this._w=h*c*l+u*d*p):"YZX"===a?(this._x=u*c*l+h*d*p,this._y=h*d*l+u*c*p,this._z=h*c*p-u*d*l,this._w=h*c*l-u*d*p):"XZY"===a&&(this._x=u*c*l-h*d*p,this._y=h*d*l-u*c*p,this._z=h*c*p+u*d*l,this._w=h*c*l+u*d*p),!1!==e&&this.onChangeCallback(),this},setFromAxisAngle:function(t,e){var i=e/2,n=Math.sin(i);return this._x=t.x*n,this._y=t.y*n,this._z=t.z*n,this._w=Math.cos(i),this.onChangeCallback(),this},setFromRotationMatrix:function(t){var e,i=t.elements,n=i[0],r=i[4],a=i[8],o=i[1],s=i[5],h=i[9],c=i[2],l=i[6],u=i[10],d=n+s+u;return 0<d?(e=.5/Math.sqrt(d+1),this._w=.25/e,this._x=(l-h)*e,this._y=(a-c)*e,this._z=(o-r)*e):s<n&&u<n?(e=2*Math.sqrt(1+n-s-u),this._w=(l-h)/e,this._x=.25*e,this._y=(r+o)/e,this._z=(a+c)/e):u<s?(e=2*Math.sqrt(1+s-n-u),this._w=(a-c)/e,this._x=(r+o)/e,this._y=.25*e,this._z=(h+l)/e):(e=2*Math.sqrt(1+u-n-s),this._w=(o-r)/e,this._x=(a+c)/e,this._y=(h+l)/e,this._z=.25*e),this.onChangeCallback(),this},setFromUnitVectors:(d=new Ge,function(t,e){return void 0===d&&(d=new Ge),(c=t.dot(e)+1)<1e-6?(c=0,Math.abs(t.x)>Math.abs(t.z)?d.set(-t.y,t.x,0):d.set(0,-t.z,t.y)):d.crossVectors(t,e),this._x=d.x,this._y=d.y,this._z=d.z,this._w=c,this.normalize()}),inverse:function(){return this.conjugate()},conjugate:function(){return this._x*=-1,this._y*=-1,this._z*=-1,this.onChangeCallback(),this},dot:function(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w},lengthSq:function(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w},length:function(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)},normalize:function(){var t=this.length();return 0===t?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this.onChangeCallback(),this},multiply:function(t,e){return void 0!==e?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(t,e)):this.multiplyQuaternions(this,t)},premultiply:function(t){return this.multiplyQuaternions(t,this)},multiplyQuaternions:function(t,e){var i=t._x,n=t._y,r=t._z,a=t._w,o=e._x,s=e._y,h=e._z,c=e._w;return this._x=i*c+a*o+n*h-r*s,this._y=n*c+a*s+r*o-i*h,this._z=r*c+a*h+i*s-n*o,this._w=a*c-i*o-n*s-r*h,this.onChangeCallback(),this},slerp:function(t,e){if(0===e)return this;if(1===e)return this.copy(t);var i=this._x,n=this._y,r=this._z,a=this._w,o=a*t._w+i*t._x+n*t._y+r*t._z;if(o<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,o=-o):this.copy(t),1<=o)return this._w=a,this._x=i,this._y=n,this._z=r,this;var s=Math.sqrt(1-o*o);if(Math.abs(s)<.001)return this._w=.5*(a+this._w),this._x=.5*(i+this._x),this._y=.5*(n+this._y),this._z=.5*(r+this._z),this;var h=Math.atan2(s,o),c=Math.sin((1-e)*h)/s,l=Math.sin(e*h)/s;return this._w=a*c+this._w*l,this._x=i*c+this._x*l,this._y=n*c+this._y*l,this._z=r*c+this._z*l,this.onChangeCallback(),this},equals:function(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w},fromArray:function(t,e){return void 0===e&&(e=0),this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this.onChangeCallback(),this},toArray:function(t,e){return void 0===t&&(t=[]),void 0===e&&(e=0),t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t},onChange:function(t){return this.onChangeCallback=t,this},onChangeCallback:function(){}}),Object.assign(Ge.prototype,{isVector3:!0,set:function(t,e,i){return this.x=t,this.y=e,this.z=i,this},setScalar:function(t){return this.x=t,this.y=t,this.z=t,this},setX:function(t){return this.x=t,this},setY:function(t){return this.y=t,this},setZ:function(t){return this.z=t,this},setComponent:function(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this},getComponent:function(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}},clone:function(){return new this.constructor(this.x,this.y,this.z)},copy:function(t){return this.x=t.x,this.y=t.y,this.z=t.z,this},add:function(t,e){return void 0!==e?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this)},addScalar:function(t){return this.x+=t,this.y+=t,this.z+=t,this},addVectors:function(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this},addScaledVector:function(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this},sub:function(t,e){return void 0!==e?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this)},subScalar:function(t){return this.x-=t,this.y-=t,this.z-=t,this},subVectors:function(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this},multiply:function(t,e){return void 0!==e?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(t,e)):(this.x*=t.x,this.y*=t.y,this.z*=t.z,this)},multiplyScalar:function(t){return this.x*=t,this.y*=t,this.z*=t,this},multiplyVectors:function(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this},applyEuler:(b=new ze,function(t){return t&&t.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(b.setFromEuler(t))}),applyAxisAngle:(x=new ze,function(t,e){return this.applyQuaternion(x.setFromAxisAngle(t,e))}),applyMatrix3:function(t){var e=this.x,i=this.y,n=this.z,r=t.elements;return this.x=r[0]*e+r[3]*i+r[6]*n,this.y=r[1]*e+r[4]*i+r[7]*n,this.z=r[2]*e+r[5]*i+r[8]*n,this},applyMatrix4:function(t){var e=this.x,i=this.y,n=this.z,r=t.elements,a=1/(r[3]*e+r[7]*i+r[11]*n+r[15]);return this.x=(r[0]*e+r[4]*i+r[8]*n+r[12])*a,this.y=(r[1]*e+r[5]*i+r[9]*n+r[13])*a,this.z=(r[2]*e+r[6]*i+r[10]*n+r[14])*a,this},applyQuaternion:function(t){var e=this.x,i=this.y,n=this.z,r=t.x,a=t.y,o=t.z,s=t.w,h=s*e+a*n-o*i,c=s*i+o*e-r*n,l=s*n+r*i-a*e,u=-r*e-a*i-o*n;return this.x=h*s+u*-r+c*-o-l*-a,this.y=c*s+u*-a+l*-r-h*-o,this.z=l*s+u*-o+h*-a-c*-r,this},project:(y=new Fe,function(t){return y.multiplyMatrices(t.projectionMatrix,y.getInverse(t.matrixWorld)),this.applyMatrix4(y)}),unproject:(v=new Fe,function(t){return v.multiplyMatrices(t.matrixWorld,v.getInverse(t.projectionMatrix)),this.applyMatrix4(v)}),transformDirection:function(t){var e=this.x,i=this.y,n=this.z,r=t.elements;return this.x=r[0]*e+r[4]*i+r[8]*n,this.y=r[1]*e+r[5]*i+r[9]*n,this.z=r[2]*e+r[6]*i+r[10]*n,this.normalize()},divide:function(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this},divideScalar:function(t){return this.multiplyScalar(1/t)},min:function(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this},max:function(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this},clamp:function(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this},clampScalar:(m=new Ge,g=new Ge,function(t,e){return m.set(t,t,t),g.set(e,e,e),this.clamp(m,g)}),clampLength:function(t,e){var i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(e,i)))},floor:function(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this},ceil:function(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this},round:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this},roundToZero:function(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this},negate:function(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this},dot:function(t){return this.x*t.x+this.y*t.y+this.z*t.z},lengthSq:function(){return this.x*this.x+this.y*this.y+this.z*this.z},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)},manhattanLength:function(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)},normalize:function(){return this.divideScalar(this.length()||1)},setLength:function(t){return this.normalize().multiplyScalar(t)},lerp:function(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this},lerpVectors:function(t,e,i){return this.subVectors(e,t).multiplyScalar(i).add(t)},cross:function(t,e){return void 0!==e?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(t,e)):this.crossVectors(this,t)},crossVectors:function(t,e){var i=t.x,n=t.y,r=t.z,a=e.x,o=e.y,s=e.z;return this.x=n*s-r*o,this.y=r*a-i*s,this.z=i*o-n*a,this},projectOnVector:function(t){var e=t.dot(this)/t.lengthSq();return this.copy(t).multiplyScalar(e)},projectOnPlane:(f=new Ge,function(t){return f.copy(this).projectOnVector(t),this.sub(f)}),reflect:(p=new Ge,function(t){return this.sub(p.copy(t).multiplyScalar(2*this.dot(t)))}),angleTo:function(t){var e=this.dot(t)/Math.sqrt(this.lengthSq()*t.lengthSq());return Math.acos(De.clamp(e,-1,1))},distanceTo:function(t){return Math.sqrt(this.distanceToSquared(t))},distanceToSquared:function(t){var e=this.x-t.x,i=this.y-t.y,n=this.z-t.z;return e*e+i*i+n*n},manhattanDistanceTo:function(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)},setFromSpherical:function(t){var e=Math.sin(t.phi)*t.radius;return this.x=e*Math.sin(t.theta),this.y=Math.cos(t.phi)*t.radius,this.z=e*Math.cos(t.theta),this},setFromCylindrical:function(t){return this.x=t.radius*Math.sin(t.theta),this.y=t.y,this.z=t.radius*Math.cos(t.theta),this},setFromMatrixPosition:function(t){var e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this},setFromMatrixScale:function(t){var e=this.setFromMatrixColumn(t,0).length(),i=this.setFromMatrixColumn(t,1).length(),n=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=i,this.z=n,this},setFromMatrixColumn:function(t,e){return this.fromArray(t.elements,4*e)},equals:function(t){return t.x===this.x&&t.y===this.y&&t.z===this.z},fromArray:function(t,e){return void 0===e&&(e=0),this.x=t[e],this.y=t[e+1],this.z=t[e+2],this},toArray:function(t,e){return void 0===t&&(t=[]),void 0===e&&(e=0),t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t},fromBufferAttribute:function(t,e,i){return void 0!==i&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}}),Object.assign(He.prototype,{isMatrix3:!0,set:function(t,e,i,n,r,a,o,s,h){var c=this.elements;return c[0]=t,c[1]=n,c[2]=o,c[3]=e,c[4]=r,c[5]=s,c[6]=i,c[7]=a,c[8]=h,this},identity:function(){return this.set(1,0,0,0,1,0,0,0,1),this},clone:function(){return(new this.constructor).fromArray(this.elements)},copy:function(t){var e=this.elements,i=t.elements;return e[0]=i[0],e[1]=i[1],e[2]=i[2],e[3]=i[3],e[4]=i[4],e[5]=i[5],e[6]=i[6],e[7]=i[7],e[8]=i[8],this},setFromMatrix4:function(t){var e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this},applyToBufferAttribute:(_=new Ge,function(t){for(var e=0,i=t.count;e<i;e++)_.x=t.getX(e),_.y=t.getY(e),_.z=t.getZ(e),_.applyMatrix3(this),t.setXYZ(e,_.x,_.y,_.z);return t}),multiply:function(t){return this.multiplyMatrices(this,t)},premultiply:function(t){return this.multiplyMatrices(t,this)},multiplyMatrices:function(t,e){var i=t.elements,n=e.elements,r=this.elements,a=i[0],o=i[3],s=i[6],h=i[1],c=i[4],l=i[7],u=i[2],d=i[5],p=i[8],f=n[0],m=n[3],g=n[6],v=n[1],y=n[4],x=n[7],b=n[2],_=n[5],w=n[8];return r[0]=a*f+o*v+s*b,r[3]=a*m+o*y+s*_,r[6]=a*g+o*x+s*w,r[1]=h*f+c*v+l*b,r[4]=h*m+c*y+l*_,r[7]=h*g+c*x+l*w,r[2]=u*f+d*v+p*b,r[5]=u*m+d*y+p*_,r[8]=u*g+d*x+p*w,this},multiplyScalar:function(t){var e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this},determinant:function(){var t=this.elements,e=t[0],i=t[1],n=t[2],r=t[3],a=t[4],o=t[5],s=t[6],h=t[7],c=t[8];return e*a*c-e*o*h-i*r*c+i*o*s+n*r*h-n*a*s},getInverse:function(t,e){t&&t.isMatrix4&&console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");var i=t.elements,n=this.elements,r=i[0],a=i[1],o=i[2],s=i[3],h=i[4],c=i[5],l=i[6],u=i[7],d=i[8],p=d*h-c*u,f=c*l-d*s,m=u*s-h*l,g=r*p+a*f+o*m;if(0===g){var v="THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";if(!0===e)throw new Error(v);return console.warn(v),this.identity()}var y=1/g;return n[0]=p*y,n[1]=(o*u-d*a)*y,n[2]=(c*a-o*h)*y,n[3]=f*y,n[4]=(d*r-o*l)*y,n[5]=(o*s-c*r)*y,n[6]=m*y,n[7]=(a*l-u*r)*y,n[8]=(h*r-a*s)*y,this},transpose:function(){var t,e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this},getNormalMatrix:function(t){return this.setFromMatrix4(t).getInverse(this).transpose()},transposeIntoArray:function(t){var e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this},setUvTransform:function(t,e,i,n,r,a,o){var s=Math.cos(r),h=Math.sin(r);this.set(i*s,i*h,-i*(s*a+h*o)+a+t,-n*h,n*s,-n*(-h*a+s*o)+o+e,0,0,1)},scale:function(t,e){var i=this.elements;return i[0]*=t,i[3]*=t,i[6]*=t,i[1]*=e,i[4]*=e,i[7]*=e,this},rotate:function(t){var e=Math.cos(t),i=Math.sin(t),n=this.elements,r=n[0],a=n[3],o=n[6],s=n[1],h=n[4],c=n[7];return n[0]=e*r+i*s,n[3]=e*a+i*h,n[6]=e*o+i*c,n[1]=-i*r+e*s,n[4]=-i*a+e*h,n[7]=-i*o+e*c,this},translate:function(t,e){var i=this.elements;return i[0]+=t*i[2],i[3]+=t*i[5],i[6]+=t*i[8],i[1]+=e*i[2],i[4]+=e*i[5],i[7]+=e*i[8],this},equals:function(t){for(var e=this.elements,i=t.elements,n=0;n<9;n++)if(e[n]!==i[n])return!1;return!0},fromArray:function(t,e){void 0===e&&(e=0);for(var i=0;i<9;i++)this.elements[i]=t[i+e];return this},toArray:function(t,e){void 0===t&&(t=[]),void 0===e&&(e=0);var i=this.elements;return t[e]=i[0],t[e+1]=i[1],t[e+2]=i[2],t[e+3]=i[3],t[e+4]=i[4],t[e+5]=i[5],t[e+6]=i[6],t[e+7]=i[7],t[e+8]=i[8],t}});var Ve,ke,je,We,Xe,qe,Ye,Ze,Je,Qe,Ke,$e,ti,ei,ii,ni,ri=0;function ai(t,e,i,n,r,a,o,s,h,c){Object.defineProperty(this,"id",{value:ri++}),this.uuid=De.generateUUID(),this.name="",this.image=void 0!==t?t:ai.DEFAULT_IMAGE,this.mipmaps=[],this.mapping=void 0!==e?e:ai.DEFAULT_MAPPING,this.wrapS=void 0!==i?i:_t,this.wrapT=void 0!==n?n:_t,this.magFilter=void 0!==r?r:St,this.minFilter=void 0!==a?a:Pt,this.anisotropy=void 0!==h?h:1,this.format=void 0!==o?o:Xt,this.type=void 0!==s?s:Ot,this.offset=new Be(0,0),this.repeat=new Be(1,1),this.center=new Be(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new He,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=void 0!==c?c:Ae,this.version=0,this.onUpdate=null}function oi(t,e,i,n){this.x=t||0,this.y=e||0,this.z=i||0,this.w=void 0!==n?n:1}function si(t,e,i){this.width=t,this.height=e,this.scissor=new oi(0,0,t,e),this.scissorTest=!1,this.viewport=new oi(0,0,t,e),void 0===(i=i||{}).minFilter&&(i.minFilter=St),this.texture=new ai(void 0,void 0,i.wrapS,i.wrapT,i.magFilter,i.minFilter,i.format,i.type,i.anisotropy,i.encoding),this.texture.generateMipmaps=void 0===i.generateMipmaps||i.generateMipmaps,this.depthBuffer=void 0===i.depthBuffer||i.depthBuffer,this.stencilBuffer=void 0===i.stencilBuffer||i.stencilBuffer,this.depthTexture=void 0!==i.depthTexture?i.depthTexture:null}function hi(t,e,i){si.call(this,t,e,i),this.activeCubeFace=0,this.activeMipMapLevel=0}function ci(t,e,i,n,r,a,o,s,h,c,l,u){ai.call(this,null,a,o,s,h,c,n,r,l,u),this.image={data:t,width:e,height:i},this.magFilter=void 0!==h?h:Mt,this.minFilter=void 0!==c?c:Mt,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}function li(t,e){this.min=void 0!==t?t:new Ge(1/0,1/0,1/0),this.max=void 0!==e?e:new Ge(-1/0,-1/0,-1/0)}function ui(t,e){this.center=void 0!==t?t:new Ge,this.radius=void 0!==e?e:0}function di(t,e){this.normal=void 0!==t?t:new Ge(1,0,0),this.constant=void 0!==e?e:0}function pi(t,e,i,n,r,a){this.planes=[void 0!==t?t:new di,void 0!==e?e:new di,void 0!==i?i:new di,void 0!==n?n:new di,void 0!==r?r:new di,void 0!==a?a:new di]}ai.DEFAULT_IMAGE=void 0,ai.DEFAULT_MAPPING=300,ai.prototype=Object.assign(Object.create(e.prototype),{constructor:ai,isTexture:!0,updateMatrix:function(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)},clone:function(){return(new this.constructor).copy(this)},copy:function(t){return this.name=t.name,this.image=t.image,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.encoding=t.encoding,this},toJSON:function(t){var e=void 0===t||"string"==typeof t;if(!e&&void 0!==t.textures[this.uuid])return t.textures[this.uuid];var i={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY};if(void 0!==this.image){var n=this.image;void 0===n.uuid&&(n.uuid=De.generateUUID()),e||void 0!==t.images[n.uuid]||(t.images[n.uuid]={uuid:n.uuid,url:function(t){var e;if(t instanceof HTMLCanvasElement)e=t;else{(e=document.createElementNS("http://www.w3.org/1999/xhtml","canvas")).width=t.width,e.height=t.height;var i=e.getContext("2d");t instanceof ImageData?i.putImageData(t,0,0):i.drawImage(t,0,0,t.width,t.height)}return 2048<e.width||2048<e.height?e.toDataURL("image/jpeg",.6):e.toDataURL("image/png")}(n)}),i.image=n.uuid}return e||(t.textures[this.uuid]=i),i},dispose:function(){this.dispatchEvent({type:"dispose"})},transformUv:function(t){if(300===this.mapping){if(t.applyMatrix3(this.matrix),t.x<0||1<t.x)switch(this.wrapS){case bt:t.x=t.x-Math.floor(t.x);break;case _t:t.x=t.x<0?0:1;break;case wt:1===Math.abs(Math.floor(t.x)%2)?t.x=Math.ceil(t.x)-t.x:t.x=t.x-Math.floor(t.x)}if(t.y<0||1<t.y)switch(this.wrapT){case bt:t.y=t.y-Math.floor(t.y);break;case _t:t.y=t.y<0?0:1;break;case wt:1===Math.abs(Math.floor(t.y)%2)?t.y=Math.ceil(t.y)-t.y:t.y=t.y-Math.floor(t.y)}this.flipY&&(t.y=1-t.y)}}}),Object.defineProperty(ai.prototype,"needsUpdate",{set:function(t){!0===t&&this.version++}}),Object.assign(oi.prototype,{isVector4:!0,set:function(t,e,i,n){return this.x=t,this.y=e,this.z=i,this.w=n,this},setScalar:function(t){return this.x=t,this.y=t,this.z=t,this.w=t,this},setX:function(t){return this.x=t,this},setY:function(t){return this.y=t,this},setZ:function(t){return this.z=t,this},setW:function(t){return this.w=t,this},setComponent:function(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+t)}return this},getComponent:function(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}},clone:function(){return new this.constructor(this.x,this.y,this.z,this.w)},copy:function(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=void 0!==t.w?t.w:1,this},add:function(t,e){return void 0!==e?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this)},addScalar:function(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this},addVectors:function(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this},addScaledVector:function(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this},sub:function(t,e){return void 0!==e?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this)},subScalar:function(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this},subVectors:function(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this},multiplyScalar:function(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this},applyMatrix4:function(t){var e=this.x,i=this.y,n=this.z,r=this.w,a=t.elements;return this.x=a[0]*e+a[4]*i+a[8]*n+a[12]*r,this.y=a[1]*e+a[5]*i+a[9]*n+a[13]*r,this.z=a[2]*e+a[6]*i+a[10]*n+a[14]*r,this.w=a[3]*e+a[7]*i+a[11]*n+a[15]*r,this},divideScalar:function(t){return this.multiplyScalar(1/t)},setAxisAngleFromQuaternion:function(t){this.w=2*Math.acos(t.w);var e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this},setAxisAngleFromRotationMatrix:function(t){var e,i,n,r,a=t.elements,o=a[0],s=a[4],h=a[8],c=a[1],l=a[5],u=a[9],d=a[2],p=a[6],f=a[10];if(Math.abs(s-c)<.01&&Math.abs(h-d)<.01&&Math.abs(u-p)<.01){if(Math.abs(s+c)<.1&&Math.abs(h+d)<.1&&Math.abs(u+p)<.1&&Math.abs(o+l+f-3)<.1)return this.set(1,0,0,0),this;e=Math.PI;var m=(o+1)/2,g=(l+1)/2,v=(f+1)/2,y=(s+c)/4,x=(h+d)/4,b=(u+p)/4;return g<m&&v<m?m<.01?(i=0,r=n=.707106781):(n=y/(i=Math.sqrt(m)),r=x/i):v<g?g<.01?(n=0,r=i=.707106781):(i=y/(n=Math.sqrt(g)),r=b/n):v<.01?(n=i=.707106781,r=0):(i=x/(r=Math.sqrt(v)),n=b/r),this.set(i,n,r,e),this}var _=Math.sqrt((p-u)*(p-u)+(h-d)*(h-d)+(c-s)*(c-s));return Math.abs(_)<.001&&(_=1),this.x=(p-u)/_,this.y=(h-d)/_,this.z=(c-s)/_,this.w=Math.acos((o+l+f-1)/2),this},min:function(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this},max:function(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this},clamp:function(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this.w=Math.max(t.w,Math.min(e.w,this.w)),this},clampScalar:function(t,e){return void 0===Ve&&(Ve=new oi,ke=new oi),Ve.set(t,t,t,t),ke.set(e,e,e,e),this.clamp(Ve,ke)},clampLength:function(t,e){var i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(e,i)))},floor:function(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this},ceil:function(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this},round:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this},roundToZero:function(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this},negate:function(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this},dot:function(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w},lengthSq:function(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)},manhattanLength:function(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)},normalize:function(){return this.divideScalar(this.length()||1)},setLength:function(t){return this.normalize().multiplyScalar(t)},lerp:function(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this},lerpVectors:function(t,e,i){return this.subVectors(e,t).multiplyScalar(i).add(t)},equals:function(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w},fromArray:function(t,e){return void 0===e&&(e=0),this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this},toArray:function(t,e){return void 0===t&&(t=[]),void 0===e&&(e=0),t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t},fromBufferAttribute:function(t,e,i){return void 0!==i&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this.w=t.getW(e),this}}),si.prototype=Object.assign(Object.create(e.prototype),{constructor:si,isWebGLRenderTarget:!0,setSize:function(t,e){this.width===t&&this.height===e||(this.width=t,this.height=e,this.dispose()),this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e)},clone:function(){return(new this.constructor).copy(this)},copy:function(t){return this.width=t.width,this.height=t.height,this.viewport.copy(t.viewport),this.texture=t.texture.clone(),this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,this.depthTexture=t.depthTexture,this},dispose:function(){this.dispatchEvent({type:"dispose"})}}),((hi.prototype=Object.create(si.prototype)).constructor=hi).prototype.isWebGLRenderTargetCube=!0,((ci.prototype=Object.create(ai.prototype)).constructor=ci).prototype.isDataTexture=!0,Object.assign(li.prototype,{isBox3:!0,set:function(t,e){return this.min.copy(t),this.max.copy(e),this},setFromArray:function(t){for(var e=1/0,i=1/0,n=1/0,r=-1/0,a=-1/0,o=-1/0,s=0,h=t.length;s<h;s+=3){var c=t[s],l=t[s+1],u=t[s+2];c<e&&(e=c),l<i&&(i=l),u<n&&(n=u),r<c&&(r=c),a<l&&(a=l),o<u&&(o=u)}return this.min.set(e,i,n),this.max.set(r,a,o),this},setFromBufferAttribute:function(t){for(var e=1/0,i=1/0,n=1/0,r=-1/0,a=-1/0,o=-1/0,s=0,h=t.count;s<h;s++){var c=t.getX(s),l=t.getY(s),u=t.getZ(s);c<e&&(e=c),l<i&&(i=l),u<n&&(n=u),r<c&&(r=c),a<l&&(a=l),o<u&&(o=u)}return this.min.set(e,i,n),this.max.set(r,a,o),this},setFromPoints:function(t){this.makeEmpty();for(var e=0,i=t.length;e<i;e++)this.expandByPoint(t[e]);return this},setFromCenterAndSize:(qe=new Ge,function(t,e){var i=qe.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(i),this.max.copy(t).add(i),this}),setFromObject:function(t){return this.makeEmpty(),this.expandByObject(t)},clone:function(){return(new this.constructor).copy(this)},copy:function(t){return this.min.copy(t.min),this.max.copy(t.max),this},makeEmpty:function(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this},isEmpty:function(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z},getCenter:function(t){return void 0===t&&(console.warn("THREE.Box3: .getCenter() target is now required"),t=new Ge),this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)},getSize:function(t){return void 0===t&&(console.warn("THREE.Box3: .getSize() target is now required"),t=new Ge),this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)},expandByPoint:function(t){return this.min.min(t),this.max.max(t),this},expandByVector:function(t){return this.min.sub(t),this.max.add(t),this},expandByScalar:function(t){return this.min.addScalar(-t),this.max.addScalar(t),this},expandByObject:function(){var r,a,o,s=new Ge;function e(t){var e=t.geometry;if(void 0!==e)if(e.isGeometry){var i=e.vertices;for(a=0,o=i.length;a<o;a++)s.copy(i[a]),s.applyMatrix4(t.matrixWorld),r.expandByPoint(s)}else if(e.isBufferGeometry){var n=e.attributes.position;if(void 0!==n)for(a=0,o=n.count;a<o;a++)s.fromBufferAttribute(n,a).applyMatrix4(t.matrixWorld),r.expandByPoint(s)}}return function(t){return r=this,t.updateMatrixWorld(!0),t.traverse(e),this}}(),containsPoint:function(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y||t.z<this.min.z||t.z>this.max.z)},containsBox:function(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z},getParameter:function(t,e){return void 0===e&&(console.warn("THREE.Box3: .getParameter() target is now required"),e=new Ge),e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))},intersectsBox:function(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y||t.max.z<this.min.z||t.min.z>this.max.z)},intersectsSphere:(Xe=new Ge,function(t){return this.clampPoint(t.center,Xe),Xe.distanceToSquared(t.center)<=t.radius*t.radius}),intersectsPlane:function(t){var e,i;return 0<t.normal.x?(e=t.normal.x*this.min.x,i=t.normal.x*this.max.x):(e=t.normal.x*this.max.x,i=t.normal.x*this.min.x),0<t.normal.y?(e+=t.normal.y*this.min.y,i+=t.normal.y*this.max.y):(e+=t.normal.y*this.max.y,i+=t.normal.y*this.min.y),0<t.normal.z?(e+=t.normal.z*this.min.z,i+=t.normal.z*this.max.z):(e+=t.normal.z*this.max.z,i+=t.normal.z*this.min.z),e<=t.constant&&i>=t.constant},intersectsTriangle:function(){var s=new Ge,h=new Ge,c=new Ge,i=new Ge,n=new Ge,r=new Ge,l=new Ge,a=new Ge,u=new Ge,o=new Ge;function d(t){var e,i;for(e=0,i=t.length-3;e<=i;e+=3){l.fromArray(t,e);var n=u.x*Math.abs(l.x)+u.y*Math.abs(l.y)+u.z*Math.abs(l.z),r=s.dot(l),a=h.dot(l),o=c.dot(l);if(Math.max(-Math.max(r,a,o),Math.min(r,a,o))>n)return!1}return!0}return function(t){if(this.isEmpty())return!1;this.getCenter(a),u.subVectors(this.max,a),s.subVectors(t.a,a),h.subVectors(t.b,a),c.subVectors(t.c,a),i.subVectors(h,s),n.subVectors(c,h),r.subVectors(s,c);var e=[0,-i.z,i.y,0,-n.z,n.y,0,-r.z,r.y,i.z,0,-i.x,n.z,0,-n.x,r.z,0,-r.x,-i.y,i.x,0,-n.y,n.x,0,-r.y,r.x,0];return!!d(e)&&(!!d(e=[1,0,0,0,1,0,0,0,1])&&(o.crossVectors(i,n),d(e=[o.x,o.y,o.z])))}}(),clampPoint:function(t,e){return void 0===e&&(console.warn("THREE.Box3: .clampPoint() target is now required"),e=new Ge),e.copy(t).clamp(this.min,this.max)},distanceToPoint:(We=new Ge,function(t){return We.copy(t).clamp(this.min,this.max).sub(t).length()}),getBoundingSphere:(je=new Ge,function(t){return void 0===t&&(console.warn("THREE.Box3: .getBoundingSphere() target is now required"),t=new ui),this.getCenter(t.center),t.radius=.5*this.getSize(je).length(),t}),intersect:function(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this},union:function(t){return this.min.min(t.min),this.max.max(t.max),this},applyMatrix4:function(t){if(this.isEmpty())return this;var e=t.elements,i=e[0]*this.min.x,n=e[1]*this.min.x,r=e[2]*this.min.x,a=e[0]*this.max.x,o=e[1]*this.max.x,s=e[2]*this.max.x,h=e[4]*this.min.y,c=e[5]*this.min.y,l=e[6]*this.min.y,u=e[4]*this.max.y,d=e[5]*this.max.y,p=e[6]*this.max.y,f=e[8]*this.min.z,m=e[9]*this.min.z,g=e[10]*this.min.z,v=e[8]*this.max.z,y=e[9]*this.max.z,x=e[10]*this.max.z;return this.min.x=Math.min(i,a)+Math.min(h,u)+Math.min(f,v)+e[12],this.min.y=Math.min(n,o)+Math.min(c,d)+Math.min(m,y)+e[13],this.min.z=Math.min(r,s)+Math.min(l,p)+Math.min(g,x)+e[14],this.max.x=Math.max(i,a)+Math.max(h,u)+Math.max(f,v)+e[12],this.max.y=Math.max(n,o)+Math.max(c,d)+Math.max(m,y)+e[13],this.max.z=Math.max(r,s)+Math.max(l,p)+Math.max(g,x)+e[14],this},translate:function(t){return this.min.add(t),this.max.add(t),this},equals:function(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}),Object.assign(ui.prototype,{set:function(t,e){return this.center.copy(t),this.radius=e,this},setFromPoints:(Ye=new li,function(t,e){var i=this.center;void 0!==e?i.copy(e):Ye.setFromPoints(t).getCenter(i);for(var n=0,r=0,a=t.length;r<a;r++)n=Math.max(n,i.distanceToSquared(t[r]));return this.radius=Math.sqrt(n),this}),clone:function(){return(new this.constructor).copy(this)},copy:function(t){return this.center.copy(t.center),this.radius=t.radius,this},empty:function(){return this.radius<=0},containsPoint:function(t){return t.distanceToSquared(this.center)<=this.radius*this.radius},distanceToPoint:function(t){return t.distanceTo(this.center)-this.radius},intersectsSphere:function(t){var e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e},intersectsBox:function(t){return t.intersectsSphere(this)},intersectsPlane:function(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius},clampPoint:function(t,e){var i=this.center.distanceToSquared(t);return void 0===e&&(console.warn("THREE.Sphere: .clampPoint() target is now required"),e=new Ge),e.copy(t),i>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e},getBoundingBox:function(t){return void 0===t&&(console.warn("THREE.Sphere: .getBoundingBox() target is now required"),t=new li),t.set(this.center,this.center),t.expandByScalar(this.radius),t},applyMatrix4:function(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this},translate:function(t){return this.center.add(t),this},equals:function(t){return t.center.equals(this.center)&&t.radius===this.radius}}),Object.assign(di.prototype,{set:function(t,e){return this.normal.copy(t),this.constant=e,this},setComponents:function(t,e,i,n){return this.normal.set(t,e,i),this.constant=n,this},setFromNormalAndCoplanarPoint:function(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this},setFromCoplanarPoints:(Ke=new Ge,$e=new Ge,function(t,e,i){var n=Ke.subVectors(i,e).cross($e.subVectors(t,e)).normalize();return this.setFromNormalAndCoplanarPoint(n,t),this}),clone:function(){return(new this.constructor).copy(this)},copy:function(t){return this.normal.copy(t.normal),this.constant=t.constant,this},normalize:function(){var t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this},negate:function(){return this.constant*=-1,this.normal.negate(),this},distanceToPoint:function(t){return this.normal.dot(t)+this.constant},distanceToSphere:function(t){return this.distanceToPoint(t.center)-t.radius},projectPoint:function(t,e){return void 0===e&&(console.warn("THREE.Plane: .projectPoint() target is now required"),e=new Ge),e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)},intersectLine:(Qe=new Ge,function(t,e){void 0===e&&(console.warn("THREE.Plane: .intersectLine() target is now required"),e=new Ge);var i=t.delta(Qe),n=this.normal.dot(i);if(0===n)return 0===this.distanceToPoint(t.start)?e.copy(t.start):void 0;var r=-(t.start.dot(this.normal)+this.constant)/n;return r<0||1<r?void 0:e.copy(i).multiplyScalar(r).add(t.start)}),intersectsLine:function(t){var e=this.distanceToPoint(t.start),i=this.distanceToPoint(t.end);return e<0&&0<i||i<0&&0<e},intersectsBox:function(t){return t.intersectsPlane(this)},intersectsSphere:function(t){return t.intersectsPlane(this)},coplanarPoint:function(t){return void 0===t&&(console.warn("THREE.Plane: .coplanarPoint() target is now required"),t=new Ge),t.copy(this.normal).multiplyScalar(-this.constant)},applyMatrix4:(Ze=new Ge,Je=new He,function(t,e){var i=e||Je.getNormalMatrix(t),n=this.coplanarPoint(Ze).applyMatrix4(t),r=this.normal.applyMatrix3(i).normalize();return this.constant=-n.dot(r),this}),translate:function(t){return this.constant-=t.dot(this.normal),this},equals:function(t){return t.normal.equals(this.normal)&&t.constant===this.constant}}),Object.assign(pi.prototype,{set:function(t,e,i,n,r,a){var o=this.planes;return o[0].copy(t),o[1].copy(e),o[2].copy(i),o[3].copy(n),o[4].copy(r),o[5].copy(a),this},clone:function(){return(new this.constructor).copy(this)},copy:function(t){for(var e=this.planes,i=0;i<6;i++)e[i].copy(t.planes[i]);return this},setFromMatrix:function(t){var e=this.planes,i=t.elements,n=i[0],r=i[1],a=i[2],o=i[3],s=i[4],h=i[5],c=i[6],l=i[7],u=i[8],d=i[9],p=i[10],f=i[11],m=i[12],g=i[13],v=i[14],y=i[15];return e[0].setComponents(o-n,l-s,f-u,y-m).normalize(),e[1].setComponents(o+n,l+s,f+u,y+m).normalize(),e[2].setComponents(o+r,l+h,f+d,y+g).normalize(),e[3].setComponents(o-r,l-h,f-d,y-g).normalize(),e[4].setComponents(o-a,l-c,f-p,y-v).normalize(),e[5].setComponents(o+a,l+c,f+p,y+v).normalize(),this},intersectsObject:(ni=new ui,function(t){var e=t.geometry;return null===e.boundingSphere&&e.computeBoundingSphere(),ni.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),this.intersectsSphere(ni)}),intersectsSprite:(ii=new ui,function(t){return ii.center.set(0,0,0),ii.radius=.7071067811865476,ii.applyMatrix4(t.matrixWorld),this.intersectsSphere(ii)}),intersectsSphere:function(t){for(var e=this.planes,i=t.center,n=-t.radius,r=0;r<6;r++){if(e[r].distanceToPoint(i)<n)return!1}return!0},intersectsBox:(ti=new Ge,ei=new Ge,function(t){for(var e=this.planes,i=0;i<6;i++){var n=e[i];ti.x=0<n.normal.x?t.min.x:t.max.x,ei.x=0<n.normal.x?t.max.x:t.min.x,ti.y=0<n.normal.y?t.min.y:t.max.y,ei.y=0<n.normal.y?t.max.y:t.min.y,ti.z=0<n.normal.z?t.min.z:t.max.z,ei.z=0<n.normal.z?t.max.z:t.min.z;var r=n.distanceToPoint(ti),a=n.distanceToPoint(ei);if(r<0&&a<0)return!1}return!0}),containsPoint:function(t){for(var e=this.planes,i=0;i<6;i++)if(e[i].distanceToPoint(t)<0)return!1;return!0}});var fi,mi={alphamap_fragment:"#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n",alphamap_pars_fragment:"#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n",alphatest_fragment:"#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n",aomap_fragment:"#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n",aomap_pars_fragment:"#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",begin_vertex:"\nvec3 transformed = vec3( position );\n",beginnormal_vertex:"\nvec3 objectNormal = vec3( normal );\n",bsdfs:"float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t}\n\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n",bumpmap_pars_fragment:"#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n",clipping_planes_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n",clipping_planes_pars_fragment:"#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n",clipping_planes_pars_vertex:"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n",clipping_planes_vertex:"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n",color_fragment:"#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",color_pars_fragment:"#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n",color_pars_vertex:"#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",color_vertex:"#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",common:"#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\n",cube_uv_reflection_fragment:"#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n",defaultnormal_vertex:"vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n",displacementmap_pars_vertex:"#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n",displacementmap_vertex:"#ifdef USE_DISPLACEMENTMAP\n\tvec2 transformedUV = ( uvTransform * vec3( uv, 1 ) ).xy;\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, transformedUV ).x * displacementScale + displacementBias );\n#endif\n",emissivemap_fragment:"#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n",emissivemap_pars_fragment:"#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n",encodings_fragment:"  gl_FragColor = linearToOutputTexel( gl_FragColor );\n",encodings_pars_fragment:"\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n",envmap_fragment:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n",envmap_pars_fragment:"#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n",envmap_pars_vertex:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n",envmap_vertex:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n",fog_vertex:"\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif",fog_pars_vertex:"#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n",fog_fragment:"#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n",fog_pars_fragment:"#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n",gradientmap_pars_fragment:"#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n",lightmap_fragment:"#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n",lightmap_pars_fragment:"#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",lights_lambert_vertex:"vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n",lights_pars_begin:"uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n",lights_pars_maps:"#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n",lights_phong_fragment:"BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n",lights_phong_pars_fragment:"varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n",lights_physical_fragment:"PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n",lights_physical_pars_fragment:"struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n",lights_fragment_begin:"\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif\n",lights_fragment_maps:"#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif\n",lights_fragment_end:"#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n",logdepthbuf_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",logdepthbuf_pars_fragment:"#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n",logdepthbuf_pars_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif",logdepthbuf_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif\n",map_fragment:"#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n",map_pars_fragment:"#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n",map_particle_fragment:"#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n",map_particle_pars_fragment:"#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif\n",metalnessmap_fragment:"float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n",metalnessmap_pars_fragment:"#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",morphnormal_vertex:"#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n",morphtarget_pars_vertex:"#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",morphtarget_vertex:"#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n",normal_fragment_begin:"#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif\n",normal_fragment_maps:"#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n",normalmap_pars_fragment:"#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy *= normalScale;\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n",packing:"vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n",premultiplied_alpha_fragment:"#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n",project_vertex:"vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n",dithering_fragment:"#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n",dithering_pars_fragment:"#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n",roughnessmap_fragment:"float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n",roughnessmap_pars_fragment:"#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",shadowmap_pars_fragment:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n",shadowmap_pars_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n",shadowmap_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n",shadowmask_pars_fragment:"float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n",skinbase_vertex:"#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",skinning_pars_vertex:"#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n",skinning_vertex:"#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n",skinnormal_vertex:"#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n",specularmap_fragment:"float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",specularmap_pars_fragment:"#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",tonemapping_fragment:"#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n",tonemapping_pars_fragment:"#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n",uv_pars_fragment:"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif",uv_pars_vertex:"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#else\n \t#if defined( USE_DISPLACEMENTMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n",uv_vertex:"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif\n",uv2_pars_fragment:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",uv2_pars_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",uv2_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",worldpos_vertex:"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif\n",cube_frag:"uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n",cube_vert:"varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}\n",depth_frag:"#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n",depth_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n",distanceRGBA_frag:"#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}\n",distanceRGBA_vert:"#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}\n",equirect_frag:"uniform sampler2D tEquirect;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n",equirect_vert:"varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n",linedashed_frag:"uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",linedashed_vert:"uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n",meshbasic_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",meshbasic_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n",meshlambert_frag:"uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_pars_maps>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",meshlambert_vert:"#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_pars_maps>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",meshphong_frag:"#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_pars_maps>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",meshphong_vert:"#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",meshphysical_frag:"#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars_begin>\n#include <lights_pars_maps>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",meshphysical_vert:"#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",normal_frag:"#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n",normal_vert:"#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n",points_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",points_vert:"uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",shadow_frag:"uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}\n",shadow_vert:"#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n"},gi={merge:function(t){for(var e={},i=0;i<t.length;i++){var n=this.clone(t[i]);for(var r in n)e[r]=n[r]}return e},clone:function(t){var e={};for(var i in t)for(var n in e[i]={},t[i]){var r=t[i][n];r&&(r.isColor||r.isMatrix3||r.isMatrix4||r.isVector2||r.isVector3||r.isVector4||r.isTexture)?e[i][n]=r.clone():Array.isArray(r)?e[i][n]=r.slice():e[i][n]=r}return e}},vi={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074};function yi(t,e,i){return void 0===e&&void 0===i?this.set(t):this.setRGB(t,e,i)}Object.assign(yi.prototype,{isColor:!0,r:1,g:1,b:1,set:function(t){return t&&t.isColor?this.copy(t):"number"==typeof t?this.setHex(t):"string"==typeof t&&this.setStyle(t),this},setScalar:function(t){return this.r=t,this.g=t,this.b=t,this},setHex:function(t){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(255&t)/255,this},setRGB:function(t,e,i){return this.r=t,this.g=e,this.b=i,this},setHSL:function(){function a(t,e,i){return i<0&&(i+=1),1<i&&(i-=1),i<1/6?t+6*(e-t)*i:i<.5?e:i<2/3?t+6*(e-t)*(2/3-i):t}return function(t,e,i){if(t=De.euclideanModulo(t,1),e=De.clamp(e,0,1),i=De.clamp(i,0,1),0===e)this.r=this.g=this.b=i;else{var n=i<=.5?i*(1+e):i+e-i*e,r=2*i-n;this.r=a(r,n,t+1/3),this.g=a(r,n,t),this.b=a(r,n,t-1/3)}return this}}(),setStyle:function(e){function t(t){void 0!==t&&parseFloat(t)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}var i;if(i=/^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(e)){var n,r=i[1],a=i[2];switch(r){case"rgb":case"rgba":if(n=/^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a))return this.r=Math.min(255,parseInt(n[1],10))/255,this.g=Math.min(255,parseInt(n[2],10))/255,this.b=Math.min(255,parseInt(n[3],10))/255,t(n[5]),this;if(n=/^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a))return this.r=Math.min(100,parseInt(n[1],10))/100,this.g=Math.min(100,parseInt(n[2],10))/100,this.b=Math.min(100,parseInt(n[3],10))/100,t(n[5]),this;break;case"hsl":case"hsla":if(n=/^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)){var o=parseFloat(n[1])/360,s=parseInt(n[2],10)/100,h=parseInt(n[3],10)/100;return t(n[5]),this.setHSL(o,s,h)}}}else if(i=/^\#([A-Fa-f0-9]+)$/.exec(e)){var c,l=(c=i[1]).length;if(3===l)return this.r=parseInt(c.charAt(0)+c.charAt(0),16)/255,this.g=parseInt(c.charAt(1)+c.charAt(1),16)/255,this.b=parseInt(c.charAt(2)+c.charAt(2),16)/255,this;if(6===l)return this.r=parseInt(c.charAt(0)+c.charAt(1),16)/255,this.g=parseInt(c.charAt(2)+c.charAt(3),16)/255,this.b=parseInt(c.charAt(4)+c.charAt(5),16)/255,this}e&&0<e.length&&(void 0!==(c=vi[e])?this.setHex(c):console.warn("THREE.Color: Unknown color "+e));return this},clone:function(){return new this.constructor(this.r,this.g,this.b)},copy:function(t){return this.r=t.r,this.g=t.g,this.b=t.b,this},copyGammaToLinear:function(t,e){return void 0===e&&(e=2),this.r=Math.pow(t.r,e),this.g=Math.pow(t.g,e),this.b=Math.pow(t.b,e),this},copyLinearToGamma:function(t,e){void 0===e&&(e=2);var i=0<e?1/e:1;return this.r=Math.pow(t.r,i),this.g=Math.pow(t.g,i),this.b=Math.pow(t.b,i),this},convertGammaToLinear:function(t){return this.copyGammaToLinear(this,t),this},convertLinearToGamma:function(t){return this.copyLinearToGamma(this,t),this},getHex:function(){return 255*this.r<<16^255*this.g<<8^255*this.b<<0},getHexString:function(){return("000000"+this.getHex().toString(16)).slice(-6)},getHSL:function(t){void 0===t&&(console.warn("THREE.Color: .getHSL() target is now required"),t={h:0,s:0,l:0});var e,i,n=this.r,r=this.g,a=this.b,o=Math.max(n,r,a),s=Math.min(n,r,a),h=(s+o)/2;if(s===o)i=e=0;else{var c=o-s;switch(i=h<=.5?c/(o+s):c/(2-o-s),o){case n:e=(r-a)/c+(r<a?6:0);break;case r:e=(a-n)/c+2;break;case a:e=(n-r)/c+4}e/=6}return t.h=e,t.s=i,t.l=h,t},getStyle:function(){return"rgb("+(255*this.r|0)+","+(255*this.g|0)+","+(255*this.b|0)+")"},offsetHSL:(fi={},function(t,e,i){return this.getHSL(fi),fi.h+=t,fi.s+=e,fi.l+=i,this.setHSL(fi.h,fi.s,fi.l),this}),add:function(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this},addColors:function(t,e){return this.r=t.r+e.r,this.g=t.g+e.g,this.b=t.b+e.b,this},addScalar:function(t){return this.r+=t,this.g+=t,this.b+=t,this},sub:function(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this},multiply:function(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this},multiplyScalar:function(t){return this.r*=t,this.g*=t,this.b*=t,this},lerp:function(t,e){return this.r+=(t.r-this.r)*e,this.g+=(t.g-this.g)*e,this.b+=(t.b-this.b)*e,this},equals:function(t){return t.r===this.r&&t.g===this.g&&t.b===this.b},fromArray:function(t,e){return void 0===e&&(e=0),this.r=t[e],this.g=t[e+1],this.b=t[e+2],this},toArray:function(t,e){return void 0===t&&(t=[]),void 0===e&&(e=0),t[e]=this.r,t[e+1]=this.g,t[e+2]=this.b,t},toJSON:function(){return this.getHex()}});var xi,bi,_i={common:{diffuse:{value:new yi(15658734)},opacity:{value:1},map:{value:null},uvTransform:{value:new He},alphaMap:{value:null}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},refractionRatio:{value:.98},maxMipLevel:{value:0}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new Be(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new yi(16777215)}},lights:{ambientLightColor:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{},shadow:{},shadowBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{},shadow:{},shadowBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{},shadow:{},shadowBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}}},points:{diffuse:{value:new yi(15658734)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},uvTransform:{value:new He}}},wi={basic:{uniforms:gi.merge([_i.common,_i.specularmap,_i.envmap,_i.aomap,_i.lightmap,_i.fog]),vertexShader:mi.meshbasic_vert,fragmentShader:mi.meshbasic_frag},lambert:{uniforms:gi.merge([_i.common,_i.specularmap,_i.envmap,_i.aomap,_i.lightmap,_i.emissivemap,_i.fog,_i.lights,{emissive:{value:new yi(0)}}]),vertexShader:mi.meshlambert_vert,fragmentShader:mi.meshlambert_frag},phong:{uniforms:gi.merge([_i.common,_i.specularmap,_i.envmap,_i.aomap,_i.lightmap,_i.emissivemap,_i.bumpmap,_i.normalmap,_i.displacementmap,_i.gradientmap,_i.fog,_i.lights,{emissive:{value:new yi(0)},specular:{value:new yi(1118481)},shininess:{value:30}}]),vertexShader:mi.meshphong_vert,fragmentShader:mi.meshphong_frag},standard:{uniforms:gi.merge([_i.common,_i.envmap,_i.aomap,_i.lightmap,_i.emissivemap,_i.bumpmap,_i.normalmap,_i.displacementmap,_i.roughnessmap,_i.metalnessmap,_i.fog,_i.lights,{emissive:{value:new yi(0)},roughness:{value:.5},metalness:{value:.5},envMapIntensity:{value:1}}]),vertexShader:mi.meshphysical_vert,fragmentShader:mi.meshphysical_frag},points:{uniforms:gi.merge([_i.points,_i.fog]),vertexShader:mi.points_vert,fragmentShader:mi.points_frag},dashed:{uniforms:gi.merge([_i.common,_i.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:mi.linedashed_vert,fragmentShader:mi.linedashed_frag},depth:{uniforms:gi.merge([_i.common,_i.displacementmap]),vertexShader:mi.depth_vert,fragmentShader:mi.depth_frag},normal:{uniforms:gi.merge([_i.common,_i.bumpmap,_i.normalmap,_i.displacementmap,{opacity:{value:1}}]),vertexShader:mi.normal_vert,fragmentShader:mi.normal_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:mi.cube_vert,fragmentShader:mi.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:mi.equirect_vert,fragmentShader:mi.equirect_frag},distanceRGBA:{uniforms:gi.merge([_i.common,_i.displacementmap,{referencePosition:{value:new Ge},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:mi.distanceRGBA_vert,fragmentShader:mi.distanceRGBA_frag},shadow:{uniforms:gi.merge([_i.lights,_i.fog,{color:{value:new yi(0)},opacity:{value:1}}]),vertexShader:mi.shadow_vert,fragmentShader:mi.shadow_frag}};function Mi(h){var n=new WeakMap;return{get:function(t){return t.isInterleavedBufferAttribute&&(t=t.data),n.get(t)},remove:function(t){t.isInterleavedBufferAttribute&&(t=t.data);var e=n.get(t);e&&(h.deleteBuffer(e.buffer),n.delete(t))},update:function(t,e){t.isInterleavedBufferAttribute&&(t=t.data);var i=n.get(t);void 0===i?n.set(t,function(t,e){var i=t.array,n=t.dynamic?h.DYNAMIC_DRAW:h.STATIC_DRAW,r=h.createBuffer();h.bindBuffer(e,r),h.bufferData(e,i,n),t.onUploadCallback();var a=h.FLOAT;return i instanceof Float32Array?a=h.FLOAT:i instanceof Float64Array?console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."):i instanceof Uint16Array?a=h.UNSIGNED_SHORT:i instanceof Int16Array?a=h.SHORT:i instanceof Uint32Array?a=h.UNSIGNED_INT:i instanceof Int32Array?a=h.INT:i instanceof Int8Array?a=h.BYTE:i instanceof Uint8Array&&(a=h.UNSIGNED_BYTE),{buffer:r,type:a,bytesPerElement:i.BYTES_PER_ELEMENT,version:t.version}}(t,e)):i.version<t.version&&(function(t,e,i){var n=e.array,r=e.updateRange;if(h.bindBuffer(i,t),!1===e.dynamic)h.bufferData(i,n,h.STATIC_DRAW);else if(void 0===r.offset&&void 0===r.count){for(var a=0;a<r.length;a++){var o=r[a].count,s=r[a].offset;0!=o&&-1!=o?s>=n.length||o>n.length?console.error("THREE.WebGLObjects.updateBuffer: Buffer overflow."):h.bufferSubData(i,s*n.BYTES_PER_ELEMENT,n.subarray(s,s+o)):0==r&&console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0 for index "+a+", ensure you are using set methods or updating manually.")}r||h.bufferSubData(i,0,n),e.updateRange.length=0}else-1===r.count?h.bufferSubData(i,0,n):0===r.count?console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually."):(h.bufferSubData(i,r.offset*n.BYTES_PER_ELEMENT,n.subarray(r.offset,r.offset+r.count)),r.count=-1)}(i.buffer,t,e),i.version=t.version)}}}function Ei(t,e,i,n){this._x=t||0,this._y=e||0,this._z=i||0,this._order=n||Ei.DefaultOrder}function Ti(){this.mask=1}wi.physical={uniforms:gi.merge([wi.standard.uniforms,{clearCoat:{value:0},clearCoatRoughness:{value:0}}]),vertexShader:mi.meshphysical_vert,fragmentShader:mi.meshphysical_frag},Ei.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"],Ei.DefaultOrder="XYZ",Object.defineProperties(Ei.prototype,{x:{get:function(){return this._x},set:function(t){this._x=t,this.onChangeCallback()}},y:{get:function(){return this._y},set:function(t){this._y=t,this.onChangeCallback()}},z:{get:function(){return this._z},set:function(t){this._z=t,this.onChangeCallback()}},order:{get:function(){return this._order},set:function(t){this._order=t,this.onChangeCallback()}}}),Object.assign(Ei.prototype,{isEuler:!0,set:function(t,e,i,n){return this._x=t,this._y=e,this._z=i,this._order=n||this._order,this.onChangeCallback(),this},clone:function(){return new this.constructor(this._x,this._y,this._z,this._order)},copy:function(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this.onChangeCallback(),this},setFromRotationMatrix:function(t,e,i){var n=De.clamp,r=t.elements,a=r[0],o=r[4],s=r[8],h=r[1],c=r[5],l=r[9],u=r[2],d=r[6],p=r[10];return"XYZ"===(e=e||this._order)?(this._y=Math.asin(n(s,-1,1)),Math.abs(s)<.99999?(this._x=Math.atan2(-l,p),this._z=Math.atan2(-o,a)):(this._x=Math.atan2(d,c),this._z=0)):"YXZ"===e?(this._x=Math.asin(-n(l,-1,1)),Math.abs(l)<.99999?(this._y=Math.atan2(s,p),this._z=Math.atan2(h,c)):(this._y=Math.atan2(-u,a),this._z=0)):"ZXY"===e?(this._x=Math.asin(n(d,-1,1)),Math.abs(d)<.99999?(this._y=Math.atan2(-u,p),this._z=Math.atan2(-o,c)):(this._y=0,this._z=Math.atan2(h,a))):"ZYX"===e?(this._y=Math.asin(-n(u,-1,1)),Math.abs(u)<.99999?(this._x=Math.atan2(d,p),this._z=Math.atan2(h,a)):(this._x=0,this._z=Math.atan2(-o,c))):"YZX"===e?(this._z=Math.asin(n(h,-1,1)),Math.abs(h)<.99999?(this._x=Math.atan2(-l,c),this._y=Math.atan2(-u,a)):(this._x=0,this._y=Math.atan2(s,p))):"XZY"===e?(this._z=Math.asin(-n(o,-1,1)),Math.abs(o)<.99999?(this._x=Math.atan2(d,c),this._y=Math.atan2(s,a)):(this._x=Math.atan2(-l,p),this._y=0)):console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: "+e),this._order=e,!1!==i&&this.onChangeCallback(),this},setFromQuaternion:(bi=new Fe,function(t,e,i){return bi.makeRotationFromQuaternion(t),this.setFromRotationMatrix(bi,e,i)}),setFromVector3:function(t,e){return this.set(t.x,t.y,t.z,e||this._order)},reorder:(xi=new ze,function(t){return xi.setFromEuler(this),this.setFromQuaternion(xi,t)}),equals:function(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order},fromArray:function(t){return this._x=t[0],this._y=t[1],this._z=t[2],void 0!==t[3]&&(this._order=t[3]),this.onChangeCallback(),this},toArray:function(t,e){return void 0===t&&(t=[]),void 0===e&&(e=0),t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t},toVector3:function(t){return t?t.set(this._x,this._y,this._z):new Ge(this._x,this._y,this._z)},onChange:function(t){return this.onChangeCallback=t,this},onChangeCallback:function(){}}),Object.assign(Ti.prototype,{set:function(t){this.mask=1<<t|0},enable:function(t){this.mask|=1<<t|0},toggle:function(t){this.mask^=1<<t|0},disable:function(t){this.mask&=~(1<<t|0)},test:function(t){return 0!=(this.mask&t.mask)}});var Si,Ai,Li,Ri,Ci,Pi,Oi,Ii,Ni,Ui,Di,Bi,Fi,zi,Gi,Hi,Vi,ki,ji=0;function Wi(){Object.defineProperty(this,"id",{value:ji++}),this.uuid=De.generateUUID(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Wi.DefaultUp.clone();var t=new Ge,e=new Ei,i=new ze,n=new Ge(1,1,1);e.onChange(function(){i.setFromEuler(e,!1)}),i.onChange(function(){e.setFromQuaternion(i,void 0,!1)}),Object.defineProperties(this,{position:{enumerable:!0,value:t},rotation:{enumerable:!0,value:e},quaternion:{enumerable:!0,value:i},scale:{enumerable:!0,value:n},modelViewMatrix:{value:new Fe},normalMatrix:{value:new He}}),this.matrix=new Fe,this.matrixWorld=new Fe,this.matrixAutoUpdate=Wi.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new Ti,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.userData={}}function Xi(){Wi.call(this),this.type="Camera",this.matrixWorldInverse=new Fe,this.projectionMatrix=new Fe}function qi(t,e,i,n,r,a){Xi.call(this),this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=t,this.right=e,this.top=i,this.bottom=n,this.near=void 0!==r?r:.1,this.far=void 0!==a?a:2e3,this.updateProjectionMatrix()}function Yi(t,e,i,n,r,a){this.a=t,this.b=e,this.c=i,this.normal=n&&n.isVector3?n:new Ge,this.vertexNormals=Array.isArray(n)?n:[],this.color=r&&r.isColor?r:new yi,this.vertexColors=Array.isArray(r)?r:[],this.materialIndex=void 0!==a?a:0}Wi.DefaultUp=new Ge(0,1,0),Wi.DefaultMatrixAutoUpdate=!0,Wi.prototype=Object.assign(Object.create(e.prototype),{constructor:Wi,isObject3D:!0,onBeforeRender:function(){},onAfterRender:function(){},applyMatrix:function(t){this.matrix.multiplyMatrices(t,this.matrix),this.matrix.decompose(this.position,this.quaternion,this.scale)},applyQuaternion:function(t){return this.quaternion.premultiply(t),this},setRotationFromAxisAngle:function(t,e){this.quaternion.setFromAxisAngle(t,e)},setRotationFromEuler:function(t){this.quaternion.setFromEuler(t,!0)},setRotationFromMatrix:function(t){this.quaternion.setFromRotationMatrix(t)},setRotationFromQuaternion:function(t){this.quaternion.copy(t)},rotateOnAxis:(Vi=new ze,function(t,e){return Vi.setFromAxisAngle(t,e),this.quaternion.multiply(Vi),this}),rotateOnWorldAxis:(Hi=new ze,function(t,e){return Hi.setFromAxisAngle(t,e),this.quaternion.premultiply(Hi),this}),rotateX:(Gi=new Ge(1,0,0),function(t){return this.rotateOnAxis(Gi,t)}),rotateY:(zi=new Ge(0,1,0),function(t){return this.rotateOnAxis(zi,t)}),rotateZ:(Fi=new Ge(0,0,1),function(t){return this.rotateOnAxis(Fi,t)}),translateOnAxis:(Bi=new Ge,function(t,e){return Bi.copy(t).applyQuaternion(this.quaternion),this.position.add(Bi.multiplyScalar(e)),this}),translateX:(Di=new Ge(1,0,0),function(t){return this.translateOnAxis(Di,t)}),translateY:(Ui=new Ge(0,1,0),function(t){return this.translateOnAxis(Ui,t)}),translateZ:(Ni=new Ge(0,0,1),function(t){return this.translateOnAxis(Ni,t)}),localToWorld:function(t){return t.applyMatrix4(this.matrixWorld)},worldToLocal:(Ii=new Fe,function(t){return t.applyMatrix4(Ii.getInverse(this.matrixWorld))}),lookAt:(Pi=new Fe,Oi=new Ge,function(t,e,i){t.isVector3?Oi.copy(t):Oi.set(t,e,i),this.isCamera?Pi.lookAt(this.position,Oi,this.up):Pi.lookAt(Oi,this.position,this.up),this.quaternion.setFromRotationMatrix(Pi)}),add:function(t){if(1<arguments.length){for(var e=0;e<arguments.length;e++)this.add(arguments[e]);return this}return t===this?console.error("THREE.Object3D.add: object can't be added as a child of itself.",t):t&&t.isObject3D?(null!==t.parent&&t.parent.remove(t),t.parent=this,t.dispatchEvent({type:"added"}),this.children.push(t)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",t),this},remove:function(t){if(1<arguments.length){for(var e=0;e<arguments.length;e++)this.remove(arguments[e]);return this}var i=this.children.indexOf(t);return-1!==i&&(t.parent=null,t.dispatchEvent({type:"removed"}),this.children.splice(i,1)),this},getObjectById:function(t){return this.getObjectByProperty("id",t)},getObjectByName:function(t){return this.getObjectByProperty("name",t)},getObjectByProperty:function(t,e){if(this[t]===e)return this;for(var i=0,n=this.children.length;i<n;i++){var r=this.children[i].getObjectByProperty(t,e);if(void 0!==r)return r}},getWorldPosition:function(t){return void 0===t&&(console.warn("THREE.Object3D: .getWorldPosition() target is now required"),t=new Ge),this.updateMatrixWorld(!0),t.setFromMatrixPosition(this.matrixWorld)},getWorldQuaternion:(Ri=new Ge,Ci=new Ge,function(t){return void 0===t&&(console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"),t=new ze),this.updateMatrixWorld(!0),this.matrixWorld.decompose(Ri,t,Ci),t}),getWorldScale:(Ai=new Ge,Li=new ze,function(t){return void 0===t&&(console.warn("THREE.Object3D: .getWorldScale() target is now required"),t=new Ge),this.updateMatrixWorld(!0),this.matrixWorld.decompose(Ai,Li,t),t}),getWorldDirection:(Si=new ze,function(t){return void 0===t&&(console.warn("THREE.Object3D: .getWorldDirection() target is now required"),t=new Ge),this.getWorldQuaternion(Si),t.set(0,0,1).applyQuaternion(Si)}),raycast:function(){},traverse:function(t){t(this);for(var e=this.children,i=0,n=e.length;i<n;i++)e[i].traverse(t)},traverseVisible:function(t){if(!1!==this.visible){t(this);for(var e=this.children,i=0,n=e.length;i<n;i++)e[i].traverseVisible(t)}},traverseAncestors:function(t){var e=this.parent;null!==e&&(t(e),e.traverseAncestors(t))},updateMatrix:function(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0},updateMatrixWorld:function(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),t=!(this.matrixWorldNeedsUpdate=!1));for(var e=this.children,i=0,n=e.length;i<n;i++)e[i].updateMatrixWorld(t)},toJSON:function(i){var t=void 0===i||"string"==typeof i,e={};t&&(i={geometries:{},materials:{},textures:{},images:{},shapes:{}},e.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});var n={};function r(t,e){return void 0===t[e.uuid]&&(t[e.uuid]=e.toJSON(i)),e.uuid}if(n.uuid=this.uuid,n.type=this.type,""!==this.name&&(n.name=this.name),!0===this.castShadow&&(n.castShadow=!0),!0===this.receiveShadow&&(n.receiveShadow=!0),!1===this.visible&&(n.visible=!1),!1===this.frustumCulled&&(n.frustumCulled=!1),0!==this.renderOrder&&(n.renderOrder=this.renderOrder),"{}"!==JSON.stringify(this.userData)&&(n.userData=this.userData),n.matrix=this.matrix.toArray(),!1===this.matrixAutoUpdate&&(n.matrixAutoUpdate=!1),void 0!==this.geometry){n.geometry=r(i.geometries,this.geometry);var a=this.geometry.parameters;if(void 0!==a&&void 0!==a.shapes){var o=a.shapes;if(Array.isArray(o))for(var s=0,h=o.length;s<h;s++){var c=o[s];r(i.shapes,c)}else r(i.shapes,o)}}if(void 0!==this.material)if(Array.isArray(this.material)){var l=[];for(s=0,h=this.material.length;s<h;s++)l.push(r(i.materials,this.material[s]));n.material=l}else n.material=r(i.materials,this.material);if(0<this.children.length){n.children=[];for(s=0;s<this.children.length;s++)n.children.push(this.children[s].toJSON(i).object)}if(t){var u=m(i.geometries),d=m(i.materials),p=m(i.textures),f=m(i.images);o=m(i.shapes);0<u.length&&(e.geometries=u),0<d.length&&(e.materials=d),0<p.length&&(e.textures=p),0<f.length&&(e.images=f),0<o.length&&(e.shapes=o)}return e.object=n,e;function m(t){var e=[];for(var i in t){var n=t[i];delete n.metadata,e.push(n)}return e}},clone:function(t){return(new this.constructor).copy(this,t)},copy:function(t,e){if(void 0===e&&(e=!0),this.name=t.name,this.up.copy(t.up),this.position.copy(t.position),this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.matrixWorld.copy(t.matrixWorld),this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrixWorldNeedsUpdate=t.matrixWorldNeedsUpdate,this.layers.mask=t.layers.mask,this.visible=t.visible,this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.frustumCulled=t.frustumCulled,this.renderOrder=t.renderOrder,this.userData=JSON.parse(JSON.stringify(t.userData)),!0===e)for(var i=0;i<t.children.length;i++){var n=t.children[i];this.add(n.clone())}return this}}),Xi.prototype=Object.assign(Object.create(Wi.prototype),{constructor:Xi,isCamera:!0,copy:function(t,e){return Wi.prototype.copy.call(this,t,e),this.matrixWorldInverse.copy(t.matrixWorldInverse),this.projectionMatrix.copy(t.projectionMatrix),this},getWorldDirection:(ki=new ze,function(t){return void 0===t&&(console.warn("THREE.Camera: .getWorldDirection() target is now required"),t=new Ge),this.getWorldQuaternion(ki),t.set(0,0,-1).applyQuaternion(ki)}),updateMatrixWorld:function(t){Wi.prototype.updateMatrixWorld.call(this,t),this.matrixWorldInverse.getInverse(this.matrixWorld)},clone:function(){return(new this.constructor).copy(this)}}),qi.prototype=Object.assign(Object.create(Xi.prototype),{constructor:qi,isOrthographicCamera:!0,copy:function(t,e){return Xi.prototype.copy.call(this,t,e),this.left=t.left,this.right=t.right,this.top=t.top,this.bottom=t.bottom,this.near=t.near,this.far=t.far,this.zoom=t.zoom,this.view=null===t.view?null:Object.assign({},t.view),this},setViewOffset:function(t,e,i,n,r,a){null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=i,this.view.offsetY=n,this.view.width=r,this.view.height=a,this.updateProjectionMatrix()},clearViewOffset:function(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()},updateProjectionMatrix:function(){var t=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),i=(this.right+this.left)/2,n=(this.top+this.bottom)/2,r=i-t,a=i+t,o=n+e,s=n-e;if(null!==this.view&&this.view.enabled){var h=this.zoom/(this.view.width/this.view.fullWidth),c=this.zoom/(this.view.height/this.view.fullHeight),l=(this.right-this.left)/this.view.width,u=(this.top-this.bottom)/this.view.height;a=(r+=l*(this.view.offsetX/h))+l*(this.view.width/h),s=(o-=u*(this.view.offsetY/c))-u*(this.view.height/c)}this.projectionMatrix.makeOrthographic(r,a,o,s,this.near,this.far)},toJSON:function(t){var e=Wi.prototype.toJSON.call(this,t);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,null!==this.view&&(e.object.view=Object.assign({},this.view)),e}}),Object.assign(Yi.prototype,{clone:function(){return(new this.constructor).copy(this)},copy:function(t){this.a=t.a,this.b=t.b,this.c=t.c,this.normal.copy(t.normal),this.color.copy(t.color),this.materialIndex=t.materialIndex;for(var e=0,i=t.vertexNormals.length;e<i;e++)this.vertexNormals[e]=t.vertexNormals[e].clone();for(e=0,i=t.vertexColors.length;e<i;e++)this.vertexColors[e]=t.vertexColors[e].clone();return this}});var Zi,Ji,Qi,Ki,$i,tn,en,nn=0;function rn(){Object.defineProperty(this,"id",{value:nn+=2}),this.uuid=De.generateUUID(),this.name="",this.type="Geometry",this.vertices=[],this.colors=[],this.faces=[],this.faceVertexUvs=[[]],this.morphTargets=[],this.morphNormals=[],this.skinWeights=[],this.skinIndices=[],this.lineDistances=[],this.boundingBox=null,this.boundingSphere=null,this.elementsNeedUpdate=!1,this.verticesNeedUpdate=!1,this.uvsNeedUpdate=!1,this.normalsNeedUpdate=!1,this.colorsNeedUpdate=!1,this.lineDistancesNeedUpdate=!1,this.groupsNeedUpdate=!1}function an(t,e,i){if(Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=t,this.itemSize=e,this.count=void 0!==t?t.length/e:0,this.normalized=!0===i,this.dynamic=!1,this.updateRange=[],this.version=0}function on(t,e,i){an.call(this,new Int8Array(t),e,i)}function sn(t,e,i){an.call(this,new Uint8Array(t),e,i)}function hn(t,e,i){an.call(this,new Uint8ClampedArray(t),e,i)}function cn(t,e,i){an.call(this,new Int16Array(t),e,i)}function ln(t,e,i){an.call(this,new Uint16Array(t),e,i)}function un(t,e,i){an.call(this,new Int32Array(t),e,i)}function dn(t,e,i){an.call(this,new Uint32Array(t),e,i)}function pn(t,e,i){an.call(this,new Float32Array(t),e,i)}function fn(t,e,i){an.call(this,new Float64Array(t),e,i)}function mn(){this.vertices=[],this.normals=[],this.colors=[],this.uvs=[],this.uvs2=[],this.groups=[],this.morphTargets={},this.skinWeights=[],this.skinIndices=[],this.boundingBox=null,this.boundingSphere=null,this.verticesNeedUpdate=!1,this.normalsNeedUpdate=!1,this.colorsNeedUpdate=!1,this.uvsNeedUpdate=!1,this.groupsNeedUpdate=!1}function gn(t){if(0===t.length)return-1/0;for(var e=t[0],i=1,n=t.length;i<n;++i)t[i]>e&&(e=t[i]);return e}rn.prototype=Object.assign(Object.create(e.prototype),{constructor:rn,isGeometry:!0,applyMatrix:function(t){for(var e=(new He).getNormalMatrix(t),i=0,n=this.vertices.length;i<n;i++){this.vertices[i].applyMatrix4(t)}for(i=0,n=this.faces.length;i<n;i++){var r=this.faces[i];r.normal.applyMatrix3(e).normalize();for(var a=0,o=r.vertexNormals.length;a<o;a++)r.vertexNormals[a].applyMatrix3(e).normalize()}return null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this.verticesNeedUpdate=!0,this.normalsNeedUpdate=!0,this},rotateX:(en=new Fe,function(t){return en.makeRotationX(t),this.applyMatrix(en),this}),rotateY:(tn=new Fe,function(t){return tn.makeRotationY(t),this.applyMatrix(tn),this}),rotateZ:($i=new Fe,function(t){return $i.makeRotationZ(t),this.applyMatrix($i),this}),translate:(Ki=new Fe,function(t,e,i){return Ki.makeTranslation(t,e,i),this.applyMatrix(Ki),this}),scale:(Qi=new Fe,function(t,e,i){return Qi.makeScale(t,e,i),this.applyMatrix(Qi),this}),lookAt:(Ji=new Wi,function(t){Ji.lookAt(t),Ji.updateMatrix(),this.applyMatrix(Ji.matrix)}),fromBufferGeometry:function(t){var a=this,e=null!==t.index?t.index.array:void 0,i=t.attributes,n=i.position.array,o=void 0!==i.normal?i.normal.array:void 0,s=void 0!==i.color?i.color.array:void 0,h=void 0!==i.uv?i.uv.array:void 0,c=void 0!==i.uv2?i.uv2.array:void 0;void 0!==c&&(this.faceVertexUvs[1]=[]);for(var l=[],u=[],d=[],r=0,p=0;r<n.length;r+=3,p+=2)a.vertices.push(new Ge(n[r],n[r+1],n[r+2])),void 0!==o&&l.push(new Ge(o[r],o[r+1],o[r+2])),void 0!==s&&a.colors.push(new yi(s[r],s[r+1],s[r+2])),void 0!==h&&u.push(new Be(h[p],h[p+1])),void 0!==c&&d.push(new Be(c[p],c[p+1]));function f(t,e,i,n){var r=new Yi(t,e,i,void 0!==o?[l[t].clone(),l[e].clone(),l[i].clone()]:[],void 0!==s?[a.colors[t].clone(),a.colors[e].clone(),a.colors[i].clone()]:[],n);a.faces.push(r),void 0!==h&&a.faceVertexUvs[0].push([u[t].clone(),u[e].clone(),u[i].clone()]),void 0!==c&&a.faceVertexUvs[1].push([d[t].clone(),d[e].clone(),d[i].clone()])}var m=t.groups;if(0<m.length)for(r=0;r<m.length;r++)for(var g=m[r],v=g.start,y=(p=v,v+g.count);p<y;p+=3)void 0!==e?f(e[p],e[p+1],e[p+2],g.materialIndex):f(p,p+1,p+2,g.materialIndex);else if(void 0!==e)for(r=0;r<e.length;r+=3)f(e[r],e[r+1],e[r+2]);else for(r=0;r<n.length/3;r+=3)f(r,r+1,r+2);return this.computeFaceNormals(),null!==t.boundingBox&&(this.boundingBox=t.boundingBox.clone()),null!==t.boundingSphere&&(this.boundingSphere=t.boundingSphere.clone()),this},center:(Zi=new Ge,function(){return this.computeBoundingBox(),this.boundingBox.getCenter(Zi).negate(),this.translate(Zi.x,Zi.y,Zi.z),this}),normalize:function(){this.computeBoundingSphere();var t=this.boundingSphere.center,e=this.boundingSphere.radius,i=0===e?1:1/e,n=new Fe;return n.set(i,0,0,-i*t.x,0,i,0,-i*t.y,0,0,i,-i*t.z,0,0,0,1),this.applyMatrix(n),this},computeFaceNormals:function(){for(var t=new Ge,e=new Ge,i=0,n=this.faces.length;i<n;i++){var r=this.faces[i],a=this.vertices[r.a],o=this.vertices[r.b],s=this.vertices[r.c];t.subVectors(s,o),e.subVectors(a,o),t.cross(e),t.normalize(),r.normal.copy(t)}},computeVertexNormals:function(t){var e,i,n,r,a,o;for(void 0===t&&(t=!0),o=new Array(this.vertices.length),e=0,i=this.vertices.length;e<i;e++)o[e]=new Ge;if(t){var s,h,c,l=new Ge,u=new Ge;for(n=0,r=this.faces.length;n<r;n++)a=this.faces[n],s=this.vertices[a.a],h=this.vertices[a.b],c=this.vertices[a.c],l.subVectors(c,h),u.subVectors(s,h),l.cross(u),o[a.a].add(l),o[a.b].add(l),o[a.c].add(l)}else for(this.computeFaceNormals(),n=0,r=this.faces.length;n<r;n++)o[(a=this.faces[n]).a].add(a.normal),o[a.b].add(a.normal),o[a.c].add(a.normal);for(e=0,i=this.vertices.length;e<i;e++)o[e].normalize();for(n=0,r=this.faces.length;n<r;n++){var d=(a=this.faces[n]).vertexNormals;3===d.length?(d[0].copy(o[a.a]),d[1].copy(o[a.b]),d[2].copy(o[a.c])):(d[0]=o[a.a].clone(),d[1]=o[a.b].clone(),d[2]=o[a.c].clone())}0<this.faces.length&&(this.normalsNeedUpdate=!0)},computeFlatVertexNormals:function(){var t,e,i;for(this.computeFaceNormals(),t=0,e=this.faces.length;t<e;t++){var n=(i=this.faces[t]).vertexNormals;3===n.length?(n[0].copy(i.normal),n[1].copy(i.normal),n[2].copy(i.normal)):(n[0]=i.normal.clone(),n[1]=i.normal.clone(),n[2]=i.normal.clone())}0<this.faces.length&&(this.normalsNeedUpdate=!0)},computeMorphNormals:function(){var t,e,i,n,r;for(i=0,n=this.faces.length;i<n;i++)for((r=this.faces[i]).__originalFaceNormal?r.__originalFaceNormal.copy(r.normal):r.__originalFaceNormal=r.normal.clone(),r.__originalVertexNormals||(r.__originalVertexNormals=[]),t=0,e=r.vertexNormals.length;t<e;t++)r.__originalVertexNormals[t]?r.__originalVertexNormals[t].copy(r.vertexNormals[t]):r.__originalVertexNormals[t]=r.vertexNormals[t].clone();var a=new rn;for(a.faces=this.faces,t=0,e=this.morphTargets.length;t<e;t++){if(!this.morphNormals[t]){this.morphNormals[t]={},this.morphNormals[t].faceNormals=[],this.morphNormals[t].vertexNormals=[];var o=this.morphNormals[t].faceNormals,s=this.morphNormals[t].vertexNormals;for(i=0,n=this.faces.length;i<n;i++)h=new Ge,c={a:new Ge,b:new Ge,c:new Ge},o.push(h),s.push(c)}var h,c,l=this.morphNormals[t];for(a.vertices=this.morphTargets[t].vertices,a.computeFaceNormals(),a.computeVertexNormals(),i=0,n=this.faces.length;i<n;i++)r=this.faces[i],h=l.faceNormals[i],c=l.vertexNormals[i],h.copy(r.normal),c.a.copy(r.vertexNormals[0]),c.b.copy(r.vertexNormals[1]),c.c.copy(r.vertexNormals[2])}for(i=0,n=this.faces.length;i<n;i++)(r=this.faces[i]).normal=r.__originalFaceNormal,r.vertexNormals=r.__originalVertexNormals},computeBoundingBox:function(){null===this.boundingBox&&(this.boundingBox=new li),this.boundingBox.setFromPoints(this.vertices)},computeBoundingSphere:function(){null===this.boundingSphere&&(this.boundingSphere=new ui),this.boundingSphere.setFromPoints(this.vertices)},merge:function(t,e,i){if(t&&t.isGeometry){var n,r=this.vertices.length,a=this.vertices,o=t.vertices,s=this.faces,h=t.faces,c=this.faceVertexUvs[0],l=t.faceVertexUvs[0],u=this.colors,d=t.colors;void 0===i&&(i=0),void 0!==e&&(n=(new He).getNormalMatrix(e));for(var p=0,f=o.length;p<f;p++){var m=o[p].clone();void 0!==e&&m.applyMatrix4(e),a.push(m)}for(p=0,f=d.length;p<f;p++)u.push(d[p].clone());for(p=0,f=h.length;p<f;p++){var g,v,y,x=h[p],b=x.vertexNormals,_=x.vertexColors;(g=new Yi(x.a+r,x.b+r,x.c+r)).normal.copy(x.normal),void 0!==n&&g.normal.applyMatrix3(n).normalize();for(var w=0,M=b.length;w<M;w++)v=b[w].clone(),void 0!==n&&v.applyMatrix3(n).normalize(),g.vertexNormals.push(v);g.color.copy(x.color);for(w=0,M=_.length;w<M;w++)y=_[w],g.vertexColors.push(y.clone());g.materialIndex=x.materialIndex+i,s.push(g)}for(p=0,f=l.length;p<f;p++){var E=l[p],T=[];if(void 0!==E){for(w=0,M=E.length;w<M;w++)T.push(E[w].clone());c.push(T)}}}else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.",t)},mergeMesh:function(t){t&&t.isMesh?(t.matrixAutoUpdate&&t.updateMatrix(),this.merge(t.geometry,t.matrix)):console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.",t)},mergeVertices:function(){var t,e,i,n,r,a,o,s,h={},c=[],l=[],u=Math.pow(10,4);for(i=0,n=this.vertices.length;i<n;i++)t=this.vertices[i],void 0===h[e=Math.round(t.x*u)+"_"+Math.round(t.y*u)+"_"+Math.round(t.z*u)]?(h[e]=i,c.push(this.vertices[i]),l[i]=c.length-1):l[i]=l[h[e]];var d=[];for(i=0,n=this.faces.length;i<n;i++){(r=this.faces[i]).a=l[r.a],r.b=l[r.b],r.c=l[r.c],a=[r.a,r.b,r.c];for(var p=0;p<3;p++)if(a[p]===a[(p+1)%3]){d.push(i);break}}for(i=d.length-1;0<=i;i--){var f=d[i];for(this.faces.splice(f,1),o=0,s=this.faceVertexUvs.length;o<s;o++)this.faceVertexUvs[o].splice(f,1)}var m=this.vertices.length-c.length;return this.vertices=c,m},setFromPoints:function(t){this.vertices=[];for(var e=0,i=t.length;e<i;e++){var n=t[e];this.vertices.push(new Ge(n.x,n.y,n.z||0))}return this},sortFacesByMaterialIndex:function(){for(var t=this.faces,e=t.length,i=0;i<e;i++)t[i]._id=i;t.sort(function(t,e){return t.materialIndex-e.materialIndex});var n,r,a=this.faceVertexUvs[0],o=this.faceVertexUvs[1];a&&a.length===e&&(n=[]),o&&o.length===e&&(r=[]);for(i=0;i<e;i++){var s=t[i]._id;n&&n.push(a[s]),r&&r.push(o[s])}n&&(this.faceVertexUvs[0]=n),r&&(this.faceVertexUvs[1]=r)},toJSON:function(){var t={metadata:{version:4.5,type:"Geometry",generator:"Geometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,""!==this.name&&(t.name=this.name),void 0!==this.parameters){var e=this.parameters;for(var i in e)void 0!==e[i]&&(t[i]=e[i]);return t}for(var n=[],r=0;r<this.vertices.length;r++){var a=this.vertices[r];n.push(a.x,a.y,a.z)}var o=[],s=[],h={},c=[],l={},u=[],d={};for(r=0;r<this.faces.length;r++){var p=this.faces[r],f=void 0!==this.faceVertexUvs[0][r],m=0<p.normal.length(),g=0<p.vertexNormals.length,v=1!==p.color.r||1!==p.color.g||1!==p.color.b,y=0<p.vertexColors.length,x=0;if(x=M(x=M(x=M(x=M(x=M(x=M(x=M(x=M(x,0,0),1,!0),2,!1),3,f),4,m),5,g),6,v),7,y),o.push(x),o.push(p.a,p.b,p.c),o.push(p.materialIndex),f){var b=this.faceVertexUvs[0][r];o.push(S(b[0]),S(b[1]),S(b[2]))}if(m&&o.push(E(p.normal)),g){var _=p.vertexNormals;o.push(E(_[0]),E(_[1]),E(_[2]))}if(v&&o.push(T(p.color)),y){var w=p.vertexColors;o.push(T(w[0]),T(w[1]),T(w[2]))}}function M(t,e,i){return i?t|1<<e:t&~(1<<e)}function E(t){var e=t.x.toString()+t.y.toString()+t.z.toString();return void 0!==h[e]||(h[e]=s.length/3,s.push(t.x,t.y,t.z)),h[e]}function T(t){var e=t.r.toString()+t.g.toString()+t.b.toString();return void 0!==l[e]||(l[e]=c.length,c.push(t.getHex())),l[e]}function S(t){var e=t.x.toString()+t.y.toString();return void 0!==d[e]||(d[e]=u.length/2,u.push(t.x,t.y)),d[e]}return t.data={},t.data.vertices=n,t.data.normals=s,0<c.length&&(t.data.colors=c),0<u.length&&(t.data.uvs=[u]),t.data.faces=o,t},clone:function(){return(new rn).copy(this)},copy:function(t){var e,i,n,r,a,o;this.vertices=[],this.colors=[],this.faces=[],this.faceVertexUvs=[[]],this.morphTargets=[],this.morphNormals=[],this.skinWeights=[],this.skinIndices=[],this.lineDistances=[],this.boundingBox=null,this.boundingSphere=null,this.name=t.name;var s=t.vertices;for(e=0,i=s.length;e<i;e++)this.vertices.push(s[e].clone());var h=t.colors;for(e=0,i=h.length;e<i;e++)this.colors.push(h[e].clone());var c=t.faces;for(e=0,i=c.length;e<i;e++)this.faces.push(c[e].clone());for(e=0,i=t.faceVertexUvs.length;e<i;e++){var l=t.faceVertexUvs[e];for(void 0===this.faceVertexUvs[e]&&(this.faceVertexUvs[e]=[]),n=0,r=l.length;n<r;n++){var u=l[n],d=[];for(a=0,o=u.length;a<o;a++){var p=u[a];d.push(p.clone())}this.faceVertexUvs[e].push(d)}}var f=t.morphTargets;for(e=0,i=f.length;e<i;e++){var m={};if(m.name=f[e].name,void 0!==f[e].vertices)for(m.vertices=[],n=0,r=f[e].vertices.length;n<r;n++)m.vertices.push(f[e].vertices[n].clone());if(void 0!==f[e].normals)for(m.normals=[],n=0,r=f[e].normals.length;n<r;n++)m.normals.push(f[e].normals[n].clone());this.morphTargets.push(m)}var g=t.morphNormals;for(e=0,i=g.length;e<i;e++){var v={};if(void 0!==g[e].vertexNormals)for(v.vertexNormals=[],n=0,r=g[e].vertexNormals.length;n<r;n++){var y=g[e].vertexNormals[n],x={};x.a=y.a.clone(),x.b=y.b.clone(),x.c=y.c.clone(),v.vertexNormals.push(x)}if(void 0!==g[e].faceNormals)for(v.faceNormals=[],n=0,r=g[e].faceNormals.length;n<r;n++)v.faceNormals.push(g[e].faceNormals[n].clone());this.morphNormals.push(v)}var b=t.skinWeights;for(e=0,i=b.length;e<i;e++)this.skinWeights.push(b[e].clone());var _=t.skinIndices;for(e=0,i=_.length;e<i;e++)this.skinIndices.push(_[e].clone());var w=t.lineDistances;for(e=0,i=w.length;e<i;e++)this.lineDistances.push(w[e]);var M=t.boundingBox;null!==M&&(this.boundingBox=M.clone());var E=t.boundingSphere;return null!==E&&(this.boundingSphere=E.clone()),this.elementsNeedUpdate=t.elementsNeedUpdate,this.verticesNeedUpdate=t.verticesNeedUpdate,this.uvsNeedUpdate=t.uvsNeedUpdate,this.normalsNeedUpdate=t.normalsNeedUpdate,this.colorsNeedUpdate=t.colorsNeedUpdate,this.lineDistancesNeedUpdate=t.lineDistancesNeedUpdate,this.groupsNeedUpdate=t.groupsNeedUpdate,this},dispose:function(){this.dispatchEvent({type:"dispose"})}}),Object.defineProperty(an.prototype,"needsUpdate",{set:function(t){!0===t&&this.version++}}),Object.assign(an.prototype,{isBufferAttribute:!0,onUploadCallback:function(){},setArray:function(t){if(Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");return this.count=void 0!==t?t.length/this.itemSize:0,this.array=t,this},setDynamic:function(t){return this.dynamic=t,this},copy:function(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.dynamic=t.dynamic,this},copyAt:function(t,e,i){t*=this.itemSize,i*=e.itemSize;for(var n=0,r=this.itemSize;n<r;n++)this.array[t+n]=e.array[i+n];return this},copyArray:function(t){return this.array.set(t),this},copyColorsArray:function(t){for(var e=this.array,i=0,n=0,r=t.length;n<r;n++){var a=t[n];void 0===a&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",n),a=new yi),e[i++]=a.r,e[i++]=a.g,e[i++]=a.b}return this},copyVector2sArray:function(t){for(var e=this.array,i=0,n=0,r=t.length;n<r;n++){var a=t[n];void 0===a&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",n),a=new Be),e[i++]=a.x,e[i++]=a.y}return this},copyVector3sArray:function(t){for(var e=this.array,i=0,n=0,r=t.length;n<r;n++){var a=t[n];void 0===a&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",n),a=new Ge),e[i++]=a.x,e[i++]=a.y,e[i++]=a.z}return this},copyVector4sArray:function(t){for(var e=this.array,i=0,n=0,r=t.length;n<r;n++){var a=t[n];void 0===a&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",n),a=new oi),e[i++]=a.x,e[i++]=a.y,e[i++]=a.z,e[i++]=a.w}return this},set:function(t,e){return void 0===e&&(e=0),this.array.set(t,e),this},getX:function(t){return this.array[t*this.itemSize]},setX:function(t,e){return this.array[t*this.itemSize]=e,this},getY:function(t){return this.array[t*this.itemSize+1]},setY:function(t,e){return this.array[t*this.itemSize+1]=e,this},getZ:function(t){return this.array[t*this.itemSize+2]},setZ:function(t,e){return this.array[t*this.itemSize+2]=e,this},getW:function(t){return this.array[t*this.itemSize+3]},setW:function(t,e){return this.array[t*this.itemSize+3]=e,this},setXY:function(t,e,i){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=i,this},setXYZ:function(t,e,i,n){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=i,this.array[t+2]=n,this},setXYZW:function(t,e,i,n,r){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=i,this.array[t+2]=n,this.array[t+3]=r,this},onUpload:function(t){return this.onUploadCallback=t,this},clone:function(){return new this.constructor(this.array,this.itemSize).copy(this)}}),(on.prototype=Object.create(an.prototype)).constructor=on,(sn.prototype=Object.create(an.prototype)).constructor=sn,(hn.prototype=Object.create(an.prototype)).constructor=hn,(cn.prototype=Object.create(an.prototype)).constructor=cn,(ln.prototype=Object.create(an.prototype)).constructor=ln,(un.prototype=Object.create(an.prototype)).constructor=un,(dn.prototype=Object.create(an.prototype)).constructor=dn,(pn.prototype=Object.create(an.prototype)).constructor=pn,(fn.prototype=Object.create(an.prototype)).constructor=fn,Object.assign(mn.prototype,{computeGroups:function(t){for(var e,i=[],n=void 0,r=t.faces,a=0;a<r.length;a++){var o=r[a];o.materialIndex!==n&&(n=o.materialIndex,void 0!==e&&(e.count=3*a-e.start,i.push(e)),e={start:3*a,materialIndex:n})}void 0!==e&&(e.count=3*a-e.start,i.push(e)),this.groups=i},fromGeometry:function(t){var e,i=t.faces,n=t.vertices,r=t.faceVertexUvs,a=r[0]&&0<r[0].length,o=r[1]&&0<r[1].length,s=t.morphTargets,h=s.length;if(0<h){e=[];for(var c=0;c<h;c++)e[c]=[];this.morphTargets.position=e}var l,u=t.morphNormals,d=u.length;if(0<d){l=[];for(c=0;c<d;c++)l[c]=[];this.morphTargets.normal=l}var p=t.skinIndices,f=t.skinWeights,m=p.length===n.length,g=f.length===n.length;for(c=0;c<i.length;c++){var v=i[c];this.vertices.push(n[v.a],n[v.b],n[v.c]);var y=v.vertexNormals;if(3===y.length)this.normals.push(y[0],y[1],y[2]);else{var x=v.normal;this.normals.push(x,x,x)}var b,_=v.vertexColors;if(3===_.length)this.colors.push(_[0],_[1],_[2]);else{var w=v.color;this.colors.push(w,w,w)}if(!0===a)void 0!==(b=r[0][c])?this.uvs.push(b[0],b[1],b[2]):(console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ",c),this.uvs.push(new Be,new Be,new Be));if(!0===o)void 0!==(b=r[1][c])?this.uvs2.push(b[0],b[1],b[2]):(console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ",c),this.uvs2.push(new Be,new Be,new Be));for(var M=0;M<h;M++){var E=s[M].vertices;e[M].push(E[v.a],E[v.b],E[v.c])}for(M=0;M<d;M++){var T=u[M].vertexNormals[c];l[M].push(T.a,T.b,T.c)}m&&this.skinIndices.push(p[v.a],p[v.b],p[v.c]),g&&this.skinWeights.push(f[v.a],f[v.b],f[v.c])}return this.computeGroups(t),this.verticesNeedUpdate=t.verticesNeedUpdate,this.normalsNeedUpdate=t.normalsNeedUpdate,this.colorsNeedUpdate=t.colorsNeedUpdate,this.uvsNeedUpdate=t.uvsNeedUpdate,this.groupsNeedUpdate=t.groupsNeedUpdate,this}});var vn,yn,xn,bn,_n,wn,Mn,En,Tn,Sn,An=1;function Ln(){Object.defineProperty(this,"id",{value:An+=2}),this.uuid=De.generateUUID(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0}}function Rn(t,e,i,n,r,a){rn.call(this),this.type="BoxGeometry",this.parameters={width:t,height:e,depth:i,widthSegments:n,heightSegments:r,depthSegments:a},this.fromBufferGeometry(new Cn(t,e,i,n,r,a)),this.mergeVertices()}function Cn(t,e,i,n,r,a){Ln.call(this),this.type="BoxBufferGeometry",this.parameters={width:t,height:e,depth:i,widthSegments:n,heightSegments:r,depthSegments:a};var R=this;t=t||1,e=e||1,i=i||1,n=Math.floor(n)||1,r=Math.floor(r)||1,a=Math.floor(a)||1;var C=[],P=[],O=[],I=[],N=0,U=0;function o(t,e,i,n,r,a,o,s,h,c,l){var u,d,p=a/h,f=o/c,m=a/2,g=o/2,v=s/2,y=h+1,x=c+1,b=0,_=0,w=new Ge;for(d=0;d<x;d++){var M=d*f-g;for(u=0;u<y;u++){var E=u*p-m;w[t]=E*n,w[e]=M*r,w[i]=v,P.push(w.x,w.y,w.z),w[t]=0,w[e]=0,w[i]=0<s?1:-1,O.push(w.x,w.y,w.z),I.push(u/h),I.push(1-d/c),b+=1}}for(d=0;d<c;d++)for(u=0;u<h;u++){var T=N+u+y*d,S=N+u+y*(d+1),A=N+(u+1)+y*(d+1),L=N+(u+1)+y*d;C.push(T,S,L),C.push(S,A,L),_+=6}R.addGroup(U,_,l),U+=_,N+=b}o("z","y","x",-1,-1,i,e,t,a,r,0),o("z","y","x",1,-1,i,e,-t,a,r,1),o("x","z","y",1,1,t,i,e,n,a,2),o("x","z","y",1,-1,t,i,-e,n,a,3),o("x","y","z",1,-1,t,e,i,n,r,4),o("x","y","z",-1,-1,t,e,-i,n,r,5),this.setIndex(C),this.addAttribute("position",new pn(P,3)),this.addAttribute("normal",new pn(O,3)),this.addAttribute("uv",new pn(I,2))}function Pn(t,e,i,n){rn.call(this),this.type="PlaneGeometry",this.parameters={width:t,height:e,widthSegments:i,heightSegments:n},this.fromBufferGeometry(new On(t,e,i,n)),this.mergeVertices()}function On(t,e,i,n){Ln.call(this),this.type="PlaneBufferGeometry",this.parameters={width:t,height:e,widthSegments:i,heightSegments:n};var r,a,o=(t=t||1)/2,s=(e=e||1)/2,h=Math.floor(i)||1,c=Math.floor(n)||1,l=h+1,u=c+1,d=t/h,p=e/c,f=[],m=[],g=[],v=[];for(a=0;a<u;a++){var y=a*p-s;for(r=0;r<l;r++){var x=r*d-o;m.push(x,-y,0),g.push(0,0,1),v.push(r/h),v.push(1-a/c)}}for(a=0;a<c;a++)for(r=0;r<h;r++){var b=r+l*a,_=r+l*(a+1),w=r+1+l*(a+1),M=r+1+l*a;f.push(b,_,M),f.push(_,w,M)}this.setIndex(f),this.addAttribute("position",new pn(m,3)),this.addAttribute("normal",new pn(g,3)),this.addAttribute("uv",new pn(v,2))}Ln.prototype=Object.assign(Object.create(e.prototype),{constructor:Ln,isBufferGeometry:!0,getIndex:function(){return this.index},setIndex:function(t){Array.isArray(t)?this.index=new(65535<gn(t)?dn:ln)(t,1):this.index=t},addAttribute:function(t,e){return e&&e.isBufferAttribute||e&&e.isInterleavedBufferAttribute?("index"===t?(console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),this.setIndex(e)):this.attributes[t]=e,this):(console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.addAttribute(t,new an(e,arguments[2])))},getAttribute:function(t){return this.attributes[t]},removeAttribute:function(t){return delete this.attributes[t],this},addGroup:function(t,e,i){this.groups.push({start:t,count:e,materialIndex:void 0!==i?i:0})},clearGroups:function(){this.groups=[]},setDrawRange:function(t,e){this.drawRange.start=t,this.drawRange.count=e},applyMatrix:function(t){var e=this.attributes.position;void 0!==e&&(t.applyToBufferAttribute(e),e.needsUpdate=!0);var i=this.attributes.normal;void 0!==i&&((new He).getNormalMatrix(t).applyToBufferAttribute(i),i.needsUpdate=!0);return null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this},rotateX:(Sn=new Fe,function(t){return Sn.makeRotationX(t),this.applyMatrix(Sn),this}),rotateY:(Tn=new Fe,function(t){return Tn.makeRotationY(t),this.applyMatrix(Tn),this}),rotateZ:(En=new Fe,function(t){return En.makeRotationZ(t),this.applyMatrix(En),this}),translate:(Mn=new Fe,function(t,e,i){return Mn.makeTranslation(t,e,i),this.applyMatrix(Mn),this}),scale:(wn=new Fe,function(t,e,i){return wn.makeScale(t,e,i),this.applyMatrix(wn),this}),lookAt:(_n=new Wi,function(t){_n.lookAt(t),_n.updateMatrix(),this.applyMatrix(_n.matrix)}),center:(bn=new Ge,function(){return this.computeBoundingBox(),this.boundingBox.getCenter(bn).negate(),this.translate(bn.x,bn.y,bn.z),this}),setFromObject:function(t){var e=t.geometry;if(t.isPoints||t.isLine){var i=new pn(3*e.vertices.length,3),n=new pn(3*e.colors.length,3);if(this.addAttribute("position",i.copyVector3sArray(e.vertices)),this.addAttribute("color",n.copyColorsArray(e.colors)),e.lineDistances&&e.lineDistances.length===e.vertices.length){var r=new pn(e.lineDistances.length,1);this.addAttribute("lineDistance",r.copyArray(e.lineDistances))}null!==e.boundingSphere&&(this.boundingSphere=e.boundingSphere.clone()),null!==e.boundingBox&&(this.boundingBox=e.boundingBox.clone())}else t.isMesh&&e&&e.isGeometry&&this.fromGeometry(e);return this},setFromPoints:function(t){for(var e=[],i=0,n=t.length;i<n;i++){var r=t[i];e.push(r.x,r.y,r.z||0)}return this.addAttribute("position",new pn(e,3)),this},updateFromObject:function(t){var e,i=t.geometry;if(t.isMesh){var n=i.__directGeometry;if(!0===i.elementsNeedUpdate&&(n=void 0,i.elementsNeedUpdate=!1),void 0===n)return this.fromGeometry(i);n.verticesNeedUpdate=i.verticesNeedUpdate,n.normalsNeedUpdate=i.normalsNeedUpdate,n.colorsNeedUpdate=i.colorsNeedUpdate,n.uvsNeedUpdate=i.uvsNeedUpdate,n.groupsNeedUpdate=i.groupsNeedUpdate,i.verticesNeedUpdate=!1,i.normalsNeedUpdate=!1,i.colorsNeedUpdate=!1,i.uvsNeedUpdate=!1,i.groupsNeedUpdate=!1,i=n}return!0===i.verticesNeedUpdate&&(void 0!==(e=this.attributes.position)&&(e.copyVector3sArray(i.vertices),e.needsUpdate=!0),i.verticesNeedUpdate=!1),!0===i.normalsNeedUpdate&&(void 0!==(e=this.attributes.normal)&&(e.copyVector3sArray(i.normals),e.needsUpdate=!0),i.normalsNeedUpdate=!1),!0===i.colorsNeedUpdate&&(void 0!==(e=this.attributes.color)&&(e.copyColorsArray(i.colors),e.needsUpdate=!0),i.colorsNeedUpdate=!1),i.uvsNeedUpdate&&(void 0!==(e=this.attributes.uv)&&(e.copyVector2sArray(i.uvs),e.needsUpdate=!0),i.uvsNeedUpdate=!1),i.lineDistancesNeedUpdate&&(void 0!==(e=this.attributes.lineDistance)&&(e.copyArray(i.lineDistances),e.needsUpdate=!0),i.lineDistancesNeedUpdate=!1),i.groupsNeedUpdate&&(i.computeGroups(t.geometry),this.groups=i.groups,i.groupsNeedUpdate=!1),this},fromGeometry:function(t){return t.__directGeometry=(new mn).fromGeometry(t),this.fromDirectGeometry(t.__directGeometry)},fromDirectGeometry:function(t){var e=new Float32Array(3*t.vertices.length);if(this.addAttribute("position",new an(e,3).copyVector3sArray(t.vertices)),0<t.normals.length){var i=new Float32Array(3*t.normals.length);this.addAttribute("normal",new an(i,3).copyVector3sArray(t.normals))}if(0<t.colors.length){var n=new Float32Array(3*t.colors.length);this.addAttribute("color",new an(n,3).copyColorsArray(t.colors))}if(0<t.uvs.length){var r=new Float32Array(2*t.uvs.length);this.addAttribute("uv",new an(r,2).copyVector2sArray(t.uvs))}if(0<t.uvs2.length){var a=new Float32Array(2*t.uvs2.length);this.addAttribute("uv2",new an(a,2).copyVector2sArray(t.uvs2))}for(var o in this.groups=t.groups,t.morphTargets){for(var s=[],h=t.morphTargets[o],c=0,l=h.length;c<l;c++){var u=h[c],d=new pn(3*u.length,3);s.push(d.copyVector3sArray(u))}this.morphAttributes[o]=s}if(0<t.skinIndices.length){var p=new pn(4*t.skinIndices.length,4);this.addAttribute("skinIndex",p.copyVector4sArray(t.skinIndices))}if(0<t.skinWeights.length){var f=new pn(4*t.skinWeights.length,4);this.addAttribute("skinWeight",f.copyVector4sArray(t.skinWeights))}return null!==t.boundingSphere&&(this.boundingSphere=t.boundingSphere.clone()),null!==t.boundingBox&&(this.boundingBox=t.boundingBox.clone()),this},computeBoundingBox:function(){null===this.boundingBox&&(this.boundingBox=new li);var t=this.attributes.position;void 0!==t?this.boundingBox.setFromBufferAttribute(t):this.boundingBox.makeEmpty(),(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)},computeBoundingSphere:(yn=new li,xn=new Ge,function(){null===this.boundingSphere&&(this.boundingSphere=new ui);var t=this.attributes.position;if(t){var e=this.boundingSphere.center;yn.setFromBufferAttribute(t),yn.getCenter(e);for(var i=0,n=0,r=t.count;n<r;n++)xn.x=t.getX(n),xn.y=t.getY(n),xn.z=t.getZ(n),i=Math.max(i,e.distanceToSquared(xn));this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}),computeFaceNormals:function(){},computeVertexNormals:function(){var t=this.index,e=this.attributes,i=this.groups;if(e.position){var n=e.position.array;if(void 0===e.normal)this.addAttribute("normal",new an(new Float32Array(n.length),3));else for(var r=e.normal.array,a=0,o=r.length;a<o;a++)r[a]=0;var s,h,c,l=e.normal.array,u=new Ge,d=new Ge,p=new Ge,f=new Ge,m=new Ge;if(t){var g=t.array;0===i.length&&this.addGroup(0,g.length);for(var v=0,y=i.length;v<y;++v){var x=i[v],b=x.start;for(a=b,o=b+x.count;a<o;a+=3)s=3*g[a+0],h=3*g[a+1],c=3*g[a+2],u.fromArray(n,s),d.fromArray(n,h),p.fromArray(n,c),f.subVectors(p,d),m.subVectors(u,d),f.cross(m),l[s]+=f.x,l[s+1]+=f.y,l[s+2]+=f.z,l[h]+=f.x,l[h+1]+=f.y,l[h+2]+=f.z,l[c]+=f.x,l[c+1]+=f.y,l[c+2]+=f.z}}else for(a=0,o=n.length;a<o;a+=9)u.fromArray(n,a),d.fromArray(n,a+3),p.fromArray(n,a+6),f.subVectors(p,d),m.subVectors(u,d),f.cross(m),l[a]=f.x,l[a+1]=f.y,l[a+2]=f.z,l[a+3]=f.x,l[a+4]=f.y,l[a+5]=f.z,l[a+6]=f.x,l[a+7]=f.y,l[a+8]=f.z;this.normalizeNormals(),e.normal.needsUpdate=!0}},merge:function(t,e){if(t&&t.isBufferGeometry){void 0===e&&(e=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));var i=this.attributes;for(var n in i)if(void 0!==t.attributes[n])for(var r=i[n].array,a=t.attributes[n],o=a.array,s=0,h=a.itemSize*e;s<o.length;s++,h++)r[h]=o[s];return this}console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",t)},normalizeNormals:(vn=new Ge,function(){for(var t=this.attributes.normal,e=0,i=t.count;e<i;e++)vn.x=t.getX(e),vn.y=t.getY(e),vn.z=t.getZ(e),vn.normalize(),t.setXYZ(e,vn.x,vn.y,vn.z)}),toNonIndexed:function(){if(null===this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."),this;var t=new Ln,e=this.index.array,i=this.attributes;for(var n in i){for(var r=i[n],a=r.array,o=r.itemSize,s=new a.constructor(e.length*o),h=0,c=0,l=0,u=e.length;l<u;l++){h=e[l]*o;for(var d=0;d<o;d++)s[c++]=a[h++]}t.addAttribute(n,new an(s,o))}var p=this.groups;for(l=0,u=p.length;l<u;l++){var f=p[l];t.addGroup(f.start,f.count,f.materialIndex)}return t},toJSON:function(){var t={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,""!==this.name&&(t.name=this.name),void 0!==this.parameters){var e=this.parameters;for(var i in e)void 0!==e[i]&&(t[i]=e[i]);return t}t.data={attributes:{}};var n=this.index;if(null!==n){var r=Array.prototype.slice.call(n.array);t.data.index={type:n.array.constructor.name,array:r}}var a=this.attributes;for(var i in a){var o=a[i];r=Array.prototype.slice.call(o.array);t.data.attributes[i]={itemSize:o.itemSize,type:o.array.constructor.name,array:r,normalized:o.normalized}}var s=this.groups;0<s.length&&(t.data.groups=JSON.parse(JSON.stringify(s)));var h=this.boundingSphere;return null!==h&&(t.data.boundingSphere={center:h.center.toArray(),radius:h.radius}),t},clone:function(){return(new Ln).copy(this)},copy:function(t){var e,i,n;this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.name=t.name;var r=t.index;null!==r&&this.setIndex(r.clone());var a=t.attributes;for(e in a){var o=a[e];this.addAttribute(e,o.clone())}var s=t.morphAttributes;for(e in s){var h=[],c=s[e];for(i=0,n=c.length;i<n;i++)h.push(c[i].clone());this.morphAttributes[e]=h}var l=t.groups;for(i=0,n=l.length;i<n;i++){var u=l[i];this.addGroup(u.start,u.count,u.materialIndex)}var d=t.boundingBox;null!==d&&(this.boundingBox=d.clone());var p=t.boundingSphere;return null!==p&&(this.boundingSphere=p.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this},dispose:function(){this.dispatchEvent({type:"dispose"})}}),(Rn.prototype=Object.create(rn.prototype)).constructor=Rn,(Cn.prototype=Object.create(Ln.prototype)).constructor=Cn,(Pn.prototype=Object.create(rn.prototype)).constructor=Pn,(On.prototype=Object.create(Ln.prototype)).constructor=On;var In,Nn,Un,Dn,Bn,Fn,zn,Gn,Hn,Vn,kn,jn,Wn,Xn,qn,Yn,Zn,Jn,Qn,Kn,$n,tr,er,ir,nr=0;function rr(){Object.defineProperty(this,"id",{value:nr++}),this.uuid=De.generateUUID(),this.name="",this.type="Material",this.fog=!0,this.lights=!0,this.blending=Y,this.side=U,this.flatShading=!1,this.vertexColors=Lt,this.opacity=1,this.transparent=!1,this.blendSrc=O,this.blendDst=I,this.blendEquation=M,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=nt,this.depthTest=!0,this.depthWrite=!0,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaTest=0,this.premultipliedAlpha=!1,this.overdraw=0,this.visible=!0,this.userData={},this.needsUpdate=!0}function ar(t){rr.call(this),this.type="MeshBasicMaterial",this.color=new yi(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=V,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.lights=!1,this.setValues(t)}function or(t){rr.call(this),this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader="void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",this.fragmentShader="void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,void 0!==t&&(void 0!==t.attributes&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(t))}function sr(t,e){this.origin=void 0!==t?t:new Ge,this.direction=void 0!==e?e:new Ge}function hr(t,e){this.start=void 0!==t?t:new Ge,this.end=void 0!==e?e:new Ge}function cr(t,e,i){this.a=void 0!==t?t:new Ge,this.b=void 0!==e?e:new Ge,this.c=void 0!==i?i:new Ge}function lr(t,e){Wi.call(this),this.type="Mesh",this.geometry=void 0!==t?t:new Ln,this.material=void 0!==e?e:new ar({color:16777215*Math.random()}),this.drawMode=Se,this.updateMorphTargets()}function ur(a,i,o,n){var s,h,c,l=new yi(0),u=0;function d(t,e){i.buffers.color.setClear(t.r,t.g,t.b,e,n)}return{getClearColor:function(){return l},setClearColor:function(t,e){l.set(t),d(l,u=void 0!==e?e:1)},getClearAlpha:function(){return u},setClearAlpha:function(t){d(l,u=t)},render:function(t,e,i,n){var r=e.background;null===r?d(l,u):r&&r.isColor&&(d(r,1),n=!0),(a.autoClear||n)&&a.clear(a.autoClearColor,a.autoClearDepth,a.autoClearStencil),r&&r.isCubeTexture?(void 0===c&&((c=new lr(new Cn(1,1,1),new or({uniforms:wi.cube.uniforms,vertexShader:wi.cube.vertexShader,fragmentShader:wi.cube.fragmentShader,side:At,depthTest:!0,depthWrite:!1,fog:!1}))).geometry.removeAttribute("normal"),c.geometry.removeAttribute("uv"),c.onBeforeRender=function(t,e,i){this.matrixWorld.copyPosition(i.matrixWorld)},o.update(c)),c.material.uniforms.tCube.value=r,t.push(c,c.geometry,c.material,0,null)):r&&r.isTexture&&(void 0===s&&(s=new qi(-1,1,1,-1,0,1),h=new lr(new On(2,2),new ar({depthTest:!1,depthWrite:!1,fog:!1})),o.update(h)),h.material.map=r,a.renderBufferDirect(s,null,h.geometry,h.material,h,null))}}}function dr(i,r,a){var o;this.setMode=function(t){o=t},this.render=function(t,e){i.drawArrays(o,t,e),a.update(e,o)},this.renderInstances=function(t,e,i){var n=r.get("ANGLE_instanced_arrays");null!==n?(n.drawArraysInstancedANGLE(o,e,i,t.maxInstancedCount),a.update(i,o,t.maxInstancedCount)):console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.")}}function pr(e,i,t){var n;function r(t){return"lowp"}var a=void 0!==t.precision?t.precision:"highp";"lowp"!==a&&(a="lowp");var o=!0===t.logarithmicDepthBuffer,s=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),h=e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS),c=e.getParameter(e.MAX_TEXTURE_SIZE),l=e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE),u=e.getParameter(e.MAX_VERTEX_ATTRIBS),d=e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS),p=e.getParameter(e.MAX_VARYING_VECTORS),f=e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS),m=0<h,g=!!i.get("OES_texture_float");return{getMaxAnisotropy:function(){if(void 0!==n)return n;var t=i.get("EXT_texture_filter_anisotropic");return n=null!==t?e.getParameter(t.MAX_TEXTURE_MAX_ANISOTROPY_EXT):0},getMaxPrecision:r,precision:a,logarithmicDepthBuffer:o,maxTextures:s,maxVertexTextures:h,maxTextureSize:c,maxCubemapSize:l,maxAttributes:u,maxVertexUniforms:d,maxVaryings:p,maxFragmentUniforms:f,vertexTextures:m,floatFragmentTextures:g,floatVertexTextures:m&&g}}function fr(){var l=this,u=null,d=0,p=!1,f=!1,m=new di,g=new He,v={value:null,needsUpdate:!1};function y(){v.value!==u&&(v.value=u,v.needsUpdate=0<d),l.numPlanes=d,l.numIntersection=0}function x(t,e,i,n){var r=null!==t?t.length:0,a=null;if(0!==r){if(a=v.value,!0!==n||null===a){var o=i+4*r,s=e.matrixWorldInverse;g.getNormalMatrix(s),(null===a||a.length<o)&&(a=new Float32Array(o));for(var h=0,c=i;h!==r;++h,c+=4)m.copy(t[h]).applyMatrix4(s,g),m.normal.toArray(a,c),a[c+3]=m.constant}v.value=a,v.needsUpdate=!0}return l.numPlanes=r,a}this.uniform=v,this.numPlanes=0,this.numIntersection=0,this.init=function(t,e,i){var n=0!==t.length||e||0!==d||p;return p=e,u=x(t,i,0),d=t.length,n},this.beginShadows=function(){f=!0,x(null)},this.endShadows=function(){f=!1,y()},this.setState=function(t,e,i,n,r,a){if(!p||null===t||0===t.length||f&&!i)f?x(null):y();else{var o=f?0:d,s=4*o,h=r.clippingState||null;v.value=h,h=x(t,n,s,a);for(var c=0;c!==s;++c)h[c]=u[c];r.clippingState=h,this.numIntersection=e?this.numPlanes:0,this.numPlanes+=o}}}function mr(i){var n={};return{get:function(t){if(void 0!==n[t])return n[t];var e;switch(t){case"WEBGL_depth_texture":e=i.getExtension("WEBGL_depth_texture")||i.getExtension("MOZ_WEBGL_depth_texture")||i.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":e=i.getExtension("EXT_texture_filter_anisotropic")||i.getExtension("MOZ_EXT_texture_filter_anisotropic")||i.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":e=i.getExtension("WEBGL_compressed_texture_s3tc")||i.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||i.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":e=i.getExtension("WEBGL_compressed_texture_pvrtc")||i.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:e=i.getExtension(t)}return n[t]=e}}}function gr(u,d,a){var o={},p={};function s(t){var e=t.target,i=o[e.id];for(var n in null!==i.index&&d.remove(i.index),i.attributes)d.remove(i.attributes[n]);e.removeEventListener("dispose",s),delete o[e.id];var r=p[e.id];r&&(d.remove(r),delete p[e.id]),(r=p[i.id])&&(d.remove(r),delete p[i.id]),a.memory.geometries--}return{get:function(t,e){var i=o[e.id];return i||(e.addEventListener("dispose",s),e.isBufferGeometry?i=e:e.isGeometry&&(void 0===e._bufferGeometry&&(e._bufferGeometry=(new Ln).setFromObject(t)),i=e._bufferGeometry),o[e.id]=i,a.memory.geometries++,i)},update:function(t){var e=t.index,i=t.attributes;for(var n in null!==e&&d.update(e,u.ELEMENT_ARRAY_BUFFER),i)d.update(i[n],u.ARRAY_BUFFER);var r=t.morphAttributes;for(var n in r)for(var a=r[n],o=0,s=a.length;o<s;o++)d.update(a[o],u.ARRAY_BUFFER)},getWireframeAttribute:function(t){var e=p[t.id];if(e)return e;var i,n=[],r=t.index,a=t.attributes;if(null!==r)for(var o=0,s=(i=r.array).length;o<s;o+=3){var h=i[o+0],c=i[o+1],l=i[o+2];n.push(h,c,c,l,l,h)}else for(o=0,s=(i=a.position.array).length/3-1;o<s;o+=3)h=o+0,c=o+1,l=o+2,n.push(h,c,c,l,l,h);return e=new(65535<gn(n)?dn:ln)(n,1),d.update(e,u.ELEMENT_ARRAY_BUFFER),p[t.id]=e}}}function vr(i,r,a){var o,s,h;this.setMode=function(t){o=t},this.setIndex=function(t){s=t.type,h=t.bytesPerElement},this.render=function(t,e){i.drawElements(o,e,s,t*h),a.update(e,o)},this.renderInstances=function(t,e,i){var n=r.get("ANGLE_instanced_arrays");null!==n?(n.drawElementsInstancedANGLE(o,i,s,e*h,t.maxInstancedCount),a.update(i,o,t.maxInstancedCount)):console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.")}}function yr(n){var r={frame:0,calls:0,triangles:0,points:0,lines:0};return{memory:{geometries:0,textures:0},render:r,programs:null,autoReset:!0,reset:function(){r.frame++,r.calls=0,r.triangles=0,r.points=0,r.lines=0},update:function(t,e,i){switch(i=i||1,r.calls++,e){case n.TRIANGLES:r.triangles+=i*(t/3);break;case n.TRIANGLE_STRIP:case n.TRIANGLE_FAN:r.triangles+=i*(t-2);break;case n.LINES:r.lines+=i*(t/2);break;case n.LINE_STRIP:r.lines+=i*(t-1);break;case n.LINE_LOOP:r.lines+=i*t;break;case n.POINTS:r.points+=i*t;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",e)}}}}function xr(t,e){return Math.abs(e[1])-Math.abs(t[1])}function br(p){var f={},m=new Float32Array(8);return{update:function(t,e,i,n){var r=t.morphTargetInfluences,a=r.length,o=f[e.id];if(void 0===o){o=[];for(var s=0;s<a;s++)o[s]=[s,0];f[e.id]=o}var h=i.morphTargets&&e.morphAttributes.position,c=i.morphNormals&&e.morphAttributes.normal;for(s=0;s<a;s++)0!==(l=o[s])[1]&&(h&&e.removeAttribute("morphTarget"+s),c&&e.removeAttribute("morphNormal"+s));for(s=0;s<a;s++)(l=o[s])[0]=s,l[1]=r[s];for(o.sort(xr),s=0;s<8;s++){var l;if(l=o[s]){var u=l[0],d=l[1];if(d){h&&e.addAttribute("morphTarget"+s,h[u]),c&&e.addAttribute("morphNormal"+s,c[u]),m[s]=d;continue}}m[s]=0}n.getUniforms().setValue(p,"morphTargetInfluences",m)}}}function _r(r,a){var o={};return{update:function(t){var e=a.render.frame,i=t.geometry,n=r.get(t,i);return o[n.id]!==e&&(i.isGeometry&&n.updateFromObject(t),r.update(n),o[n.id]=e),n},dispose:function(){o={}}}}function wr(t,e,i,n,r,a,o,s,h,c){ai.call(this,t=void 0!==t?t:[],e=void 0!==e?e:pt,i,n,r,a,o,s,h,c),this.flipY=!1}rr.prototype=Object.assign(Object.create(e.prototype),{constructor:rr,isMaterial:!0,onBeforeCompile:function(){},setValues:function(t){if(void 0!==t)for(var e in t){var i=t[e];if(void 0!==i)if("shading"!==e){var n=this[e];void 0!==n?n&&n.isColor?n.set(i):n&&n.isVector3&&i&&i.isVector3?n.copy(i):this[e]="overdraw"===e?Number(i):i:console.warn("THREE."+this.type+": '"+e+"' is not a property of this material.")}else console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=1===i;else console.warn("THREE.Material: '"+e+"' parameter is undefined.")}},toJSON:function(t){var e=void 0===t||"string"==typeof t;e&&(t={textures:{},images:{}});var i={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};function n(t){var e=[];for(var i in t){var n=t[i];delete n.metadata,e.push(n)}return e}if(i.uuid=this.uuid,i.type=this.type,""!==this.name&&(i.name=this.name),this.color&&this.color.isColor&&(i.color=this.color.getHex()),void 0!==this.roughness&&(i.roughness=this.roughness),void 0!==this.metalness&&(i.metalness=this.metalness),this.emissive&&this.emissive.isColor&&(i.emissive=this.emissive.getHex()),1!==this.emissiveIntensity&&(i.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(i.specular=this.specular.getHex()),void 0!==this.shininess&&(i.shininess=this.shininess),void 0!==this.clearCoat&&(i.clearCoat=this.clearCoat),void 0!==this.clearCoatRoughness&&(i.clearCoatRoughness=this.clearCoatRoughness),this.map&&this.map.isTexture&&(i.map=this.map.toJSON(t).uuid),this.alphaMap&&this.alphaMap.isTexture&&(i.alphaMap=this.alphaMap.toJSON(t).uuid),this.lightMap&&this.lightMap.isTexture&&(i.lightMap=this.lightMap.toJSON(t).uuid),this.aoMap&&this.aoMap.isTexture&&(i.aoMap=this.aoMap.toJSON(t).uuid,i.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(i.bumpMap=this.bumpMap.toJSON(t).uuid,i.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(i.normalMap=this.normalMap.toJSON(t).uuid,i.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(i.displacementMap=this.displacementMap.toJSON(t).uuid,i.displacementScale=this.displacementScale,i.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(i.roughnessMap=this.roughnessMap.toJSON(t).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(i.metalnessMap=this.metalnessMap.toJSON(t).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(i.emissiveMap=this.emissiveMap.toJSON(t).uuid),this.specularMap&&this.specularMap.isTexture&&(i.specularMap=this.specularMap.toJSON(t).uuid),this.envMap&&this.envMap.isTexture&&(i.envMap=this.envMap.toJSON(t).uuid,i.reflectivity=this.reflectivity),this.gradientMap&&this.gradientMap.isTexture&&(i.gradientMap=this.gradientMap.toJSON(t).uuid),void 0!==this.size&&(i.size=this.size),void 0!==this.sizeAttenuation&&(i.sizeAttenuation=this.sizeAttenuation),this.blending!==Y&&(i.blending=this.blending),!0===this.flatShading&&(i.flatShading=this.flatShading),this.side!==U&&(i.side=this.side),this.vertexColors!==Lt&&(i.vertexColors=this.vertexColors),this.opacity<1&&(i.opacity=this.opacity),!0===this.transparent&&(i.transparent=this.transparent),i.depthFunc=this.depthFunc,i.depthTest=this.depthTest,i.depthWrite=this.depthWrite,0!==this.rotation&&(i.rotation=this.rotation),1!==this.linewidth&&(i.linewidth=this.linewidth),void 0!==this.dashSize&&(i.dashSize=this.dashSize),void 0!==this.gapSize&&(i.gapSize=this.gapSize),void 0!==this.scale&&(i.scale=this.scale),!0===this.dithering&&(i.dithering=!0),0<this.alphaTest&&(i.alphaTest=this.alphaTest),!0===this.premultipliedAlpha&&(i.premultipliedAlpha=this.premultipliedAlpha),!0===this.wireframe&&(i.wireframe=this.wireframe),1<this.wireframeLinewidth&&(i.wireframeLinewidth=this.wireframeLinewidth),"round"!==this.wireframeLinecap&&(i.wireframeLinecap=this.wireframeLinecap),"round"!==this.wireframeLinejoin&&(i.wireframeLinejoin=this.wireframeLinejoin),!0===this.morphTargets&&(i.morphTargets=!0),!0===this.skinning&&(i.skinning=!0),!1===this.visible&&(i.visible=!1),"{}"!==JSON.stringify(this.userData)&&(i.userData=this.userData),e){var r=n(t.textures),a=n(t.images);0<r.length&&(i.textures=r),0<a.length&&(i.images=a)}return i},clone:function(){return(new this.constructor).copy(this)},copy:function(t){this.name=t.name,this.fog=t.fog,this.lights=t.lights,this.blending=t.blending,this.side=t.side,this.flatShading=t.flatShading,this.vertexColors=t.vertexColors,this.opacity=t.opacity,this.transparent=t.transparent,this.blendSrc=t.blendSrc,this.blendDst=t.blendDst,this.blendEquation=t.blendEquation,this.blendSrcAlpha=t.blendSrcAlpha,this.blendDstAlpha=t.blendDstAlpha,this.blendEquationAlpha=t.blendEquationAlpha,this.depthFunc=t.depthFunc,this.depthTest=t.depthTest,this.depthWrite=t.depthWrite,this.colorWrite=t.colorWrite,this.precision=t.precision,this.polygonOffset=t.polygonOffset,this.polygonOffsetFactor=t.polygonOffsetFactor,this.polygonOffsetUnits=t.polygonOffsetUnits,this.dithering=t.dithering,this.alphaTest=t.alphaTest,this.premultipliedAlpha=t.premultipliedAlpha,this.overdraw=t.overdraw,this.visible=t.visible,this.userData=JSON.parse(JSON.stringify(t.userData)),this.clipShadows=t.clipShadows,this.clipIntersection=t.clipIntersection;var e=t.clippingPlanes,i=null;if(null!==e){var n=e.length;i=new Array(n);for(var r=0;r!==n;++r)i[r]=e[r].clone()}return this.clippingPlanes=i,this.shadowSide=t.shadowSide,this},dispose:function(){this.dispatchEvent({type:"dispose"})}}),((ar.prototype=Object.create(rr.prototype)).constructor=ar).prototype.isMeshBasicMaterial=!0,ar.prototype.copy=function(t){return rr.prototype.copy.call(this,t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this},((or.prototype=Object.create(rr.prototype)).constructor=or).prototype.isShaderMaterial=!0,or.prototype.copy=function(t){return rr.prototype.copy.call(this,t),this.fragmentShader=t.fragmentShader,this.vertexShader=t.vertexShader,this.uniforms=gi.clone(t.uniforms),this.defines=Object.assign({},t.defines),this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.lights=t.lights,this.clipping=t.clipping,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.morphNormals=t.morphNormals,this.extensions=t.extensions,this},or.prototype.toJSON=function(t){var e=rr.prototype.toJSON.call(this,t);return e.uniforms=this.uniforms,e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader,e},Object.assign(sr.prototype,{set:function(t,e){return this.origin.copy(t),this.direction.copy(e),this},clone:function(){return(new this.constructor).copy(this)},copy:function(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this},at:function(t,e){return void 0===e&&(console.warn("THREE.Ray: .at() target is now required"),e=new Ge),e.copy(this.direction).multiplyScalar(t).add(this.origin)},lookAt:function(t){return this.direction.copy(t).sub(this.origin).normalize(),this},recast:(kn=new Ge,function(t){return this.origin.copy(this.at(t,kn)),this}),closestPointToPoint:function(t,e){void 0===e&&(console.warn("THREE.Ray: .closestPointToPoint() target is now required"),e=new Ge),e.subVectors(t,this.origin);var i=e.dot(this.direction);return i<0?e.copy(this.origin):e.copy(this.direction).multiplyScalar(i).add(this.origin)},distanceToPoint:function(t){return Math.sqrt(this.distanceSqToPoint(t))},distanceSqToPoint:(Vn=new Ge,function(t){var e=Vn.subVectors(t,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(t):(Vn.copy(this.direction).multiplyScalar(e).add(this.origin),Vn.distanceToSquared(t))}),distanceSqToSegment:(zn=new Ge,Gn=new Ge,Hn=new Ge,function(t,e,i,n){zn.copy(t).add(e).multiplyScalar(.5),Gn.copy(e).sub(t).normalize(),Hn.copy(this.origin).sub(zn);var r,a,o,s,h=.5*t.distanceTo(e),c=-this.direction.dot(Gn),l=Hn.dot(this.direction),u=-Hn.dot(Gn),d=Hn.lengthSq(),p=Math.abs(1-c*c);if(0<p)if(a=c*l-u,s=h*p,0<=(r=c*u-l))if(-s<=a)if(a<=s){var f=1/p;o=(r*=f)*(r+c*(a*=f)+2*l)+a*(c*r+a+2*u)+d}else a=h,o=-(r=Math.max(0,-(c*a+l)))*r+a*(a+2*u)+d;else a=-h,o=-(r=Math.max(0,-(c*a+l)))*r+a*(a+2*u)+d;else a<=-s?o=-(r=Math.max(0,-(-c*h+l)))*r+(a=0<r?-h:Math.min(Math.max(-h,-u),h))*(a+2*u)+d:a<=s?(r=0,o=(a=Math.min(Math.max(-h,-u),h))*(a+2*u)+d):o=-(r=Math.max(0,-(c*h+l)))*r+(a=0<r?h:Math.min(Math.max(-h,-u),h))*(a+2*u)+d;else a=0<c?-h:h,o=-(r=Math.max(0,-(c*a+l)))*r+a*(a+2*u)+d;return i&&i.copy(this.direction).multiplyScalar(r).add(this.origin),n&&n.copy(Gn).multiplyScalar(a).add(zn),o}),intersectSphere:(Fn=new Ge,function(t,e){Fn.subVectors(t.center,this.origin);var i=Fn.dot(this.direction),n=Fn.dot(Fn)-i*i,r=t.radius*t.radius;if(r<n)return null;var a=Math.sqrt(r-n),o=i-a,s=i+a;return o<0&&s<0?null:o<0?this.at(s,e):this.at(o,e)}),intersectsSphere:function(t){return this.distanceToPoint(t.center)<=t.radius},distanceToPlane:function(t){var e=t.normal.dot(this.direction);if(0===e)return 0===t.distanceToPoint(this.origin)?0:null;var i=-(this.origin.dot(t.normal)+t.constant)/e;return 0<=i?i:null},intersectPlane:function(t,e){var i=this.distanceToPlane(t);return null===i?null:this.at(i,e)},intersectsPlane:function(t){var e=t.distanceToPoint(this.origin);return 0===e||t.normal.dot(this.direction)*e<0},intersectBox:function(t,e){var i,n,r,a,o,s,h=1/this.direction.x,c=1/this.direction.y,l=1/this.direction.z,u=this.origin;return 0<=h?(i=(t.min.x-u.x)*h,n=(t.max.x-u.x)*h):(i=(t.max.x-u.x)*h,n=(t.min.x-u.x)*h),0<=c?(r=(t.min.y-u.y)*c,a=(t.max.y-u.y)*c):(r=(t.max.y-u.y)*c,a=(t.min.y-u.y)*c),a<i||n<r?null:((i<r||i!=i)&&(i=r),(a<n||n!=n)&&(n=a),0<=l?(o=(t.min.z-u.z)*l,s=(t.max.z-u.z)*l):(o=(t.max.z-u.z)*l,s=(t.min.z-u.z)*l),s<i||n<o?null:((i<o||i!=i)&&(i=o),(s<n||n!=n)&&(n=s),n<0?null:this.at(0<=i?i:n,e)))},intersectsBox:(Bn=new Ge,function(t){return null!==this.intersectBox(t,Bn)}),intersectTriangle:(In=new Ge,Nn=new Ge,Un=new Ge,Dn=new Ge,function(t,e,i,n,r){Nn.subVectors(e,t),Un.subVectors(i,t),Dn.crossVectors(Nn,Un);var a,o=this.direction.dot(Dn);if(0<o){if(n)return null;a=1}else{if(!(o<0))return null;a=-1,o=-o}In.subVectors(this.origin,t);var s=a*this.direction.dot(Un.crossVectors(In,Un));if(s<0)return null;var h=a*this.direction.dot(Nn.cross(In));if(h<0)return null;if(o<s+h)return null;var c=-a*In.dot(Dn);return c<0?null:this.at(c/o,r)}),applyMatrix4:function(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this},equals:function(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}}),Object.assign(hr.prototype,{set:function(t,e){return this.start.copy(t),this.end.copy(e),this},clone:function(){return(new this.constructor).copy(this)},copy:function(t){return this.start.copy(t.start),this.end.copy(t.end),this},getCenter:function(t){return void 0===t&&(console.warn("THREE.Line3: .getCenter() target is now required"),t=new Ge),t.addVectors(this.start,this.end).multiplyScalar(.5)},delta:function(t){return void 0===t&&(console.warn("THREE.Line3: .delta() target is now required"),t=new Ge),t.subVectors(this.end,this.start)},distanceSq:function(){return this.start.distanceToSquared(this.end)},distance:function(){return this.start.distanceTo(this.end)},at:function(t,e){return void 0===e&&(console.warn("THREE.Line3: .at() target is now required"),e=new Ge),this.delta(e).multiplyScalar(t).add(this.start)},closestPointToPointParameter:(jn=new Ge,Wn=new Ge,function(t,e){jn.subVectors(t,this.start),Wn.subVectors(this.end,this.start);var i=Wn.dot(Wn),n=Wn.dot(jn)/i;return e&&(n=De.clamp(n,0,1)),n}),closestPointToPoint:function(t,e,i){var n=this.closestPointToPointParameter(t,e);return void 0===i&&(console.warn("THREE.Line3: .closestPointToPoint() target is now required"),i=new Ge),this.delta(i).multiplyScalar(n).add(this.start)},applyMatrix4:function(t){return this.start.applyMatrix4(t),this.end.applyMatrix4(t),this},equals:function(t){return t.start.equals(this.start)&&t.end.equals(this.end)}}),Object.assign(cr,{getNormal:(Jn=new Ge,function(t,e,i,n){void 0===n&&(console.warn("THREE.Triangle: .getNormal() target is now required"),n=new Ge),n.subVectors(i,e),Jn.subVectors(t,e),n.cross(Jn);var r=n.lengthSq();return 0<r?n.multiplyScalar(1/Math.sqrt(r)):n.set(0,0,0)}),getBarycoord:(qn=new Ge,Yn=new Ge,Zn=new Ge,function(t,e,i,n,r){qn.subVectors(n,e),Yn.subVectors(i,e),Zn.subVectors(t,e);var a=qn.dot(qn),o=qn.dot(Yn),s=qn.dot(Zn),h=Yn.dot(Yn),c=Yn.dot(Zn),l=a*h-o*o;if(void 0===r&&(console.warn("THREE.Triangle: .getBarycoord() target is now required"),r=new Ge),0===l)return r.set(-2,-1,-1);var u=1/l,d=(h*s-o*c)*u,p=(a*c-o*s)*u;return r.set(1-d-p,p,d)}),containsPoint:(Xn=new Ge,function(t,e,i,n){return cr.getBarycoord(t,e,i,n,Xn),0<=Xn.x&&0<=Xn.y&&Xn.x+Xn.y<=1})}),Object.assign(cr.prototype,{set:function(t,e,i){return this.a.copy(t),this.b.copy(e),this.c.copy(i),this},setFromPointsAndIndices:function(t,e,i,n){return this.a.copy(t[e]),this.b.copy(t[i]),this.c.copy(t[n]),this},clone:function(){return(new this.constructor).copy(this)},copy:function(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this},getArea:(er=new Ge,ir=new Ge,function(){return er.subVectors(this.c,this.b),ir.subVectors(this.a,this.b),.5*er.cross(ir).length()}),getMidpoint:function(t){return void 0===t&&(console.warn("THREE.Triangle: .getMidpoint() target is now required"),t=new Ge),t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)},getNormal:function(t){return cr.getNormal(this.a,this.b,this.c,t)},getPlane:function(t){return void 0===t&&(console.warn("THREE.Triangle: .getPlane() target is now required"),t=new Ge),t.setFromCoplanarPoints(this.a,this.b,this.c)},getBarycoord:function(t,e){return cr.getBarycoord(t,this.a,this.b,this.c,e)},containsPoint:function(t){return cr.containsPoint(t,this.a,this.b,this.c)},intersectsBox:function(t){return t.intersectsTriangle(this)},closestPointToPoint:(Qn=new di,Kn=[new hr,new hr,new hr],$n=new Ge,tr=new Ge,function(t,e){void 0===e&&(console.warn("THREE.Triangle: .closestPointToPoint() target is now required"),e=new Ge);var i=1/0;if(Qn.setFromCoplanarPoints(this.a,this.b,this.c),Qn.projectPoint(t,$n),!0===this.containsPoint($n))e.copy($n);else{Kn[0].set(this.a,this.b),Kn[1].set(this.b,this.c),Kn[2].set(this.c,this.a);for(var n=0;n<Kn.length;n++){Kn[n].closestPointToPoint($n,!0,tr);var r=$n.distanceToSquared(tr);r<i&&(i=r,e.copy(tr))}}return e}),equals:function(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}),lr.prototype=Object.assign(Object.create(Wi.prototype),{constructor:lr,isMesh:!0,setDrawMode:function(t){this.drawMode=t},copy:function(t){return Wi.prototype.copy.call(this,t),this.drawMode=t.drawMode,void 0!==t.morphTargetInfluences&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),void 0!==t.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this},updateMorphTargets:function(){var t,e,i,n=this.geometry;if(n.isBufferGeometry){var r=n.morphAttributes,a=Object.keys(r);if(0<a.length){var o=r[a[0]];if(void 0!==o)for(this.morphTargetInfluences=[],this.morphTargetDictionary={},t=0,e=o.length;t<e;t++)i=o[t].name||String(t),this.morphTargetInfluences.push(0),this.morphTargetDictionary[i]=t}}else{var s=n.morphTargets;if(void 0!==s&&0<s.length)for(this.morphTargetInfluences=[],this.morphTargetDictionary={},t=0,e=s.length;t<e;t++)i=s[t].name||String(t),this.morphTargetInfluences.push(0),this.morphTargetDictionary[i]=t}},raycast:function(){var I=new Fe,N=new sr,U=new ui,D=new Ge,B=new Ge,F=new Ge,z=new Ge,G=new Ge,H=new Ge,V=new Be,k=new Be,j=new Be,s=new Ge,W=new Ge,c=new Ge;function X(t,e,i,n,r,a,o){return cr.getBarycoord(t,e,i,n,s),r.multiplyScalar(s.x),a.multiplyScalar(s.y),o.multiplyScalar(s.z),r.add(a).add(o),r.clone()}function q(t,e,i,n,r,a,o,s){if(null===(e.side===At?n.intersectTriangle(o,a,r,!0,s):n.intersectTriangle(r,a,o,e.side!==Z,s)))return null;c.copy(s),c.applyMatrix4(t.matrixWorld);var h=i.ray.origin.distanceTo(c);return h<i.near||h>i.far?null:{distance:h,point:c.clone(),object:t}}function Y(t,e,i,n,r,a,o,s){D.fromBufferAttribute(n,a),B.fromBufferAttribute(n,o),F.fromBufferAttribute(n,s);var h=q(t,t.material,e,i,D,B,F,W);if(h){r&&(V.fromBufferAttribute(r,a),k.fromBufferAttribute(r,o),j.fromBufferAttribute(r,s),h.uv=X(W,D,B,F,V,k,j));var c=new Yi(a,o,s);cr.getNormal(D,B,F,c.normal),h.face=c}return h}return function(t,e){var i,n=this.geometry,r=this.material,a=this.matrixWorld;if(void 0!==r&&(null===n.boundingSphere&&n.computeBoundingSphere(),U.copy(n.boundingSphere),U.applyMatrix4(a),!1!==t.ray.intersectsSphere(U)&&(I.getInverse(a),N.copy(t.ray).applyMatrix4(I),null===n.boundingBox||!1!==N.intersectsBox(n.boundingBox))))if(n.isBufferGeometry){var o,s,h,c,l,u=n.index,d=n.attributes.position,p=n.attributes.uv;if(null!==u)for(c=0,l=u.count;c<l;c+=3)o=u.getX(c),s=u.getX(c+1),h=u.getX(c+2),(i=Y(this,t,N,d,p,o,s,h))&&(i.faceIndex=Math.floor(c/3),e.push(i));else if(void 0!==d)for(c=0,l=d.count;c<l;c+=3)(i=Y(this,t,N,d,p,o=c,s=c+1,h=c+2))&&(i.faceIndex=Math.floor(c/3),e.push(i))}else if(n.isGeometry){var f,m,g,v,y=Array.isArray(r),x=n.vertices,b=n.faces,_=n.faceVertexUvs[0];0<_.length&&(v=_);for(var w=0,M=b.length;w<M;w++){var E=b[w],T=y?r[E.materialIndex]:r;if(void 0!==T){if(f=x[E.a],m=x[E.b],g=x[E.c],!0===T.morphTargets){var S=n.morphTargets,A=this.morphTargetInfluences;D.set(0,0,0),B.set(0,0,0),F.set(0,0,0);for(var L=0,R=S.length;L<R;L++){var C=A[L];if(0!==C){var P=S[L].vertices;D.addScaledVector(z.subVectors(P[E.a],f),C),B.addScaledVector(G.subVectors(P[E.b],m),C),F.addScaledVector(H.subVectors(P[E.c],g),C)}}D.add(f),B.add(m),F.add(g),f=D,m=B,g=F}if(i=q(this,T,t,N,f,m,g,W)){if(v&&v[w]){var O=v[w];V.copy(O[0]),k.copy(O[1]),j.copy(O[2]),i.uv=X(W,f,m,g,V,k,j)}i.face=E,i.faceIndex=w,e.push(i)}}}}}}(),clone:function(){return new this.constructor(this.geometry,this.material).copy(this)}}),((wr.prototype=Object.create(ai.prototype)).constructor=wr).prototype.isCubeTexture=!0,Object.defineProperty(wr.prototype,"images",{get:function(){return this.image},set:function(t){this.image=t}});var Mr=new ai,Er=new wr;function Tr(){this.seq=[],this.map={}}var Sr=[],Ar=[],Lr=new Float32Array(16),Rr=new Float32Array(9),Cr=new Float32Array(4);function Pr(t,e,i){var n=t[0];if(n<=0||0<n)return t;var r=e*i,a=Sr[r];if(void 0===a&&(a=new Float32Array(r),Sr[r]=a),0!==e){n.toArray(a,0);for(var o=1,s=0;o!==e;++o)s+=i,t[o].toArray(a,s)}return a}function Or(t,e){if(t.length!==e.length)return!1;for(var i=0,n=t.length;i<n;i++)if(t[i]!==e[i])return!1;return!0}function Ir(t,e){for(var i=0,n=e.length;i<n;i++)t[i]=e[i]}function Nr(t,e){var i=Ar[e];void 0===i&&(i=new Int32Array(e),Ar[e]=i);for(var n=0;n!==e;++n)i[n]=t.allocTextureUnit();return i}function Ur(t,e){var i=this.cache;i[0]!==e&&(t.uniform1f(this.addr,e),i[0]=e)}function Dr(t,e){var i=this.cache;i[0]!==e&&(t.uniform1i(this.addr,e),i[0]=e)}function Br(t,e){var i=this.cache;if(void 0!==e.x)i[0]===e.x&&i[1]===e.y||(t.uniform2f(this.addr,e.x,e.y),i[0]=e.x,i[1]=e.y);else{if(Or(i,e))return;t.uniform2fv(this.addr,e),Ir(i,e)}}function Fr(t,e){var i=this.cache;if(void 0!==e.x)i[0]===e.x&&i[1]===e.y&&i[2]===e.z||(t.uniform3f(this.addr,e.x,e.y,e.z),i[0]=e.x,i[1]=e.y,i[2]=e.z);else if(void 0!==e.r)i[0]===e.r&&i[1]===e.g&&i[2]===e.b||(t.uniform3f(this.addr,e.r,e.g,e.b),i[0]=e.r,i[1]=e.g,i[2]=e.b);else{if(Or(i,e))return;t.uniform3fv(this.addr,e),Ir(i,e)}}function zr(t,e){var i=this.cache;if(void 0!==e.x)i[0]===e.x&&i[1]===e.y&&i[2]===e.z&&i[3]===e.w||(t.uniform4f(this.addr,e.x,e.y,e.z,e.w),i[0]=e.x,i[1]=e.y,i[2]=e.z,i[3]=e.w);else{if(Or(i,e))return;t.uniform4fv(this.addr,e),Ir(i,e)}}function Gr(t,e){var i=this.cache,n=e.elements;if(void 0===n){if(Or(i,e))return;t.uniformMatrix2fv(this.addr,!1,e),Ir(i,e)}else{if(Or(i,n))return;Cr.set(n),t.uniformMatrix2fv(this.addr,!1,Cr),Ir(i,n)}}function Hr(t,e){var i=this.cache,n=e.elements;if(void 0===n){if(Or(i,e))return;t.uniformMatrix3fv(this.addr,!1,e),Ir(i,e)}else{if(Or(i,n))return;Rr.set(n),t.uniformMatrix3fv(this.addr,!1,Rr),Ir(i,n)}}function Vr(t,e){var i=this.cache,n=e.elements;if(void 0===n){if(Or(i,e))return;t.uniformMatrix4fv(this.addr,!1,e),Ir(i,e)}else{if(Or(i,n))return;Lr.set(n),t.uniformMatrix4fv(this.addr,!1,Lr),Ir(i,n)}}function kr(t,e,i){var n=this.cache,r=i.allocTextureUnit();n[0]!==r&&(t.uniform1i(this.addr,r),n[0]=r),i.setTexture2D(e||Mr,r)}function jr(t,e,i){var n=this.cache,r=i.allocTextureUnit();n[0]!==r&&(t.uniform1i(this.addr,r),n[0]=r),i.setTextureCube(e||Er,r)}function Wr(t,e){var i=this.cache;Or(i,e)||(t.uniform2iv(this.addr,e),Ir(i,e))}function Xr(t,e){var i=this.cache;Or(i,e)||(t.uniform3iv(this.addr,e),Ir(i,e))}function qr(t,e){var i=this.cache;Or(i,e)||(t.uniform4iv(this.addr,e),Ir(i,e))}function Yr(t,e){var i=this.cache;Or(i,e)||(t.uniform1fv(this.addr,e),Ir(i,e))}function Zr(t,e){var i=this.cache;Or(i,e)||(t.uniform1iv(this.addr,e),Ir(i,e))}function Jr(t,e){var i=this.cache,n=Pr(e,this.size,2);Or(i,n)||(t.uniform2fv(this.addr,n),this.updateCache(n))}function Qr(t,e){var i=this.cache,n=Pr(e,this.size,3);Or(i,n)||(t.uniform3fv(this.addr,n),this.updateCache(n))}function Kr(t,e){var i=this.cache,n=Pr(e,this.size,4);Or(i,n)||(t.uniform4fv(this.addr,n),this.updateCache(n))}function $r(t,e){var i=this.cache,n=Pr(e,this.size,4);Or(i,n)||(t.uniformMatrix2fv(this.addr,!1,n),this.updateCache(n))}function ta(t,e){var i=this.cache,n=Pr(e,this.size,9);Or(i,n)||(t.uniformMatrix3fv(this.addr,!1,n),this.updateCache(n))}function ea(t,e){var i=this.cache,n=Pr(e,this.size,16);Or(i,n)||(t.uniformMatrix4fv(this.addr,!1,n),this.updateCache(n))}function ia(t,e,i){var n=this.cache,r=e.length,a=Nr(i,r);!1===Or(n,a)&&(t.uniform1iv(this.addr,a),Ir(n,a));for(var o=0;o!==r;++o)i.setTexture2D(e[o]||Mr,a[o])}function na(t,e,i){var n=this.cache,r=e.length,a=Nr(i,r);!1===Or(n,a)&&(t.uniform1iv(this.addr,a),Ir(n,a));for(var o=0;o!==r;++o)i.setTextureCube(e[o]||Er,a[o])}function ra(t,e,i){this.id=t,this.addr=i,this.cache=[],this.setValue=function(t){switch(t){case 5126:return Ur;case 35664:return Br;case 35665:return Fr;case 35666:return zr;case 35674:return Gr;case 35675:return Hr;case 35676:return Vr;case 35678:case 36198:return kr;case 35680:return jr;case 5124:case 35670:return Dr;case 35667:case 35671:return Wr;case 35668:case 35672:return Xr;case 35669:case 35673:return qr}}(e.type)}function aa(t,e,i){this.id=t,this.addr=i,this.cache=[],this.size=e.size,this.setValue=function(t){switch(t){case 5126:return Yr;case 35664:return Jr;case 35665:return Qr;case 35666:return Kr;case 35674:return $r;case 35675:return ta;case 35676:return ea;case 35678:return ia;case 35680:return na;case 5124:case 35670:return Zr;case 35667:case 35671:return Wr;case 35668:case 35672:return Xr;case 35669:case 35673:return qr}}(e.type)}function oa(t){this.id=t,Tr.call(this)}aa.prototype.updateCache=function(t){var e=this.cache;t instanceof Float32Array&&e.length!==t.length&&(this.cache=new Float32Array(t.length)),Ir(e,t)},oa.prototype.setValue=function(t,e){for(var i=this.seq,n=0,r=i.length;n!==r;++n){var a=i[n];a.setValue(t,e[a.id])}};var sa=/([\w\d_]+)(\])?(\[|\.)?/g;function ha(t,e){t.seq.push(e),t.map[e.id]=e}function ca(t,e,i){var n=t.name,r=n.length;for(sa.lastIndex=0;;){var a=sa.exec(n),o=sa.lastIndex,s=a[1],h="]"===a[2],c=a[3];if(h&&(s|=0),void 0===c||"["===c&&o+2===r){ha(i,void 0===c?new ra(s,t,e):new aa(s,t,e));break}var l=i.map[s];void 0===l&&ha(i,l=new oa(s)),i=l}}function la(t,e,i){Tr.call(this),this.renderer=i;for(var n=t.getProgramParameter(e,t.ACTIVE_UNIFORMS),r=0;r<n;++r){var a=t.getActiveUniform(e,r);ca(a,t.getUniformLocation(e,a.name),this)}}function ua(t,e,i){var n=t.createShader(e);return t.shaderSource(n,i),t.compileShader(n),!1===t.getShaderParameter(n,t.COMPILE_STATUS)&&console.error("THREE.WebGLShader: Shader couldn't compile."),""!==t.getShaderInfoLog(n)&&console.warn("THREE.WebGLShader: gl.getShaderInfoLog()",e===t.VERTEX_SHADER?"vertex":"fragment",t.getShaderInfoLog(n),function(t){for(var e=t.split("\n"),i=0;i<e.length;i++)e[i]=i+1+": "+e[i];return e.join("\n")}(i)),n}la.prototype.setValue=function(t,e,i){var n=this.map[e];void 0!==n&&n.setValue(t,i,this.renderer)},la.prototype.setOptional=function(t,e,i){var n=e[i];void 0!==n&&this.setValue(t,i,n)},la.upload=function(t,e,i,n){for(var r=0,a=e.length;r!==a;++r){var o=e[r],s=i[o.id];!1!==s.needsUpdate&&o.setValue(t,s.value,n)}},la.seqWithValue=function(t,e){for(var i=[],n=0,r=t.length;n!==r;++n){var a=t[n];a.id in e&&i.push(a)}return i};var da=0;function pa(t){switch(t){case Ae:return["Linear","( value )"];case Le:return["sRGB","( value )"];case Ce:return["RGBE","( value )"];case Pe:return["RGBM","( value, 7.0 )"];case Oe:return["RGBM","( value, 16.0 )"];case Ie:return["RGBD","( value, 256.0 )"];case Re:return["Gamma","( value, float( GAMMA_FACTOR ) )"];default:throw new Error("unsupported encoding: "+t)}}function fa(t,e){var i=pa(e);return"vec4 "+t+"( vec4 value ) { return "+i[0]+"ToLinear"+i[1]+"; }"}function ma(t){return""!==t}function ga(t,e){return t.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights)}function va(t,e){return t.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}function ya(t){return t.replace(/^[ \t]*#include +<([\w\d.]+)>/gm,function(t,e){var i=mi[e];if(void 0===i)throw new Error("Can not resolve #include <"+e+">");return ya(i)})}function xa(t){return t.replace(/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,function(t,e,i,n){for(var r="",a=parseInt(e);a<parseInt(i);a++)r+=n.replace(/\[ i \]/g,"[ "+a+" ]");return r})}function ba(t,e,i,n,r,a){var o=t.context,s=n.defines,h=r.vertexShader,c=r.fragmentShader,l="SHADOWMAP_TYPE_BASIC";a.shadowMapType===B?l="SHADOWMAP_TYPE_PCF":a.shadowMapType===F&&(l="SHADOWMAP_TYPE_PCF_SOFT");var u="ENVMAP_TYPE_CUBE",d="ENVMAP_MODE_REFLECTION",p="ENVMAP_BLENDING_MULTIPLY";if(a.envMap){switch(n.envMap.mapping){case pt:case ft:u="ENVMAP_TYPE_CUBE";break;case yt:case xt:u="ENVMAP_TYPE_CUBE_UV";break;case mt:case gt:u="ENVMAP_TYPE_EQUIREC";break;case vt:u="ENVMAP_TYPE_SPHERE"}switch(n.envMap.mapping){case ft:case gt:d="ENVMAP_MODE_REFRACTION"}switch(n.combine){case V:p="ENVMAP_BLENDING_MULTIPLY";break;case k:p="ENVMAP_BLENDING_MIX";break;case ht:p="ENVMAP_BLENDING_ADD"}}var f,m,g,v,y,x,b,_,w=0<t.gammaFactor?t.gammaFactor:1,M=(f=n.extensions,m=a,g=e,[(f=f||{}).derivatives||m.envMapCubeUV||m.bumpMap||m.normalMap||m.flatShading?"#extension GL_OES_standard_derivatives : enable":"",(f.fragDepth||m.logarithmicDepthBuffer)&&g.get("EXT_frag_depth")?"#extension GL_EXT_frag_depth : enable":"",f.drawBuffers&&g.get("WEBGL_draw_buffers")?"#extension GL_EXT_draw_buffers : require":"",(f.shaderTextureLOD||m.envMap)&&g.get("EXT_shader_texture_lod")?"#extension GL_EXT_shader_texture_lod : enable":""].filter(ma).join("\n")),E=function(t){var e=[];for(var i in t){var n=t[i];!1!==n&&e.push("#define "+i+" "+n)}return e.join("\n")}(s),T=o.createProgram();n.isRawShaderMaterial?(0<(v=[E].filter(ma).join("\n")).length&&(v+="\n"),0<(y=[M,E].filter(ma).join("\n")).length&&(y+="\n")):(v=["precision "+a.precision+" float;","precision "+a.precision+" int;","#define SHADER_NAME "+r.name,E,a.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define GAMMA_FACTOR "+w,"#define MAX_BONES "+a.maxBones,a.useFog&&a.fog?"#define USE_FOG":"",a.useFog&&a.fogExp?"#define FOG_EXP2":"",a.map?"#define USE_MAP":"",a.envMap?"#define USE_ENVMAP":"",a.envMap?"#define "+d:"",a.lightMap?"#define USE_LIGHTMAP":"",a.aoMap?"#define USE_AOMAP":"",a.emissiveMap?"#define USE_EMISSIVEMAP":"",a.bumpMap?"#define USE_BUMPMAP":"",a.normalMap?"#define USE_NORMALMAP":"",a.displacementMap&&a.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",a.specularMap?"#define USE_SPECULARMAP":"",a.roughnessMap?"#define USE_ROUGHNESSMAP":"",a.metalnessMap?"#define USE_METALNESSMAP":"",a.alphaMap?"#define USE_ALPHAMAP":"",a.vertexColors?"#define USE_COLOR":"",a.flatShading?"#define FLAT_SHADED":"",a.skinning?"#define USE_SKINNING":"",a.useVertexTexture?"#define BONE_TEXTURE":"",a.morphTargets?"#define USE_MORPHTARGETS":"",a.morphNormals&&!1===a.flatShading?"#define USE_MORPHNORMALS":"",a.doubleSided?"#define DOUBLE_SIDED":"",a.flipSided?"#define FLIP_SIDED":"",a.shadowMapEnabled?"#define USE_SHADOWMAP":"",a.shadowMapEnabled?"#define "+l:"",a.sizeAttenuation?"#define USE_SIZEATTENUATION":"",a.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",a.logarithmicDepthBuffer&&e.get("EXT_frag_depth")?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_COLOR","\tattribute vec3 color;","#endif","#ifdef USE_MORPHTARGETS","\tattribute vec3 morphTarget0;","\tattribute vec3 morphTarget1;","\tattribute vec3 morphTarget2;","\tattribute vec3 morphTarget3;","\t#ifdef USE_MORPHNORMALS","\t\tattribute vec3 morphNormal0;","\t\tattribute vec3 morphNormal1;","\t\tattribute vec3 morphNormal2;","\t\tattribute vec3 morphNormal3;","\t#else","\t\tattribute vec3 morphTarget4;","\t\tattribute vec3 morphTarget5;","\t\tattribute vec3 morphTarget6;","\t\tattribute vec3 morphTarget7;","\t#endif","#endif","#ifdef USE_SKINNING","\tattribute vec4 skinIndex;","\tattribute vec4 skinWeight;","#endif","\n"].filter(ma).join("\n"),y=[M,"precision "+a.precision+" float;","precision "+a.precision+" int;","#define SHADER_NAME "+r.name,E,a.alphaTest?"#define ALPHATEST "+a.alphaTest+(a.alphaTest%1?"":".0"):"","#define GAMMA_FACTOR "+w,a.useFog&&a.fog?"#define USE_FOG":"",a.useFog&&a.fogExp?"#define FOG_EXP2":"",a.map?"#define USE_MAP":"",a.envMap?"#define USE_ENVMAP":"",a.envMap?"#define "+u:"",a.envMap?"#define "+d:"",a.envMap?"#define "+p:"",a.lightMap?"#define USE_LIGHTMAP":"",a.aoMap?"#define USE_AOMAP":"",a.emissiveMap?"#define USE_EMISSIVEMAP":"",a.bumpMap?"#define USE_BUMPMAP":"",a.normalMap?"#define USE_NORMALMAP":"",a.specularMap?"#define USE_SPECULARMAP":"",a.roughnessMap?"#define USE_ROUGHNESSMAP":"",a.metalnessMap?"#define USE_METALNESSMAP":"",a.alphaMap?"#define USE_ALPHAMAP":"",a.vertexColors?"#define USE_COLOR":"",a.gradientMap?"#define USE_GRADIENTMAP":"",a.flatShading?"#define FLAT_SHADED":"",a.doubleSided?"#define DOUBLE_SIDED":"",a.flipSided?"#define FLIP_SIDED":"",a.shadowMapEnabled?"#define USE_SHADOWMAP":"",a.shadowMapEnabled?"#define "+l:"",a.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",a.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",a.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",a.logarithmicDepthBuffer&&e.get("EXT_frag_depth")?"#define USE_LOGDEPTHBUF_EXT":"",a.envMap&&e.get("EXT_shader_texture_lod")?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;",a.toneMapping!==ct?"#define TONE_MAPPING":"",a.toneMapping!==ct?mi.tonemapping_pars_fragment:"",a.toneMapping!==ct?function(t,e){var i;switch(e){case Rt:i="Linear";break;case lt:i="Reinhard";break;case ut:i="Uncharted2";break;case dt:i="OptimizedCineon";break;default:throw new Error("unsupported toneMapping: "+e)}return"vec3 "+t+"( vec3 color ) { return "+i+"ToneMapping( color ); }"}("toneMapping",a.toneMapping):"",a.dithering?"#define DITHERING":"",a.outputEncoding||a.mapEncoding||a.envMapEncoding||a.emissiveMapEncoding?mi.encodings_pars_fragment:"",a.mapEncoding?fa("mapTexelToLinear",a.mapEncoding):"",a.envMapEncoding?fa("envMapTexelToLinear",a.envMapEncoding):"",a.emissiveMapEncoding?fa("emissiveMapTexelToLinear",a.emissiveMapEncoding):"",a.outputEncoding?(x="linearToOutputTexel",b=a.outputEncoding,_=pa(b),"vec4 "+x+"( vec4 value ) { return LinearTo"+_[0]+_[1]+"; }"):"",a.depthPacking?"#define DEPTH_PACKING "+n.depthPacking:"","\n"].filter(ma).join("\n")),h=va(h=ga(h=ya(h),a),a),c=va(c=ga(c=ya(c),a),a);var S=v+(h=xa(h)),A=y+(c=xa(c)),L=ua(o,o.VERTEX_SHADER,S),R=ua(o,o.FRAGMENT_SHADER,A);o.attachShader(T,L),o.attachShader(T,R),void 0!==n.index0AttributeName?o.bindAttribLocation(T,0,n.index0AttributeName):!0===a.morphTargets&&o.bindAttribLocation(T,0,"position"),o.linkProgram(T);var C,P,O=o.getProgramInfoLog(T).trim(),I=o.getShaderInfoLog(L).trim(),N=o.getShaderInfoLog(R).trim(),U=!0,D=!0;return!1===o.getProgramParameter(T,o.LINK_STATUS)?(U=!1,console.error("THREE.WebGLProgram: shader error: ",o.getError(),"gl.VALIDATE_STATUS",o.getProgramParameter(T,o.VALIDATE_STATUS),"gl.getProgramInfoLog",O,I,N)):""!==O?console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()",O):""!==I&&""!==N||(D=!1),D&&(this.diagnostics={runnable:U,material:n,programLog:O,vertexShader:{log:I,prefix:v},fragmentShader:{log:N,prefix:y}}),o.deleteShader(L),o.deleteShader(R),this.getUniforms=function(){return void 0===C&&(C=new la(o,T,t)),C},this.getAttributes=function(){return void 0===P&&(P=function(t,e){for(var i={},n=t.getProgramParameter(e,t.ACTIVE_ATTRIBUTES),r=0;r<n;r++){var a=t.getActiveAttrib(e,r).name;i[a]=t.getAttribLocation(e,a)}return i}(o,T)),P},this.destroy=function(){o.deleteProgram(T),this.program=void 0},Object.defineProperties(this,{uniforms:{get:function(){return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."),this.getUniforms()}},attributes:{get:function(){return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."),this.getAttributes()}}}),this.name=r.name,this.id=da++,this.code=i,this.usedTimes=1,this.program=T,this.vertexShader=L,this.fragmentShader=R,this}function _a(u,h,d){var c=[],p={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"phong",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow"},a=["precision","supportsVertexTextures","map","mapEncoding","envMap","envMapMode","envMapEncoding","lightMap","aoMap","emissiveMap","emissiveMapEncoding","bumpMap","normalMap","displacementMap","specularMap","roughnessMap","metalnessMap","gradientMap","alphaMap","combine","vertexColors","fog","useFog","fogExp","flatShading","sizeAttenuation","logarithmicDepthBuffer","skinning","maxBones","useVertexTexture","morphTargets","morphNormals","maxMorphTargets","maxMorphNormals","premultipliedAlpha","numDirLights","numPointLights","numSpotLights","numHemiLights","numRectAreaLights","shadowMapEnabled","shadowMapType","toneMapping","physicallyCorrectLights","alphaTest","doubleSided","flipSided","numClippingPlanes","numClipIntersection","depthPacking","dithering"];function f(t,e){var i;return t?t.isTexture?i=t.encoding:t.isWebGLRenderTarget&&(console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),i=t.texture.encoding):i=Ae,i===Ae&&e&&(i=Re),i}this.getParameters=function(t,e,i,n,r,a,o){var s=p[t.type],h=o.isSkinnedMesh?function(t){var e=t.skeleton.bones;if(d.floatVertexTextures)return 1024;var i=d.maxVertexUniforms,n=Math.floor((i-20)/4),r=Math.min(n,e.length);return r<e.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+e.length+" bones. This GPU supports "+r+"."),0):r}(o):0,c=d.precision;null!==t.precision&&(c=d.getMaxPrecision(t.precision))!==t.precision&&console.warn("THREE.WebGLProgram.getParameters:",t.precision,"not supported, using",c,"instead.");var l=u.getRenderTarget();return{shaderID:s,precision:c,supportsVertexTextures:d.vertexTextures,outputEncoding:f(l?l.texture:null,u.gammaOutput),map:!!t.map,mapEncoding:f(t.map,u.gammaInput),envMap:!!t.envMap,envMapMode:t.envMap&&t.envMap.mapping,envMapEncoding:f(t.envMap,u.gammaInput),envMapCubeUV:!!t.envMap&&(t.envMap.mapping===yt||t.envMap.mapping===xt),lightMap:!!t.lightMap,aoMap:!!t.aoMap,emissiveMap:!!t.emissiveMap,emissiveMapEncoding:f(t.emissiveMap,u.gammaInput),bumpMap:!!t.bumpMap,normalMap:!!t.normalMap,displacementMap:!!t.displacementMap,roughnessMap:!!t.roughnessMap,metalnessMap:!!t.metalnessMap,specularMap:!!t.specularMap,alphaMap:!!t.alphaMap,gradientMap:!!t.gradientMap,combine:t.combine,vertexColors:t.vertexColors,fog:!!n,useFog:t.fog,fogExp:n&&n.isFogExp2,flatShading:t.flatShading,sizeAttenuation:t.sizeAttenuation,logarithmicDepthBuffer:d.logarithmicDepthBuffer,skinning:t.skinning&&0<h,maxBones:h,useVertexTexture:d.floatVertexTextures,morphTargets:t.morphTargets,morphNormals:t.morphNormals,maxMorphTargets:u.maxMorphTargets,maxMorphNormals:u.maxMorphNormals,numDirLights:e.directional.length,numPointLights:e.point.length,numSpotLights:e.spot.length,numRectAreaLights:e.rectArea.length,numHemiLights:e.hemi.length,numClippingPlanes:r,numClipIntersection:a,dithering:t.dithering,shadowMapEnabled:u.shadowMap.enabled&&o.receiveShadow&&0<i.length,shadowMapType:u.shadowMap.type,toneMapping:u.toneMapping,physicallyCorrectLights:u.physicallyCorrectLights,premultipliedAlpha:t.premultipliedAlpha,alphaTest:t.alphaTest,doubleSided:t.side===Z,flipSided:t.side===At,depthPacking:void 0!==t.depthPacking&&t.depthPacking}},this.getProgramCode=function(t,e){var i=[];if(e.shaderID?i.push(e.shaderID):(i.push(t.fragmentShader),i.push(t.vertexShader)),void 0!==t.defines)for(var n in t.defines)i.push(n),i.push(t.defines[n]);for(var r=0;r<a.length;r++)i.push(e[a[r]]);return i.push(t.onBeforeCompile.toString()),i.push(u.gammaOutput),i.join()},this.acquireProgram=function(t,e,i,n){for(var r,a=0,o=c.length;a<o;a++){var s=c[a];if(s.code===n){++(r=s).usedTimes;break}}return void 0===r&&(r=new ba(u,h,n,t,e,i),c.push(r)),r},this.releaseProgram=function(t){if(0==--t.usedTimes){var e=c.indexOf(t);c[e]=c[c.length-1],c.pop(),t.destroy()}},this.programs=c}function wa(){var n=new WeakMap;return{get:function(t){var e=n.get(t);return void 0===e&&(e={},n.set(t,e)),e},remove:function(t){n.delete(t)},update:function(t,e,i){n.get(t)[e]=i},dispose:function(){n=new WeakMap}}}function Ma(t,e){return t.renderOrder!==e.renderOrder?t.renderOrder-e.renderOrder:t.program&&e.program&&t.program!==e.program?t.program.id-e.program.id:t.material.id!==e.material.id?t.material.id-e.material.id:t.z!==e.z?t.z-e.z:t.id-e.id}function Ea(t,e){return t.renderOrder!==e.renderOrder?t.renderOrder-e.renderOrder:t.z!==e.z?e.z-t.z:t.id-e.id}function Ta(){var o=[],s=0,h=[],c=[];return{opaque:h,transparent:c,init:function(){s=0,h.length=0,c.length=0},push:function(t,e,i,n,r){var a=o[s];void 0===a?(a={id:t.id,object:t,geometry:e,material:i,program:i.program,renderOrder:t.renderOrder,z:n,group:r},o[s]=a):(a.id=t.id,a.object=t,a.geometry=e,a.material=i,a.program=i.program,a.renderOrder=t.renderOrder,a.z=n,a.group=r),t.addedObject?t.addedObject.mesh.material.uniforms.forcedColor&&-50==t.addedObject.mesh.material.uniforms.forcedColor.value.x?1==t.addedObject.mesh.material.uniforms.alpha.value?(h.push(a),t.addedObject.listedAsOpaque=!0):(c.push(a),t.addedObject.listedAsOpaque=!1):t.addedObject.mesh.material.uniforms.forcedColor&&1==t.addedObject.mesh.material.uniforms.forcedColor.value.x?(h.push(a),t.addedObject.listedAsOpaque=!0):(c.push(a),t.addedObject.listedAsOpaque=!1):(!0===i.transparent?c:h).push(a),s++},sort:function(){1<h.length&&h.sort(Ma),1<c.length&&c.sort(Ea)}}}function Sa(){var r={};return{get:function(t,e){var i,n=r[t.id];return void 0===n?(i=new Ta,r[t.id]={},r[t.id][e.id]=i):(i=n[e.id])||(i=new Ta,n[e.id]=i),i},dispose:function(){r={}}}}function Aa(){var i={};return{get:function(t){if(void 0!==i[t.id])return i[t.id];var e;switch(t.type){case"DirectionalLight":e={direction:new Ge,color:new yi,shadow:!1,shadowBias:0,shadowRadius:1,shadowMapSize:new Be};break;case"SpotLight":e={position:new Ge,direction:new Ge,color:new yi,distance:0,coneCos:0,penumbraCos:0,decay:0,shadow:!1,shadowBias:0,shadowRadius:1,shadowMapSize:new Be};break;case"PointLight":e={position:new Ge,color:new yi,distance:0,decay:0,shadow:!1,shadowBias:0,shadowRadius:1,shadowMapSize:new Be,shadowCameraNear:1,shadowCameraFar:1e3};break;case"HemisphereLight":e={direction:new Ge,skyColor:new yi,groundColor:new yi};break;case"RectAreaLight":e={color:new yi,position:new Ge,halfWidth:new Ge,halfHeight:new Ge}}return i[t.id]=e}}}var La,Ra,Ca,Pa,Oa,Ia,Na,Ua,Da,Ba,Fa,za,Ga,Ha,Va,ka,ja,Wa,Xa=0;function qa(){var _=new Aa,w={id:Xa++,hash:{stateID:-1,directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,shadowsLength:-1},ambient:[0,0,0],directional:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],point:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]},M=new Ge,E=new Fe,T=new Fe;return{setup:function(t,e,i){for(var n=0,r=0,a=0,o=0,s=0,h=0,c=0,l=0,u=i.matrixWorldInverse,d=0,p=t.length;d<p;d++){var f=t[d],m=f.color,g=f.intensity,v=f.distance,y=f.shadow&&f.shadow.map?f.shadow.map.texture:null;if(f.isAmbientLight)n+=m.r*g,r+=m.g*g,a+=m.b*g;else if(f.isDirectionalLight){if((b=_.get(f)).color.copy(f.color).multiplyScalar(f.intensity),b.direction.setFromMatrixPosition(f.matrixWorld),M.setFromMatrixPosition(f.target.matrixWorld),b.direction.sub(M),b.direction.transformDirection(u),b.shadow=f.castShadow,f.castShadow){var x=f.shadow;b.shadowBias=x.bias,b.shadowRadius=x.radius,b.shadowMapSize=x.mapSize}w.directionalShadowMap[o]=y,w.directionalShadowMatrix[o]=f.shadow.matrix,w.directional[o]=b,o++}else if(f.isSpotLight)(b=_.get(f)).position.setFromMatrixPosition(f.matrixWorld),b.position.applyMatrix4(u),b.color.copy(m).multiplyScalar(g),b.distance=v,b.direction.setFromMatrixPosition(f.matrixWorld),M.setFromMatrixPosition(f.target.matrixWorld),b.direction.sub(M),b.direction.transformDirection(u),b.coneCos=Math.cos(f.angle),b.penumbraCos=Math.cos(f.angle*(1-f.penumbra)),b.decay=0===f.distance?0:f.decay,b.shadow=f.castShadow,f.castShadow&&(x=f.shadow,b.shadowBias=x.bias,b.shadowRadius=x.radius,b.shadowMapSize=x.mapSize),w.spotShadowMap[h]=y,w.spotShadowMatrix[h]=f.shadow.matrix,w.spot[h]=b,h++;else if(f.isRectAreaLight)(b=_.get(f)).color.copy(m).multiplyScalar(g),b.position.setFromMatrixPosition(f.matrixWorld),b.position.applyMatrix4(u),T.identity(),E.copy(f.matrixWorld),E.premultiply(u),T.extractRotation(E),b.halfWidth.set(.5*f.width,0,0),b.halfHeight.set(0,.5*f.height,0),b.halfWidth.applyMatrix4(T),b.halfHeight.applyMatrix4(T),w.rectArea[c]=b,c++;else if(f.isPointLight)(b=_.get(f)).position.setFromMatrixPosition(f.matrixWorld),b.position.applyMatrix4(u),b.color.copy(f.color).multiplyScalar(f.intensity),b.distance=f.distance,b.decay=0===f.distance?0:f.decay,b.shadow=f.castShadow,f.castShadow&&(x=f.shadow,b.shadowBias=x.bias,b.shadowRadius=x.radius,b.shadowMapSize=x.mapSize,b.shadowCameraNear=x.camera.near,b.shadowCameraFar=x.camera.far),w.pointShadowMap[s]=y,w.pointShadowMatrix[s]=f.shadow.matrix,w.point[s]=b,s++;else if(f.isHemisphereLight){var b;(b=_.get(f)).direction.setFromMatrixPosition(f.matrixWorld),b.direction.transformDirection(u),b.direction.normalize(),b.skyColor.copy(f.color).multiplyScalar(g),b.groundColor.copy(f.groundColor).multiplyScalar(g),w.hemi[l]=b,l++}}w.ambient[0]=n,w.ambient[1]=r,w.ambient[2]=a,w.directional.length=o,w.spot.length=h,w.rectArea.length=c,w.point.length=s,w.hemi.length=l,w.hash.stateID=w.id,w.hash.directionalLength=o,w.hash.pointLength=s,w.hash.spotLength=h,w.hash.rectAreaLength=c,w.hash.hemiLength=l,w.hash.shadowsLength=e.length},state:w}}function Ya(){var e=new qa,i=[],n=[],r=[];return{init:function(){i.length=0,n.length=0,r.length=0},state:{lightsArray:i,shadowsArray:n,spritesArray:r,lights:e},setupLights:function(t){e.setup(i,n,t)},pushLight:function(t){i.push(t)},pushShadow:function(t){n.push(t)},pushSprite:function(t){r.push(t)}}}function Za(){var n={};return{get:function(t,e){var i;return void 0===n[t.id]?(i=new Ya,n[t.id]={},n[t.id][e.id]=i):void 0===n[t.id][e.id]?(i=new Ya,n[t.id][e.id]=i):i=n[t.id][e.id],i},dispose:function(){n={}}}}function Ja(t){rr.call(this),this.type="MeshDepthMaterial",this.depthPacking=Ne,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.setValues(t)}function Qa(t){rr.call(this),this.type="MeshDistanceMaterial",this.referencePosition=new Ge,this.nearDistance=1,this.farDistance=1e3,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.fog=!1,this.lights=!1,this.setValues(t)}function Ka(x,m,t){for(var b=new pi,_=new Fe,w=new Be,M=new Be(t,t),E=new Ge,T=new Ge,v=1,y=2,e=1+(v|y),S=new Array(e),A=new Array(e),L={},R={0:At,1:U,2:Z},C=[new Ge(1,0,0),new Ge(-1,0,0),new Ge(0,0,1),new Ge(0,0,-1),new Ge(0,1,0),new Ge(0,-1,0)],P=[new Ge(0,1,0),new Ge(0,1,0),new Ge(0,1,0),new Ge(0,1,0),new Ge(0,0,1),new Ge(0,0,-1)],O=[new oi,new oi,new oi,new oi,new oi,new oi],i=0;i!==e;++i){var n=0!=(i&v),r=0!=(i&y),a=new Ja({depthPacking:Ue,morphTargets:n,skinning:r});S[i]=a;var o=new Qa({morphTargets:n,skinning:r});A[i]=o}var I=this;function g(t,e,i,n,r,a){var o=t.geometry,s=null,h=S,c=t.customDepthMaterial;if(i&&(h=A,c=t.customDistanceMaterial),c)s=c;else{var l=!1;e.morphTargets&&(o&&o.isBufferGeometry?l=o.morphAttributes&&o.morphAttributes.position&&0<o.morphAttributes.position.length:o&&o.isGeometry&&(l=o.morphTargets&&0<o.morphTargets.length)),t.isSkinnedMesh&&!1===e.skinning&&console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",t);var u=t.isSkinnedMesh&&e.skinning,d=0;l&&(d|=v),u&&(d|=y),s=h[d]}if(x.localClippingEnabled&&!0===e.clipShadows&&0!==e.clippingPlanes.length){var p=s.uuid,f=e.uuid,m=L[p];void 0===m&&(m={},L[p]=m);var g=m[f];void 0===g&&(g=s.clone(),m[f]=g),s=g}return s.visible=e.visible,s.wireframe=e.wireframe,s.side=null!=e.shadowSide?e.shadowSide:R[e.side],s.clipShadows=e.clipShadows,s.clippingPlanes=e.clippingPlanes,s.clipIntersection=e.clipIntersection,s.wireframeLinewidth=e.wireframeLinewidth,s.linewidth=e.linewidth,i&&s.isMeshDistanceMaterial&&(s.referencePosition.copy(n),s.nearDistance=r,s.farDistance=a),s}function N(t,e,i,n){if(!1!==t.visible){if(t.layers.test(e.layers)&&(t.isMesh||t.isLine||t.isPoints)&&t.castShadow&&(!t.frustumCulled||b.intersectsObject(t))){t.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse,t.matrixWorld);var r=m.update(t),a=t.material;if(Array.isArray(a))for(var o=r.groups,s=0,h=o.length;s<h;s++){var c=o[s],l=a[c.materialIndex];if(l&&l.visible){var u=g(t,l,n,T,i.near,i.far);x.renderBufferDirect(i,null,r,u,t,c)}}else if(a.visible){u=g(t,a,n,T,i.near,i.far);x.renderBufferDirect(i,null,r,u,t,null)}}for(var d=t.children,p=0,f=d.length;p<f;p++)N(d[p],e,i,n)}}this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=B,this.render=function(t,e,i){if(!1!==I.enabled&&(!1!==I.autoUpdate||!1!==I.needsUpdate)&&0!==t.length){var n,r=x.context,a=x.state;a.disable(r.BLEND),a.buffers.color.setClear(1,1,1,1),a.buffers.depth.setTest(!0),a.setScissorTest(!1);for(var o=0,s=t.length;o<s;o++){var h=t[o],c=h.shadow,l=h&&h.isPointLight;if(void 0!==c){var u=c.camera;if(w.copy(c.mapSize),w.min(M),l){var d=w.x,p=w.y;O[0].set(2*d,p,d,p),O[1].set(0,p,d,p),O[2].set(3*d,p,d,p),O[3].set(d,p,d,p),O[4].set(3*d,0,d,p),O[5].set(d,0,d,p),w.x*=4,w.y*=2}if(null===c.map){var f={minFilter:Mt,magFilter:Mt,format:Xt};c.map=new si(w.x,w.y,f),c.map.texture.name=h.name+".shadowMap",u.updateProjectionMatrix()}c.isSpotLightShadow&&c.update(h);var m=c.map,g=c.matrix;T.setFromMatrixPosition(h.matrixWorld),u.position.copy(T),l?(n=6,g.makeTranslation(-T.x,-T.y,-T.z)):(n=1,E.setFromMatrixPosition(h.target.matrixWorld),u.lookAt(E),u.updateMatrixWorld(),g.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),g.multiply(u.projectionMatrix),g.multiply(u.matrixWorldInverse)),x.setRenderTarget(m),x.clear();for(var v=0;v<n;v++){if(l){E.copy(u.position),E.add(C[v]),u.up.copy(P[v]),u.lookAt(E),u.updateMatrixWorld();var y=O[v];a.viewport(y)}_.multiplyMatrices(u.projectionMatrix,u.matrixWorldInverse),b.setFromMatrix(_),N(e,i,u,l)}}else console.warn("THREE.WebGLShadowMap:",h,"has no shadow.")}I.needsUpdate=!1}}}function $a(t,e,i,n,r,a,o,s,h){ai.call(this,t,e,i,n,r,a,o,s,h),this.needsUpdate=!0}function to(p,f,m,g,s){var v,y,x,b,_,w,M=new Ge,E=new ze,T=new Ge;function S(){var t,e,i,n=new Float32Array([-.5,-.5,0,0,.5,-.5,1,0,.5,.5,1,1,-.5,.5,0,1]),r=new Uint16Array([0,1,2,0,2,3]);v=f.createBuffer(),y=f.createBuffer(),f.bindBuffer(f.ARRAY_BUFFER,v),f.bufferData(f.ARRAY_BUFFER,n,f.STATIC_DRAW),f.bindBuffer(f.ELEMENT_ARRAY_BUFFER,y),f.bufferData(f.ELEMENT_ARRAY_BUFFER,r,f.STATIC_DRAW),t=f.createProgram(),e=f.createShader(f.VERTEX_SHADER),i=f.createShader(f.FRAGMENT_SHADER),f.shaderSource(e,["precision "+s.precision+" float;","#define SHADER_NAME SpriteMaterial","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform float rotation;","uniform vec2 center;","uniform vec2 scale;","uniform vec2 uvOffset;","uniform vec2 uvScale;","attribute vec2 position;","attribute vec2 uv;","varying vec2 vUV;","varying float fogDepth;","void main() {","\tvUV = uvOffset + uv * uvScale;","\tvec2 alignedPosition = ( position - center ) * scale;","\tvec2 rotatedPosition;","\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;","\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;","\tvec4 mvPosition;","\tmvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );","\tmvPosition.xy += rotatedPosition;","\tgl_Position = projectionMatrix * mvPosition;","\tfogDepth = - mvPosition.z;","}"].join("\n")),f.shaderSource(i,["precision "+s.precision+" float;","#define SHADER_NAME SpriteMaterial","uniform vec3 color;","uniform sampler2D map;","uniform float opacity;","uniform int fogType;","uniform vec3 fogColor;","uniform float fogDensity;","uniform float fogNear;","uniform float fogFar;","uniform float alphaTest;","varying vec2 vUV;","varying float fogDepth;","void main() {","\tvec4 texture = texture2D( map, vUV );","\tgl_FragColor = vec4( color * texture.xyz, texture.a * opacity );","\tif ( gl_FragColor.a < alphaTest ) discard;","\tif ( fogType > 0 ) {","\t\tfloat fogFactor = 0.0;","\t\tif ( fogType == 1 ) {","\t\t\tfogFactor = smoothstep( fogNear, fogFar, fogDepth );","\t\t} else {","\t\t\tconst float LOG2 = 1.442695;","\t\t\tfogFactor = exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 );","\t\t\tfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );","\t\t}","\t\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );","\t}","}"].join("\n")),f.compileShader(e),f.compileShader(i),f.attachShader(t,e),f.attachShader(t,i),f.linkProgram(t),x=t,b={position:f.getAttribLocation(x,"position"),uv:f.getAttribLocation(x,"uv")},_={uvOffset:f.getUniformLocation(x,"uvOffset"),uvScale:f.getUniformLocation(x,"uvScale"),rotation:f.getUniformLocation(x,"rotation"),center:f.getUniformLocation(x,"center"),scale:f.getUniformLocation(x,"scale"),color:f.getUniformLocation(x,"color"),map:f.getUniformLocation(x,"map"),opacity:f.getUniformLocation(x,"opacity"),modelViewMatrix:f.getUniformLocation(x,"modelViewMatrix"),projectionMatrix:f.getUniformLocation(x,"projectionMatrix"),fogType:f.getUniformLocation(x,"fogType"),fogDensity:f.getUniformLocation(x,"fogDensity"),fogNear:f.getUniformLocation(x,"fogNear"),fogFar:f.getUniformLocation(x,"fogFar"),fogColor:f.getUniformLocation(x,"fogColor"),fogDepth:f.getUniformLocation(x,"fogDepth"),alphaTest:f.getUniformLocation(x,"alphaTest")};var a=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");a.width=8,a.height=8;var o=a.getContext("2d");o.fillStyle="white",o.fillRect(0,0,8,8),w=new $a(a)}function A(t,e){return t.renderOrder!==e.renderOrder?t.renderOrder-e.renderOrder:t.z!==e.z?e.z-t.z:e.id-t.id}this.render=function(t,e,i){if(0!==t.length){void 0===x&&S(),m.useProgram(x),m.initAttributes(),m.enableAttribute(b.position),m.enableAttribute(b.uv),m.disableUnusedAttributes(),m.disable(f.CULL_FACE),m.enable(f.BLEND),f.bindBuffer(f.ARRAY_BUFFER,v),f.vertexAttribPointer(b.position,2,f.FLOAT,!1,16,0),f.vertexAttribPointer(b.uv,2,f.FLOAT,!1,16,8),f.bindBuffer(f.ELEMENT_ARRAY_BUFFER,y),f.uniformMatrix4fv(_.projectionMatrix,!1,i.projectionMatrix.elements),m.activeTexture(f.TEXTURE0),f.uniform1i(_.map,0);var n=0,r=0,a=e.fog;a?(f.uniform3f(_.fogColor,a.color.r,a.color.g,a.color.b),a.isFog?(f.uniform1f(_.fogNear,a.near),f.uniform1f(_.fogFar,a.far),f.uniform1i(_.fogType,1),r=n=1):a.isFogExp2&&(f.uniform1f(_.fogDensity,a.density),f.uniform1i(_.fogType,2),r=n=2)):(f.uniform1i(_.fogType,0),r=n=0);for(var o=0,s=t.length;o<s;o++){(l=t[o]).modelViewMatrix.multiplyMatrices(i.matrixWorldInverse,l.matrixWorld),l.z=-l.modelViewMatrix.elements[14]}t.sort(A);var h=[],c=[];for(o=0,s=t.length;o<s;o++){var l,u=(l=t[o]).material;if(!1!==u.visible){l.onBeforeRender(p,e,i,void 0,u,void 0),f.uniform1f(_.alphaTest,u.alphaTest),f.uniformMatrix4fv(_.modelViewMatrix,!1,l.modelViewMatrix.elements),l.matrixWorld.decompose(M,E,T),h[0]=T.x,h[1]=T.y,c[0]=l.center.x-.5,c[1]=l.center.y-.5;var d=0;e.fog&&u.fog&&(d=r),n!==d&&(f.uniform1i(_.fogType,d),n=d),null!==u.map?(f.uniform2f(_.uvOffset,u.map.offset.x,u.map.offset.y),f.uniform2f(_.uvScale,u.map.repeat.x,u.map.repeat.y)):(f.uniform2f(_.uvOffset,0,0),f.uniform2f(_.uvScale,1,1)),f.uniform1f(_.opacity,u.opacity),f.uniform3f(_.color,u.color.r,u.color.g,u.color.b),f.uniform1f(_.rotation,u.rotation),f.uniform2fv(_.center,c),f.uniform2fv(_.scale,h),m.setBlending(u.blending,u.blendEquation,u.blendSrc,u.blendDst,u.blendEquationAlpha,u.blendSrcAlpha,u.blendDstAlpha,u.premultipliedAlpha),m.buffers.depth.setTest(u.depthTest),m.buffers.depth.setMask(u.depthWrite),m.buffers.color.setMask(u.colorWrite),g.setTexture2D(u.map||w,0),f.drawElements(f.TRIANGLES,6,f.UNSIGNED_SHORT,0),l.onAfterRender(p,e,i,void 0,u,void 0)}}m.enable(f.CULL_FACE),m.reset()}}}function eo(l,i,h){var n=new function(){var e=!1,a=new oi,i=null,o=new oi(0,0,0,0);return{setMask:function(t){i===t||e||(l.colorMask(t,t,t,t),i=t)},setLocked:function(t){e=t},setClear:function(t,e,i,n,r){!0===r&&(t*=n,e*=n,i*=n),a.set(t,e,i,n),!1===o.equals(a)&&(l.clearColor(t,e,i,n),o.copy(a))},reset:function(){e=!1,i=null,o.set(-1,0,0,0)}}},r=new function(){var e=!1,i=null,n=null,r=null;return{setTest:function(t){t?B(l.DEPTH_TEST):F(l.DEPTH_TEST)},setMask:function(t){i===t||e||(l.depthMask(t),i=t)},setFunc:function(t){if(n!==t){if(t)switch(t){case tt:l.depthFunc(l.NEVER);break;case et:l.depthFunc(l.ALWAYS);break;case it:l.depthFunc(l.LESS);break;case nt:l.depthFunc(l.LEQUAL);break;case rt:l.depthFunc(l.EQUAL);break;case at:l.depthFunc(l.GEQUAL);break;case ot:l.depthFunc(l.GREATER);break;case st:l.depthFunc(l.NOTEQUAL);break;default:l.depthFunc(l.LEQUAL)}else l.depthFunc(l.LEQUAL);n=t}},setLocked:function(t){e=t},setClear:function(t){r!==t&&(l.clearDepth(t),r=t)},reset:function(){e=!1,r=n=i=null}}},e=new function(){var e=!1,i=null,n=null,r=null,a=null,o=null,s=null,h=null,c=null;return{setTest:function(t){t?B(l.STENCIL_TEST):F(l.STENCIL_TEST)},setMask:function(t){i===t||e||(l.stencilMask(t),i=t)},setFunc:function(t,e,i){n===t&&r===e&&a===i||(l.stencilFunc(t,e,i),n=t,r=e,a=i)},setOp:function(t,e,i){o===t&&s===e&&h===i||(l.stencilOp(t,e,i),o=t,s=e,h=i)},setLocked:function(t){e=t},setClear:function(t){c!==t&&(l.clearStencil(t),c=t)},reset:function(){e=!1,c=h=s=o=a=r=n=i=null}}},t=l.getParameter(l.MAX_VERTEX_ATTRIBS),a=new Uint8Array(t),o=new Uint8Array(t),s=new Uint8Array(t),c={},u=null,d=null,p=null,f=null,m=null,g=null,v=null,y=null,x=null,b=!1,_=null,w=null,M=null,E=null,T=null,S=l.getParameter(l.MAX_COMBINED_TEXTURE_IMAGE_UNITS),A=!1,L=0,R=l.getParameter(l.VERSION);-1!==R.indexOf("WebGL")?(L=parseFloat(/^WebGL\ ([0-9])/.exec(R)[1]),A=1<=L):-1!==R.indexOf("OpenGL ES")&&(L=parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(R)[1]),A=2<=L);var C=null,P={},O=new oi,I=new oi;function N(t,e,i){var n=new Uint8Array(4),r=l.createTexture();l.bindTexture(t,r),l.texParameteri(t,l.TEXTURE_MIN_FILTER,l.NEAREST),l.texParameteri(t,l.TEXTURE_MAG_FILTER,l.NEAREST);for(var a=0;a<i;a++)l.texImage2D(e+a,0,l.RGBA,1,1,0,l.RGBA,l.UNSIGNED_BYTE,n);return r}var U={};function D(t,e){(a[t]=1,0===o[t]&&(l.enableVertexAttribArray(t),o[t]=1),s[t]!==e)&&(i.get("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(t,e),s[t]=e)}function B(t){!0!==c[t]&&(l.enable(t),c[t]=!0)}function F(t){!1!==c[t]&&(l.disable(t),c[t]=!1)}function z(t,e,i,n,r,a,o,s){if(t!==q){if(B(l.BLEND),t!==$){if(t!==p||s!==b)switch(t){case J:s?(l.blendEquationSeparate(l.FUNC_ADD,l.FUNC_ADD),l.blendFuncSeparate(l.ONE,l.ONE,l.ONE,l.ONE)):(l.blendEquation(l.FUNC_ADD),l.blendFunc(l.SRC_ALPHA,l.ONE));break;case Q:s?(l.blendEquationSeparate(l.FUNC_ADD,l.FUNC_ADD),l.blendFuncSeparate(l.ZERO,l.ZERO,l.ONE_MINUS_SRC_COLOR,l.ONE_MINUS_SRC_ALPHA)):(l.blendEquation(l.FUNC_ADD),l.blendFunc(l.ZERO,l.ONE_MINUS_SRC_COLOR));break;case K:s?(l.blendEquationSeparate(l.FUNC_ADD,l.FUNC_ADD),l.blendFuncSeparate(l.ZERO,l.SRC_COLOR,l.ZERO,l.SRC_ALPHA)):(l.blendEquation(l.FUNC_ADD),l.blendFunc(l.ZERO,l.SRC_COLOR));break;default:s?(l.blendEquationSeparate(l.FUNC_ADD,l.FUNC_ADD),l.blendFuncSeparate(l.ONE,l.ONE_MINUS_SRC_ALPHA,l.ONE,l.ONE_MINUS_SRC_ALPHA)):(l.blendEquationSeparate(l.FUNC_ADD,l.FUNC_ADD),l.blendFuncSeparate(l.SRC_ALPHA,l.ONE_MINUS_SRC_ALPHA,l.ONE,l.ONE_MINUS_SRC_ALPHA))}x=y=v=g=m=f=null}else r=r||e,a=a||i,o=o||n,e===f&&r===v||(l.blendEquationSeparate(h.convert(e),h.convert(r)),f=e,v=r),i===m&&n===g&&a===y&&o===x||(l.blendFuncSeparate(h.convert(i),h.convert(n),h.convert(a),h.convert(o)),m=i,g=n,y=a,x=o);p=t,b=s}else F(l.BLEND)}function G(t){_!==t&&(t?l.frontFace(l.CW):l.frontFace(l.CCW),_=t)}function H(t){t!==j?(B(l.CULL_FACE),t!==w&&(t===W?l.cullFace(l.BACK):t===X?l.cullFace(l.FRONT):l.cullFace(l.FRONT_AND_BACK))):F(l.CULL_FACE),w=t}function V(t,e,i){t?(B(l.POLYGON_OFFSET_FILL),E===e&&T===i||(l.polygonOffset(e,i),E=e,T=i)):F(l.POLYGON_OFFSET_FILL)}function k(t){void 0===t&&(t=l.TEXTURE0+S-1),C!==t&&(l.activeTexture(t),C=t)}return U[l.TEXTURE_2D]=N(l.TEXTURE_2D,l.TEXTURE_2D,1),U[l.TEXTURE_CUBE_MAP]=N(l.TEXTURE_CUBE_MAP,l.TEXTURE_CUBE_MAP_POSITIVE_X,6),n.setClear(0,0,0,1),r.setClear(1),e.setClear(0),B(l.DEPTH_TEST),r.setFunc(nt),G(!1),H(W),B(l.CULL_FACE),B(l.BLEND),z(Y),{buffers:{color:n,depth:r,stencil:e},initAttributes:function(){for(var t=0,e=a.length;t<e;t++)a[t]=0},enableAttribute:function(t){D(t,0)},enableAttributeAndDivisor:D,disableUnusedAttributes:function(){for(var t=0,e=o.length;t!==e;++t)o[t]!==a[t]&&(l.disableVertexAttribArray(t),o[t]=0)},enable:B,disable:F,getCompressedTextureFormats:function(){if(null===u&&(u=[],i.get("WEBGL_compressed_texture_pvrtc")||i.get("WEBGL_compressed_texture_s3tc")||i.get("WEBGL_compressed_texture_etc1")||i.get("WEBGL_compressed_texture_astc")))for(var t=l.getParameter(l.COMPRESSED_TEXTURE_FORMATS),e=0;e<t.length;e++)u.push(t[e]);return u},useProgram:function(t){return d!==t&&(l.useProgram(t),d=t,!0)},setBlending:z,setMaterial:function(t,e){t.side===Z?F(l.CULL_FACE):B(l.CULL_FACE);var i=t.side===At;e&&(i=!i),G(i),!0===t.transparent?z(t.blending,t.blendEquation,t.blendSrc,t.blendDst,t.blendEquationAlpha,t.blendSrcAlpha,t.blendDstAlpha,t.premultipliedAlpha):z(q),r.setFunc(t.depthFunc),r.setTest(t.depthTest),r.setMask(t.depthWrite),n.setMask(t.colorWrite),V(t.polygonOffset,t.polygonOffsetFactor,t.polygonOffsetUnits)},setFlipSided:G,setCullFace:H,setLineWidth:function(t){t!==M&&(A&&l.lineWidth(t),M=t)},setPolygonOffset:V,setScissorTest:function(t){t?B(l.SCISSOR_TEST):F(l.SCISSOR_TEST)},activeTexture:k,bindTexture:function(t,e){null===C&&k();var i=P[C];void 0===i&&(i={type:void 0,texture:void 0},P[C]=i),i.type===t&&i.texture===e||(l.bindTexture(t,e||U[t]),i.type=t,i.texture=e)},compressedTexImage2D:function(){try{l.compressedTexImage2D.apply(l,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texImage2D:function(){try{l.texImage2D.apply(l,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},scissor:function(t){!1===O.equals(t)&&(l.scissor(t.x,t.y,t.z,t.w),O.copy(t))},viewport:function(t){!1===I.equals(t)&&(l.viewport(t.x,t.y,t.z,t.w),I.copy(t))},reset:function(){for(var t=0;t<o.length;t++)1===o[t]&&(l.disableVertexAttribArray(t),o[t]=0);c={},P={},w=_=p=d=C=u=null,n.reset(),r.reset(),e.reset()}}}function io(m,r,g,v,y,x,b){var f,_="undefined"!=typeof WebGL2RenderingContext&&m instanceof WebGL2RenderingContext,s={};function w(t,e){if(t.width>e||t.height>e){if("data"in t)return void console.warn("THREE.WebGLRenderer: image in DataTexture is too big ("+t.width+"x"+t.height+").");var i=e/Math.max(t.width,t.height),n=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");return n.width=Math.floor(t.width*i),n.height=Math.floor(t.height*i),n.getContext("2d").drawImage(t,0,0,t.width,t.height,0,0,n.width,n.height),console.warn("THREE.WebGLRenderer: image is too big ("+t.width+"x"+t.height+"). Resized to "+n.width+"x"+n.height,t),n}return t}function M(t){return De.isPowerOfTwo(t.width)&&De.isPowerOfTwo(t.height)}function E(t,e){return t.generateMipmaps&&e&&t.minFilter!==Mt&&t.minFilter!==St}function T(t,e,i,n){m.generateMipmap(t),v.get(e).__maxMipLevel=Math.log(Math.max(i,n))*Math.LOG2E}function a(t){return t===Mt||t===Et||t===Tt?m.NEAREST:m.LINEAR}function S(t){var e=t.target;e.removeEventListener("dispose",S),function(t){var e=v.get(t);if(t.image&&e.__image__webglTextureCube)m.deleteTexture(e.__image__webglTextureCube);else{if(void 0===e.__webglInit)return;m.deleteTexture(e.__webglTexture)}v.remove(t)}(e),e.isVideoTexture&&delete s[e.id],b.memory.textures--}function o(t){var e=t.target;e.removeEventListener("dispose",o),function(t){var e=v.get(t),i=v.get(t.texture);if(!t)return;void 0!==i.__webglTexture&&m.deleteTexture(i.__webglTexture);t.depthTexture&&t.depthTexture.dispose();if(t.isWebGLRenderTargetCube)for(var n=0;n<6;n++)m.deleteFramebuffer(e.__webglFramebuffer[n]),e.__webglDepthbuffer&&m.deleteRenderbuffer(e.__webglDepthbuffer[n]);else m.deleteFramebuffer(e.__webglFramebuffer),e.__webglDepthbuffer&&m.deleteRenderbuffer(e.__webglDepthbuffer);v.remove(t.texture),v.remove(t)}(e),b.memory.textures--}function h(t,e){var i,n,r,a=v.get(t);if(t.isVideoTexture&&(n=(i=t).id,r=b.render.frame,s[n]!==r&&(s[n]=r,i.update())),0<t.version&&a.__version!==t.version){var o=t.image;if(void 0===o)return;if(!1!==o.complete)return void function(t,e,i){void 0===t.__webglInit&&(t.__webglInit=!0,e.addEventListener("dispose",S),t.__webglTexture=m.createTexture(),b.memory.textures++);g.activeTexture(m.TEXTURE0+i),g.bindTexture(m.TEXTURE_2D,t.__webglTexture),m.pixelStorei(m.UNPACK_FLIP_Y_WEBGL,e.flipY),m.pixelStorei(m.UNPACK_PREMULTIPLY_ALPHA_WEBGL,e.premultiplyAlpha),m.pixelStorei(m.UNPACK_ALIGNMENT,e.unpackAlignment);var n=w(e.image,y.maxTextureSize);a=e,(a.wrapS!==_t||a.wrapT!==_t||a.minFilter!==Mt&&a.minFilter!==St)&&!1===M(n)&&(n=(r=n)instanceof HTMLImageElement||r instanceof HTMLCanvasElement||r instanceof ImageBitmap?(void 0===f&&(f=document.createElementNS("http://www.w3.org/1999/xhtml","canvas")),f.width=De.floorPowerOfTwo(r.width),f.height=De.floorPowerOfTwo(r.height),f.getContext("2d").drawImage(r,0,0,f.width,f.height),console.warn("THREE.WebGLRenderer: image is not power of two ("+r.width+"x"+r.height+"). Resized to "+f.width+"x"+f.height,r),f):r);var r;var a;var o=M(n),s=x.convert(e.format),h=x.convert(e.type);A(m.TEXTURE_2D,e,o);var c,l=e.mipmaps;if(e.isDepthTexture){var u=m.DEPTH_COMPONENT;if(e.type===Ft){if(!_)throw new Error("Float Depth Texture only supported in WebGL2.0");u=m.DEPTH_COMPONENT32F}else _&&(u=m.DEPTH_COMPONENT16);e.format===Jt&&u===m.DEPTH_COMPONENT&&e.type!==Ut&&e.type!==Bt&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),e.type=Ut,h=x.convert(e.type)),e.format===Qt&&(u=m.DEPTH_STENCIL,e.type!==kt&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),e.type=kt,h=x.convert(e.type))),g.texImage2D(m.TEXTURE_2D,0,u,n.width,n.height,0,s,h,null)}else if(e.isDataTexture)if(0<l.length&&o){for(var d=0,p=l.length;d<p;d++)c=l[d],g.texImage2D(m.TEXTURE_2D,d,s,c.width,c.height,0,s,h,c.data);e.generateMipmaps=!1,t.__maxMipLevel=l.length-1}else g.texImage2D(m.TEXTURE_2D,0,s,n.width,n.height,0,s,h,n.data),t.__maxMipLevel=0;else if(e.isCompressedTexture){for(var d=0,p=l.length;d<p;d++)c=l[d],e.format!==Xt&&e.format!==Wt?-1<g.getCompressedTextureFormats().indexOf(s)?g.compressedTexImage2D(m.TEXTURE_2D,d,s,c.width,c.height,0,c.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):g.texImage2D(m.TEXTURE_2D,d,s,c.width,c.height,0,s,h,c.data);t.__maxMipLevel=l.length-1}else if(0<l.length&&o){for(var d=0,p=l.length;d<p;d++)c=l[d],g.texImage2D(m.TEXTURE_2D,d,s,s,h,c);e.generateMipmaps=!1,t.__maxMipLevel=l.length-1}else g.texImage2D(m.TEXTURE_2D,0,s,s,h,n),t.__maxMipLevel=0;E(e,o)&&T(m.TEXTURE_2D,e,n.width,n.height);t.__version=e.version,e.onUpdate&&e.onUpdate(e)}(a,t,e);console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete",t)}g.activeTexture(m.TEXTURE0+e),g.bindTexture(m.TEXTURE_2D,a.__webglTexture)}function A(t,e,i){var n;if(i?(m.texParameteri(t,m.TEXTURE_WRAP_S,x.convert(e.wrapS)),m.texParameteri(t,m.TEXTURE_WRAP_T,x.convert(e.wrapT)),m.texParameteri(t,m.TEXTURE_MAG_FILTER,x.convert(e.magFilter)),m.texParameteri(t,m.TEXTURE_MIN_FILTER,x.convert(e.minFilter))):(m.texParameteri(t,m.TEXTURE_WRAP_S,m.CLAMP_TO_EDGE),m.texParameteri(t,m.TEXTURE_WRAP_T,m.CLAMP_TO_EDGE),e.wrapS===_t&&e.wrapT===_t||console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.",e),m.texParameteri(t,m.TEXTURE_MAG_FILTER,a(e.magFilter)),m.texParameteri(t,m.TEXTURE_MIN_FILTER,a(e.minFilter)),e.minFilter!==Mt&&e.minFilter!==St&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.",e)),n=r.get("EXT_texture_filter_anisotropic")){if(e.type===Ft&&null===r.get("OES_texture_float_linear"))return;if(e.type===zt&&null===r.get("OES_texture_half_float_linear"))return;(1<e.anisotropy||v.get(e).__currentAnisotropy)&&(m.texParameterf(t,n.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(e.anisotropy,y.getMaxAnisotropy())),v.get(e).__currentAnisotropy=e.anisotropy)}}function c(t,e,i,n){var r=x.convert(e.texture.format),a=x.convert(e.texture.type);g.texImage2D(n,0,r,e.width,e.height,0,r,a,null),m.bindFramebuffer(m.FRAMEBUFFER,t),m.framebufferTexture2D(m.FRAMEBUFFER,i,n,v.get(e.texture).__webglTexture,0),m.bindFramebuffer(m.FRAMEBUFFER,null)}function l(t,e){m.bindRenderbuffer(m.RENDERBUFFER,t),e.depthBuffer&&!e.stencilBuffer?(m.renderbufferStorage(m.RENDERBUFFER,m.DEPTH_COMPONENT16,e.width,e.height),m.framebufferRenderbuffer(m.FRAMEBUFFER,m.DEPTH_ATTACHMENT,m.RENDERBUFFER,t)):e.depthBuffer&&e.stencilBuffer?(m.renderbufferStorage(m.RENDERBUFFER,m.DEPTH_STENCIL,e.width,e.height),m.framebufferRenderbuffer(m.FRAMEBUFFER,m.DEPTH_STENCIL_ATTACHMENT,m.RENDERBUFFER,t)):m.renderbufferStorage(m.RENDERBUFFER,m.RGBA4,e.width,e.height),m.bindRenderbuffer(m.RENDERBUFFER,null)}function u(t){var e=v.get(t),i=!0===t.isWebGLRenderTargetCube;if(t.depthTexture){if(i)throw new Error("target.depthTexture not supported in Cube render targets");!function(t,e){if(e&&e.isWebGLRenderTargetCube)throw new Error("Depth Texture with cube render targets is not supported");if(m.bindFramebuffer(m.FRAMEBUFFER,t),!e.depthTexture||!e.depthTexture.isDepthTexture)throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");v.get(e.depthTexture).__webglTexture&&e.depthTexture.image.width===e.width&&e.depthTexture.image.height===e.height||(e.depthTexture.image.width=e.width,e.depthTexture.image.height=e.height,e.depthTexture.needsUpdate=!0),h(e.depthTexture,0);var i=v.get(e.depthTexture).__webglTexture;if(e.depthTexture.format===Jt)m.framebufferTexture2D(m.FRAMEBUFFER,m.DEPTH_ATTACHMENT,m.TEXTURE_2D,i,0);else{if(e.depthTexture.format!==Qt)throw new Error("Unknown depthTexture format");m.framebufferTexture2D(m.FRAMEBUFFER,m.DEPTH_STENCIL_ATTACHMENT,m.TEXTURE_2D,i,0)}}(e.__webglFramebuffer,t)}else if(i){e.__webglDepthbuffer=[];for(var n=0;n<6;n++)m.bindFramebuffer(m.FRAMEBUFFER,e.__webglFramebuffer[n]),e.__webglDepthbuffer[n]=m.createRenderbuffer(),l(e.__webglDepthbuffer[n],t)}else m.bindFramebuffer(m.FRAMEBUFFER,e.__webglFramebuffer),e.__webglDepthbuffer=m.createRenderbuffer(),l(e.__webglDepthbuffer,t);m.bindFramebuffer(m.FRAMEBUFFER,null)}this.setTexture2D=h,this.setTextureCube=function(t,e){var i=v.get(t);if(6===t.image.length)if(0<t.version&&i.__version!==t.version){i.__image__webglTextureCube||(t.addEventListener("dispose",S),i.__image__webglTextureCube=m.createTexture(),b.memory.textures++),g.activeTexture(m.TEXTURE0+e),g.bindTexture(m.TEXTURE_CUBE_MAP,i.__image__webglTextureCube),m.pixelStorei(m.UNPACK_FLIP_Y_WEBGL,t.flipY);for(var n=t&&t.isCompressedTexture,r=t.image[0]&&t.image[0].isDataTexture,a=[],o=0;o<6;o++)a[o]=n||r?r?t.image[o].image:t.image[o]:w(t.image[o],y.maxCubemapSize);var s=a[0],h=M(s),c=x.convert(t.format),l=x.convert(t.type);for(A(m.TEXTURE_CUBE_MAP,t,h),o=0;o<6;o++)if(n)for(var u,d=a[o].mipmaps,p=0,f=d.length;p<f;p++)u=d[p],t.format!==Xt&&t.format!==Wt?-1<g.getCompressedTextureFormats().indexOf(c)?g.compressedTexImage2D(m.TEXTURE_CUBE_MAP_POSITIVE_X+o,p,c,u.width,u.height,0,u.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):g.texImage2D(m.TEXTURE_CUBE_MAP_POSITIVE_X+o,p,c,u.width,u.height,0,c,l,u.data);else r?g.texImage2D(m.TEXTURE_CUBE_MAP_POSITIVE_X+o,0,c,a[o].width,a[o].height,0,c,l,a[o].data):g.texImage2D(m.TEXTURE_CUBE_MAP_POSITIVE_X+o,0,c,c,l,a[o]);i.__maxMipLevel=n?d.length-1:0,E(t,h)&&T(m.TEXTURE_CUBE_MAP,t,s.width,s.height),i.__version=t.version,t.onUpdate&&t.onUpdate(t)}else g.activeTexture(m.TEXTURE0+e),g.bindTexture(m.TEXTURE_CUBE_MAP,i.__image__webglTextureCube)},this.setTextureCubeDynamic=function(t,e){g.activeTexture(m.TEXTURE0+e),g.bindTexture(m.TEXTURE_CUBE_MAP,v.get(t).__webglTexture)},this.setupRenderTarget=function(t){var e=v.get(t),i=v.get(t.texture);t.addEventListener("dispose",o),i.__webglTexture=m.createTexture(),b.memory.textures++;var n=!0===t.isWebGLRenderTargetCube,r=M(t);if(n){e.__webglFramebuffer=[];for(var a=0;a<6;a++)e.__webglFramebuffer[a]=m.createFramebuffer()}else e.__webglFramebuffer=m.createFramebuffer();if(n){for(g.bindTexture(m.TEXTURE_CUBE_MAP,i.__webglTexture),A(m.TEXTURE_CUBE_MAP,t.texture,r),a=0;a<6;a++)c(e.__webglFramebuffer[a],t,m.COLOR_ATTACHMENT0,m.TEXTURE_CUBE_MAP_POSITIVE_X+a);E(t.texture,r)&&T(m.TEXTURE_CUBE_MAP,t.texture,t.width,t.height),g.bindTexture(m.TEXTURE_CUBE_MAP,null)}else g.bindTexture(m.TEXTURE_2D,i.__webglTexture),A(m.TEXTURE_2D,t.texture,r),c(e.__webglFramebuffer,t,m.COLOR_ATTACHMENT0,m.TEXTURE_2D),E(t.texture,r)&&T(m.TEXTURE_2D,t.texture,t.width,t.height),g.bindTexture(m.TEXTURE_2D,null);t.depthBuffer&&u(t)},this.updateRenderTargetMipmap=function(t){var e=t.texture;if(E(e,M(t))){var i=t.isWebGLRenderTargetCube?m.TEXTURE_CUBE_MAP:m.TEXTURE_2D,n=v.get(e).__webglTexture;g.bindTexture(i,n),T(i,e,t.width,t.height),g.bindTexture(i,null)}}}function no(i,n){return{convert:function(t){var e;if(t===bt)return i.REPEAT;if(t===_t)return i.CLAMP_TO_EDGE;if(t===wt)return i.MIRRORED_REPEAT;if(t===Mt)return i.NEAREST;if(t===Et)return i.NEAREST_MIPMAP_NEAREST;if(t===Tt)return i.NEAREST_MIPMAP_LINEAR;if(t===St)return i.LINEAR;if(t===Ct)return i.LINEAR_MIPMAP_NEAREST;if(t===Pt)return i.LINEAR_MIPMAP_LINEAR;if(t===Ot)return i.UNSIGNED_BYTE;if(t===Gt)return i.UNSIGNED_SHORT_4_4_4_4;if(t===Ht)return i.UNSIGNED_SHORT_5_5_5_1;if(t===Vt)return i.UNSIGNED_SHORT_5_6_5;if(t===It)return i.BYTE;if(t===Nt)return i.SHORT;if(t===Ut)return i.UNSIGNED_SHORT;if(t===Dt)return i.INT;if(t===Bt)return i.UNSIGNED_INT;if(t===Ft)return i.FLOAT;if(t===zt&&null!==(e=n.get("OES_texture_half_float")))return e.HALF_FLOAT_OES;if(t===jt)return i.ALPHA;if(t===Wt)return i.RGB;if(t===Xt)return i.RGBA;if(t===qt)return i.LUMINANCE;if(t===Yt)return i.LUMINANCE_ALPHA;if(t===Jt)return i.DEPTH_COMPONENT;if(t===Qt)return i.DEPTH_STENCIL;if(t===M)return i.FUNC_ADD;if(t===E)return i.FUNC_SUBTRACT;if(t===T)return i.FUNC_REVERSE_SUBTRACT;if(t===L)return i.ZERO;if(t===R)return i.ONE;if(t===C)return i.SRC_COLOR;if(t===P)return i.ONE_MINUS_SRC_COLOR;if(t===O)return i.SRC_ALPHA;if(t===I)return i.ONE_MINUS_SRC_ALPHA;if(t===N)return i.DST_ALPHA;if(t===D)return i.ONE_MINUS_DST_ALPHA;if(t===z)return i.DST_COLOR;if(t===G)return i.ONE_MINUS_DST_COLOR;if(t===H)return i.SRC_ALPHA_SATURATE;if((t===Kt||t===$t||t===te||t===ee)&&null!==(e=n.get("WEBGL_compressed_texture_s3tc"))){if(t===Kt)return e.COMPRESSED_RGB_S3TC_DXT1_EXT;if(t===$t)return e.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(t===te)return e.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(t===ee)return e.COMPRESSED_RGBA_S3TC_DXT5_EXT}if((t===ie||t===ne||t===re||t===ae)&&null!==(e=n.get("WEBGL_compressed_texture_pvrtc"))){if(t===ie)return e.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(t===ne)return e.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(t===re)return e.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(t===ae)return e.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(t===oe&&null!==(e=n.get("WEBGL_compressed_texture_etc1")))return e.COMPRESSED_RGB_ETC1_WEBGL;if((t===se||t===he||t===ce||t===le||t===ue||t===de||t===pe||t===fe||t===me||t===ge||t===ve||t===ye||t===xe||t===be)&&null!==(e=n.get("WEBGL_compressed_texture_astc")))return t;if((t===S||t===A)&&null!==(e=n.get("EXT_blend_minmax"))){if(t===S)return e.MIN_EXT;if(t===A)return e.MAX_EXT}return t===kt&&null!==(e=n.get("WEBGL_depth_texture"))?e.UNSIGNED_INT_24_8_WEBGL:0}}}function ro(t,e,i,n){Xi.call(this),this.type="PerspectiveCamera",this.fov=void 0!==t?t:50,this.zoom=1,this.near=void 0!==i?i:.1,this.far=void 0!==n?n:2e3,this.focus=10,this.aspect=void 0!==e?e:1,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}function ao(t){ro.call(this),this.cameras=t||[]}function oo(n){var s=this,h=null,c=null,l=null,u=new Fe,d=new Fe;"undefined"!=typeof window&&"VRFrameData"in window&&(c=new window.VRFrameData,window.addEventListener("vrdisplaypresentchange",t,!1));var p=new Fe,f=new ze,m=new Ge,g=new ro;g.bounds=new oi(0,0,.5,1),g.layers.enable(1);var v=new ro;v.bounds=new oi(.5,0,.5,1),v.layers.enable(2);var r,a,y=new ao([g,v]);function o(){return null!==h&&!0===h.isPresenting}function t(){if(o()){var t=h.getEyeParameters("left"),e=t.renderWidth,i=t.renderHeight;a=n.getPixelRatio(),r=n.getSize(),n.setDrawingBufferSize(2*e,i,1)}else s.enabled&&n.setDrawingBufferSize(r.width,r.height,a)}y.layers.enable(1),y.layers.enable(2),this.enabled=!1,this.userHeight=1.6,this.getDevice=function(){return h},this.setDevice=function(t){void 0!==t&&(h=t)},this.setPoseTarget=function(t){void 0!==t&&(l=t)},this.getCamera=function(t){if(null===h)return t;h.depthNear=t.near,h.depthFar=t.far,h.getFrameData(c);var e=h.stageParameters;e?u.fromArray(e.sittingToStandingTransform):u.makeTranslation(0,s.userHeight,0);var i=c.pose,n=null!==l?l:t;if(n.matrix.copy(u),n.matrix.decompose(n.position,n.quaternion,n.scale),null!==i.orientation&&(f.fromArray(i.orientation),n.quaternion.multiply(f)),null!==i.position&&(f.setFromRotationMatrix(u),m.fromArray(i.position),m.applyQuaternion(f),n.position.add(m)),n.updateMatrixWorld(),!1===h.isPresenting)return t;g.near=t.near,v.near=t.near,g.far=t.far,v.far=t.far,y.matrixWorld.copy(t.matrixWorld),y.matrixWorldInverse.copy(t.matrixWorldInverse),g.matrixWorldInverse.fromArray(c.leftViewMatrix),v.matrixWorldInverse.fromArray(c.rightViewMatrix),d.getInverse(u),g.matrixWorldInverse.multiply(d),v.matrixWorldInverse.multiply(d);var r=n.parent;null!==r&&(p.getInverse(r.matrixWorld),g.matrixWorldInverse.multiply(p),v.matrixWorldInverse.multiply(p)),g.matrixWorld.getInverse(g.matrixWorldInverse),v.matrixWorld.getInverse(v.matrixWorldInverse),g.projectionMatrix.fromArray(c.leftProjectionMatrix),v.projectionMatrix.fromArray(c.rightProjectionMatrix),y.projectionMatrix.copy(g.projectionMatrix);var a=h.getLayers();if(a.length){var o=a[0];null!==o.leftBounds&&4===o.leftBounds.length&&g.bounds.fromArray(o.leftBounds),null!==o.rightBounds&&4===o.rightBounds.length&&v.bounds.fromArray(o.rightBounds)}return y},this.getStandingMatrix=function(){return u},this.isPresenting=o,this.requestAnimationFrame=function(t){h.requestAnimationFrame(t)},this.submitFrame=function(){o()&&h.submitFrame()},this.dispose=function(){"undefined"!=typeof window&&window.removeEventListener("vrdisplaypresentchange",t)}}function so(l){var e=null,u=null,d=null,p=null;function i(){return null!==u&&null!==d}var t=new ro;t.layers.enable(1),t.viewport=new oi;var n=new ro;n.layers.enable(2),n.viewport=new oi;var f=new ao([t,n]);f.layers.enable(1),f.layers.enable(2),this.enabled=!1,this.getDevice=function(){return e},this.setDevice=function(t){void 0!==t&&(e=t),l.setCompatibleXRDevice(t)},this.setSession=function(t){null!==(u=t)&&(u.baseLayer=new XRWebGLLayer(u,l),u.requestFrameOfReference("stage").then(function(t){d=t,u.exclusive}))},this.getCamera=function(t){return i()?f:t},this.isPresenting=i,this.requestAnimationFrame=function(c){u.requestAnimationFrame(function(t,e){p=e.getDevicePose(d);for(var i=u.baseLayer,n=e.views,r=0;r<n.length;r++){var a=n[r],o=i.getViewport(a),s=p.getViewMatrix(a),h=f.cameras[r];h.projectionMatrix.fromArray(a.projectionMatrix),h.matrixWorldInverse.fromArray(s),h.matrixWorld.getInverse(h.matrixWorldInverse),h.viewport.set(o.x,o.y,o.width,o.height),0===r&&(f.matrixWorld.copy(h.matrixWorld),f.matrixWorldInverse.copy(h.matrixWorldInverse),f.projectionMatrix.copy(h.projectionMatrix))}l.bindFramebuffer(l.FRAMEBUFFER,u.baseLayer.framebuffer),c()})},this.getStandingMatrix=function(){return console.warn("THREE.WebXRManager: getStandingMatrix() is no longer needed."),new THREE.Matrix4},this.submitFrame=function(){}}function ho(t){var n=void 0!==(t=t||{}).canvas?t.canvas:document.createElementNS("http://www.w3.org/1999/xhtml","canvas"),e=void 0!==t.context?t.context:null,i=void 0!==t.alpha&&t.alpha,r=void 0===t.depth||t.depth,a=void 0===t.stencil||t.stencil,o=void 0!==t.antialias&&t.antialias,s=void 0===t.premultipliedAlpha||t.premultipliedAlpha,h=void 0!==t.preserveDrawingBuffer&&t.preserveDrawingBuffer,c=void 0!==t.powerPreference?t.powerPreference:"default",m=null,B=null;this.domElement=n,this.context=null,this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.gammaFactor=2,this.gammaInput=!1,this.gammaOutput=!1,this.physicallyCorrectLights=!1,this.toneMapping=Rt,this.toneMappingExposure=1,this.toneMappingWhitePoint=1,this.maxMorphTargets=8,this.maxMorphNormals=4;var F,S,z,G,l,H,u,A,L,g,v,d,p,f,R,C,P,y,x,V=this,b=!1,_=null,w=null,k=-1,O=null,I=null,N=null,j=null,W=null,M=new oi,E=new oi,T=null,X=0,U=n.width,q=n.height,Y=1,D=new oi(0,0,U,q),Z=new oi(0,0,U,q),J=!1,Q=new pi,K=new fr,$=!1,tt=!1,et=new Fe,it=new Ge;function nt(){return null===_?Y:1}try{var rt={alpha:i,depth:r,stencil:a,antialias:o,premultipliedAlpha:s,preserveDrawingBuffer:h,powerPreference:c};if(n.addEventListener("webglcontextlost",ht,!1),n.addEventListener("webglcontextrestored",ct,!1),null===(F=e||n.getContext("webgl",rt)||n.getContext("experimental-webgl",rt)))throw null!==n.getContext("webgl")?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.");void 0===F.getShaderPrecisionFormat&&(F.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(t){console.error("THREE.WebGLRenderer: "+t.message)}function at(){(S=new mr(F)).get("WEBGL_depth_texture"),S.get("OES_texture_float"),S.get("OES_texture_float_linear"),S.get("OES_texture_half_float"),S.get("OES_texture_half_float_linear"),S.get("OES_standard_derivatives"),S.get("OES_element_index_uint"),S.get("ANGLE_instanced_arrays"),x=new no(F,S),z=new pr(F,S,t),(G=new eo(F,S,x)).scissor(E.copy(Z).multiplyScalar(Y)),G.viewport(M.copy(D).multiplyScalar(Y)),l=new yr(F),H=new wa,u=new io(F,S,G,H,z,x,l),A=new Mi(F),L=new gr(F,A,l),g=new _r(L,l),R=new br(F),v=new _a(V,S,z),d=new Sa,p=new Za,f=new ur(V,G,g,s),C=new dr(F,S,l),P=new vr(F,S,l),y=new to(V,F,G,u,z),l.programs=v.programs,V.context=F,V.capabilities=z,V.extensions=S,V.properties=H,V.renderLists=d,V.state=G,V.info=l}at();var ot="xr"in navigator?new so(F):new oo(V);this.vr=ot;var st=new Ka(V,g,z.maxTextureSize);function ht(t){t.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),b=!0}function ct(){console.log("THREE.WebGLRenderer: Context Restored."),b=!1,at()}function lt(t){var e,i=t.target;i.removeEventListener("dispose",lt),ut(e=i),H.remove(e)}function ut(t){var e=H.get(t).program;(t.program=void 0)!==e&&v.releaseProgram(e)}this.shadowMap=st,this.getContext=function(){return F},this.getContextAttributes=function(){return F.getContextAttributes()},this.forceContextLoss=function(){var t=S.get("WEBGL_lose_context");t&&t.loseContext()},this.forceContextRestore=function(){var t=S.get("WEBGL_lose_context");t&&t.restoreContext()},this.getPixelRatio=function(){return Y},this.setPixelRatio=function(t){void 0!==t&&(Y=t,this.setSize(U,q,!1))},this.getSize=function(){return{width:U,height:q}},this.setSize=function(t,e,i){ot.isPresenting()?console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting."):(U=t,q=e,n.width=t*Y,n.height=e*Y,!1!==i&&(n.style.width=t+"px",n.style.height=e+"px"),this.setViewport(0,0,t,e))},this.getDrawingBufferSize=function(){return{width:U*Y,height:q*Y}},this.setDrawingBufferSize=function(t,e,i){U=t,q=e,Y=i,n.width=t*i,n.height=e*i,this.setViewport(0,0,t,e)},this.getCurrentViewport=function(){return M},this.setViewport=function(t,e,i,n){D.set(t,q-e-n,i,n),G.viewport(M.copy(D).multiplyScalar(Y))},this.setScissor=function(t,e,i,n){Z.set(t,q-e-n,i,n),G.scissor(E.copy(Z).multiplyScalar(Y))},this.setScissorTest=function(t){G.setScissorTest(J=t)},this.getClearColor=function(){return f.getClearColor()},this.setClearColor=function(){f.setClearColor.apply(f,arguments)},this.getClearAlpha=function(){return f.getClearAlpha()},this.setClearAlpha=function(){f.setClearAlpha.apply(f,arguments)},this.clear=function(t,e,i){var n=0;(void 0===t||t)&&(n|=F.COLOR_BUFFER_BIT),(void 0===e||e)&&(n|=F.DEPTH_BUFFER_BIT),(void 0===i||i)&&(n|=F.STENCIL_BUFFER_BIT),F.clear(n)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.clearTarget=function(t,e,i,n){this.setRenderTarget(t),this.clear(e,i,n)},this.dispose=function(){n.removeEventListener("webglcontextlost",ht,!1),n.removeEventListener("webglcontextrestored",ct,!1),d.dispose(),p.dispose(),H.dispose(),g.dispose(),ot.dispose(),vt()},this.renderBufferImmediate=function(t,e,i){G.initAttributes();var n=H.get(t);t.hasPositions&&!n.position&&(n.position=F.createBuffer()),t.hasNormals&&!n.normal&&(n.normal=F.createBuffer()),t.hasUvs&&!n.uv&&(n.uv=F.createBuffer()),t.hasColors&&!n.color&&(n.color=F.createBuffer());var r=e.getAttributes();if(t.hasPositions&&(F.bindBuffer(F.ARRAY_BUFFER,n.position),F.bufferData(F.ARRAY_BUFFER,t.positionArray,F.DYNAMIC_DRAW),G.enableAttribute(r.position),F.vertexAttribPointer(r.position,3,F.FLOAT,!1,0,0)),t.hasNormals){if(F.bindBuffer(F.ARRAY_BUFFER,n.normal),!i.isMeshPhongMaterial&&!i.isMeshStandardMaterial&&!i.isMeshNormalMaterial&&!0===i.flatShading)for(var a=0,o=3*t.count;a<o;a+=9){var s=t.normalArray,h=(s[a+0]+s[a+3]+s[a+6])/3,c=(s[a+1]+s[a+4]+s[a+7])/3,l=(s[a+2]+s[a+5]+s[a+8])/3;s[a+0]=h,s[a+1]=c,s[a+2]=l,s[a+3]=h,s[a+4]=c,s[a+5]=l,s[a+6]=h,s[a+7]=c,s[a+8]=l}F.bufferData(F.ARRAY_BUFFER,t.normalArray,F.DYNAMIC_DRAW),G.enableAttribute(r.normal),F.vertexAttribPointer(r.normal,3,F.FLOAT,!1,0,0)}t.hasUvs&&i.map&&(F.bindBuffer(F.ARRAY_BUFFER,n.uv),F.bufferData(F.ARRAY_BUFFER,t.uvArray,F.DYNAMIC_DRAW),G.enableAttribute(r.uv),F.vertexAttribPointer(r.uv,2,F.FLOAT,!1,0,0)),t.hasColors&&i.vertexColors!==Lt&&(F.bindBuffer(F.ARRAY_BUFFER,n.color),F.bufferData(F.ARRAY_BUFFER,t.colorArray,F.DYNAMIC_DRAW),G.enableAttribute(r.color),F.vertexAttribPointer(r.color,3,F.FLOAT,!1,0,0)),G.disableUnusedAttributes(),F.drawArrays(F.TRIANGLES,0,t.count),t.count=0},this.renderBufferDirect=function(t,e,i,n,r,a){var o=r.isMesh&&r.matrixWorld.determinant()<0;G.setMaterial(n,o);var s=Mt(t,e,n,r),h=i.id,c=s.id,l=!0===n.wireframe,u=!1;h==O&&c==I&&l==N||(O=h,I=c,N=l,u=!0),r.morphTargetInfluences&&(R.update(r,i,n,s),u=!0);var d,p=i.index,f=i.attributes.position,m=1;!0===n.wireframe&&(p=L.getWireframeAttribute(i),m=2);var g=C;null!==p&&(d=A.get(p),(g=P).setIndex(d)),u&&(!function(t,e,i){if(i&&i.isInstancedBufferGeometry&&null===S.get("ANGLE_instanced_arrays"))return console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");G.initAttributes();var n=i.attributes,r=e.getAttributes(),a=t.defaultAttributeValues;for(var o in r){var s=r[o];if(0<=s){var h=n[o];if(void 0!==h){var c=h.normalized,l=h.itemSize,u=A.get(h);if(void 0===u)continue;var d=u.buffer,p=u.type,f=u.bytesPerElement;if(h.isInterleavedBufferAttribute){var m=h.data,g=m.stride,v=h.offset;m&&m.isInstancedInterleavedBuffer?(G.enableAttributeAndDivisor(s,m.meshPerAttribute),void 0===i.maxInstancedCount&&(i.maxInstancedCount=m.meshPerAttribute*m.count)):G.enableAttribute(s),F.bindBuffer(F.ARRAY_BUFFER,d),F.vertexAttribPointer(s,l,p,c,g*f,v*f)}else h.isInstancedBufferAttribute?(G.enableAttributeAndDivisor(s,h.meshPerAttribute),void 0===i.maxInstancedCount&&(i.maxInstancedCount=h.meshPerAttribute*h.count)):G.enableAttribute(s),F.bindBuffer(F.ARRAY_BUFFER,d),F.vertexAttribPointer(s,l,p,c,0,0)}else if(void 0!==a){var y=a[o];if(void 0!==y)switch(y.length){case 2:F.vertexAttrib2fv(s,y);break;case 3:F.vertexAttrib3fv(s,y);break;case 4:F.vertexAttrib4fv(s,y);break;default:F.vertexAttrib1fv(s,y)}}}}G.disableUnusedAttributes()}(n,s,i),null!==p&&F.bindBuffer(F.ELEMENT_ARRAY_BUFFER,d.buffer));var v=1/0;null!==p?v=p.count:void 0!==f&&(v=f.count);var y=i.drawRange.start*m,x=i.drawRange.count*m,b=null!==a?a.start*m:0,_=null!==a?a.count*m:1/0,w=Math.max(y,b),M=Math.min(v,y+x,b+_)-1,E=Math.max(0,M-w+1);if(0!==E){if(r.isMesh)if(!0===n.wireframe)G.setLineWidth(n.wireframeLinewidth*nt()),g.setMode(F.LINES);else switch(r.drawMode){case Se:g.setMode(F.TRIANGLES);break;case 1:g.setMode(F.TRIANGLE_STRIP);break;case 2:g.setMode(F.TRIANGLE_FAN)}else if(r.isLine){var T=n.linewidth;void 0===T&&(T=1),G.setLineWidth(T*nt()),r.isLineSegments?g.setMode(F.LINES):r.isLineLoop?g.setMode(F.LINE_LOOP):g.setMode(F.LINE_STRIP)}else r.isPoints&&g.setMode(F.POINTS);i&&i.isInstancedBufferGeometry?0<i.maxInstancedCount&&g.renderInstances(i,w,E):g.render(w,E)}};var dt,pt,ft,mt=!(this.compile=function(i,t){(B=p.get(i,t)).init(),i.traverse(function(t){t.isLight&&(B.pushLight(t),t.castShadow&&B.pushShadow(t))}),B.setupLights(t),i.traverse(function(t){if(t.material)if(Array.isArray(t.material))for(var e=0;e<t.material.length;e++)wt(t.material[e],i.fog,t);else wt(t.material,i.fog,t)})}),gt=null;function vt(){mt=!1}function yt(){ot.isPresenting()?ot.requestAnimationFrame(xt):window.requestAnimationFrame(xt)}function xt(t){!1!==mt&&(gt(t),yt())}function bt(t,e,i,n){for(var r=0,a=t.length;r<a;r++){var o=t[r],s=o.object,h=o.geometry,c=void 0===n?o.material:n,l=o.group;if(i.isArrayCamera)for(var u=(W=i).cameras,d=0,p=u.length;d<p;d++){var f=u[d];if(s.layers.test(f.layers)){if("viewport"in f)G.viewport(M.copy(f.viewport));else{var m=f.bounds,g=m.x*U,v=m.y*q,y=m.z*U,x=m.w*q;G.viewport(M.set(g,v,y,x).multiplyScalar(Y))}_t(s,e,f,h,c,l)}}else W=null,_t(s,e,i,h,c,l)}}function _t(t,e,i,n,r,a){if(t.onBeforeRender(V,e,i,n,r,a),B=p.get(e,W||i),t.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse,t.matrixWorld),t.normalMatrix.getNormalMatrix(t.modelViewMatrix),t.isImmediateRenderObject){var o=t.isMesh&&t.matrixWorld.determinant()<0;G.setMaterial(r,o);var s=Mt(i,e.fog,r,t);N=I=O=null,h=s,c=r,t.render(function(t){V.renderBufferImmediate(t,h,c)})}else V.renderBufferDirect(i,e.fog,n,r,t,a);var h,c;t.onAfterRender(V,e,i,n,r,a),B=p.get(e,W||i)}function wt(t,e,i){var n=H.get(t);void 0===n.lightsHash&&(n.lightsHash={});var r=B.state.lights,a=B.state.shadowsArray,o=v.getParameters(t,r.state,a,e,K.numPlanes,K.numIntersection,i),s=v.getProgramCode(t,o),h=n.program,c=!0;if(void 0===h)t.addEventListener("dispose",lt);else if(h.code!==s)ut(t);else if(n.lightsHash.stateID!==r.state.hash.stateID||n.lightsHash.directionalLength!==r.state.hash.directionalLength||n.lightsHash.pointLength!==r.state.hash.pointLength||n.lightsHash.spotLength!==r.state.hash.spotLength||n.lightsHash.rectAreaLength!==r.state.hash.rectAreaLength||n.lightsHash.hemiLength!==r.state.hash.hemiLength||n.lightsHash.shadowsLength!==r.state.hash.shadowsLength)H.update(t,"lightsHash",r.state.hash),c=!1;else{if(void 0!==o.shaderID)return;c=!1}if(c){if(o.shaderID){var l=wi[o.shaderID];n.shader={name:t.type,uniforms:gi.clone(l.uniforms),vertexShader:l.vertexShader,fragmentShader:l.fragmentShader}}else n.shader={name:t.type,uniforms:t.uniforms,vertexShader:t.vertexShader,fragmentShader:t.fragmentShader};t.onBeforeCompile(n.shader,V),h=v.acquireProgram(t,n.shader,o,s),n.program=h,t.program=h}var u=h.getAttributes();if(t.morphTargets)for(var d=t.numSupportedMorphTargets=0;d<V.maxMorphTargets;d++)0<=u["morphTarget"+d]&&t.numSupportedMorphTargets++;if(t.morphNormals)for(d=t.numSupportedMorphNormals=0;d<V.maxMorphNormals;d++)0<=u["morphNormal"+d]&&t.numSupportedMorphNormals++;var p=n.shader.uniforms;(t.isShaderMaterial||t.isRawShaderMaterial)&&!0!==t.clipping||(n.numClippingPlanes=K.numPlanes,n.numIntersection=K.numIntersection,p.clippingPlanes=K.uniform),n.fog=e,n.lightsHash.stateID=r.state.hash.stateID,n.lightsHash.directionalLength=r.state.hash.directionalLength,n.lightsHash.pointLength=r.state.hash.pointLength,n.lightsHash.spotLength=r.state.hash.spotLength,n.lightsHash.rectAreaLength=r.state.hash.rectAreaLength,n.lightsHash.hemiLength=r.state.hash.hemiLength,n.lightsHash.shadowsLength=r.state.hash.shadowsLength,t.lights&&(p.ambientLightColor.value=r.state.ambient,p.directionalLights.value=r.state.directional,p.spotLights.value=r.state.spot,p.rectAreaLights.value=r.state.rectArea,p.pointLights.value=r.state.point,p.hemisphereLights.value=r.state.hemi,p.directionalShadowMap.value=r.state.directionalShadowMap,p.directionalShadowMatrix.value=r.state.directionalShadowMatrix,p.spotShadowMap.value=r.state.spotShadowMap,p.spotShadowMatrix.value=r.state.spotShadowMatrix,p.pointShadowMap.value=r.state.pointShadowMap,p.pointShadowMatrix.value=r.state.pointShadowMatrix);var f=n.program.getUniforms(),m=la.seqWithValue(f.seq,p);n.uniformsList=m}function Mt(t,e,i,n){X=0;var r=H.get(i),a=B.state.lights;if($&&(tt||t!==j)){var o=t===j&&i.id===k;K.setState(i.clippingPlanes,i.clipIntersection,i.clipShadows,t,r,o)}!1===i.needsUpdate&&(void 0===r.program?i.needsUpdate=!0:i.fog&&r.fog!==e?i.needsUpdate=!0:i.lights&&r.lightsHash.stateID!==a.state.hash.stateID||r.lightsHash.directionalLength!==a.state.hash.directionalLength||r.lightsHash.pointLength!==a.state.hash.pointLength||r.lightsHash.spotLength!==a.state.hash.spotLength||r.lightsHash.rectAreaLength!==a.state.hash.rectAreaLength||r.lightsHash.shadowsLength!==a.state.hash.shadowsLength?i.needsUpdate=!0:void 0===r.numClippingPlanes||r.numClippingPlanes===K.numPlanes&&r.numIntersection===K.numIntersection||(i.needsUpdate=!0)),i.needsUpdate&&(wt(i,e,n),i.needsUpdate=!1);var s,h,c,l,u,d,p,f,m,g,v,y,x,b,_,w,M,E,T=!1,S=!1,A=!1,L=r.program,R=L.getUniforms(),C=r.shader.uniforms;if(G.useProgram(L.program)&&(A=S=T=!0),i.id!==k&&(k=i.id,S=!0),T||t!==j){if(R.setValue(F,"projectionMatrix",t.projectionMatrix),z.logarithmicDepthBuffer&&R.setValue(F,"logDepthBufFC",2/(Math.log(t.far+1)/Math.LN2)),j!==(W||t)&&(j=W||t,A=S=!0),i.isShaderMaterial||i.isMeshPhongMaterial||i.isMeshStandardMaterial||i.envMap){var P=R.map.cameraPosition;void 0!==P&&P.setValue(F,it.setFromMatrixPosition(t.matrixWorld))}(i.isMeshPhongMaterial||i.isMeshLambertMaterial||i.isMeshBasicMaterial||i.isMeshStandardMaterial||i.isShaderMaterial||i.skinning)&&R.setValue(F,"viewMatrix",t.matrixWorldInverse)}if(i.skinning){R.setOptional(F,n,"bindMatrix"),R.setOptional(F,n,"bindMatrixInverse");var O=n.skeleton;if(O){var I=O.bones;if(z.floatVertexTextures){if(void 0===O.boneTexture){var N=Math.sqrt(4*I.length);N=De.ceilPowerOfTwo(N),N=Math.max(N,4);var U=new Float32Array(N*N*4);U.set(O.boneMatrices);var D=new ci(U,N,N,Xt,Ft);D.needsUpdate=!0,O.boneMatrices=U,O.boneTexture=D,O.boneTextureSize=N}R.setValue(F,"boneTexture",O.boneTexture),R.setValue(F,"boneTextureSize",O.boneTextureSize)}else R.setOptional(F,O,"boneMatrices")}}return S&&(R.setValue(F,"toneMappingExposure",V.toneMappingExposure),R.setValue(F,"toneMappingWhitePoint",V.toneMappingWhitePoint),i.lights&&(E=A,(M=C).ambientLightColor.needsUpdate=E,M.directionalLights.needsUpdate=E,M.pointLights.needsUpdate=E,M.spotLights.needsUpdate=E,M.rectAreaLights.needsUpdate=E,M.hemisphereLights.needsUpdate=E),e&&i.fog&&(w=e,(_=C).fogColor.value=w.color,w.isFog?(_.fogNear.value=w.near,_.fogFar.value=w.far):w.isFogExp2&&(_.fogDensity.value=w.density)),i.isMeshBasicMaterial?Et(C,i):i.isMeshLambertMaterial?(Et(C,i),x=C,(b=i).emissiveMap&&(x.emissiveMap.value=b.emissiveMap)):i.isMeshPhongMaterial?(Et(C,i),i.isMeshToonMaterial?(Tt(v=C,y=i),y.gradientMap&&(v.gradientMap.value=y.gradientMap)):Tt(C,i)):i.isMeshStandardMaterial?(Et(C,i),i.isMeshPhysicalMaterial?(g=i,(m=C).clearCoat.value=g.clearCoat,m.clearCoatRoughness.value=g.clearCoatRoughness,St(m,g)):St(C,i)):i.isMeshDepthMaterial?(Et(C,i),p=C,(f=i).displacementMap&&(p.displacementMap.value=f.displacementMap,p.displacementScale.value=f.displacementScale,p.displacementBias.value=f.displacementBias)):i.isMeshDistanceMaterial?(Et(C,i),function(t,e){e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias);t.referencePosition.value.copy(e.referencePosition),t.nearDistance.value=e.nearDistance,t.farDistance.value=e.farDistance}(C,i)):i.isMeshNormalMaterial?(Et(C,i),function(t,e){e.bumpMap&&(t.bumpMap.value=e.bumpMap,t.bumpScale.value=e.bumpScale,e.side===At&&(t.bumpScale.value*=-1));e.normalMap&&(t.normalMap.value=e.normalMap,t.normalScale.value.copy(e.normalScale),e.side===At&&t.normalScale.value.negate());e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias)}(C,i)):i.isLineBasicMaterial?(d=i,(u=C).diffuse.value=d.color,u.opacity.value=d.opacity,i.isLineDashedMaterial&&(l=i,(c=C).dashSize.value=l.dashSize,c.totalSize.value=l.dashSize+l.gapSize,c.scale.value=l.scale)):i.isPointsMaterial?(h=i,(s=C).diffuse.value=h.color,s.opacity.value=h.opacity,s.size.value=h.size*Y,s.scale.value=.5*q,s.map.value=h.map,null!==h.map&&(!0===h.map.matrixAutoUpdate&&h.map.updateMatrix(),s.uvTransform.value.copy(h.map.matrix))):i.isShadowMaterial&&(C.color.value=i.color,C.opacity.value=i.opacity),void 0!==C.ltc_1&&(C.ltc_1.value=_i.LTC_1),void 0!==C.ltc_2&&(C.ltc_2.value=_i.LTC_2),la.upload(F,r.uniformsList,C,V)),i.isShaderMaterial&&!0===i.uniformsNeedUpdate&&(la.upload(F,r.uniformsList,C,V),i.uniformsNeedUpdate=!1),R.setValue(F,"modelViewMatrix",n.modelViewMatrix),R.setValue(F,"normalMatrix",n.normalMatrix),R.setValue(F,"modelMatrix",n.matrixWorld),L}function Et(t,e){var i;t.opacity.value=e.opacity,e.color&&(t.diffuse.value=e.color),e.emissive&&t.emissive.value.copy(e.emissive).multiplyScalar(e.emissiveIntensity),e.map&&(t.map.value=e.map),e.alphaMap&&(t.alphaMap.value=e.alphaMap),e.specularMap&&(t.specularMap.value=e.specularMap),e.envMap&&(t.envMap.value=e.envMap,t.flipEnvMap.value=e.envMap&&e.envMap.isCubeTexture?-1:1,t.reflectivity.value=e.reflectivity,t.refractionRatio.value=e.refractionRatio,t.maxMipLevel.value=H.get(e.envMap).__maxMipLevel),e.lightMap&&(t.lightMap.value=e.lightMap,t.lightMapIntensity.value=e.lightMapIntensity),e.aoMap&&(t.aoMap.value=e.aoMap,t.aoMapIntensity.value=e.aoMapIntensity),e.map?i=e.map:e.specularMap?i=e.specularMap:e.displacementMap?i=e.displacementMap:e.normalMap?i=e.normalMap:e.bumpMap?i=e.bumpMap:e.roughnessMap?i=e.roughnessMap:e.metalnessMap?i=e.metalnessMap:e.alphaMap?i=e.alphaMap:e.emissiveMap?i=e.emissiveMap:e.displacementMap&&(i=e.displacementMap),void 0!==i&&(i.isWebGLRenderTarget&&(i=i.texture),!0===i.matrixAutoUpdate&&i.updateMatrix(),t.uvTransform.value.copy(i.matrix))}function Tt(t,e){t.specular.value=e.specular,t.shininess.value=Math.max(e.shininess,1e-4),e.emissiveMap&&(t.emissiveMap.value=e.emissiveMap),e.bumpMap&&(t.bumpMap.value=e.bumpMap,t.bumpScale.value=e.bumpScale,e.side===At&&(t.bumpScale.value*=-1)),e.normalMap&&(t.normalMap.value=e.normalMap,t.normalScale.value.copy(e.normalScale),e.side===At&&t.normalScale.value.negate()),e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias)}function St(t,e){t.roughness.value=e.roughness,t.metalness.value=e.metalness,e.roughnessMap&&(t.roughnessMap.value=e.roughnessMap),e.metalnessMap&&(t.metalnessMap.value=e.metalnessMap),e.emissiveMap&&(t.emissiveMap.value=e.emissiveMap),e.bumpMap&&(t.bumpMap.value=e.bumpMap,t.bumpScale.value=e.bumpScale,e.side===At&&(t.bumpScale.value*=-1)),e.normalMap&&(t.normalMap.value=e.normalMap,t.normalScale.value.copy(e.normalScale),e.side===At&&t.normalScale.value.negate()),e.displacementMap&&(t.displacementMap.value=e.displacementMap,t.displacementScale.value=e.displacementScale,t.displacementBias.value=e.displacementBias),e.envMap&&(t.envMapIntensity.value=e.envMapIntensity)}this.animate=function(t){null!==(gt=t)?mt||(yt(),mt=!0):vt()},this.render=function(t,e,i,n){if(e&&e.isCamera){if(!b){k=-1,!(j=N=O=I=null)===t.autoUpdate&&t.updateMatrixWorld(),null===e.parent&&e.updateMatrixWorld(),ot.enabled&&(e=ot.getCamera(e)),(B=p.get(t,e)).init(),t.onBeforeRender(V,t,e,i),et.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),Q.setFromMatrix(et),tt=this.localClippingEnabled,$=K.init(this.clippingPlanes,tt,e),(m=d.get(t,e)).init(),function t(e,i,n){if(!1===e.visible)return;var r=e.layers.test(i.layers);if(r)if(e.isLight)B.pushLight(e),e.castShadow&&B.pushShadow(e);else if(e.isSprite)e.frustumCulled&&!Q.intersectsSprite(e)||B.pushSprite(e);else if(e.isImmediateRenderObject)n&&it.setFromMatrixPosition(e.matrixWorld).applyMatrix4(et),m.push(e,null,e.material,it.z,null);else if((e.isMesh||e.isLine||e.isPoints)&&(e.isSkinnedMesh&&e.skeleton.update(),!e.frustumCulled||Q.intersectsObject(e))){n&&it.setFromMatrixPosition(e.matrixWorld).applyMatrix4(et);var a=g.update(e),o=e.material;if(Array.isArray(o))for(var s=a.groups,h=0,c=s.length;h<c;h++){var l=s[h],u=o[l.materialIndex];u&&u.visible&&m.push(e,a,u,it.z,l)}else o.visible&&m.push(e,a,o,it.z,null)}var d=e.children;for(var h=0,c=d.length;h<c;h++){var p=d[h];if(window.areaConfigurationsHandler.updateNeeded&&(p.addedObject&&p.addedObject.applyAreaConfiguration(window.areaConfigurationsHandler.currentArea),p.objectGroupName)){var f=window.objectGroups[p.objectGroupName];f.applyAreaConfiguration(window.areaConfigurationsHandler.currentArea)}p.visible&&t(p,i,n)}}(t,e,V.sortObjects),!0===V.sortObjects&&m.sort(),$&&K.beginShadows();var r=B.state.shadowsArray;st.render(r,t,e),B.setupLights(e),$&&K.endShadows(),this.info.autoReset&&this.info.reset(),void 0===i&&(i=null),this.setRenderTarget(i),f.render(m,t,e,n);var a=m.opaque,o=m.transparent;if(t.overrideMaterial){var s=t.overrideMaterial;a.length&&bt(a,t,e,s),o.length&&bt(o,t,e,s)}else a.length&&bt(a,t,e),o.length&&bt(o,t,e);var h=B.state.spritesArray;y.render(h,t,e),i&&u.updateRenderTargetMipmap(i),G.buffers.depth.setTest(!0),G.buffers.depth.setMask(!0),G.buffers.color.setMask(!0),G.setPolygonOffset(!1),t.onAfterRender(V,t,e),ot.enabled&&ot.submitFrame(),B=m=null}}else console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")},this.allocTextureUnit=function(){var t=X;return t>=z.maxTextures&&console.warn("THREE.WebGLRenderer: Trying to use "+t+" texture units while this GPU supports only "+z.maxTextures),X+=1,t},this.setTexture2D=(dt=!1,function(t,e){t&&t.isWebGLRenderTarget&&(dt||(console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."),dt=!0),t=t.texture),u.setTexture2D(t,e)}),this.setTexture=(pt=!1,function(t,e){pt||(console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."),pt=!0),u.setTexture2D(t,e)}),this.setTextureCube=(ft=!1,function(t,e){t&&t.isWebGLRenderTargetCube&&(ft||(console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."),ft=!0),t=t.texture),t&&t.isCubeTexture||Array.isArray(t.image)&&6===t.image.length?u.setTextureCube(t,e):u.setTextureCubeDynamic(t,e)}),this.getRenderTarget=function(){return _},this.setRenderTarget=function(t){(_=t)&&void 0===H.get(t).__webglFramebuffer&&u.setupRenderTarget(t);var e=null,i=!1;if(t){var n=H.get(t).__webglFramebuffer;t.isWebGLRenderTargetCube?(e=n[t.activeCubeFace],i=!0):e=n,M.copy(t.viewport),E.copy(t.scissor),T=t.scissorTest}else M.copy(D).multiplyScalar(Y),E.copy(Z).multiplyScalar(Y),T=J;if(w!==e&&(F.bindFramebuffer(F.FRAMEBUFFER,e),w=e),G.viewport(M),G.scissor(E),G.setScissorTest(T),i){var r=H.get(t.texture);F.framebufferTexture2D(F.FRAMEBUFFER,F.COLOR_ATTACHMENT0,F.TEXTURE_CUBE_MAP_POSITIVE_X+t.activeCubeFace,r.__webglTexture,t.activeMipMapLevel)}},this.readRenderTargetPixels=function(t,e,i,n,r,a){if(t&&t.isWebGLRenderTarget){var o=H.get(t).__webglFramebuffer;if(o){var s=!1;o!==w&&(F.bindFramebuffer(F.FRAMEBUFFER,o),s=!0);try{var h=t.texture,c=h.format,l=h.type;if(c!==Xt&&x.convert(c)!==F.getParameter(F.IMPLEMENTATION_COLOR_READ_FORMAT))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");if(!(l===Ot||x.convert(l)===F.getParameter(F.IMPLEMENTATION_COLOR_READ_TYPE)||l===Ft&&(S.get("OES_texture_float")||S.get("WEBGL_color_buffer_float"))||l===zt&&S.get("EXT_color_buffer_half_float")))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");F.checkFramebufferStatus(F.FRAMEBUFFER)===F.FRAMEBUFFER_COMPLETE?0<=e&&e<=t.width-n&&0<=i&&i<=t.height-r&&F.readPixels(e,i,n,r,x.convert(c),x.convert(l),a):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")}finally{s&&F.bindFramebuffer(F.FRAMEBUFFER,w)}}}else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")},this.copyFramebufferToTexture=function(t,e,i){var n=e.image.width,r=e.image.height,a=x.convert(e.format);this.setTexture2D(e,0),F.copyTexImage2D(F.TEXTURE_2D,i||0,a,t.x,t.y,n,r,0)},this.copyTextureToTexture=function(t,e,i,n){var r=e.image.width,a=e.image.height,o=x.convert(i.format),s=x.convert(i.type);this.setTexture2D(i,0),e.isDataTexture?F.texSubImage2D(F.TEXTURE_2D,n||0,t.x,t.y,r,a,o,s,e.image.data):F.texSubImage2D(F.TEXTURE_2D,n||0,t.x,t.y,o,s,e.image)}}function co(t,e){this.name="",this.color=new yi(t),this.density=void 0!==e?e:25e-5}function lo(t,e,i){this.name="",this.color=new yi(t),this.near=void 0!==e?e:1,this.far=void 0!==i?i:1e3}function uo(){Wi.call(this),this.type="Scene",this.background=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0}function po(t){rr.call(this),this.type="SpriteMaterial",this.color=new yi(16777215),this.map=null,this.rotation=0,this.fog=!1,this.lights=!1,this.setValues(t)}function fo(t){Wi.call(this),this.type="Sprite",this.material=void 0!==t?t:new po,this.center=new Be(.5,.5)}function mo(){Wi.call(this),this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]}})}function go(t,e){if(t=t||[],this.bones=t.slice(0),this.boneMatrices=new Float32Array(16*this.bones.length),void 0===e)this.calculateInverses();else if(this.bones.length===e.length)this.boneInverses=e.slice(0);else{console.warn("THREE.Skeleton boneInverses is the wrong length."),this.boneInverses=[];for(var i=0,n=this.bones.length;i<n;i++)this.boneInverses.push(new Fe)}}function vo(){Wi.call(this),this.type="Bone"}function yo(t,e){lr.call(this,t,e),this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new Fe,this.bindMatrixInverse=new Fe;var i=new go(this.initBones());this.bind(i,this.matrixWorld),this.normalizeSkinWeights()}function xo(t){rr.call(this),this.type="LineBasicMaterial",this.color=new yi(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.lights=!1,this.setValues(t)}function bo(t,e,i){if(1===i)return console.warn("THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead."),new _o(t,e);Wi.call(this),this.type="Line",this.geometry=void 0!==t?t:new Ln,this.material=void 0!==e?e:new xo({color:16777215*Math.random()})}function _o(t,e){bo.call(this,t,e),this.type="LineSegments"}function wo(t,e){bo.call(this,t,e),this.type="LineLoop"}function Mo(t){rr.call(this),this.type="PointsMaterial",this.color=new yi(16777215),this.map=null,this.size=1,this.sizeAttenuation=!0,this.lights=!1,this.setValues(t)}function Eo(t,e){Wi.call(this),this.type="Points",this.geometry=void 0!==t?t:new Ln,this.material=void 0!==e?e:new Mo({color:16777215*Math.random()})}function To(){Wi.call(this),this.type="Group"}function So(t,e,i,n,r,a,o,s,h){ai.call(this,t,e,i,n,r,a,o,s,h),this.generateMipmaps=!1}function Ao(t,e,i,n,r,a,o,s,h,c,l,u){ai.call(this,null,a,o,s,h,c,n,r,l,u),this.image={width:e,height:i},this.mipmaps=t,this.flipY=!1,this.generateMipmaps=!1}function Lo(t,e,i,n,r,a,o,s,h,c){if((c=void 0!==c?c:Jt)!==Jt&&c!==Qt)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");void 0===i&&c===Jt&&(i=Ut),void 0===i&&c===Qt&&(i=kt),ai.call(this,null,n,r,a,o,s,c,i,h),this.image={width:t,height:e},this.magFilter=void 0!==o?o:Mt,this.minFilter=void 0!==s?s:Mt,this.flipY=!1,this.generateMipmaps=!1}function Ro(t){Ln.call(this),this.type="WireframeGeometry";var e,i,n,r,a,o,s,h,c,l,u=[],d=[0,0],p={},f=["a","b","c"];if(t&&t.isGeometry){var m=t.faces;for(e=0,n=m.length;e<n;e++){var g=m[e];for(i=0;i<3;i++)s=g[f[i]],h=g[f[(i+1)%3]],d[0]=Math.min(s,h),d[1]=Math.max(s,h),void 0===p[c=d[0]+","+d[1]]&&(p[c]={index1:d[0],index2:d[1]})}for(c in p)o=p[c],l=t.vertices[o.index1],u.push(l.x,l.y,l.z),l=t.vertices[o.index2],u.push(l.x,l.y,l.z)}else if(t&&t.isBufferGeometry){var v,y,x,b,_,w;if(l=new Ge,null!==t.index){for(v=t.attributes.position,y=t.index,0===(x=t.groups).length&&(x=[{start:0,count:y.count,materialIndex:0}]),r=0,a=x.length;r<a;++r)for(n=(e=(b=x[r]).start)+b.count;e<n;e+=3)for(i=0;i<3;i++)s=y.getX(e+i),h=y.getX(e+(i+1)%3),d[0]=Math.min(s,h),d[1]=Math.max(s,h),void 0===p[c=d[0]+","+d[1]]&&(p[c]={index1:d[0],index2:d[1]});for(c in p)o=p[c],l.fromBufferAttribute(v,o.index1),u.push(l.x,l.y,l.z),l.fromBufferAttribute(v,o.index2),u.push(l.x,l.y,l.z)}else for(e=0,n=(v=t.attributes.position).count/3;e<n;e++)for(i=0;i<3;i++)_=3*e+i,l.fromBufferAttribute(v,_),u.push(l.x,l.y,l.z),w=3*e+(i+1)%3,l.fromBufferAttribute(v,w),u.push(l.x,l.y,l.z)}this.addAttribute("position",new pn(u,3))}function Co(t,e,i){rn.call(this),this.type="ParametricGeometry",this.parameters={func:t,slices:e,stacks:i},this.fromBufferGeometry(new Po(t,e,i)),this.mergeVertices()}function Po(t,e,i){Ln.call(this),this.type="ParametricBufferGeometry",this.parameters={func:t,slices:e,stacks:i};var n,r,a=[],o=[],s=[],h=[],c=new Ge,l=new Ge,u=new Ge,d=new Ge,p=new Ge,f=e+1;for(n=0;n<=i;n++){var m=n/i;for(r=0;r<=e;r++){var g=r/e;t(g,m,l),o.push(l.x,l.y,l.z),0<=g-1e-5?(t(g-1e-5,m,u),d.subVectors(l,u)):(t(g+1e-5,m,u),d.subVectors(u,l)),0<=m-1e-5?(t(g,m-1e-5,u),p.subVectors(l,u)):(t(g,m+1e-5,u),p.subVectors(u,l)),c.crossVectors(d,p).normalize(),s.push(c.x,c.y,c.z),h.push(g,m)}}for(n=0;n<i;n++)for(r=0;r<e;r++){var v=n*f+r,y=n*f+r+1,x=(n+1)*f+r+1,b=(n+1)*f+r;a.push(v,y,b),a.push(y,x,b)}this.setIndex(a),this.addAttribute("position",new pn(o,3)),this.addAttribute("normal",new pn(s,3)),this.addAttribute("uv",new pn(h,2))}function Oo(t,e,i,n){rn.call(this),this.type="PolyhedronGeometry",this.parameters={vertices:t,indices:e,radius:i,detail:n},this.fromBufferGeometry(new Io(t,e,i,n)),this.mergeVertices()}function Io(n,a,t,e){Ln.call(this),this.type="PolyhedronBufferGeometry",this.parameters={vertices:n,indices:a,radius:t,detail:e},t=t||1;var l=[],u=[];function o(t,e,i,n){var r,a,o=Math.pow(2,n),s=[];for(r=0;r<=o;r++){s[r]=[];var h=t.clone().lerp(i,r/o),c=e.clone().lerp(i,r/o),l=o-r;for(a=0;a<=l;a++)s[r][a]=0===a&&r===o?h:h.clone().lerp(c,a/l)}for(r=0;r<o;r++)for(a=0;a<2*(o-r)-1;a++){var u=Math.floor(a/2);a%2==0?(d(s[r][u+1]),d(s[r+1][u]),d(s[r][u])):(d(s[r][u+1]),d(s[r+1][u+1]),d(s[r+1][u]))}}function d(t){l.push(t.x,t.y,t.z)}function s(t,e){var i=3*t;e.x=n[i+0],e.y=n[i+1],e.z=n[i+2]}function p(t,e,i,n){n<0&&1===t.x&&(u[e]=t.x-1),0===i.x&&0===i.z&&(u[e]=n/2/Math.PI+.5)}function f(t){return Math.atan2(t.z,-t.x)}!function(t){for(var e=new Ge,i=new Ge,n=new Ge,r=0;r<a.length;r+=3)s(a[r+0],e),s(a[r+1],i),s(a[r+2],n),o(e,i,n,t)}(e=e||0),function(t){for(var e=new Ge,i=0;i<l.length;i+=3)e.x=l[i+0],e.y=l[i+1],e.z=l[i+2],e.normalize().multiplyScalar(t),l[i+0]=e.x,l[i+1]=e.y,l[i+2]=e.z}(t),function(){for(var t=new Ge,e=0;e<l.length;e+=3){t.x=l[e+0],t.y=l[e+1],t.z=l[e+2];var i=f(t)/2/Math.PI+.5,n=(r=t,Math.atan2(-r.y,Math.sqrt(r.x*r.x+r.z*r.z))/Math.PI+.5);u.push(i,1-n)}var r;(function(){for(var t=new Ge,e=new Ge,i=new Ge,n=new Ge,r=new Be,a=new Be,o=new Be,s=0,h=0;s<l.length;s+=9,h+=6){t.set(l[s+0],l[s+1],l[s+2]),e.set(l[s+3],l[s+4],l[s+5]),i.set(l[s+6],l[s+7],l[s+8]),r.set(u[h+0],u[h+1]),a.set(u[h+2],u[h+3]),o.set(u[h+4],u[h+5]),n.copy(t).add(e).add(i).divideScalar(3);var c=f(n);p(r,h+0,t,c),p(a,h+2,e,c),p(o,h+4,i,c)}})(),function(){for(var t=0;t<u.length;t+=6){var e=u[t+0],i=u[t+2],n=u[t+4],r=Math.max(e,i,n),a=Math.min(e,i,n);.9<r&&a<.1&&(e<.2&&(u[t+0]+=1),i<.2&&(u[t+2]+=1),n<.2&&(u[t+4]+=1))}}()}(),this.addAttribute("position",new pn(l,3)),this.addAttribute("normal",new pn(l.slice(),3)),this.addAttribute("uv",new pn(u,2)),0===e?this.computeVertexNormals():this.normalizeNormals()}function No(t,e){rn.call(this),this.type="TetrahedronGeometry",this.parameters={radius:t,detail:e},this.fromBufferGeometry(new Uo(t,e)),this.mergeVertices()}function Uo(t,e){Io.call(this,[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],[2,1,0,0,3,2,1,3,0,2,3,1],t,e),this.type="TetrahedronBufferGeometry",this.parameters={radius:t,detail:e}}function Do(t,e){rn.call(this),this.type="OctahedronGeometry",this.parameters={radius:t,detail:e},this.fromBufferGeometry(new Bo(t,e)),this.mergeVertices()}function Bo(t,e){Io.call(this,[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2],t,e),this.type="OctahedronBufferGeometry",this.parameters={radius:t,detail:e}}function Fo(t,e){rn.call(this),this.type="IcosahedronGeometry",this.parameters={radius:t,detail:e},this.fromBufferGeometry(new zo(t,e)),this.mergeVertices()}function zo(t,e){var i=(1+Math.sqrt(5))/2;Io.call(this,[-1,i,0,1,i,0,-1,-i,0,1,-i,0,0,-1,i,0,1,i,0,-1,-i,0,1,-i,i,0,-1,i,0,1,-i,0,-1,-i,0,1],[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1],t,e),this.type="IcosahedronBufferGeometry",this.parameters={radius:t,detail:e}}function Go(t,e){rn.call(this),this.type="DodecahedronGeometry",this.parameters={radius:t,detail:e},this.fromBufferGeometry(new Ho(t,e)),this.mergeVertices()}function Ho(t,e){var i=(1+Math.sqrt(5))/2,n=1/i;Io.call(this,[-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-n,-i,0,-n,i,0,n,-i,0,n,i,-n,-i,0,-n,i,0,n,-i,0,n,i,0,-i,0,-n,i,0,-n,-i,0,n,i,0,n],[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9],t,e),this.type="DodecahedronBufferGeometry",this.parameters={radius:t,detail:e}}function Vo(t,e,i,n,r,a){rn.call(this),this.type="TubeGeometry",this.parameters={path:t,tubularSegments:e,radius:i,radialSegments:n,closed:r},void 0!==a&&console.warn("THREE.TubeGeometry: taper has been removed.");var o=new ko(t,e,i,n,r);this.tangents=o.tangents,this.normals=o.normals,this.binormals=o.binormals,this.fromBufferGeometry(o),this.mergeVertices()}function ko(o,s,h,c,t){Ln.call(this),this.type="TubeBufferGeometry",this.parameters={path:o,tubularSegments:s,radius:h,radialSegments:c,closed:t},s=s||64,h=h||1,c=c||8,t=t||!1;var l=o.computeFrenetFrames(s,t);this.tangents=l.tangents,this.normals=l.normals,this.binormals=l.binormals;var r,u,d=new Ge,p=new Ge,e=new Be,f=new Ge,m=[],g=[],i=[],a=[];function n(t){f=o.getPointAt(t/s,f);var e=l.normals[t],i=l.binormals[t];for(u=0;u<=c;u++){var n=u/c*Math.PI*2,r=Math.sin(n),a=-Math.cos(n);p.x=a*e.x+r*i.x,p.y=a*e.y+r*i.y,p.z=a*e.z+r*i.z,p.normalize(),g.push(p.x,p.y,p.z),d.x=f.x+h*p.x,d.y=f.y+h*p.y,d.z=f.z+h*p.z,m.push(d.x,d.y,d.z)}}!function(){for(r=0;r<s;r++)n(r);n(!1===t?s:0),function(){for(r=0;r<=s;r++)for(u=0;u<=c;u++)e.x=r/s,e.y=u/c,i.push(e.x,e.y)}(),function(){for(u=1;u<=s;u++)for(r=1;r<=c;r++){var t=(c+1)*(u-1)+(r-1),e=(c+1)*u+(r-1),i=(c+1)*u+r,n=(c+1)*(u-1)+r;a.push(t,e,n),a.push(e,i,n)}}()}(),this.setIndex(a),this.addAttribute("position",new pn(m,3)),this.addAttribute("normal",new pn(g,3)),this.addAttribute("uv",new pn(i,2))}function jo(t,e,i,n,r,a,o){rn.call(this),this.type="TorusKnotGeometry",this.parameters={radius:t,tube:e,tubularSegments:i,radialSegments:n,p:r,q:a},void 0!==o&&console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."),this.fromBufferGeometry(new Wo(t,e,i,n,r,a)),this.mergeVertices()}function Wo(t,e,i,n,r,a){Ln.call(this),this.type="TorusKnotBufferGeometry",this.parameters={radius:t,tube:e,tubularSegments:i,radialSegments:n,p:r,q:a},t=t||1,e=e||.4,i=Math.floor(i)||64,n=Math.floor(n)||8,r=r||2,a=a||3;var o,s,h=[],c=[],l=[],u=[],d=new Ge,p=new Ge,f=new Ge,m=new Ge,g=new Ge,v=new Ge,y=new Ge;for(o=0;o<=i;++o){var x=o/i*r*Math.PI*2;for(A(x,r,a,t,f),A(x+.01,r,a,t,m),v.subVectors(m,f),y.addVectors(m,f),g.crossVectors(v,y),y.crossVectors(g,v),g.normalize(),y.normalize(),s=0;s<=n;++s){var b=s/n*Math.PI*2,_=-e*Math.cos(b),w=e*Math.sin(b);d.x=f.x+(_*y.x+w*g.x),d.y=f.y+(_*y.y+w*g.y),d.z=f.z+(_*y.z+w*g.z),c.push(d.x,d.y,d.z),p.subVectors(d,f).normalize(),l.push(p.x,p.y,p.z),u.push(o/i),u.push(s/n)}}for(s=1;s<=i;s++)for(o=1;o<=n;o++){var M=(n+1)*(s-1)+(o-1),E=(n+1)*s+(o-1),T=(n+1)*s+o,S=(n+1)*(s-1)+o;h.push(M,E,S),h.push(E,T,S)}function A(t,e,i,n,r){var a=Math.cos(t),o=Math.sin(t),s=i/e*t,h=Math.cos(s);r.x=n*(2+h)*.5*a,r.y=n*(2+h)*o*.5,r.z=n*Math.sin(s)*.5}this.setIndex(h),this.addAttribute("position",new pn(c,3)),this.addAttribute("normal",new pn(l,3)),this.addAttribute("uv",new pn(u,2))}function Xo(t,e,i,n,r){rn.call(this),this.type="TorusGeometry",this.parameters={radius:t,tube:e,radialSegments:i,tubularSegments:n,arc:r},this.fromBufferGeometry(new qo(t,e,i,n,r)),this.mergeVertices()}function qo(t,e,i,n,r){Ln.call(this),this.type="TorusBufferGeometry",this.parameters={radius:t,tube:e,radialSegments:i,tubularSegments:n,arc:r},t=t||1,e=e||.4,i=Math.floor(i)||8,n=Math.floor(n)||6,r=r||2*Math.PI;var a,o,s=[],h=[],c=[],l=[],u=new Ge,d=new Ge,p=new Ge;for(a=0;a<=i;a++)for(o=0;o<=n;o++){var f=o/n*r,m=a/i*Math.PI*2;d.x=(t+e*Math.cos(m))*Math.cos(f),d.y=(t+e*Math.cos(m))*Math.sin(f),d.z=e*Math.sin(m),h.push(d.x,d.y,d.z),u.x=t*Math.cos(f),u.y=t*Math.sin(f),p.subVectors(d,u).normalize(),c.push(p.x,p.y,p.z),l.push(o/n),l.push(a/i)}for(a=1;a<=i;a++)for(o=1;o<=n;o++){var g=(n+1)*a+o-1,v=(n+1)*(a-1)+o-1,y=(n+1)*(a-1)+o,x=(n+1)*a+o;s.push(g,v,x),s.push(v,y,x)}this.setIndex(s),this.addAttribute("position",new pn(h,3)),this.addAttribute("normal",new pn(c,3)),this.addAttribute("uv",new pn(l,2))}((Ja.prototype=Object.create(rr.prototype)).constructor=Ja).prototype.isMeshDepthMaterial=!0,Ja.prototype.copy=function(t){return rr.prototype.copy.call(this,t),this.depthPacking=t.depthPacking,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this},((Qa.prototype=Object.create(rr.prototype)).constructor=Qa).prototype.isMeshDistanceMaterial=!0,Qa.prototype.copy=function(t){return rr.prototype.copy.call(this,t),this.referencePosition.copy(t.referencePosition),this.nearDistance=t.nearDistance,this.farDistance=t.farDistance,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this},(($a.prototype=Object.create(ai.prototype)).constructor=$a).prototype.isCanvasTexture=!0,ro.prototype=Object.assign(Object.create(Xi.prototype),{constructor:ro,isPerspectiveCamera:!0,copy:function(t,e){return Xi.prototype.copy.call(this,t,e),this.fov=t.fov,this.zoom=t.zoom,this.near=t.near,this.far=t.far,this.focus=t.focus,this.aspect=t.aspect,this.view=null===t.view?null:Object.assign({},t.view),this.filmGauge=t.filmGauge,this.filmOffset=t.filmOffset,this},setFocalLength:function(t){var e=.5*this.getFilmHeight()/t;this.fov=2*De.RAD2DEG*Math.atan(e),this.updateProjectionMatrix()},getFocalLength:function(){var t=Math.tan(.5*De.DEG2RAD*this.fov);return.5*this.getFilmHeight()/t},getEffectiveFOV:function(){return 2*De.RAD2DEG*Math.atan(Math.tan(.5*De.DEG2RAD*this.fov)/this.zoom)},getFilmWidth:function(){return this.filmGauge*Math.min(this.aspect,1)},getFilmHeight:function(){return this.filmGauge/Math.max(this.aspect,1)},setViewOffset:function(t,e,i,n,r,a){this.aspect=t/e,null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=i,this.view.offsetY=n,this.view.width=r,this.view.height=a,this.updateProjectionMatrix()},clearViewOffset:function(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()},updateProjectionMatrix:function(){var t=this.near,e=t*Math.tan(.5*De.DEG2RAD*this.fov)/this.zoom,i=2*e,n=this.aspect*i,r=-.5*n,a=this.view;if(null!==this.view&&this.view.enabled){var o=a.fullWidth,s=a.fullHeight;r+=a.offsetX*n/o,e-=a.offsetY*i/s,n*=a.width/o,i*=a.height/s}var h=this.filmOffset;0!==h&&(r+=t*h/this.getFilmWidth()),this.projectionMatrix.makePerspective(r,r+n,e,e-i,t,this.far)},toJSON:function(t){var e=Wi.prototype.toJSON.call(this,t);return e.object.fov=this.fov,e.object.zoom=this.zoom,e.object.near=this.near,e.object.far=this.far,e.object.focus=this.focus,e.object.aspect=this.aspect,null!==this.view&&(e.object.view=Object.assign({},this.view)),e.object.filmGauge=this.filmGauge,e.object.filmOffset=this.filmOffset,e}}),ao.prototype=Object.assign(Object.create(ro.prototype),{constructor:ao,isArrayCamera:!0}),co.prototype.isFogExp2=!0,co.prototype.clone=function(){return new co(this.color,this.density)},co.prototype.toJSON=function(){return{type:"FogExp2",color:this.color.getHex(),density:this.density}},lo.prototype.isFog=!0,lo.prototype.clone=function(){return new lo(this.color,this.near,this.far)},lo.prototype.toJSON=function(){return{type:"Fog",color:this.color.getHex(),near:this.near,far:this.far}},uo.prototype=Object.assign(Object.create(Wi.prototype),{constructor:uo,copy:function(t,e){return Wi.prototype.copy.call(this,t,e),null!==t.background&&(this.background=t.background.clone()),null!==t.fog&&(this.fog=t.fog.clone()),null!==t.overrideMaterial&&(this.overrideMaterial=t.overrideMaterial.clone()),this.autoUpdate=t.autoUpdate,this.matrixAutoUpdate=t.matrixAutoUpdate,this},toJSON:function(t){var e=Wi.prototype.toJSON.call(this,t);return null!==this.background&&(e.object.background=this.background.toJSON(t)),null!==this.fog&&(e.object.fog=this.fog.toJSON()),e}}),((po.prototype=Object.create(rr.prototype)).constructor=po).prototype.isSpriteMaterial=!0,po.prototype.copy=function(t){return rr.prototype.copy.call(this,t),this.color.copy(t.color),this.map=t.map,this.rotation=t.rotation,this},fo.prototype=Object.assign(Object.create(Wi.prototype),{constructor:fo,isSprite:!0,raycast:(La=new Ge,Ra=new Ge,Ca=new Ge,function(t,e){Ra.setFromMatrixPosition(this.matrixWorld),t.ray.closestPointToPoint(Ra,La),Ca.setFromMatrixScale(this.matrixWorld);var i=Ca.x*Ca.y/4;if(!(Ra.distanceToSquared(La)>i)){var n=t.ray.origin.distanceTo(La);n<t.near||n>t.far||e.push({distance:n,point:La.clone(),face:null,object:this})}}),clone:function(){return new this.constructor(this.material).copy(this)},copy:function(t){return Wi.prototype.copy.call(this,t),void 0!==t.center&&this.center.copy(t.center),this}}),mo.prototype=Object.assign(Object.create(Wi.prototype),{constructor:mo,copy:function(t){Wi.prototype.copy.call(this,t,!1);for(var e=t.levels,i=0,n=e.length;i<n;i++){var r=e[i];this.addLevel(r.object.clone(),r.distance)}return this},addLevel:function(t,e){void 0===e&&(e=0),e=Math.abs(e);for(var i=this.levels,n=0;n<i.length&&!(e<i[n].distance);n++);i.splice(n,0,{distance:e,object:t}),this.add(t)},getObjectForDistance:function(t){for(var e=this.levels,i=1,n=e.length;i<n&&!(t<e[i].distance);i++);return e[i-1].object},raycast:(Ia=new Ge,function(t,e){Ia.setFromMatrixPosition(this.matrixWorld);var i=t.ray.origin.distanceTo(Ia);this.getObjectForDistance(i).raycast(t,e)}),update:(Pa=new Ge,Oa=new Ge,function(t){var e=this.levels;if(1<e.length){Pa.setFromMatrixPosition(t.matrixWorld),Oa.setFromMatrixPosition(this.matrixWorld);var i=Pa.distanceTo(Oa);e[0].object.visible=!0;for(var n=1,r=e.length;n<r&&i>=e[n].distance;n++)e[n-1].object.visible=!1,e[n].object.visible=!0;for(;n<r;n++)e[n].object.visible=!1}}),toJSON:function(t){var e=Wi.prototype.toJSON.call(this,t);e.object.levels=[];for(var i=this.levels,n=0,r=i.length;n<r;n++){var a=i[n];e.object.levels.push({object:a.object.uuid,distance:a.distance})}return e}}),Object.assign(go.prototype,{calculateInverses:function(){this.boneInverses=[];for(var t=0,e=this.bones.length;t<e;t++){var i=new Fe;this.bones[t]&&i.getInverse(this.bones[t].matrixWorld),this.boneInverses.push(i)}},pose:function(){var t,e,i;for(e=0,i=this.bones.length;e<i;e++)(t=this.bones[e])&&t.matrixWorld.getInverse(this.boneInverses[e]);for(e=0,i=this.bones.length;e<i;e++)(t=this.bones[e])&&(t.parent&&t.parent.isBone?(t.matrix.getInverse(t.parent.matrixWorld),t.matrix.multiply(t.matrixWorld)):t.matrix.copy(t.matrixWorld),t.matrix.decompose(t.position,t.quaternion,t.scale))},update:(Na=new Fe,Ua=new Fe,function(){for(var t=this.bones,e=this.boneInverses,i=this.boneMatrices,n=this.boneTexture,r=0,a=t.length;r<a;r++){var o=t[r]?t[r].matrixWorld:Ua;Na.multiplyMatrices(o,e[r]),Na.toArray(i,16*r)}void 0!==n&&(n.needsUpdate=!0)}),clone:function(){return new go(this.bones,this.boneInverses)},getBoneByName:function(t){for(var e=0,i=this.bones.length;e<i;e++){var n=this.bones[e];if(n.name===t)return n}}}),vo.prototype=Object.assign(Object.create(Wi.prototype),{constructor:vo,isBone:!0}),yo.prototype=Object.assign(Object.create(lr.prototype),{constructor:yo,isSkinnedMesh:!0,initBones:function(){var t,e,i,n,r=[];if(this.geometry&&void 0!==this.geometry.bones){for(i=0,n=this.geometry.bones.length;i<n;i++)e=this.geometry.bones[i],t=new vo,r.push(t),t.name=e.name,t.position.fromArray(e.pos),t.quaternion.fromArray(e.rotq),void 0!==e.scl&&t.scale.fromArray(e.scl);for(i=0,n=this.geometry.bones.length;i<n;i++)-1!==(e=this.geometry.bones[i]).parent&&null!==e.parent&&void 0!==r[e.parent]?r[e.parent].add(r[i]):this.add(r[i])}return this.updateMatrixWorld(!0),r},bind:function(t,e){this.skeleton=t,void 0===e&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),e=this.matrixWorld),this.bindMatrix.copy(e),this.bindMatrixInverse.getInverse(e)},pose:function(){this.skeleton.pose()},normalizeSkinWeights:function(){var t,e;if(this.geometry&&this.geometry.isGeometry)for(e=0;e<this.geometry.skinWeights.length;e++){var i=this.geometry.skinWeights[e];(t=1/i.manhattanLength())!==1/0?i.multiplyScalar(t):i.set(1,0,0,0)}else if(this.geometry&&this.geometry.isBufferGeometry){var n=new oi,r=this.geometry.attributes.skinWeight;for(e=0;e<r.count;e++)n.x=r.getX(e),n.y=r.getY(e),n.z=r.getZ(e),n.w=r.getW(e),(t=1/n.manhattanLength())!==1/0?n.multiplyScalar(t):n.set(1,0,0,0),r.setXYZW(e,n.x,n.y,n.z,n.w)}},updateMatrixWorld:function(t){lr.prototype.updateMatrixWorld.call(this,t),"attached"===this.bindMode?this.bindMatrixInverse.getInverse(this.matrixWorld):"detached"===this.bindMode?this.bindMatrixInverse.getInverse(this.bindMatrix):console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)},clone:function(){return new this.constructor(this.geometry,this.material).copy(this)}}),((xo.prototype=Object.create(rr.prototype)).constructor=xo).prototype.isLineBasicMaterial=!0,xo.prototype.copy=function(t){return rr.prototype.copy.call(this,t),this.color.copy(t.color),this.linewidth=t.linewidth,this.linecap=t.linecap,this.linejoin=t.linejoin,this},bo.prototype=Object.assign(Object.create(Wi.prototype),{constructor:bo,isLine:!0,computeLineDistances:(za=new Ge,Ga=new Ge,function(){var t=this.geometry;if(t.isBufferGeometry)if(null===t.index){for(var e=t.attributes.position,i=[0],n=1,r=e.count;n<r;n++)za.fromBufferAttribute(e,n-1),Ga.fromBufferAttribute(e,n),i[n]=i[n-1],i[n]+=za.distanceTo(Ga);t.addAttribute("lineDistance",new pn(i,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else if(t.isGeometry){var a=t.vertices;for((i=t.lineDistances)[0]=0,n=1,r=a.length;n<r;n++)i[n]=i[n-1],i[n]+=a[n-1].distanceTo(a[n])}return this}),raycast:(Da=new Fe,Ba=new sr,Fa=new ui,function(t,e){var i=t.linePrecision,n=i*i,r=this.geometry,a=this.matrixWorld;if(null===r.boundingSphere&&r.computeBoundingSphere(),Fa.copy(r.boundingSphere),Fa.applyMatrix4(a),!1!==t.ray.intersectsSphere(Fa)){Da.getInverse(a),Ba.copy(t.ray).applyMatrix4(Da);var o=new Ge,s=new Ge,h=new Ge,c=new Ge,l=this&&this.isLineSegments?2:1;if(r.isBufferGeometry){var u=r.index,d=r.attributes.position.array;if(null!==u)for(var p=u.array,f=0,m=p.length-1;f<m;f+=l){var g=p[f],v=p[f+1];o.fromArray(d,3*g),s.fromArray(d,3*v),n<Ba.distanceSqToSegment(o,s,c,h)||(c.applyMatrix4(this.matrixWorld),(b=t.ray.origin.distanceTo(c))<t.near||b>t.far||e.push({distance:b,point:h.clone().applyMatrix4(this.matrixWorld),index:f,face:null,faceIndex:null,object:this}))}else for(f=0,m=d.length/3-1;f<m;f+=l)o.fromArray(d,3*f),s.fromArray(d,3*f+3),n<Ba.distanceSqToSegment(o,s,c,h)||(c.applyMatrix4(this.matrixWorld),(b=t.ray.origin.distanceTo(c))<t.near||b>t.far||e.push({distance:b,point:h.clone().applyMatrix4(this.matrixWorld),index:f,face:null,faceIndex:null,object:this}))}else if(r.isGeometry){var y=r.vertices,x=y.length;for(f=0;f<x-1;f+=l){var b;n<Ba.distanceSqToSegment(y[f],y[f+1],c,h)||(c.applyMatrix4(this.matrixWorld),(b=t.ray.origin.distanceTo(c))<t.near||b>t.far||e.push({distance:b,point:h.clone().applyMatrix4(this.matrixWorld),index:f,face:null,faceIndex:null,object:this}))}}}}),clone:function(){return new this.constructor(this.geometry,this.material).copy(this)}}),_o.prototype=Object.assign(Object.create(bo.prototype),{constructor:_o,isLineSegments:!0,computeLineDistances:(Ha=new Ge,Va=new Ge,function(){var t=this.geometry;if(t.isBufferGeometry)if(null===t.index){for(var e=t.attributes.position,i=[],n=0,r=e.count;n<r;n+=2)Ha.fromBufferAttribute(e,n),Va.fromBufferAttribute(e,n+1),i[n]=0===n?0:i[n-1],i[n+1]=i[n]+Ha.distanceTo(Va);t.addAttribute("lineDistance",new pn(i,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else if(t.isGeometry){var a=t.vertices;for(i=t.lineDistances,n=0,r=a.length;n<r;n+=2)Ha.copy(a[n]),Va.copy(a[n+1]),i[n]=0===n?0:i[n-1],i[n+1]=i[n]+Ha.distanceTo(Va)}return this})}),wo.prototype=Object.assign(Object.create(bo.prototype),{constructor:wo,isLineLoop:!0}),((Mo.prototype=Object.create(rr.prototype)).constructor=Mo).prototype.isPointsMaterial=!0,Mo.prototype.copy=function(t){return rr.prototype.copy.call(this,t),this.color.copy(t.color),this.map=t.map,this.size=t.size,this.sizeAttenuation=t.sizeAttenuation,this},Eo.prototype=Object.assign(Object.create(Wi.prototype),{constructor:Eo,isPoints:!0,raycast:(ka=new Fe,ja=new sr,Wa=new ui,function(r,a){var o=this,t=this.geometry,s=this.matrixWorld,e=r.params.Points.threshold;if(null===t.boundingSphere&&t.computeBoundingSphere(),Wa.copy(t.boundingSphere),Wa.applyMatrix4(s),Wa.radius+=e,!1!==r.ray.intersectsSphere(Wa)){ka.getInverse(s),ja.copy(r.ray).applyMatrix4(ka);var i=e/((this.scale.x+this.scale.y+this.scale.z)/3),h=i*i,n=new Ge,c=new Ge;if(t.isBufferGeometry){var l=t.index,u=t.attributes.position.array;if(null!==l)for(var d=l.array,p=0,f=d.length;p<f;p++){var m=d[p];n.fromArray(u,3*m),y(n,m)}else{p=0;for(var g=u.length/3;p<g;p++)n.fromArray(u,3*p),y(n,p)}}else{var v=t.vertices;for(p=0,g=v.length;p<g;p++)y(v[p],p)}}function y(t,e){var i=ja.distanceSqToPoint(t);if(i<h){ja.closestPointToPoint(t,c),c.applyMatrix4(s);var n=r.ray.origin.distanceTo(c);if(n<r.near||n>r.far)return;a.push({distance:n,distanceToRay:Math.sqrt(i),point:c.clone(),index:e,face:null,object:o})}}}),clone:function(){return new this.constructor(this.geometry,this.material).copy(this)}}),To.prototype=Object.assign(Object.create(Wi.prototype),{constructor:To,isGroup:!0}),So.prototype=Object.assign(Object.create(ai.prototype),{constructor:So,isVideoTexture:!0,update:function(){var t=this.image;t.readyState>=t.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}),((Ao.prototype=Object.create(ai.prototype)).constructor=Ao).prototype.isCompressedTexture=!0,((Lo.prototype=Object.create(ai.prototype)).constructor=Lo).prototype.isDepthTexture=!0,(Ro.prototype=Object.create(Ln.prototype)).constructor=Ro,(Co.prototype=Object.create(rn.prototype)).constructor=Co,(Po.prototype=Object.create(Ln.prototype)).constructor=Po,(Oo.prototype=Object.create(rn.prototype)).constructor=Oo,(Io.prototype=Object.create(Ln.prototype)).constructor=Io,(No.prototype=Object.create(rn.prototype)).constructor=No,(Uo.prototype=Object.create(Io.prototype)).constructor=Uo,(Do.prototype=Object.create(rn.prototype)).constructor=Do,(Bo.prototype=Object.create(Io.prototype)).constructor=Bo,(Fo.prototype=Object.create(rn.prototype)).constructor=Fo,(zo.prototype=Object.create(Io.prototype)).constructor=zo,(Go.prototype=Object.create(rn.prototype)).constructor=Go,(Ho.prototype=Object.create(Io.prototype)).constructor=Ho,(Vo.prototype=Object.create(rn.prototype)).constructor=Vo,(ko.prototype=Object.create(Ln.prototype)).constructor=ko,(jo.prototype=Object.create(rn.prototype)).constructor=jo,(Wo.prototype=Object.create(Ln.prototype)).constructor=Wo,(Xo.prototype=Object.create(rn.prototype)).constructor=Xo,(qo.prototype=Object.create(Ln.prototype)).constructor=qo;var Yo=function(t,e,i){i=i||2;var n,r,a,o,s,h,c,l=e&&e.length,u=l?e[0]*i:t.length,d=Zo(t,0,u,i,!0),p=[];if(!d)return p;if(l&&(d=function(t,e,i,n){var r,a,o,s,h,c=[];for(r=0,a=e.length;r<a;r++)o=e[r]*n,s=r<a-1?e[r+1]*n:t.length,(h=Zo(t,o,s,n,!1))===h.next&&(h.steiner=!0),c.push(as(h));for(c.sort(is),r=0;r<c.length;r++)ns(c[r],i),i=Jo(i,i.next);return i}(t,e,d,i)),t.length>80*i){n=a=t[0],r=o=t[1];for(var f=i;f<u;f+=i)(s=t[f])<n&&(n=s),(h=t[f+1])<r&&(r=h),a<s&&(a=s),o<h&&(o=h);c=0!==(c=Math.max(a-n,o-r))?1/c:0}return Qo(d,p,i,n,r,c),p};function Zo(t,e,i,n,r){var a,o;if(r===0<function(t,e,i,n){for(var r=0,a=e,o=i-n;a<i;a+=n)r+=(t[o]-t[a])*(t[a+1]+t[o+1]),o=a;return r}(t,e,i,n))for(a=e;a<i;a+=n)o=ds(a,t[a],t[a+1],o);else for(a=i-n;e<=a;a-=n)o=ds(a,t[a],t[a+1],o);return o&&hs(o,o.next)&&(ps(o),o=o.next),o}function Jo(t,e){if(!t)return t;e||(e=t);var i,n=t;do{if(i=!1,n.steiner||!hs(n,n.next)&&0!==ss(n.prev,n,n.next))n=n.next;else{if(ps(n),(n=e=n.prev)===n.next)break;i=!0}}while(i||n!==e);return e}function Qo(t,e,i,n,r,a,o){if(t){!o&&a&&function(t,e,i,n){var r=t;for(;null===r.z&&(r.z=rs(r.x,r.y,e,i,n)),r.prevZ=r.prev,r.nextZ=r.next,r=r.next,r!==t;);r.prevZ.nextZ=null,r.prevZ=null,function(t){var e,i,n,r,a,o,s,h,c=1;do{for(i=t,a=t=null,o=0;i;){for(o++,n=i,e=s=0;e<c&&(s++,n=n.nextZ);e++);for(h=c;0<s||0<h&&n;)0!==s&&(0===h||!n||i.z<=n.z)?(i=(r=i).nextZ,s--):(n=(r=n).nextZ,h--),a?a.nextZ=r:t=r,r.prevZ=a,a=r;i=n}a.nextZ=null,c*=2}while(1<o)}(r)}(t,n,r,a);for(var s,h,c=t;t.prev!==t.next;)if(s=t.prev,h=t.next,a?$o(t,n,r,a):Ko(t))e.push(s.i/i),e.push(t.i/i),e.push(h.i/i),ps(t),t=h.next,c=h.next;else if((t=h)===c){o?1===o?Qo(t=ts(t,e,i),e,i,n,r,a,2):2===o&&es(t,e,i,n,r,a):Qo(Jo(t),e,i,n,r,a,1);break}}}function Ko(t){var e=t.prev,i=t,n=t.next;if(0<=ss(e,i,n))return!1;for(var r=t.next.next;r!==t.prev;){if(os(e.x,e.y,i.x,i.y,n.x,n.y,r.x,r.y)&&0<=ss(r.prev,r,r.next))return!1;r=r.next}return!0}function $o(t,e,i,n){var r=t.prev,a=t,o=t.next;if(0<=ss(r,a,o))return!1;for(var s=r.x<a.x?r.x<o.x?r.x:o.x:a.x<o.x?a.x:o.x,h=r.y<a.y?r.y<o.y?r.y:o.y:a.y<o.y?a.y:o.y,c=r.x>a.x?r.x>o.x?r.x:o.x:a.x>o.x?a.x:o.x,l=r.y>a.y?r.y>o.y?r.y:o.y:a.y>o.y?a.y:o.y,u=rs(s,h,e,i,n),d=rs(c,l,e,i,n),p=t.nextZ;p&&p.z<=d;){if(p!==t.prev&&p!==t.next&&os(r.x,r.y,a.x,a.y,o.x,o.y,p.x,p.y)&&0<=ss(p.prev,p,p.next))return!1;p=p.nextZ}for(p=t.prevZ;p&&p.z>=u;){if(p!==t.prev&&p!==t.next&&os(r.x,r.y,a.x,a.y,o.x,o.y,p.x,p.y)&&0<=ss(p.prev,p,p.next))return!1;p=p.prevZ}return!0}function ts(t,e,i){var n=t;do{var r=n.prev,a=n.next.next;!hs(r,a)&&cs(r,n,n.next,a)&&ls(r,a)&&ls(a,r)&&(e.push(r.i/i),e.push(n.i/i),e.push(a.i/i),ps(n),ps(n.next),n=t=a),n=n.next}while(n!==t);return n}function es(t,e,i,n,r,a){var o,s,h=t;do{for(var c=h.next.next;c!==h.prev;){if(h.i!==c.i&&(s=c,(o=h).next.i!==s.i&&o.prev.i!==s.i&&!function(t,e){var i=t;do{if(i.i!==t.i&&i.next.i!==t.i&&i.i!==e.i&&i.next.i!==e.i&&cs(i,i.next,t,e))return!0;i=i.next}while(i!==t);return!1}(o,s)&&ls(o,s)&&ls(s,o)&&function(t,e){var i=t,n=!1,r=(t.x+e.x)/2,a=(t.y+e.y)/2;for(;i.y>a!=i.next.y>a&&i.next.y!==i.y&&r<(i.next.x-i.x)*(a-i.y)/(i.next.y-i.y)+i.x&&(n=!n),i=i.next,i!==t;);return n}(o,s))){var l=us(h,c);return h=Jo(h,h.next),l=Jo(l,l.next),Qo(h,e,i,n,r,a),void Qo(l,e,i,n,r,a)}c=c.next}h=h.next}while(h!==t)}function is(t,e){return t.x-e.x}function ns(t,e){if(e=function(t,e){var i,n=e,r=t.x,a=t.y,o=-1/0;do{if(a<=n.y&&a>=n.next.y&&n.next.y!==n.y){var s=n.x+(a-n.y)*(n.next.x-n.x)/(n.next.y-n.y);if(s<=r&&o<s){if((o=s)===r){if(a===n.y)return n;if(a===n.next.y)return n.next}i=n.x<n.next.x?n:n.next}}n=n.next}while(n!==e);if(!i)return null;if(r===o)return i.prev;var h,c=i,l=i.x,u=i.y,d=1/0;n=i.next;for(;n!==c;)r>=n.x&&n.x>=l&&r!==n.x&&os(a<u?r:o,a,l,u,a<u?o:r,a,n.x,n.y)&&((h=Math.abs(a-n.y)/(r-n.x))<d||h===d&&n.x>i.x)&&ls(n,t)&&(i=n,d=h),n=n.next;return i}(t,e)){var i=us(e,t);Jo(i,i.next)}}function rs(t,e,i,n,r){return(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=32767*(t-i)*r)|t<<8))|t<<4))|t<<2))|t<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=32767*(e-n)*r)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function as(t){for(var e=t,i=t;e.x<i.x&&(i=e),(e=e.next)!==t;);return i}function os(t,e,i,n,r,a,o,s){return 0<=(r-o)*(e-s)-(t-o)*(a-s)&&0<=(t-o)*(n-s)-(i-o)*(e-s)&&0<=(i-o)*(a-s)-(r-o)*(n-s)}function ss(t,e,i){return(e.y-t.y)*(i.x-e.x)-(e.x-t.x)*(i.y-e.y)}function hs(t,e){return t.x===e.x&&t.y===e.y}function cs(t,e,i,n){return!!(hs(t,e)&&hs(i,n)||hs(t,n)&&hs(i,e))||0<ss(t,e,i)!=0<ss(t,e,n)&&0<ss(i,n,t)!=0<ss(i,n,e)}function ls(t,e){return ss(t.prev,t,t.next)<0?0<=ss(t,e,t.next)&&0<=ss(t,t.prev,e):ss(t,e,t.prev)<0||ss(t,t.next,e)<0}function us(t,e){var i=new fs(t.i,t.x,t.y),n=new fs(e.i,e.x,e.y),r=t.next,a=e.prev;return(t.next=e).prev=t,(i.next=r).prev=i,(n.next=i).prev=n,(a.next=n).prev=a,n}function ds(t,e,i,n){var r=new fs(t,e,i);return n?(r.next=n.next,(r.prev=n).next.prev=r,n.next=r):(r.prev=r).next=r,r}function ps(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function fs(t,e,i){this.i=t,this.x=e,this.y=i,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}var ms={area:function(t){for(var e=t.length,i=0,n=e-1,r=0;r<e;n=r++)i+=t[n].x*t[r].y-t[r].x*t[n].y;return.5*i},isClockWise:function(t){return ms.area(t)<0},triangulateShape:function(t,e){var i=[],n=[],r=[];gs(t),vs(i,t);var a=t.length;e.forEach(gs);for(var o=0;o<e.length;o++)n.push(a),a+=e[o].length,vs(i,e[o]);var s=Yo(i,n);for(o=0;o<s.length;o+=3)r.push(s.slice(o,o+3));return r}};function gs(t){var e=t.length;2<e&&t[e-1].equals(t[0])&&t.pop()}function vs(t,e){for(var i=0;i<e.length;i++)t.push(e[i].x),t.push(e[i].y)}function ys(t,e){rn.call(this),this.type="ExtrudeGeometry",this.parameters={shapes:t,options:e},this.fromBufferGeometry(new xs(t,e)),this.mergeVertices()}function xs(t,J){Ln.call(this),this.type="ExtrudeBufferGeometry",this.parameters={shapes:t,options:J},t=Array.isArray(t)?t:[t];for(var Q=this,K=[],$=[],e=0,i=t.length;e<i;e++){n(t[e])}function n(t){var n=[],e=void 0!==J.curveSegments?J.curveSegments:12,h=void 0!==J.steps?J.steps:1,i=void 0!==J.depth?J.depth:100,r=void 0===J.bevelEnabled||J.bevelEnabled,a=void 0!==J.bevelThickness?J.bevelThickness:6,o=void 0!==J.bevelSize?J.bevelSize:a-2,c=void 0!==J.bevelSegments?J.bevelSegments:3,s=J.extrudePath,l=void 0!==J.UVGenerator?J.UVGenerator:bs;void 0!==J.amount&&(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),i=J.amount);var u,d,p,f,m,g,v,y,x=!1;s&&(u=s.getSpacedPoints(h),r=!(x=!0),d=s.computeFrenetFrames(h,!1),p=new Ge,f=new Ge,m=new Ge),r||(o=a=c=0);var b=t.extractPoints(e),_=b.shape,w=b.holes;if(!ms.isClockWise(_))for(_=_.reverse(),v=0,y=w.length;v<y;v++)g=w[v],ms.isClockWise(g)&&(w[v]=g.reverse());var M=ms.triangulateShape(_,w),E=_;for(v=0,y=w.length;v<y;v++)g=w[v],_=_.concat(g);function T(t,e,i){return e||console.error("THREE.ExtrudeGeometry: vec does not exist"),e.clone().multiplyScalar(i).add(t)}var S,A,L,R,C,P,O=_.length,I=M.length;function N(t,e,i){var n,r,a,o=t.x-e.x,s=t.y-e.y,h=i.x-t.x,c=i.y-t.y,l=o*o+s*s,u=o*c-s*h;if(Math.abs(u)>Number.EPSILON){var d=Math.sqrt(l),p=Math.sqrt(h*h+c*c),f=e.x-s/d,m=e.y+o/d,g=((i.x-c/p-f)*c-(i.y+h/p-m)*h)/(o*c-s*h),v=(n=f+o*g-t.x)*n+(r=m+s*g-t.y)*r;if(v<=2)return new Be(n,r);a=Math.sqrt(v/2)}else{var y=!1;o>Number.EPSILON?h>Number.EPSILON&&(y=!0):o<-Number.EPSILON?h<-Number.EPSILON&&(y=!0):Math.sign(s)===Math.sign(c)&&(y=!0),y?(n=-s,r=o,a=Math.sqrt(l)):(n=o,r=s,a=Math.sqrt(l/2))}return new Be(n/a,r/a)}for(var U=[],D=0,B=E.length,F=B-1,z=D+1;D<B;D++,F++,z++)F===B&&(F=0),z===B&&(z=0),U[D]=N(E[D],E[F],E[z]);var G,H,V=[],k=U.concat();for(v=0,y=w.length;v<y;v++){for(g=w[v],G=[],D=0,F=(B=g.length)-1,z=D+1;D<B;D++,F++,z++)F===B&&(F=0),z===B&&(z=0),G[D]=N(g[D],g[F],g[z]);V.push(G),k=k.concat(G)}for(S=0;S<c;S++){for(L=S/c,R=a*Math.cos(L*Math.PI/2),A=o*Math.sin(L*Math.PI/2),D=0,B=E.length;D<B;D++)W((C=T(E[D],U[D],A)).x,C.y,-R);for(v=0,y=w.length;v<y;v++)for(g=w[v],G=V[v],D=0,B=g.length;D<B;D++)W((C=T(g[D],G[D],A)).x,C.y,-R)}for(A=o,D=0;D<O;D++)C=r?T(_[D],k[D],A):_[D],x?(f.copy(d.normals[0]).multiplyScalar(C.x),p.copy(d.binormals[0]).multiplyScalar(C.y),m.copy(u[0]).add(f).add(p),W(m.x,m.y,m.z)):W(C.x,C.y,0);for(H=1;H<=h;H++)for(D=0;D<O;D++)C=r?T(_[D],k[D],A):_[D],x?(f.copy(d.normals[H]).multiplyScalar(C.x),p.copy(d.binormals[H]).multiplyScalar(C.y),m.copy(u[H]).add(f).add(p),W(m.x,m.y,m.z)):W(C.x,C.y,i/h*H);for(S=c-1;0<=S;S--){for(L=S/c,R=a*Math.cos(L*Math.PI/2),A=o*Math.sin(L*Math.PI/2),D=0,B=E.length;D<B;D++)W((C=T(E[D],U[D],A)).x,C.y,i+R);for(v=0,y=w.length;v<y;v++)for(g=w[v],G=V[v],D=0,B=g.length;D<B;D++)C=T(g[D],G[D],A),x?W(C.x,C.y+u[h-1].y,u[h-1].x+R):W(C.x,C.y,i+R)}function j(t,e){var i,n;for(D=t.length;0<=--D;){(n=(i=D)-1)<0&&(n=t.length-1);var r=0,a=h+2*c;for(r=0;r<a;r++){var o=O*r,s=O*(r+1);q(e+i+o,e+n+o,e+n+s,e+i+s)}}}function W(t,e,i){n.push(t),n.push(e),n.push(i)}function X(t,e,i){Y(t),Y(e),Y(i);var n=K.length/3,r=l.generateTopUV(Q,K,n-3,n-2,n-1);Z(r[0]),Z(r[1]),Z(r[2])}function q(t,e,i,n){Y(t),Y(e),Y(n),Y(e),Y(i),Y(n);var r=K.length/3,a=l.generateSideWallUV(Q,K,r-6,r-3,r-2,r-1);Z(a[0]),Z(a[1]),Z(a[3]),Z(a[1]),Z(a[2]),Z(a[3])}function Y(t){K.push(n[3*t+0]),K.push(n[3*t+1]),K.push(n[3*t+2])}function Z(t){$.push(t.x),$.push(t.y)}!function(){var t=K.length/3;if(r){var e=0,i=O*e;for(D=0;D<I;D++)X((P=M[D])[2]+i,P[1]+i,P[0]+i);for(i=O*(e=h+2*c),D=0;D<I;D++)X((P=M[D])[0]+i,P[1]+i,P[2]+i)}else{for(D=0;D<I;D++)X((P=M[D])[2],P[1],P[0]);for(D=0;D<I;D++)X((P=M[D])[0]+O*h,P[1]+O*h,P[2]+O*h)}Q.addGroup(t,K.length/3-t,0)}(),function(){var t=K.length/3,e=0;for(j(E,e),e+=E.length,v=0,y=w.length;v<y;v++)j(g=w[v],e),e+=g.length;Q.addGroup(t,K.length/3-t,1)}()}this.addAttribute("position",new pn(K,3)),this.addAttribute("uv",new pn($,2)),this.computeVertexNormals()}(ys.prototype=Object.create(rn.prototype)).constructor=ys,(xs.prototype=Object.create(Ln.prototype)).constructor=xs;var bs={generateTopUV:function(t,e,i,n,r){var a=e[3*i],o=e[3*i+1],s=e[3*n],h=e[3*n+1],c=e[3*r],l=e[3*r+1];return[new Be(a,o),new Be(s,h),new Be(c,l)]},generateSideWallUV:function(t,e,i,n,r,a){var o=e[3*i],s=e[3*i+1],h=e[3*i+2],c=e[3*n],l=e[3*n+1],u=e[3*n+2],d=e[3*r],p=e[3*r+1],f=e[3*r+2],m=e[3*a],g=e[3*a+1],v=e[3*a+2];return Math.abs(s-l)<.01?[new Be(o,1-h),new Be(c,1-u),new Be(d,1-f),new Be(m,1-v)]:[new Be(s,1-h),new Be(l,1-u),new Be(p,1-f),new Be(g,1-v)]}};function _s(t,e){rn.call(this),this.type="TextGeometry",this.parameters={text:t,parameters:e},this.fromBufferGeometry(new ws(t,e)),this.mergeVertices()}function ws(t,e){var i=(e=e||{}).font;if(!i||!i.isFont)return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."),new rn;var n=i.generateShapes(t,e.size,e.curveSegments);e.depth=void 0!==e.height?e.height:50,void 0===e.bevelThickness&&(e.bevelThickness=10),void 0===e.bevelSize&&(e.bevelSize=8),void 0===e.bevelEnabled&&(e.bevelEnabled=!1),xs.call(this,n,e),this.type="TextBufferGeometry"}function Ms(t,e,i,n,r,a,o){rn.call(this),this.type="SphereGeometry",this.parameters={radius:t,widthSegments:e,heightSegments:i,phiStart:n,phiLength:r,thetaStart:a,thetaLength:o},this.fromBufferGeometry(new Es(t,e,i,n,r,a,o)),this.mergeVertices()}function Es(t,e,i,n,r,a,o){Ln.call(this),this.type="SphereBufferGeometry",this.parameters={radius:t,widthSegments:e,heightSegments:i,phiStart:n,phiLength:r,thetaStart:a,thetaLength:o},t=t||1,e=Math.max(3,Math.floor(e)||8),i=Math.max(2,Math.floor(i)||6),n=void 0!==n?n:0,r=void 0!==r?r:2*Math.PI;var s,h,c=(a=void 0!==a?a:0)+(o=void 0!==o?o:Math.PI),l=0,u=[],d=new Ge,p=new Ge,f=[],m=[],g=[],v=[];for(h=0;h<=i;h++){var y=[],x=h/i;for(s=0;s<=e;s++){var b=s/e;d.x=-t*Math.cos(n+b*r)*Math.sin(a+x*o),d.y=t*Math.cos(a+x*o),d.z=t*Math.sin(n+b*r)*Math.sin(a+x*o),m.push(d.x,d.y,d.z),p.set(d.x,d.y,d.z).normalize(),g.push(p.x,p.y,p.z),v.push(b,1-x),y.push(l++)}u.push(y)}for(h=0;h<i;h++)for(s=0;s<e;s++){var _=u[h][s+1],w=u[h][s],M=u[h+1][s],E=u[h+1][s+1];(0!==h||0<a)&&f.push(_,w,E),(h!==i-1||c<Math.PI)&&f.push(w,M,E)}this.setIndex(f),this.addAttribute("position",new pn(m,3)),this.addAttribute("normal",new pn(g,3)),this.addAttribute("uv",new pn(v,2))}function Ts(t,e,i,n,r,a){rn.call(this),this.type="RingGeometry",this.parameters={innerRadius:t,outerRadius:e,thetaSegments:i,phiSegments:n,thetaStart:r,thetaLength:a},this.fromBufferGeometry(new Ss(t,e,i,n,r,a)),this.mergeVertices()}function Ss(t,e,i,n,r,a){Ln.call(this),this.type="RingBufferGeometry",this.parameters={innerRadius:t,outerRadius:e,thetaSegments:i,phiSegments:n,thetaStart:r,thetaLength:a},t=t||.5,e=e||1,r=void 0!==r?r:0,a=void 0!==a?a:2*Math.PI,i=void 0!==i?Math.max(3,i):8;var o,s,h,c=[],l=[],u=[],d=[],p=t,f=(e-t)/(n=void 0!==n?Math.max(1,n):1),m=new Ge,g=new Be;for(s=0;s<=n;s++){for(h=0;h<=i;h++)o=r+h/i*a,m.x=p*Math.cos(o),m.y=p*Math.sin(o),l.push(m.x,m.y,m.z),u.push(0,0,1),g.x=(m.x/e+1)/2,g.y=(m.y/e+1)/2,d.push(g.x,g.y);p+=f}for(s=0;s<n;s++){var v=s*(i+1);for(h=0;h<i;h++){var y=o=h+v,x=o+i+1,b=o+i+2,_=o+1;c.push(y,x,_),c.push(x,b,_)}}this.setIndex(c),this.addAttribute("position",new pn(l,3)),this.addAttribute("normal",new pn(u,3)),this.addAttribute("uv",new pn(d,2))}function As(t,e,i,n){rn.call(this),this.type="LatheGeometry",this.parameters={points:t,segments:e,phiStart:i,phiLength:n},this.fromBufferGeometry(new Ls(t,e,i,n)),this.mergeVertices()}function Ls(t,e,i,n){Ln.call(this),this.type="LatheBufferGeometry",this.parameters={points:t,segments:e,phiStart:i,phiLength:n},e=Math.floor(e)||12,i=i||0,n=n||2*Math.PI,n=De.clamp(n,0,2*Math.PI);var r,a,o,s=[],h=[],c=[],l=1/e,u=new Ge,d=new Be;for(a=0;a<=e;a++){var p=i+a*l*n,f=Math.sin(p),m=Math.cos(p);for(o=0;o<=t.length-1;o++)u.x=t[o].x*f,u.y=t[o].y,u.z=t[o].x*m,h.push(u.x,u.y,u.z),d.x=a/e,d.y=o/(t.length-1),c.push(d.x,d.y)}for(a=0;a<e;a++)for(o=0;o<t.length-1;o++){var g=r=o+a*t.length,v=r+t.length,y=r+t.length+1,x=r+1;s.push(g,v,x),s.push(v,y,x)}if(this.setIndex(s),this.addAttribute("position",new pn(h,3)),this.addAttribute("uv",new pn(c,2)),this.computeVertexNormals(),n===2*Math.PI){var b=this.attributes.normal.array,_=new Ge,w=new Ge,M=new Ge;for(r=e*t.length*3,o=a=0;a<t.length;a++,o+=3)_.x=b[o+0],_.y=b[o+1],_.z=b[o+2],w.x=b[r+o+0],w.y=b[r+o+1],w.z=b[r+o+2],M.addVectors(_,w).normalize(),b[o+0]=b[r+o+0]=M.x,b[o+1]=b[r+o+1]=M.y,b[o+2]=b[r+o+2]=M.z}}function Rs(t,e){rn.call(this),this.type="ShapeGeometry","object"==typeof e&&(console.warn("THREE.ShapeGeometry: Options parameter has been removed."),e=e.curveSegments),this.parameters={shapes:t,curveSegments:e},this.fromBufferGeometry(new Cs(t,e)),this.mergeVertices()}function Cs(t,f){Ln.call(this),this.type="ShapeBufferGeometry",this.parameters={shapes:t,curveSegments:f},f=f||12;var m=[],g=[],v=[],y=[],e=0,x=0;if(!1===Array.isArray(t))n(t);else for(var i=0;i<t.length;i++)n(t[i]),this.addGroup(e,x,i),e+=x,x=0;function n(t){var e,i,n,r=g.length/3,a=t.extractPoints(f),o=a.shape,s=a.holes;if(!1===ms.isClockWise(o))for(o=o.reverse(),e=0,i=s.length;e<i;e++)n=s[e],!0===ms.isClockWise(n)&&(s[e]=n.reverse());var h=ms.triangulateShape(o,s);for(e=0,i=s.length;e<i;e++)n=s[e],o=o.concat(n);for(e=0,i=o.length;e<i;e++){var c=o[e];g.push(c.x,c.y,0),v.push(0,0,1),y.push(c.x,c.y)}for(e=0,i=h.length;e<i;e++){var l=h[e],u=l[0]+r,d=l[1]+r,p=l[2]+r;m.push(u,d,p),x+=3}}this.setIndex(m),this.addAttribute("position",new pn(g,3)),this.addAttribute("normal",new pn(v,3)),this.addAttribute("uv",new pn(y,2))}function Ps(t,e){if(e.shapes=[],Array.isArray(t))for(var i=0,n=t.length;i<n;i++){var r=t[i];e.shapes.push(r.uuid)}else e.shapes.push(t.uuid);return e}function Os(t,e){Ln.call(this),this.type="EdgesGeometry",this.parameters={thresholdAngle:e},e=void 0!==e?e:1;var i,n,r,a,o=[],s=Math.cos(De.DEG2RAD*e),h=[0,0],c={},l=["a","b","c"];t.isBufferGeometry?(a=new rn).fromBufferGeometry(t):a=t.clone(),a.mergeVertices(),a.computeFaceNormals();for(var u=a.vertices,d=a.faces,p=0,f=d.length;p<f;p++)for(var m=d[p],g=0;g<3;g++)i=m[l[g]],n=m[l[(g+1)%3]],h[0]=Math.min(i,n),h[1]=Math.max(i,n),void 0===c[r=h[0]+","+h[1]]?c[r]={index1:h[0],index2:h[1],face1:p,face2:void 0}:c[r].face2=p;for(r in c){var v=c[r];if(void 0===v.face2||d[v.face1].normal.dot(d[v.face2].normal)<=s){var y=u[v.index1];o.push(y.x,y.y,y.z),y=u[v.index2],o.push(y.x,y.y,y.z)}}this.addAttribute("position",new pn(o,3))}function Is(t,e,i,n,r,a,o,s){rn.call(this),this.type="CylinderGeometry",this.parameters={radiusTop:t,radiusBottom:e,height:i,radialSegments:n,heightSegments:r,openEnded:a,thetaStart:o,thetaLength:s},this.fromBufferGeometry(new Ns(t,e,i,n,r,a,o,s)),this.mergeVertices()}function Ns(v,y,x,b,_,t,w,M){Ln.call(this),this.type="CylinderBufferGeometry",this.parameters={radiusTop:v,radiusBottom:y,height:x,radialSegments:b,heightSegments:_,openEnded:t,thetaStart:w,thetaLength:M};var E=this;v=void 0!==v?v:1,y=void 0!==y?y:1,x=x||1,b=Math.floor(b)||8,_=Math.floor(_)||1,t=void 0!==t&&t,w=void 0!==w?w:0,M=void 0!==M?M:2*Math.PI;var T=[],S=[],A=[],L=[],R=0,C=[],P=x/2,O=0;function e(t){var e,i,n,r=new Be,a=new Ge,o=0,s=!0===t?v:y,h=!0===t?1:-1;for(i=R,e=1;e<=b;e++)S.push(0,P*h,0),A.push(0,h,0),L.push(.5,.5),R++;for(n=R,e=0;e<=b;e++){var c=e/b*M+w,l=Math.cos(c),u=Math.sin(c);a.x=s*u,a.y=P*h,a.z=s*l,S.push(a.x,a.y,a.z),A.push(0,h,0),r.x=.5*l+.5,r.y=.5*u*h+.5,L.push(r.x,r.y),R++}for(e=0;e<b;e++){var d=i+e,p=n+e;!0===t?T.push(p,p+1,d):T.push(p+1,p,d),o+=3}E.addGroup(O,o,!0===t?1:2),O+=o}!function(){var t,e,i=new Ge,n=new Ge,r=0,a=(y-v)/x;for(e=0;e<=_;e++){var o=[],s=e/_,h=s*(y-v)+v;for(t=0;t<=b;t++){var c=t/b,l=c*M+w,u=Math.sin(l),d=Math.cos(l);n.x=h*u,n.y=-s*x+P,n.z=h*d,S.push(n.x,n.y,n.z),i.set(u,a,d).normalize(),A.push(i.x,i.y,i.z),L.push(c,1-s),o.push(R++)}C.push(o)}for(t=0;t<b;t++)for(e=0;e<_;e++){var p=C[e][t],f=C[e+1][t],m=C[e+1][t+1],g=C[e][t+1];T.push(p,f,g),T.push(f,m,g),r+=6}E.addGroup(O,r,0),O+=r}(),!1===t&&(0<v&&e(!0),0<y&&e(!1)),this.setIndex(T),this.addAttribute("position",new pn(S,3)),this.addAttribute("normal",new pn(A,3)),this.addAttribute("uv",new pn(L,2))}function Us(t,e,i,n,r,a,o){Is.call(this,0,t,e,i,n,r,a,o),this.type="ConeGeometry",this.parameters={radius:t,height:e,radialSegments:i,heightSegments:n,openEnded:r,thetaStart:a,thetaLength:o}}function Ds(t,e,i,n,r,a,o){Ns.call(this,0,t,e,i,n,r,a,o),this.type="ConeBufferGeometry",this.parameters={radius:t,height:e,radialSegments:i,heightSegments:n,openEnded:r,thetaStart:a,thetaLength:o}}function Bs(t,e,i,n){rn.call(this),this.type="CircleGeometry",this.parameters={radius:t,segments:e,thetaStart:i,thetaLength:n},this.fromBufferGeometry(new Fs(t,e,i,n)),this.mergeVertices()}function Fs(t,e,i,n){Ln.call(this),this.type="CircleBufferGeometry",this.parameters={radius:t,segments:e,thetaStart:i,thetaLength:n},t=t||1,e=void 0!==e?Math.max(3,e):8,i=void 0!==i?i:0,n=void 0!==n?n:2*Math.PI;var r,a,o=[],s=[],h=[],c=[],l=new Ge,u=new Be;for(s.push(0,0,0),h.push(0,0,1),c.push(.5,.5),a=0,r=3;a<=e;a++,r+=3){var d=i+a/e*n;l.x=t*Math.cos(d),l.y=t*Math.sin(d),s.push(l.x,l.y,l.z),h.push(0,0,1),u.x=(s[r]/t+1)/2,u.y=(s[r+1]/t+1)/2,c.push(u.x,u.y)}for(r=1;r<=e;r++)o.push(r,r+1,0);this.setIndex(o),this.addAttribute("position",new pn(s,3)),this.addAttribute("normal",new pn(h,3)),this.addAttribute("uv",new pn(c,2))}(_s.prototype=Object.create(rn.prototype)).constructor=_s,(ws.prototype=Object.create(xs.prototype)).constructor=ws,(Ms.prototype=Object.create(rn.prototype)).constructor=Ms,(Es.prototype=Object.create(Ln.prototype)).constructor=Es,(Ts.prototype=Object.create(rn.prototype)).constructor=Ts,(Ss.prototype=Object.create(Ln.prototype)).constructor=Ss,(As.prototype=Object.create(rn.prototype)).constructor=As,(Ls.prototype=Object.create(Ln.prototype)).constructor=Ls,((Rs.prototype=Object.create(rn.prototype)).constructor=Rs).prototype.toJSON=function(){var t=rn.prototype.toJSON.call(this);return Ps(this.parameters.shapes,t)},((Cs.prototype=Object.create(Ln.prototype)).constructor=Cs).prototype.toJSON=function(){var t=Ln.prototype.toJSON.call(this);return Ps(this.parameters.shapes,t)},(Os.prototype=Object.create(Ln.prototype)).constructor=Os,(Is.prototype=Object.create(rn.prototype)).constructor=Is,(Ns.prototype=Object.create(Ln.prototype)).constructor=Ns,(Us.prototype=Object.create(Is.prototype)).constructor=Us,(Ds.prototype=Object.create(Ns.prototype)).constructor=Ds,(Bs.prototype=Object.create(rn.prototype)).constructor=Bs,(Fs.prototype=Object.create(Ln.prototype)).constructor=Fs;var zs=Object.freeze({WireframeGeometry:Ro,ParametricGeometry:Co,ParametricBufferGeometry:Po,TetrahedronGeometry:No,TetrahedronBufferGeometry:Uo,OctahedronGeometry:Do,OctahedronBufferGeometry:Bo,IcosahedronGeometry:Fo,IcosahedronBufferGeometry:zo,DodecahedronGeometry:Go,DodecahedronBufferGeometry:Ho,PolyhedronGeometry:Oo,PolyhedronBufferGeometry:Io,TubeGeometry:Vo,TubeBufferGeometry:ko,TorusKnotGeometry:jo,TorusKnotBufferGeometry:Wo,TorusGeometry:Xo,TorusBufferGeometry:qo,TextGeometry:_s,TextBufferGeometry:ws,SphereGeometry:Ms,SphereBufferGeometry:Es,RingGeometry:Ts,RingBufferGeometry:Ss,PlaneGeometry:Pn,PlaneBufferGeometry:On,LatheGeometry:As,LatheBufferGeometry:Ls,ShapeGeometry:Rs,ShapeBufferGeometry:Cs,ExtrudeGeometry:ys,ExtrudeBufferGeometry:xs,EdgesGeometry:Os,ConeGeometry:Us,ConeBufferGeometry:Ds,CylinderGeometry:Is,CylinderBufferGeometry:Ns,CircleGeometry:Bs,CircleBufferGeometry:Fs,BoxGeometry:Rn,BoxBufferGeometry:Cn});function Gs(t){rr.call(this),this.type="ShadowMaterial",this.color=new yi(0),this.transparent=!0,this.setValues(t)}function Hs(t){or.call(this,t),this.type="RawShaderMaterial"}function Vs(t){rr.call(this),this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new yi(16777215),this.roughness=.5,this.metalness=.5,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new yi(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalScale=new Be(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(t)}function ks(t){Vs.call(this),this.defines={PHYSICAL:""},this.type="MeshPhysicalMaterial",this.reflectivity=.5,this.clearCoat=0,this.clearCoatRoughness=0,this.setValues(t)}function js(t){rr.call(this),this.type="MeshPhongMaterial",this.color=new yi(16777215),this.specular=new yi(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new yi(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalScale=new Be(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=V,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(t)}function Ws(t){js.call(this),this.defines={TOON:""},this.type="MeshToonMaterial",this.gradientMap=null,this.setValues(t)}function Xs(t){rr.call(this),this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalScale=new Be(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(t)}function qs(t){rr.call(this),this.type="MeshLambertMaterial",this.color=new yi(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new yi(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=V,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(t)}function Ys(t){xo.call(this),this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(t)}((Gs.prototype=Object.create(rr.prototype)).constructor=Gs).prototype.isShadowMaterial=!0,Gs.prototype.copy=function(t){return rr.prototype.copy.call(this,t),this.color.copy(t.color),this},((Hs.prototype=Object.create(or.prototype)).constructor=Hs).prototype.isRawShaderMaterial=!0,((Vs.prototype=Object.create(rr.prototype)).constructor=Vs).prototype.isMeshStandardMaterial=!0,Vs.prototype.copy=function(t){return rr.prototype.copy.call(this,t),this.defines={STANDARD:""},this.color.copy(t.color),this.roughness=t.roughness,this.metalness=t.metalness,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.roughnessMap=t.roughnessMap,this.metalnessMap=t.metalnessMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapIntensity=t.envMapIntensity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.morphNormals=t.morphNormals,this},((ks.prototype=Object.create(Vs.prototype)).constructor=ks).prototype.isMeshPhysicalMaterial=!0,ks.prototype.copy=function(t){return Vs.prototype.copy.call(this,t),this.defines={PHYSICAL:""},this.reflectivity=t.reflectivity,this.clearCoat=t.clearCoat,this.clearCoatRoughness=t.clearCoatRoughness,this},((js.prototype=Object.create(rr.prototype)).constructor=js).prototype.isMeshPhongMaterial=!0,js.prototype.copy=function(t){return rr.prototype.copy.call(this,t),this.color.copy(t.color),this.specular.copy(t.specular),this.shininess=t.shininess,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.morphNormals=t.morphNormals,this},((Ws.prototype=Object.create(js.prototype)).constructor=Ws).prototype.isMeshToonMaterial=!0,Ws.prototype.copy=function(t){return js.prototype.copy.call(this,t),this.gradientMap=t.gradientMap,this},((Xs.prototype=Object.create(rr.prototype)).constructor=Xs).prototype.isMeshNormalMaterial=!0,Xs.prototype.copy=function(t){return rr.prototype.copy.call(this,t),this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.morphNormals=t.morphNormals,this},((qs.prototype=Object.create(rr.prototype)).constructor=qs).prototype.isMeshLambertMaterial=!0,qs.prototype.copy=function(t){return rr.prototype.copy.call(this,t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.morphNormals=t.morphNormals,this},((Ys.prototype=Object.create(xo.prototype)).constructor=Ys).prototype.isLineDashedMaterial=!0,Ys.prototype.copy=function(t){return xo.prototype.copy.call(this,t),this.scale=t.scale,this.dashSize=t.dashSize,this.gapSize=t.gapSize,this};var Zs=Object.freeze({ShadowMaterial:Gs,SpriteMaterial:po,RawShaderMaterial:Hs,ShaderMaterial:or,PointsMaterial:Mo,MeshPhysicalMaterial:ks,MeshStandardMaterial:Vs,MeshPhongMaterial:js,MeshToonMaterial:Ws,MeshNormalMaterial:Xs,MeshLambertMaterial:qs,MeshDepthMaterial:Ja,MeshDistanceMaterial:Qa,MeshBasicMaterial:ar,LineDashedMaterial:Ys,LineBasicMaterial:xo,Material:rr}),Js={enabled:!1,files:{},add:function(t,e){!1!==this.enabled&&(this.files[t]=e)},get:function(t){if(!1!==this.enabled)return this.files[t]},remove:function(t){delete this.files[t]},clear:function(){this.files={}}};function Qs(t,e,i){var n=this,r=!1,a=0,o=0,s=void 0;this.onStart=void 0,this.onLoad=t,this.onProgress=e,this.onError=i,this.itemStart=function(t){o++,!1===r&&void 0!==n.onStart&&n.onStart(t,a,o),r=!0},this.itemEnd=function(t){a++,void 0!==n.onProgress&&n.onProgress(t,a,o),a===o&&(r=!1,void 0!==n.onLoad&&n.onLoad())},this.itemError=function(t){void 0!==n.onError&&n.onError(t)},this.resolveURL=function(t){return s?s(t):t},this.setURLModifier=function(t){return s=t,this}}var Ks=new Qs,$s={};function th(t){this.manager=void 0!==t?t:Ks}function eh(t){this.manager=void 0!==t?t:Ks,this._parser=null}function ih(t){this.manager=void 0!==t?t:Ks,this._parser=null}function nh(t){this.manager=void 0!==t?t:Ks}function rh(t){this.manager=void 0!==t?t:Ks}function ah(t){this.manager=void 0!==t?t:Ks}function oh(){this.type="Curve",this.arcLengthDivisions=200}function sh(t,e,i,n,r,a,o,s){oh.call(this),this.type="EllipseCurve",this.aX=t||0,this.aY=e||0,this.xRadius=i||1,this.yRadius=n||1,this.aStartAngle=r||0,this.aEndAngle=a||2*Math.PI,this.aClockwise=o||!1,this.aRotation=s||0}function hh(t,e,i,n,r,a){sh.call(this,t,e,i,i,n,r,a),this.type="ArcCurve"}function ch(){var r=0,a=0,o=0,s=0;function c(t,e,i,n){o=-3*(r=t)+3*e-2*(a=i)-n,s=2*t-2*e+i+n}return{initCatmullRom:function(t,e,i,n,r){c(e,i,r*(i-t),r*(n-e))},initNonuniformCatmullRom:function(t,e,i,n,r,a,o){var s=(e-t)/r-(i-t)/(r+a)+(i-e)/a,h=(i-e)/a-(n-e)/(a+o)+(n-i)/o;c(e,i,s*=a,h*=a)},calc:function(t){var e=t*t;return r+a*t+o*e+s*(e*t)}}}Object.assign(th.prototype,{load:function(o,t,e,i){void 0===o&&(o=""),void 0!==this.path&&(o=this.path+o),o=this.manager.resolveURL(o);var s=this,n=Js.get(o);if(void 0!==n)return s.manager.itemStart(o),setTimeout(function(){t&&t(n),s.manager.itemEnd(o)},0),n;if(void 0===$s[o]){var r=o.match(/^data:(.*?)(;base64)?,(.*)$/);if(r){var a=r[1],h=!!r[2],c=r[3];c=window.decodeURIComponent(c),h&&(c=window.atob(c));try{var l,u=(this.responseType||"").toLowerCase();switch(u){case"arraybuffer":case"blob":for(var d=new Uint8Array(c.length),p=0;p<c.length;p++)d[p]=c.charCodeAt(p);l="blob"===u?new Blob([d.buffer],{type:a}):d.buffer;break;case"document":var f=new DOMParser;l=f.parseFromString(c,a);break;case"json":l=JSON.parse(c);break;default:l=c}window.setTimeout(function(){t&&t(l),s.manager.itemEnd(o)},0)}catch(t){window.setTimeout(function(){i&&i(t),s.manager.itemEnd(o),s.manager.itemError(o)},0)}}else{$s[o]=[],$s[o].push({onLoad:t,onProgress:e,onError:i});var m=new XMLHttpRequest;for(var g in m.open("GET",o,!0),m.addEventListener("load",function(t){var e=this.response;Js.add(o,e);var i=$s[o];if(delete $s[o],200===this.status||0===this.status){0===this.status&&console.warn("THREE.FileLoader: HTTP Status 0 received.");for(var n=0,r=i.length;n<r;n++){(a=i[n]).onLoad&&a.onLoad(e)}s.manager.itemEnd(o)}else{for(n=0,r=i.length;n<r;n++){var a;(a=i[n]).onError&&a.onError(t)}s.manager.itemEnd(o),s.manager.itemError(o)}},!1),m.addEventListener("progress",function(t){for(var e=$s[o],i=0,n=e.length;i<n;i++){var r=e[i];r.onProgress&&r.onProgress(t)}},!1),m.addEventListener("error",function(t){var e=$s[o];delete $s[o];for(var i=0,n=e.length;i<n;i++){var r=e[i];r.onError&&r.onError(t)}s.manager.itemEnd(o),s.manager.itemError(o)},!1),void 0!==this.responseType&&(m.responseType=this.responseType),void 0!==this.withCredentials&&(m.withCredentials=this.withCredentials),m.overrideMimeType&&m.overrideMimeType(void 0!==this.mimeType?this.mimeType:"text/plain"),this.requestHeader)m.setRequestHeader(g,this.requestHeader[g]);m.send(null)}return s.manager.itemStart(o),m}$s[o].push({onLoad:t,onProgress:e,onError:i})},setPath:function(t){return this.path=t,this},setResponseType:function(t){return this.responseType=t,this},setWithCredentials:function(t){return this.withCredentials=t,this},setMimeType:function(t){return this.mimeType=t,this},setRequestHeader:function(t){return this.requestHeader=t,this}}),Object.assign(eh.prototype,{load:function(t,a,e,n){var o=this,s=[],h=new Ao;h.image=s;var r=new th(this.manager);function i(i){r.load(t[i],function(t){var e=o._parser(t,!0);s[i]={width:e.width,height:e.height,format:e.format,mipmaps:e.mipmaps},6===(c+=1)&&(1===e.mipmapCount&&(h.minFilter=St),h.format=e.format,h.needsUpdate=!0,a&&a(h))},e,n)}if(r.setPath(this.path),r.setResponseType("arraybuffer"),Array.isArray(t))for(var c=0,l=0,u=t.length;l<u;++l)i(l);else r.load(t,function(t){var e=o._parser(t,!0);if(e.isCubemap)for(var i=e.mipmaps.length/e.mipmapCount,n=0;n<i;n++){s[n]={mipmaps:[]};for(var r=0;r<e.mipmapCount;r++)s[n].mipmaps.push(e.mipmaps[n*e.mipmapCount+r]),s[n].format=e.format,s[n].width=e.width,s[n].height=e.height}else h.image.width=e.width,h.image.height=e.height,h.mipmaps=e.mipmaps;1===e.mipmapCount&&(h.minFilter=St),h.format=e.format,h.needsUpdate=!0,a&&a(h)},e,n);return h},setPath:function(t){return this.path=t,this}}),Object.assign(ih.prototype,{load:function(t,i,e,n){var r=this,a=new ci,o=new th(this.manager);return o.setResponseType("arraybuffer"),o.load(t,function(t){var e=r._parser(t);e&&(void 0!==e.image?a.image=e.image:void 0!==e.data&&(a.image.width=e.width,a.image.height=e.height,a.image.data=e.data),a.wrapS=void 0!==e.wrapS?e.wrapS:_t,a.wrapT=void 0!==e.wrapT?e.wrapT:_t,a.magFilter=void 0!==e.magFilter?e.magFilter:St,a.minFilter=void 0!==e.minFilter?e.minFilter:Pt,a.anisotropy=void 0!==e.anisotropy?e.anisotropy:1,void 0!==e.format&&(a.format=e.format),void 0!==e.type&&(a.type=e.type),void 0!==e.mipmaps&&(a.mipmaps=e.mipmaps),1===e.mipmapCount&&(a.minFilter=St),a.needsUpdate=!0,i&&i(a,e))},e,n),a}}),Object.assign(nh.prototype,{crossOrigin:"Anonymous",load:function(e,t,i,n){void 0===e&&(e=""),void 0!==this.path&&(e=this.path+e),e=this.manager.resolveURL(e);var r=this,a=Js.get(e);if(void 0!==a)return r.manager.itemStart(e),setTimeout(function(){t&&t(a),r.manager.itemEnd(e)},0),a;var o=document.createElementNS("http://www.w3.org/1999/xhtml","img");return o.addEventListener("load",function(){Js.add(e,this),t&&t(this),r.manager.itemEnd(e)},!1),o.addEventListener("error",function(t){n&&n(t),r.manager.itemEnd(e),r.manager.itemError(e)},!1),"data:"!==e.substr(0,5)&&void 0!==this.crossOrigin&&(o.crossOrigin=this.crossOrigin),r.manager.itemStart(e),o.src=e,o},setCrossOrigin:function(t){return this.crossOrigin=t,this},setPath:function(t){return this.path=t,this}}),Object.assign(rh.prototype,{crossOrigin:"Anonymous",load:function(t,i,e,n){var r=new wr,a=new nh(this.manager);a.setCrossOrigin(this.crossOrigin),a.setPath(this.path);var o=0;function s(e){a.load(t[e],function(t){r.images[e]=t,6===++o&&(r.needsUpdate=!0,i&&i(r))},void 0,n)}for(var h=0;h<t.length;++h)s(h);return r},setCrossOrigin:function(t){return this.crossOrigin=t,this},setPath:function(t){return this.path=t,this}}),Object.assign(ah.prototype,{crossOrigin:"Anonymous",load:function(i,n,t,e){var r=new ai,a=new nh(this.manager);return a.setCrossOrigin(this.crossOrigin),a.setPath(this.path),a.load(i,function(t){r.image=t;var e=0<i.search(/\.(jpg|jpeg)$/)||0===i.search(/^data\:image\/jpeg/);r.format=e?Wt:Xt,r.needsUpdate=!0,void 0!==n&&n(r)},t,e),r},setCrossOrigin:function(t){return this.crossOrigin=t,this},setPath:function(t){return this.path=t,this}}),Object.assign(oh.prototype,{getPoint:function(){return console.warn("THREE.Curve: .getPoint() not implemented."),null},getPointAt:function(t,e){var i=this.getUtoTmapping(t);return this.getPoint(i,e)},getPoints:function(t){void 0===t&&(t=5);for(var e=[],i=0;i<=t;i++)e.push(this.getPoint(i/t));return e},getSpacedPoints:function(t){void 0===t&&(t=5);for(var e=[],i=0;i<=t;i++)e.push(this.getPointAt(i/t));return e},getLength:function(){var t=this.getLengths();return t[t.length-1]},getLengths:function(t){if(void 0===t&&(t=this.arcLengthDivisions),this.cacheArcLengths&&this.cacheArcLengths.length===t+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;var e,i,n=[],r=this.getPoint(0),a=0;for(n.push(0),i=1;i<=t;i++)a+=(e=this.getPoint(i/t)).distanceTo(r),n.push(a),r=e;return this.cacheArcLengths=n},updateArcLengths:function(){this.needsUpdate=!0,this.getLengths()},getUtoTmapping:function(t,e){var i,n=this.getLengths(),r=0,a=n.length;i=e||t*n[a-1];for(var o,s=0,h=a-1;s<=h;)if((o=n[r=Math.floor(s+(h-s)/2)]-i)<0)s=r+1;else{if(!(0<o)){h=r;break}h=r-1}if(n[r=h]===i)return r/(a-1);var c=n[r];return(r+(i-c)/(n[r+1]-c))/(a-1)},getTangent:function(t){var e=t-1e-4,i=t+1e-4;e<0&&(e=0),1<i&&(i=1);var n=this.getPoint(e);return this.getPoint(i).clone().sub(n).normalize()},getTangentAt:function(t){var e=this.getUtoTmapping(t);return this.getTangent(e)},computeFrenetFrames:function(t,e){var i,n,r,a=new Ge,o=[],s=[],h=[],c=new Ge,l=new Fe;for(i=0;i<=t;i++)n=i/t,o[i]=this.getTangentAt(n),o[i].normalize();s[0]=new Ge,h[0]=new Ge;var u=Number.MAX_VALUE,d=Math.abs(o[0].x),p=Math.abs(o[0].y),f=Math.abs(o[0].z);for(d<=u&&(u=d,a.set(1,0,0)),p<=u&&(u=p,a.set(0,1,0)),f<=u&&a.set(0,0,1),c.crossVectors(o[0],a).normalize(),s[0].crossVectors(o[0],c),h[0].crossVectors(o[0],s[0]),i=1;i<=t;i++)s[i]=s[i-1].clone(),h[i]=h[i-1].clone(),c.crossVectors(o[i-1],o[i]),c.length()>Number.EPSILON&&(c.normalize(),r=Math.acos(De.clamp(o[i-1].dot(o[i]),-1,1)),s[i].applyMatrix4(l.makeRotationAxis(c,r))),h[i].crossVectors(o[i],s[i]);if(!0===e)for(r=Math.acos(De.clamp(s[0].dot(s[t]),-1,1)),r/=t,0<o[0].dot(c.crossVectors(s[0],s[t]))&&(r=-r),i=1;i<=t;i++)s[i].applyMatrix4(l.makeRotationAxis(o[i],r*i)),h[i].crossVectors(o[i],s[i]);return{tangents:o,normals:s,binormals:h}},clone:function(){return(new this.constructor).copy(this)},copy:function(t){return this.arcLengthDivisions=t.arcLengthDivisions,this},toJSON:function(){var t={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return t.arcLengthDivisions=this.arcLengthDivisions,t.type=this.type,t},fromJSON:function(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}}),((sh.prototype=Object.create(oh.prototype)).constructor=sh).prototype.isEllipseCurve=!0,sh.prototype.getPoint=function(t,e){for(var i=e||new Be,n=2*Math.PI,r=this.aEndAngle-this.aStartAngle,a=Math.abs(r)<Number.EPSILON;r<0;)r+=n;for(;n<r;)r-=n;r<Number.EPSILON&&(r=a?0:n),!0!==this.aClockwise||a||(r===n?r=-n:r-=n);var o=this.aStartAngle+t*r,s=this.aX+this.xRadius*Math.cos(o),h=this.aY+this.yRadius*Math.sin(o);if(0!==this.aRotation){var c=Math.cos(this.aRotation),l=Math.sin(this.aRotation),u=s-this.aX,d=h-this.aY;s=u*c-d*l+this.aX,h=u*l+d*c+this.aY}return i.set(s,h)},sh.prototype.copy=function(t){return oh.prototype.copy.call(this,t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this},sh.prototype.toJSON=function(){var t=oh.prototype.toJSON.call(this);return t.aX=this.aX,t.aY=this.aY,t.xRadius=this.xRadius,t.yRadius=this.yRadius,t.aStartAngle=this.aStartAngle,t.aEndAngle=this.aEndAngle,t.aClockwise=this.aClockwise,t.aRotation=this.aRotation,t},sh.prototype.fromJSON=function(t){return oh.prototype.fromJSON.call(this,t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this},((hh.prototype=Object.create(sh.prototype)).constructor=hh).prototype.isArcCurve=!0;var lh=new Ge,uh=new ch,dh=new ch,ph=new ch;function fh(t,e,i,n){oh.call(this),this.type="CatmullRomCurve3",this.points=t||[],this.closed=e||!1,this.curveType=i||"centripetal",this.tension=n||.5}function mh(t,e,i,n,r){var a=.5*(n-e),o=.5*(r-i),s=t*t;return(2*i-2*n+a+o)*(t*s)+(-3*i+3*n-2*a-o)*s+a*t+i}function gh(t,e,i,n){return(o=1-t)*o*e+2*(1-(a=t))*a*i+(r=t)*r*n;var r,a,o}function vh(t,e,i,n,r){return(c=1-t)*c*c*e+3*(h=1-(s=t))*h*s*i+3*(1-(o=t))*o*o*n+(a=t)*a*a*r;var a,o,s,h,c}function yh(t,e,i,n){oh.call(this),this.type="CubicBezierCurve",this.v0=t||new Be,this.v1=e||new Be,this.v2=i||new Be,this.v3=n||new Be}function xh(t,e,i,n){oh.call(this),this.type="CubicBezierCurve3",this.v0=t||new Ge,this.v1=e||new Ge,this.v2=i||new Ge,this.v3=n||new Ge}function bh(t,e){oh.call(this),this.type="LineCurve",this.v1=t||new Be,this.v2=e||new Be}function _h(t,e){oh.call(this),this.type="LineCurve3",this.v1=t||new Ge,this.v2=e||new Ge}function wh(t,e,i){oh.call(this),this.type="QuadraticBezierCurve",this.v0=t||new Be,this.v1=e||new Be,this.v2=i||new Be}function Mh(t,e,i){oh.call(this),this.type="QuadraticBezierCurve3",this.v0=t||new Ge,this.v1=e||new Ge,this.v2=i||new Ge}function Eh(t){oh.call(this),this.type="SplineCurve",this.points=t||[]}((fh.prototype=Object.create(oh.prototype)).constructor=fh).prototype.isCatmullRomCurve3=!0,fh.prototype.getPoint=function(t,e){var i,n,r,a,o=e||new Ge,s=this.points,h=s.length,c=(h-(this.closed?0:1))*t,l=Math.floor(c),u=c-l;if(this.closed?l+=0<l?0:(Math.floor(Math.abs(l)/h)+1)*h:0===u&&l===h-1&&(l=h-2,u=1),this.closed||0<l?i=s[(l-1)%h]:(lh.subVectors(s[0],s[1]).add(s[0]),i=lh),n=s[l%h],r=s[(l+1)%h],this.closed||l+2<h?a=s[(l+2)%h]:(lh.subVectors(s[h-1],s[h-2]).add(s[h-1]),a=lh),"centripetal"===this.curveType||"chordal"===this.curveType){var d="chordal"===this.curveType?.5:.25,p=Math.pow(i.distanceToSquared(n),d),f=Math.pow(n.distanceToSquared(r),d),m=Math.pow(r.distanceToSquared(a),d);f<1e-4&&(f=1),p<1e-4&&(p=f),m<1e-4&&(m=f),uh.initNonuniformCatmullRom(i.x,n.x,r.x,a.x,p,f,m),dh.initNonuniformCatmullRom(i.y,n.y,r.y,a.y,p,f,m),ph.initNonuniformCatmullRom(i.z,n.z,r.z,a.z,p,f,m)}else"catmullrom"===this.curveType&&(uh.initCatmullRom(i.x,n.x,r.x,a.x,this.tension),dh.initCatmullRom(i.y,n.y,r.y,a.y,this.tension),ph.initCatmullRom(i.z,n.z,r.z,a.z,this.tension));return o.set(uh.calc(u),dh.calc(u),ph.calc(u)),o},fh.prototype.copy=function(t){oh.prototype.copy.call(this,t),this.points=[];for(var e=0,i=t.points.length;e<i;e++){var n=t.points[e];this.points.push(n.clone())}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this},fh.prototype.toJSON=function(){var t=oh.prototype.toJSON.call(this);t.points=[];for(var e=0,i=this.points.length;e<i;e++){var n=this.points[e];t.points.push(n.toArray())}return t.closed=this.closed,t.curveType=this.curveType,t.tension=this.tension,t},fh.prototype.fromJSON=function(t){oh.prototype.fromJSON.call(this,t),this.points=[];for(var e=0,i=t.points.length;e<i;e++){var n=t.points[e];this.points.push((new Ge).fromArray(n))}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this},((yh.prototype=Object.create(oh.prototype)).constructor=yh).prototype.isCubicBezierCurve=!0,yh.prototype.getPoint=function(t,e){var i=e||new Be,n=this.v0,r=this.v1,a=this.v2,o=this.v3;return i.set(vh(t,n.x,r.x,a.x,o.x),vh(t,n.y,r.y,a.y,o.y)),i},yh.prototype.copy=function(t){return oh.prototype.copy.call(this,t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this},yh.prototype.toJSON=function(){var t=oh.prototype.toJSON.call(this);return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t},yh.prototype.fromJSON=function(t){return oh.prototype.fromJSON.call(this,t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this},((xh.prototype=Object.create(oh.prototype)).constructor=xh).prototype.isCubicBezierCurve3=!0,xh.prototype.getPoint=function(t,e){var i=e||new Ge,n=this.v0,r=this.v1,a=this.v2,o=this.v3;return i.set(vh(t,n.x,r.x,a.x,o.x),vh(t,n.y,r.y,a.y,o.y),vh(t,n.z,r.z,a.z,o.z)),i},xh.prototype.copy=function(t){return oh.prototype.copy.call(this,t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this},xh.prototype.toJSON=function(){var t=oh.prototype.toJSON.call(this);return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t},xh.prototype.fromJSON=function(t){return oh.prototype.fromJSON.call(this,t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this},((bh.prototype=Object.create(oh.prototype)).constructor=bh).prototype.isLineCurve=!0,bh.prototype.getPoint=function(t,e){var i=e||new Be;return 1===t?i.copy(this.v2):(i.copy(this.v2).sub(this.v1),i.multiplyScalar(t).add(this.v1)),i},bh.prototype.getPointAt=function(t,e){return this.getPoint(t,e)},bh.prototype.getTangent=function(){return this.v2.clone().sub(this.v1).normalize()},bh.prototype.copy=function(t){return oh.prototype.copy.call(this,t),this.v1.copy(t.v1),this.v2.copy(t.v2),this},bh.prototype.toJSON=function(){var t=oh.prototype.toJSON.call(this);return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t},bh.prototype.fromJSON=function(t){return oh.prototype.fromJSON.call(this,t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this},((_h.prototype=Object.create(oh.prototype)).constructor=_h).prototype.isLineCurve3=!0,_h.prototype.getPoint=function(t,e){var i=e||new Ge;return 1===t?i.copy(this.v2):(i.copy(this.v2).sub(this.v1),i.multiplyScalar(t).add(this.v1)),i},_h.prototype.getPointAt=function(t,e){return this.getPoint(t,e)},_h.prototype.copy=function(t){return oh.prototype.copy.call(this,t),this.v1.copy(t.v1),this.v2.copy(t.v2),this},_h.prototype.toJSON=function(){var t=oh.prototype.toJSON.call(this);return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t},_h.prototype.fromJSON=function(t){return oh.prototype.fromJSON.call(this,t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this},((wh.prototype=Object.create(oh.prototype)).constructor=wh).prototype.isQuadraticBezierCurve=!0,wh.prototype.getPoint=function(t,e){var i=e||new Be,n=this.v0,r=this.v1,a=this.v2;return i.set(gh(t,n.x,r.x,a.x),gh(t,n.y,r.y,a.y)),i},wh.prototype.copy=function(t){return oh.prototype.copy.call(this,t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this},wh.prototype.toJSON=function(){var t=oh.prototype.toJSON.call(this);return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t},wh.prototype.fromJSON=function(t){return oh.prototype.fromJSON.call(this,t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this},((Mh.prototype=Object.create(oh.prototype)).constructor=Mh).prototype.isQuadraticBezierCurve3=!0,Mh.prototype.getPoint=function(t,e){var i=e||new Ge,n=this.v0,r=this.v1,a=this.v2;return i.set(gh(t,n.x,r.x,a.x),gh(t,n.y,r.y,a.y),gh(t,n.z,r.z,a.z)),i},Mh.prototype.copy=function(t){return oh.prototype.copy.call(this,t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this},Mh.prototype.toJSON=function(){var t=oh.prototype.toJSON.call(this);return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t},Mh.prototype.fromJSON=function(t){return oh.prototype.fromJSON.call(this,t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this},((Eh.prototype=Object.create(oh.prototype)).constructor=Eh).prototype.isSplineCurve=!0,Eh.prototype.getPoint=function(t,e){var i=e||new Be,n=this.points,r=(n.length-1)*t,a=Math.floor(r),o=r-a,s=n[0===a?a:a-1],h=n[a],c=n[a>n.length-2?n.length-1:a+1],l=n[a>n.length-3?n.length-1:a+2];return i.set(mh(o,s.x,h.x,c.x,l.x),mh(o,s.y,h.y,c.y,l.y)),i},Eh.prototype.copy=function(t){oh.prototype.copy.call(this,t),this.points=[];for(var e=0,i=t.points.length;e<i;e++){var n=t.points[e];this.points.push(n.clone())}return this},Eh.prototype.toJSON=function(){var t=oh.prototype.toJSON.call(this);t.points=[];for(var e=0,i=this.points.length;e<i;e++){var n=this.points[e];t.points.push(n.toArray())}return t},Eh.prototype.fromJSON=function(t){oh.prototype.fromJSON.call(this,t),this.points=[];for(var e=0,i=t.points.length;e<i;e++){var n=t.points[e];this.points.push((new Be).fromArray(n))}return this};var Th=Object.freeze({ArcCurve:hh,CatmullRomCurve3:fh,CubicBezierCurve:yh,CubicBezierCurve3:xh,EllipseCurve:sh,LineCurve:bh,LineCurve3:_h,QuadraticBezierCurve:wh,QuadraticBezierCurve3:Mh,SplineCurve:Eh});function Sh(){oh.call(this),this.type="CurvePath",this.curves=[],this.autoClose=!1}function Ah(t){Sh.call(this),this.type="Path",this.currentPoint=new Be,t&&this.setFromPoints(t)}function Lh(t){Ah.call(this,t),this.uuid=De.generateUUID(),this.type="Shape",this.holes=[]}function Rh(t,e){Wi.call(this),this.type="Light",this.color=new yi(t),this.intensity=void 0!==e?e:1,this.receiveShadow=void 0}function Ch(t,e,i){Rh.call(this,t,i),this.type="HemisphereLight",this.castShadow=void 0,this.position.copy(Wi.DefaultUp),this.updateMatrix(),this.groundColor=new yi(e)}function Ph(t){this.camera=t,this.bias=0,this.radius=1,this.mapSize=new Be(512,512),this.map=null,this.matrix=new Fe}function Oh(){Ph.call(this,new ro(50,1,.5,500))}function Ih(t,e,i,n,r,a){Rh.call(this,t,e),this.type="SpotLight",this.position.copy(Wi.DefaultUp),this.updateMatrix(),this.target=new Wi,Object.defineProperty(this,"power",{get:function(){return this.intensity*Math.PI},set:function(t){this.intensity=t/Math.PI}}),this.distance=void 0!==i?i:0,this.angle=void 0!==n?n:Math.PI/3,this.penumbra=void 0!==r?r:0,this.decay=void 0!==a?a:1,this.shadow=new Oh}function Nh(t,e,i,n){Rh.call(this,t,e),this.type="PointLight",Object.defineProperty(this,"power",{get:function(){return 4*this.intensity*Math.PI},set:function(t){this.intensity=t/(4*Math.PI)}}),this.distance=void 0!==i?i:0,this.decay=void 0!==n?n:1,this.shadow=new Ph(new ro(90,1,.5,500))}function Uh(){Ph.call(this,new qi(-5,5,5,-5,.5,500))}function Dh(t,e){Rh.call(this,t,e),this.type="DirectionalLight",this.position.copy(Wi.DefaultUp),this.updateMatrix(),this.target=new Wi,this.shadow=new Uh}function Bh(t,e){Rh.call(this,t,e),this.type="AmbientLight",this.castShadow=void 0}function Fh(t,e,i,n){Rh.call(this,t,e),this.type="RectAreaLight",this.width=void 0!==i?i:10,this.height=void 0!==n?n:10}function zh(t,e,i,n){Jh.call(this,t,e,i,n)}function Gh(t,e,i){Jh.call(this,t,e,i)}function Hh(t,e,i,n){this.parameterPositions=t,this._cachedIndex=0,this.resultBuffer=void 0!==n?n:new e.constructor(i),this.sampleValues=e,this.valueSize=i}function Vh(t,e,i,n){Hh.call(this,t,e,i,n)}function kh(t,e,i,n){Jh.call(this,t,e,i,n)}function jh(t,e,i,n){Jh.call(this,t,e,i,n)}function Wh(t,e,i,n){Jh.call(this,t,e,i,n)}function Xh(t,e,i,n){Hh.call(this,t,e,i,n),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0}function qh(t,e,i,n){Hh.call(this,t,e,i,n)}function Yh(t,e,i,n){Hh.call(this,t,e,i,n)}Sh.prototype=Object.assign(Object.create(oh.prototype),{constructor:Sh,add:function(t){this.curves.push(t)},closePath:function(){var t=this.curves[0].getPoint(0),e=this.curves[this.curves.length-1].getPoint(1);t.equals(e)||this.curves.push(new bh(e,t))},getPoint:function(t){for(var e=t*this.getLength(),i=this.getCurveLengths(),n=0;n<i.length;){if(i[n]>=e){var r=i[n]-e,a=this.curves[n],o=a.getLength(),s=0===o?0:1-r/o;return a.getPointAt(s)}n++}return null},getLength:function(){var t=this.getCurveLengths();return t[t.length-1]},updateArcLengths:function(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()},getCurveLengths:function(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;for(var t=[],e=0,i=0,n=this.curves.length;i<n;i++)e+=this.curves[i].getLength(),t.push(e);return this.cacheLengths=t},getSpacedPoints:function(t){void 0===t&&(t=40);for(var e=[],i=0;i<=t;i++)e.push(this.getPoint(i/t));return this.autoClose&&e.push(e[0]),e},getPoints:function(t){t=t||12;for(var e,i=[],n=0,r=this.curves;n<r.length;n++)for(var a=r[n],o=a&&a.isEllipseCurve?2*t:a&&a.isLineCurve?1:a&&a.isSplineCurve?t*a.points.length:t,s=a.getPoints(o),h=0;h<s.length;h++){var c=s[h];e&&e.equals(c)||(i.push(c),e=c)}return this.autoClose&&1<i.length&&!i[i.length-1].equals(i[0])&&i.push(i[0]),i},copy:function(t){oh.prototype.copy.call(this,t),this.curves=[];for(var e=0,i=t.curves.length;e<i;e++){var n=t.curves[e];this.curves.push(n.clone())}return this.autoClose=t.autoClose,this},toJSON:function(){var t=oh.prototype.toJSON.call(this);t.autoClose=this.autoClose,t.curves=[];for(var e=0,i=this.curves.length;e<i;e++){var n=this.curves[e];t.curves.push(n.toJSON())}return t},fromJSON:function(t){oh.prototype.fromJSON.call(this,t),this.autoClose=t.autoClose,this.curves=[];for(var e=0,i=t.curves.length;e<i;e++){var n=t.curves[e];this.curves.push((new Th[n.type]).fromJSON(n))}return this}}),Ah.prototype=Object.assign(Object.create(Sh.prototype),{constructor:Ah,setFromPoints:function(t){this.moveTo(t[0].x,t[0].y);for(var e=1,i=t.length;e<i;e++)this.lineTo(t[e].x,t[e].y)},moveTo:function(t,e){this.currentPoint.set(t,e)},lineTo:function(t,e){var i=new bh(this.currentPoint.clone(),new Be(t,e));this.curves.push(i),this.currentPoint.set(t,e)},quadraticCurveTo:function(t,e,i,n){var r=new wh(this.currentPoint.clone(),new Be(t,e),new Be(i,n));this.curves.push(r),this.currentPoint.set(i,n)},bezierCurveTo:function(t,e,i,n,r,a){var o=new yh(this.currentPoint.clone(),new Be(t,e),new Be(i,n),new Be(r,a));this.curves.push(o),this.currentPoint.set(r,a)},splineThru:function(t){var e=new Eh([this.currentPoint.clone()].concat(t));this.curves.push(e),this.currentPoint.copy(t[t.length-1])},arc:function(t,e,i,n,r,a){var o=this.currentPoint.x,s=this.currentPoint.y;this.absarc(t+o,e+s,i,n,r,a)},absarc:function(t,e,i,n,r,a){this.absellipse(t,e,i,i,n,r,a)},ellipse:function(t,e,i,n,r,a,o,s){var h=this.currentPoint.x,c=this.currentPoint.y;this.absellipse(t+h,e+c,i,n,r,a,o,s)},absellipse:function(t,e,i,n,r,a,o,s){var h=new sh(t,e,i,n,r,a,o,s);if(0<this.curves.length){var c=h.getPoint(0);c.equals(this.currentPoint)||this.lineTo(c.x,c.y)}this.curves.push(h);var l=h.getPoint(1);this.currentPoint.copy(l)},copy:function(t){return Sh.prototype.copy.call(this,t),this.currentPoint.copy(t.currentPoint),this},toJSON:function(){var t=Sh.prototype.toJSON.call(this);return t.currentPoint=this.currentPoint.toArray(),t},fromJSON:function(t){return Sh.prototype.fromJSON.call(this,t),this.currentPoint.fromArray(t.currentPoint),this}}),Lh.prototype=Object.assign(Object.create(Ah.prototype),{constructor:Lh,getPointsHoles:function(t){for(var e=[],i=0,n=this.holes.length;i<n;i++)e[i]=this.holes[i].getPoints(t);return e},extractPoints:function(t){return{shape:this.getPoints(t),holes:this.getPointsHoles(t)}},copy:function(t){Ah.prototype.copy.call(this,t),this.holes=[];for(var e=0,i=t.holes.length;e<i;e++){var n=t.holes[e];this.holes.push(n.clone())}return this},toJSON:function(){var t=Ah.prototype.toJSON.call(this);t.uuid=this.uuid,t.holes=[];for(var e=0,i=this.holes.length;e<i;e++){var n=this.holes[e];t.holes.push(n.toJSON())}return t},fromJSON:function(t){Ah.prototype.fromJSON.call(this,t),this.uuid=t.uuid,this.holes=[];for(var e=0,i=t.holes.length;e<i;e++){var n=t.holes[e];this.holes.push((new Ah).fromJSON(n))}return this}}),Rh.prototype=Object.assign(Object.create(Wi.prototype),{constructor:Rh,isLight:!0,copy:function(t){return Wi.prototype.copy.call(this,t),this.color.copy(t.color),this.intensity=t.intensity,this},toJSON:function(t){var e=Wi.prototype.toJSON.call(this,t);return e.object.color=this.color.getHex(),e.object.intensity=this.intensity,void 0!==this.groundColor&&(e.object.groundColor=this.groundColor.getHex()),void 0!==this.distance&&(e.object.distance=this.distance),void 0!==this.angle&&(e.object.angle=this.angle),void 0!==this.decay&&(e.object.decay=this.decay),void 0!==this.penumbra&&(e.object.penumbra=this.penumbra),void 0!==this.shadow&&(e.object.shadow=this.shadow.toJSON()),e}}),Ch.prototype=Object.assign(Object.create(Rh.prototype),{constructor:Ch,isHemisphereLight:!0,copy:function(t){return Rh.prototype.copy.call(this,t),this.groundColor.copy(t.groundColor),this}}),Object.assign(Ph.prototype,{copy:function(t){return this.camera=t.camera.clone(),this.bias=t.bias,this.radius=t.radius,this.mapSize.copy(t.mapSize),this},clone:function(){return(new this.constructor).copy(this)},toJSON:function(){var t={};return 0!==this.bias&&(t.bias=this.bias),1!==this.radius&&(t.radius=this.radius),512===this.mapSize.x&&512===this.mapSize.y||(t.mapSize=this.mapSize.toArray()),t.camera=this.camera.toJSON(!1).object,delete t.camera.matrix,t}}),Oh.prototype=Object.assign(Object.create(Ph.prototype),{constructor:Oh,isSpotLightShadow:!0,update:function(t){var e=this.camera,i=2*De.RAD2DEG*t.angle,n=this.mapSize.width/this.mapSize.height,r=t.distance||e.far;i===e.fov&&n===e.aspect&&r===e.far||(e.fov=i,e.aspect=n,e.far=r,e.updateProjectionMatrix())}}),Ih.prototype=Object.assign(Object.create(Rh.prototype),{constructor:Ih,isSpotLight:!0,copy:function(t){return Rh.prototype.copy.call(this,t),this.distance=t.distance,this.angle=t.angle,this.penumbra=t.penumbra,this.decay=t.decay,this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}),Nh.prototype=Object.assign(Object.create(Rh.prototype),{constructor:Nh,isPointLight:!0,copy:function(t){return Rh.prototype.copy.call(this,t),this.distance=t.distance,this.decay=t.decay,this.shadow=t.shadow.clone(),this}}),Uh.prototype=Object.assign(Object.create(Ph.prototype),{constructor:Uh}),Dh.prototype=Object.assign(Object.create(Rh.prototype),{constructor:Dh,isDirectionalLight:!0,copy:function(t){return Rh.prototype.copy.call(this,t),this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}),Bh.prototype=Object.assign(Object.create(Rh.prototype),{constructor:Bh,isAmbientLight:!0}),Fh.prototype=Object.assign(Object.create(Rh.prototype),{constructor:Fh,isRectAreaLight:!0,copy:function(t){return Rh.prototype.copy.call(this,t),this.width=t.width,this.height=t.height,this},toJSON:function(t){var e=Rh.prototype.toJSON.call(this,t);return e.object.width=this.width,e.object.height=this.height,e}}),zh.prototype=Object.assign(Object.create(Jh.prototype),{constructor:zh,ValueTypeName:"string",ValueBufferType:Array,DefaultInterpolation:_e,InterpolantFactoryMethodLinear:void 0,InterpolantFactoryMethodSmooth:void 0}),Gh.prototype=Object.assign(Object.create(Jh.prototype),{constructor:Gh,ValueTypeName:"bool",ValueBufferType:Array,DefaultInterpolation:_e,InterpolantFactoryMethodLinear:void 0,InterpolantFactoryMethodSmooth:void 0}),Object.assign(Hh.prototype,{evaluate:function(t){var e=this.parameterPositions,i=this._cachedIndex,n=e[i],r=e[i-1];t:{e:{var a;i:{n:if(!(t<n)){for(var o=i+2;;){if(void 0===n){if(t<r)break n;return i=e.length,this._cachedIndex=i,this.afterEnd_(i-1,t,r)}if(i===o)break;if(r=n,t<(n=e[++i]))break e}a=e.length;break i}if(r<=t)break t;var s=e[1];t<s&&(i=2,r=s);for(o=i-2;;){if(void 0===r)return this._cachedIndex=0,this.beforeStart_(0,t,n);if(i===o)break;if(n=r,(r=e[--i-1])<=t)break e}a=i,i=0}for(;i<a;){var h=i+a>>>1;t<e[h]?a=h:i=h+1}if(n=e[i],void 0===(r=e[i-1]))return this._cachedIndex=0,this.beforeStart_(0,t,n);if(void 0===n)return i=e.length,this._cachedIndex=i,this.afterEnd_(i-1,r,t)}this._cachedIndex=i,this.intervalChanged_(i,r,n)}return this.interpolate_(i,r,t,n)},settings:null,DefaultSettings_:{},getSettings_:function(){return this.settings||this.DefaultSettings_},copySampleValue_:function(t){for(var e=this.resultBuffer,i=this.sampleValues,n=this.valueSize,r=t*n,a=0;a!==n;++a)e[a]=i[r+a];return e},interpolate_:function(){throw new Error("call to abstract method")},intervalChanged_:function(){}}),Object.assign(Hh.prototype,{beforeStart_:Hh.prototype.copySampleValue_,afterEnd_:Hh.prototype.copySampleValue_}),Vh.prototype=Object.assign(Object.create(Hh.prototype),{constructor:Vh,interpolate_:function(t,e,i,n){for(var r=this.resultBuffer,a=this.sampleValues,o=this.valueSize,s=t*o,h=(i-e)/(n-e),c=s+o;s!==c;s+=4)ze.slerpFlat(r,0,a,s-o,a,s,h);return r}}),kh.prototype=Object.assign(Object.create(Jh.prototype),{constructor:kh,ValueTypeName:"quaternion",DefaultInterpolation:we,InterpolantFactoryMethodLinear:function(t){return new Vh(this.times,this.values,this.getValueSize(),t)},InterpolantFactoryMethodSmooth:void 0}),jh.prototype=Object.assign(Object.create(Jh.prototype),{constructor:jh,ValueTypeName:"color"}),Wh.prototype=Object.assign(Object.create(Jh.prototype),{constructor:Wh,ValueTypeName:"number"}),Xh.prototype=Object.assign(Object.create(Hh.prototype),{constructor:Xh,DefaultSettings_:{endingStart:Me,endingEnd:Me},intervalChanged_:function(t,e,i){var n=this.parameterPositions,r=t-2,a=t+1,o=n[r],s=n[a];if(void 0===o)switch(this.getSettings_().endingStart){case Ee:r=t,o=2*e-i;break;case Te:o=e+n[r=n.length-2]-n[r+1];break;default:r=t,o=i}if(void 0===s)switch(this.getSettings_().endingEnd){case Ee:a=t,s=2*i-e;break;case Te:s=i+n[a=1]-n[0];break;default:a=t-1,s=e}var h=.5*(i-e),c=this.valueSize;this._weightPrev=h/(e-o),this._weightNext=h/(s-i),this._offsetPrev=r*c,this._offsetNext=a*c},interpolate_:function(t,e,i,n){for(var r=this.resultBuffer,a=this.sampleValues,o=this.valueSize,s=t*o,h=s-o,c=this._offsetPrev,l=this._offsetNext,u=this._weightPrev,d=this._weightNext,p=(i-e)/(n-e),f=p*p,m=f*p,g=-u*m+2*u*f-u*p,v=(1+u)*m+(-1.5-2*u)*f+(-.5+u)*p+1,y=(-1-d)*m+(1.5+d)*f+.5*p,x=d*m-d*f,b=0;b!==o;++b)r[b]=g*a[c+b]+v*a[h+b]+y*a[s+b]+x*a[l+b];return r}}),qh.prototype=Object.assign(Object.create(Hh.prototype),{constructor:qh,interpolate_:function(t,e,i,n){for(var r=this.resultBuffer,a=this.sampleValues,o=this.valueSize,s=t*o,h=s-o,c=(i-e)/(n-e),l=1-c,u=0;u!==o;++u)r[u]=a[h+u]*l+a[s+u]*c;return r}}),Yh.prototype=Object.assign(Object.create(Hh.prototype),{constructor:Yh,interpolate_:function(t){return this.copySampleValue_(t-1)}});var Zh={arraySlice:function(t,e,i){return Zh.isTypedArray(t)?new t.constructor(t.subarray(e,void 0!==i?i:t.length)):t.slice(e,i)},convertArray:function(t,e,i){return!t||!i&&t.constructor===e?t:"number"==typeof e.BYTES_PER_ELEMENT?new e(t):Array.prototype.slice.call(t)},isTypedArray:function(t){return ArrayBuffer.isView(t)&&!(t instanceof DataView)},getKeyframeOrder:function(i){for(var t=i.length,e=new Array(t),n=0;n!==t;++n)e[n]=n;return e.sort(function(t,e){return i[t]-i[e]}),e},sortedArray:function(t,e,i){for(var n=t.length,r=new t.constructor(n),a=0,o=0;o!==n;++a)for(var s=i[a]*e,h=0;h!==e;++h)r[o++]=t[s+h];return r},flattenJSON:function(t,e,i,n){for(var r=1,a=t[0];void 0!==a&&void 0===a[n];)a=t[r++];if(void 0!==a){var o=a[n];if(void 0!==o)if(Array.isArray(o))for(;void 0!==(o=a[n])&&(e.push(a.time),i.push.apply(i,o)),void 0!==(a=t[r++]););else if(void 0!==o.toArray)for(;void 0!==(o=a[n])&&(e.push(a.time),o.toArray(i,i.length)),void 0!==(a=t[r++]););else for(;void 0!==(o=a[n])&&(e.push(a.time),i.push(o)),void 0!==(a=t[r++]););}}};function Jh(t,e,i,n){if(void 0===t)throw new Error("THREE.KeyframeTrack: track name is undefined");if(void 0===e||0===e.length)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+t);this.name=t,this.times=Zh.convertArray(e,this.TimeBufferType),this.values=Zh.convertArray(i,this.ValueBufferType),this.setInterpolation(n||this.DefaultInterpolation),this.validate(),this.optimize()}function Qh(t,e,i,n){Jh.call(this,t,e,i,n)}function Kh(t,e,i){this.name=t,this.tracks=i,this.duration=void 0!==e?e:-1,this.uuid=De.generateUUID(),this.duration<0&&this.resetDuration(),this.optimize()}function $h(t){this.manager=void 0!==t?t:Ks,this.textures={}}function tc(t){this.manager=void 0!==t?t:Ks}Object.assign(Jh,{parse:function(t){if(void 0===t.type)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");var e=Jh._getTrackTypeForValueTypeName(t.type);if(void 0===t.times){var i=[],n=[];Zh.flattenJSON(t.keys,i,n,"value"),t.times=i,t.values=n}return void 0!==e.parse?e.parse(t):new e(t.name,t.times,t.values,t.interpolation)},toJSON:function(t){var e,i=t.constructor;if(void 0!==i.toJSON)e=i.toJSON(t);else{e={name:t.name,times:Zh.convertArray(t.times,Array),values:Zh.convertArray(t.values,Array)};var n=t.getInterpolation();n!==t.DefaultInterpolation&&(e.interpolation=n)}return e.type=t.ValueTypeName,e},_getTrackTypeForValueTypeName:function(t){switch(t.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return Wh;case"vector":case"vector2":case"vector3":case"vector4":return Qh;case"color":return jh;case"quaternion":return kh;case"bool":case"boolean":return Gh;case"string":return zh}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+t)}}),Object.assign(Jh.prototype,{constructor:Jh,TimeBufferType:Float32Array,ValueBufferType:Float32Array,DefaultInterpolation:we,InterpolantFactoryMethodDiscrete:function(t){return new Yh(this.times,this.values,this.getValueSize(),t)},InterpolantFactoryMethodLinear:function(t){return new qh(this.times,this.values,this.getValueSize(),t)},InterpolantFactoryMethodSmooth:function(t){return new Xh(this.times,this.values,this.getValueSize(),t)},setInterpolation:function(t){var e;switch(t){case _e:e=this.InterpolantFactoryMethodDiscrete;break;case we:e=this.InterpolantFactoryMethodLinear;break;case 2302:e=this.InterpolantFactoryMethodSmooth}if(void 0!==e)this.createInterpolant=e;else{var i="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(void 0===this.createInterpolant){if(t===this.DefaultInterpolation)throw new Error(i);this.setInterpolation(this.DefaultInterpolation)}console.warn("THREE.KeyframeTrack:",i)}},getInterpolation:function(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return _e;case this.InterpolantFactoryMethodLinear:return we;case this.InterpolantFactoryMethodSmooth:return 2302}},getValueSize:function(){return this.values.length/this.times.length},shift:function(t){if(0!==t)for(var e=this.times,i=0,n=e.length;i!==n;++i)e[i]+=t;return this},scale:function(t){if(1!==t)for(var e=this.times,i=0,n=e.length;i!==n;++i)e[i]*=t;return this},trim:function(t,e){for(var i=this.times,n=i.length,r=0,a=n-1;r!==n&&i[r]<t;)++r;for(;-1!==a&&i[a]>e;)--a;if(++a,0!==r||a!==n){a<=r&&(r=(a=Math.max(a,1))-1);var o=this.getValueSize();this.times=Zh.arraySlice(i,r,a),this.values=Zh.arraySlice(this.values,r*o,a*o)}return this},validate:function(){var t=!0,e=this.getValueSize();e-Math.floor(e)!=0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),t=!1);var i=this.times,n=this.values,r=i.length;0===r&&(console.error("THREE.KeyframeTrack: Track is empty.",this),t=!1);for(var a=null,o=0;o!==r;o++){var s=i[o];if("number"==typeof s&&isNaN(s)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,o,s),t=!1;break}if(null!==a&&s<a){console.error("THREE.KeyframeTrack: Out of order keys.",this,o,s,a),t=!1;break}a=s}if(void 0!==n&&Zh.isTypedArray(n)){o=0;for(var h=n.length;o!==h;++o){var c=n[o];if(isNaN(c)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,o,c),t=!1;break}}}return t},optimize:function(){for(var t=this.times,e=this.values,i=this.getValueSize(),n=2302===this.getInterpolation(),r=1,a=t.length-1,o=1;o<a;++o){var s=!1,h=t[o];if(h!==t[o+1]&&(1!==o||h!==h[0]))if(n)s=!0;else for(var c=o*i,l=c-i,u=c+i,d=0;d!==i;++d){var p=e[c+d];if(p!==e[l+d]||p!==e[u+d]){s=!0;break}}if(s){if(o!==r){t[r]=t[o];var f=o*i,m=r*i;for(d=0;d!==i;++d)e[m+d]=e[f+d]}++r}}if(0<a){t[r]=t[a];for(f=a*i,m=r*i,d=0;d!==i;++d)e[m+d]=e[f+d];++r}return r!==t.length&&(this.times=Zh.arraySlice(t,0,r),this.values=Zh.arraySlice(e,0,r*i)),this}}),Qh.prototype=Object.assign(Object.create(Jh.prototype),{constructor:Qh,ValueTypeName:"vector"}),Object.assign(Kh,{parse:function(t){for(var e=[],i=t.tracks,n=1/(t.fps||1),r=0,a=i.length;r!==a;++r)e.push(Jh.parse(i[r]).scale(n));return new Kh(t.name,t.duration,e)},toJSON:function(t){for(var e=[],i=t.tracks,n={name:t.name,duration:t.duration,tracks:e,uuid:t.uuid},r=0,a=i.length;r!==a;++r)e.push(Jh.toJSON(i[r]));return n},CreateFromMorphTargetSequence:function(t,e,i,n){for(var r=e.length,a=[],o=0;o<r;o++){var s=[],h=[];s.push((o+r-1)%r,o,(o+1)%r),h.push(0,1,0);var c=Zh.getKeyframeOrder(s);s=Zh.sortedArray(s,1,c),h=Zh.sortedArray(h,1,c),n||0!==s[0]||(s.push(r),h.push(h[0])),a.push(new Wh(".morphTargetInfluences["+e[o].name+"]",s,h).scale(1/i))}return new Kh(t,-1,a)},findByName:function(t,e){var i=t;if(!Array.isArray(t)){var n=t;i=n.geometry&&n.geometry.animations||n.animations}for(var r=0;r<i.length;r++)if(i[r].name===e)return i[r];return null},CreateClipsFromMorphTargetSequences:function(t,e,i){for(var n={},r=/^([\w-]*?)([\d]+)$/,a=0,o=t.length;a<o;a++){var s=t[a],h=s.name.match(r);if(h&&1<h.length){var c=n[u=h[1]];c||(n[u]=c=[]),c.push(s)}}var l=[];for(var u in n)l.push(Kh.CreateFromMorphTargetSequence(u,n[u],e,i));return l},parseAnimation:function(t,e){if(!t)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;for(var i=function(t,e,i,n,r){if(0!==i.length){var a=[],o=[];Zh.flattenJSON(i,a,o,n),0!==a.length&&r.push(new t(e,a,o))}},n=[],r=t.name||"default",a=t.length||-1,o=t.fps||30,s=t.hierarchy||[],h=0;h<s.length;h++){var c=s[h].keys;if(c&&0!==c.length)if(c[0].morphTargets){for(var l={},u=0;u<c.length;u++)if(c[u].morphTargets)for(var d=0;d<c[u].morphTargets.length;d++)l[c[u].morphTargets[d]]=-1;for(var p in l){var f=[],m=[];for(d=0;d!==c[u].morphTargets.length;++d){var g=c[u];f.push(g.time),m.push(g.morphTarget===p?1:0)}n.push(new Wh(".morphTargetInfluence["+p+"]",f,m))}a=l.length*(o||1)}else{var v=".bones["+e[h].name+"]";i(Qh,v+".position",c,"pos",n),i(kh,v+".quaternion",c,"rot",n),i(Qh,v+".scale",c,"scl",n)}}return 0===n.length?null:new Kh(r,a,n)}}),Object.assign(Kh.prototype,{resetDuration:function(){for(var t=0,e=0,i=this.tracks.length;e!==i;++e){var n=this.tracks[e];t=Math.max(t,n.times[n.times.length-1])}this.duration=t},trim:function(){for(var t=0;t<this.tracks.length;t++)this.tracks[t].trim(0,this.duration);return this},optimize:function(){for(var t=0;t<this.tracks.length;t++)this.tracks[t].optimize();return this}}),Object.assign($h.prototype,{load:function(t,e,i,n){var r=this;new th(r.manager).load(t,function(t){e(r.parse(JSON.parse(t)))},i,n)},setTextures:function(t){this.textures=t},parse:function(t){var e=this.textures;function i(t){return void 0===e[t]&&console.warn("THREE.MaterialLoader: Undefined texture",t),e[t]}var n=new Zs[t.type];if(void 0!==t.uuid&&(n.uuid=t.uuid),void 0!==t.name&&(n.name=t.name),void 0!==t.color&&n.color.setHex(t.color),void 0!==t.roughness&&(n.roughness=t.roughness),void 0!==t.metalness&&(n.metalness=t.metalness),void 0!==t.emissive&&n.emissive.setHex(t.emissive),void 0!==t.specular&&n.specular.setHex(t.specular),void 0!==t.shininess&&(n.shininess=t.shininess),void 0!==t.clearCoat&&(n.clearCoat=t.clearCoat),void 0!==t.clearCoatRoughness&&(n.clearCoatRoughness=t.clearCoatRoughness),void 0!==t.uniforms&&(n.uniforms=t.uniforms),void 0!==t.vertexShader&&(n.vertexShader=t.vertexShader),void 0!==t.fragmentShader&&(n.fragmentShader=t.fragmentShader),void 0!==t.vertexColors&&(n.vertexColors=t.vertexColors),void 0!==t.fog&&(n.fog=t.fog),void 0!==t.flatShading&&(n.flatShading=t.flatShading),void 0!==t.blending&&(n.blending=t.blending),void 0!==t.side&&(n.side=t.side),void 0!==t.opacity&&(n.opacity=t.opacity),void 0!==t.transparent&&(n.transparent=t.transparent),void 0!==t.alphaTest&&(n.alphaTest=t.alphaTest),void 0!==t.depthTest&&(n.depthTest=t.depthTest),void 0!==t.depthWrite&&(n.depthWrite=t.depthWrite),void 0!==t.colorWrite&&(n.colorWrite=t.colorWrite),void 0!==t.wireframe&&(n.wireframe=t.wireframe),void 0!==t.wireframeLinewidth&&(n.wireframeLinewidth=t.wireframeLinewidth),void 0!==t.wireframeLinecap&&(n.wireframeLinecap=t.wireframeLinecap),void 0!==t.wireframeLinejoin&&(n.wireframeLinejoin=t.wireframeLinejoin),void 0!==t.rotation&&(n.rotation=t.rotation),1!==t.linewidth&&(n.linewidth=t.linewidth),void 0!==t.dashSize&&(n.dashSize=t.dashSize),void 0!==t.gapSize&&(n.gapSize=t.gapSize),void 0!==t.scale&&(n.scale=t.scale),void 0!==t.polygonOffset&&(n.polygonOffset=t.polygonOffset),void 0!==t.polygonOffsetFactor&&(n.polygonOffsetFactor=t.polygonOffsetFactor),void 0!==t.polygonOffsetUnits&&(n.polygonOffsetUnits=t.polygonOffsetUnits),void 0!==t.skinning&&(n.skinning=t.skinning),void 0!==t.morphTargets&&(n.morphTargets=t.morphTargets),void 0!==t.dithering&&(n.dithering=t.dithering),void 0!==t.visible&&(n.visible=t.visible),void 0!==t.userData&&(n.userData=t.userData),void 0!==t.shading&&(n.flatShading=1===t.shading),void 0!==t.size&&(n.size=t.size),void 0!==t.sizeAttenuation&&(n.sizeAttenuation=t.sizeAttenuation),void 0!==t.map&&(n.map=i(t.map)),void 0!==t.alphaMap&&(n.alphaMap=i(t.alphaMap),n.transparent=!0),void 0!==t.bumpMap&&(n.bumpMap=i(t.bumpMap)),void 0!==t.bumpScale&&(n.bumpScale=t.bumpScale),void 0!==t.normalMap&&(n.normalMap=i(t.normalMap)),void 0!==t.normalScale){var r=t.normalScale;!1===Array.isArray(r)&&(r=[r,r]),n.normalScale=(new Be).fromArray(r)}return void 0!==t.displacementMap&&(n.displacementMap=i(t.displacementMap)),void 0!==t.displacementScale&&(n.displacementScale=t.displacementScale),void 0!==t.displacementBias&&(n.displacementBias=t.displacementBias),void 0!==t.roughnessMap&&(n.roughnessMap=i(t.roughnessMap)),void 0!==t.metalnessMap&&(n.metalnessMap=i(t.metalnessMap)),void 0!==t.emissiveMap&&(n.emissiveMap=i(t.emissiveMap)),void 0!==t.emissiveIntensity&&(n.emissiveIntensity=t.emissiveIntensity),void 0!==t.specularMap&&(n.specularMap=i(t.specularMap)),void 0!==t.envMap&&(n.envMap=i(t.envMap)),void 0!==t.reflectivity&&(n.reflectivity=t.reflectivity),void 0!==t.lightMap&&(n.lightMap=i(t.lightMap)),void 0!==t.lightMapIntensity&&(n.lightMapIntensity=t.lightMapIntensity),void 0!==t.aoMap&&(n.aoMap=i(t.aoMap)),void 0!==t.aoMapIntensity&&(n.aoMapIntensity=t.aoMapIntensity),void 0!==t.gradientMap&&(n.gradientMap=i(t.gradientMap)),n}}),Object.assign(tc.prototype,{load:function(t,e,i,n){var r=this;new th(r.manager).load(t,function(t){e(r.parse(JSON.parse(t)))},i,n)},parse:function(t){var e=new Ln,i=t.data.index;if(void 0!==i){var n=new ac[i.type](i.array);e.setIndex(new an(n,1))}var r=t.data.attributes;for(var a in r){var o=r[a];n=new ac[o.type](o.array);e.addAttribute(a,new an(n,o.itemSize,o.normalized))}var s=t.data.groups||t.data.drawcalls||t.data.offsets;if(void 0!==s)for(var h=0,c=s.length;h!==c;++h){var l=s[h];e.addGroup(l.start,l.count,l.materialIndex)}var u=t.data.boundingSphere;if(void 0!==u){var d=new Ge;void 0!==u.center&&d.fromArray(u.center),e.boundingSphere=new ui(d,u.radius)}return e}});var ec,ic,nc,rc,ac={Int8Array:Int8Array,Uint8Array:Uint8Array,Uint8ClampedArray:"undefined"!=typeof Uint8ClampedArray?Uint8ClampedArray:Uint8Array,Int16Array:Int16Array,Uint16Array:Uint16Array,Int32Array:Int32Array,Uint32Array:Uint32Array,Float32Array:Float32Array,Float64Array:Float64Array};function oc(){}oc.Handlers={handlers:[],add:function(t,e){this.handlers.push(t,e)},get:function(t){for(var e=this.handlers,i=0,n=e.length;i<n;i+=2){var r=e[i],a=e[i+1];if(r.test(t))return a}return null}},Object.assign(oc.prototype,{crossOrigin:void 0,onLoadStart:function(){},onLoadProgress:function(){},onLoadComplete:function(){},initMaterials:function(t,e,i){for(var n=[],r=0;r<t.length;++r)n[r]=this.createMaterial(t[r],e,i);return n},createMaterial:(ec={NoBlending:q,NormalBlending:Y,AdditiveBlending:J,SubtractiveBlending:Q,MultiplyBlending:K,CustomBlending:$},ic=new yi,nc=new ah,rc=new $h,function(t,c,l){var u={};function e(t,e,i,n,r){var a,o=c+t,s=oc.Handlers.get(o);null!==s?a=s.load(o):(nc.setCrossOrigin(l),a=nc.load(o)),void 0!==e&&(a.repeat.fromArray(e),1!==e[0]&&(a.wrapS=bt),1!==e[1]&&(a.wrapT=bt)),void 0!==i&&a.offset.fromArray(i),void 0!==n&&("repeat"===n[0]&&(a.wrapS=bt),"mirror"===n[0]&&(a.wrapS=wt),"repeat"===n[1]&&(a.wrapT=bt),"mirror"===n[1]&&(a.wrapT=wt)),void 0!==r&&(a.anisotropy=r);var h=De.generateUUID();return u[h]=a,h}var i={uuid:De.generateUUID(),type:"MeshLambertMaterial"};for(var n in t){var r=t[n];switch(n){case"DbgColor":case"DbgIndex":case"opticalDensity":case"illumination":break;case"DbgName":i.name=r;break;case"blending":i.blending=ec[r];break;case"colorAmbient":case"mapAmbient":console.warn("THREE.Loader.createMaterial:",n,"is no longer supported.");break;case"colorDiffuse":i.color=ic.fromArray(r).getHex();break;case"colorSpecular":i.specular=ic.fromArray(r).getHex();break;case"colorEmissive":i.emissive=ic.fromArray(r).getHex();break;case"specularCoef":i.shininess=r;break;case"shading":"basic"===r.toLowerCase()&&(i.type="MeshBasicMaterial"),"phong"===r.toLowerCase()&&(i.type="MeshPhongMaterial"),"standard"===r.toLowerCase()&&(i.type="MeshStandardMaterial");break;case"mapDiffuse":i.map=e(r,t.mapDiffuseRepeat,t.mapDiffuseOffset,t.mapDiffuseWrap,t.mapDiffuseAnisotropy);break;case"mapDiffuseRepeat":case"mapDiffuseOffset":case"mapDiffuseWrap":case"mapDiffuseAnisotropy":break;case"mapEmissive":i.emissiveMap=e(r,t.mapEmissiveRepeat,t.mapEmissiveOffset,t.mapEmissiveWrap,t.mapEmissiveAnisotropy);break;case"mapEmissiveRepeat":case"mapEmissiveOffset":case"mapEmissiveWrap":case"mapEmissiveAnisotropy":break;case"mapLight":i.lightMap=e(r,t.mapLightRepeat,t.mapLightOffset,t.mapLightWrap,t.mapLightAnisotropy);break;case"mapLightRepeat":case"mapLightOffset":case"mapLightWrap":case"mapLightAnisotropy":break;case"mapAO":i.aoMap=e(r,t.mapAORepeat,t.mapAOOffset,t.mapAOWrap,t.mapAOAnisotropy);break;case"mapAORepeat":case"mapAOOffset":case"mapAOWrap":case"mapAOAnisotropy":break;case"mapBump":i.bumpMap=e(r,t.mapBumpRepeat,t.mapBumpOffset,t.mapBumpWrap,t.mapBumpAnisotropy);break;case"mapBumpScale":i.bumpScale=r;break;case"mapBumpRepeat":case"mapBumpOffset":case"mapBumpWrap":case"mapBumpAnisotropy":break;case"mapNormal":i.normalMap=e(r,t.mapNormalRepeat,t.mapNormalOffset,t.mapNormalWrap,t.mapNormalAnisotropy);break;case"mapNormalFactor":i.normalScale=r;break;case"mapNormalRepeat":case"mapNormalOffset":case"mapNormalWrap":case"mapNormalAnisotropy":break;case"mapSpecular":i.specularMap=e(r,t.mapSpecularRepeat,t.mapSpecularOffset,t.mapSpecularWrap,t.mapSpecularAnisotropy);break;case"mapSpecularRepeat":case"mapSpecularOffset":case"mapSpecularWrap":case"mapSpecularAnisotropy":break;case"mapMetalness":i.metalnessMap=e(r,t.mapMetalnessRepeat,t.mapMetalnessOffset,t.mapMetalnessWrap,t.mapMetalnessAnisotropy);break;case"mapMetalnessRepeat":case"mapMetalnessOffset":case"mapMetalnessWrap":case"mapMetalnessAnisotropy":break;case"mapRoughness":i.roughnessMap=e(r,t.mapRoughnessRepeat,t.mapRoughnessOffset,t.mapRoughnessWrap,t.mapRoughnessAnisotropy);break;case"mapRoughnessRepeat":case"mapRoughnessOffset":case"mapRoughnessWrap":case"mapRoughnessAnisotropy":break;case"mapAlpha":i.alphaMap=e(r,t.mapAlphaRepeat,t.mapAlphaOffset,t.mapAlphaWrap,t.mapAlphaAnisotropy);break;case"mapAlphaRepeat":case"mapAlphaOffset":case"mapAlphaWrap":case"mapAlphaAnisotropy":break;case"flipSided":i.side=At;break;case"doubleSided":i.side=Z;break;case"transparency":console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"),i.opacity=r;break;case"depthTest":case"depthWrite":case"colorWrite":case"opacity":case"reflectivity":case"transparent":case"visible":case"wireframe":i[n]=r;break;case"vertexColors":!0===r&&(i.vertexColors=w),"face"===r&&(i.vertexColors=1);break;default:console.error("THREE.Loader.createMaterial: Unsupported",n,r)}}return"MeshBasicMaterial"===i.type&&delete i.emissive,"MeshPhongMaterial"!==i.type&&delete i.specular,i.opacity<1&&(i.transparent=!0),rc.setTextures(u),rc.parse(i)})});var sc={decodeText:function(t){if("undefined"!=typeof TextDecoder)return(new TextDecoder).decode(t);for(var e="",i=0,n=t.length;i<n;i++)e+=String.fromCharCode(t[i]);return decodeURIComponent(escape(e))},extractUrlBase:function(t){var e=t.lastIndexOf("/");return-1===e?"./":t.substr(0,e+1)}};function hc(t){"boolean"==typeof t&&(console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor."),t=void 0),this.manager=void 0!==t?t:Ks,this.withCredentials=!1}function cc(t){this.manager=void 0!==t?t:Ks,this.texturePath=""}Object.assign(hc.prototype,{load:function(a,o,t,e){var s=this,h=this.texturePath&&"string"==typeof this.texturePath?this.texturePath:sc.extractUrlBase(a),i=new th(this.manager);i.setWithCredentials(this.withCredentials),i.load(a,function(t){var e=JSON.parse(t),i=e.metadata;if(void 0!==i){var n=i.type;if(void 0!==n&&"object"===n.toLowerCase())return void console.error("THREE.JSONLoader: "+a+" should be loaded with THREE.ObjectLoader instead.")}var r=s.parse(e,h);o(r.geometry,r.materials)},t,e)},setTexturePath:function(t){this.texturePath=t},parse:function(t,e){void 0!==t.data&&(t=t.data),void 0!==t.scale?t.scale=1/t.scale:t.scale=1;var i=new rn;return function(t,e){function i(t,e){return t&1<<e}var n,r,a,o,s,h,c,l,u,d,p,f,m,g,v,y,x,b,_,w,M,E,T,S,A,L=t.faces,R=t.vertices,C=t.normals,P=t.colors,O=t.scale,I=0;if(void 0!==t.uvs){for(n=0;n<t.uvs.length;n++)t.uvs[n].length&&I++;for(n=0;n<I;n++)e.faceVertexUvs[n]=[]}for(o=0,s=R.length;o<s;)(b=new Ge).x=R[o++]*O,b.y=R[o++]*O,b.z=R[o++]*O,e.vertices.push(b);for(o=0,s=L.length;o<s;)if(p=i(d=L[o++],0),f=i(d,1),m=i(d,3),g=i(d,4),v=i(d,5),y=i(d,6),x=i(d,7),p){if((w=new Yi).a=L[o],w.b=L[o+1],w.c=L[o+3],(M=new Yi).a=L[o+1],M.b=L[o+2],M.c=L[o+3],o+=4,f&&(u=L[o++],w.materialIndex=u,M.materialIndex=u),a=e.faces.length,m)for(n=0;n<I;n++)for(S=t.uvs[n],e.faceVertexUvs[n][a]=[],e.faceVertexUvs[n][a+1]=[],r=0;r<4;r++)A=new Be(S[2*(l=L[o++])],S[2*l+1]),2!==r&&e.faceVertexUvs[n][a].push(A),0!==r&&e.faceVertexUvs[n][a+1].push(A);if(g&&(c=3*L[o++],w.normal.set(C[c++],C[c++],C[c]),M.normal.copy(w.normal)),v)for(n=0;n<4;n++)c=3*L[o++],T=new Ge(C[c++],C[c++],C[c]),2!==n&&w.vertexNormals.push(T),0!==n&&M.vertexNormals.push(T);if(y&&(E=P[h=L[o++]],w.color.setHex(E),M.color.setHex(E)),x)for(n=0;n<4;n++)E=P[h=L[o++]],2!==n&&w.vertexColors.push(new yi(E)),0!==n&&M.vertexColors.push(new yi(E));e.faces.push(w),e.faces.push(M)}else{if((_=new Yi).a=L[o++],_.b=L[o++],_.c=L[o++],f&&(u=L[o++],_.materialIndex=u),a=e.faces.length,m)for(n=0;n<I;n++)for(S=t.uvs[n],e.faceVertexUvs[n][a]=[],r=0;r<3;r++)A=new Be(S[2*(l=L[o++])],S[2*l+1]),e.faceVertexUvs[n][a].push(A);if(g&&(c=3*L[o++],_.normal.set(C[c++],C[c++],C[c])),v)for(n=0;n<3;n++)c=3*L[o++],T=new Ge(C[c++],C[c++],C[c]),_.vertexNormals.push(T);if(y&&(h=L[o++],_.color.setHex(P[h])),x)for(n=0;n<3;n++)h=L[o++],_.vertexColors.push(new yi(P[h]));e.faces.push(_)}}(t,i),function(t,e){var i=void 0!==t.influencesPerVertex?t.influencesPerVertex:2;if(t.skinWeights)for(var n=0,r=t.skinWeights.length;n<r;n+=i){var a=t.skinWeights[n],o=1<i?t.skinWeights[n+1]:0,s=2<i?t.skinWeights[n+2]:0,h=3<i?t.skinWeights[n+3]:0;e.skinWeights.push(new oi(a,o,s,h))}if(t.skinIndices)for(n=0,r=t.skinIndices.length;n<r;n+=i){var c=t.skinIndices[n],l=1<i?t.skinIndices[n+1]:0,u=2<i?t.skinIndices[n+2]:0,d=3<i?t.skinIndices[n+3]:0;e.skinIndices.push(new oi(c,l,u,d))}e.bones=t.bones,e.bones&&0<e.bones.length&&(e.skinWeights.length!==e.skinIndices.length||e.skinIndices.length!==e.vertices.length)&&console.warn("When skinning, number of vertices ("+e.vertices.length+"), skinIndices ("+e.skinIndices.length+"), and skinWeights ("+e.skinWeights.length+") should match.")}(t,i),function(t,e){var i=t.scale;if(void 0!==t.morphTargets)for(var n=0,r=t.morphTargets.length;n<r;n++){e.morphTargets[n]={},e.morphTargets[n].name=t.morphTargets[n].name,e.morphTargets[n].vertices=[];for(var a=e.morphTargets[n].vertices,o=t.morphTargets[n].vertices,s=0,h=o.length;s<h;s+=3){var c=new Ge;c.x=o[s]*i,c.y=o[s+1]*i,c.z=o[s+2]*i,a.push(c)}}if(void 0!==t.morphColors&&0<t.morphColors.length){console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');var l=e.faces,u=t.morphColors[0].colors;for(n=0,r=l.length;n<r;n++)l[n].color.fromArray(u,3*n)}}(t,i),function(t,e){var i=[],n=[];void 0!==t.animation&&n.push(t.animation),void 0!==t.animations&&(t.animations.length?n=n.concat(t.animations):n.push(t.animations));for(var r=0;r<n.length;r++){var a=Kh.parseAnimation(n[r],e.bones);a&&i.push(a)}if(e.morphTargets){var o=Kh.CreateClipsFromMorphTargetSequences(e.morphTargets,10);i=i.concat(o)}0<i.length&&(e.animations=i)}(t,i),i.computeFaceNormals(),i.computeBoundingSphere(),void 0===t.materials||0===t.materials.length?{geometry:i}:{geometry:i,materials:oc.prototype.initMaterials(t.materials,e,this.crossOrigin)}}}),Object.assign(cc.prototype,{load:function(n,r,t,a){""===this.texturePath&&(this.texturePath=n.substring(0,n.lastIndexOf("/")+1));var o=this;new th(o.manager).load(n,function(t){var e=null;try{e=JSON.parse(t)}catch(t){return void 0!==a&&a(t),void console.error("THREE:ObjectLoader: Can't parse "+n+".",t.message)}var i=e.metadata;void 0!==i&&void 0!==i.type&&"geometry"!==i.type.toLowerCase()?o.parse(e,r):console.error("THREE.ObjectLoader: Can't load "+n+". Use THREE.JSONLoader instead.")},t,a)},setTexturePath:function(t){return this.texturePath=t,this},setCrossOrigin:function(t){return this.crossOrigin=t,this},parse:function(t,e){var i=this.parseShape(t.shapes),n=this.parseGeometries(t.geometries,i),r=this.parseImages(t.images,function(){void 0!==e&&e(s)}),a=this.parseTextures(t.textures,r),o=this.parseMaterials(t.materials,a),s=this.parseObject(t.object,n,o);return t.animations&&(s.animations=this.parseAnimations(t.animations)),void 0!==t.images&&0!==t.images.length||void 0!==e&&e(s),s},parseShape:function(t){var e={};if(void 0!==t)for(var i=0,n=t.length;i<n;i++){var r=(new Lh).fromJSON(t[i]);e[r.uuid]=r}return e},parseGeometries:function(t,e){var i={};if(void 0!==t)for(var n=new hc,r=new tc,a=0,o=t.length;a<o;a++){var s,h=t[a];switch(h.type){case"PlaneGeometry":case"PlaneBufferGeometry":s=new zs[h.type](h.width,h.height,h.widthSegments,h.heightSegments);break;case"BoxGeometry":case"BoxBufferGeometry":case"CubeGeometry":s=new zs[h.type](h.width,h.height,h.depth,h.widthSegments,h.heightSegments,h.depthSegments);break;case"CircleGeometry":case"CircleBufferGeometry":s=new zs[h.type](h.radius,h.segments,h.thetaStart,h.thetaLength);break;case"CylinderGeometry":case"CylinderBufferGeometry":s=new zs[h.type](h.radiusTop,h.radiusBottom,h.height,h.radialSegments,h.heightSegments,h.openEnded,h.thetaStart,h.thetaLength);break;case"ConeGeometry":case"ConeBufferGeometry":s=new zs[h.type](h.radius,h.height,h.radialSegments,h.heightSegments,h.openEnded,h.thetaStart,h.thetaLength);break;case"SphereGeometry":case"SphereBufferGeometry":s=new zs[h.type](h.radius,h.widthSegments,h.heightSegments,h.phiStart,h.phiLength,h.thetaStart,h.thetaLength);break;case"DodecahedronGeometry":case"DodecahedronBufferGeometry":case"IcosahedronGeometry":case"IcosahedronBufferGeometry":case"OctahedronGeometry":case"OctahedronBufferGeometry":case"TetrahedronGeometry":case"TetrahedronBufferGeometry":s=new zs[h.type](h.radius,h.detail);break;case"RingGeometry":case"RingBufferGeometry":s=new zs[h.type](h.innerRadius,h.outerRadius,h.thetaSegments,h.phiSegments,h.thetaStart,h.thetaLength);break;case"TorusGeometry":case"TorusBufferGeometry":s=new zs[h.type](h.radius,h.tube,h.radialSegments,h.tubularSegments,h.arc);break;case"TorusKnotGeometry":case"TorusKnotBufferGeometry":s=new zs[h.type](h.radius,h.tube,h.tubularSegments,h.radialSegments,h.p,h.q);break;case"LatheGeometry":case"LatheBufferGeometry":s=new zs[h.type](h.points,h.segments,h.phiStart,h.phiLength);break;case"PolyhedronGeometry":case"PolyhedronBufferGeometry":s=new zs[h.type](h.vertices,h.indices,h.radius,h.details);break;case"ShapeGeometry":case"ShapeBufferGeometry":for(var c=[],l=0,u=h.shapes.length;l<u;l++){var d=e[h.shapes[l]];c.push(d)}s=new zs[h.type](c,h.curveSegments);break;case"BufferGeometry":s=r.parse(h);break;case"Geometry":s=n.parse(h,this.texturePath).geometry;break;default:console.warn('THREE.ObjectLoader: Unsupported geometry type "'+h.type+'"');continue}s.uuid=h.uuid,void 0!==h.name&&(s.name=h.name),i[h.uuid]=s}return i},parseMaterials:function(t,e){var i={};if(void 0!==t){var n=new $h;n.setTextures(e);for(var r=0,a=t.length;r<a;r++){var o=t[r];if("MultiMaterial"===o.type){for(var s=[],h=0;h<o.materials.length;h++)s.push(n.parse(o.materials[h]));i[o.uuid]=s}else i[o.uuid]=n.parse(o)}}return i},parseAnimations:function(t){for(var e=[],i=0;i<t.length;i++){var n=t[i],r=Kh.parse(n);void 0!==n.uuid&&(r.uuid=n.uuid),e.push(r)}return e},parseImages:function(t,e){var i=this,n={};function r(t){return i.manager.itemStart(t),a.load(t,function(){i.manager.itemEnd(t)},void 0,function(){i.manager.itemEnd(t),i.manager.itemError(t)})}if(void 0!==t&&0<t.length){var a=new nh(new Qs(e));a.setCrossOrigin(this.crossOrigin);for(var o=0,s=t.length;o<s;o++){var h=t[o],c=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(h.url)?h.url:i.texturePath+h.url;n[h.uuid]=r(c)}}return n},parseTextures:function(t,e){function i(t,e){return"number"==typeof t?t:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",t),e[t])}var n={};if(void 0!==t)for(var r=0,a=t.length;r<a;r++){var o=t[r];void 0===o.image&&console.warn('THREE.ObjectLoader: No "image" specified for',o.uuid),void 0===e[o.image]&&console.warn("THREE.ObjectLoader: Undefined image",o.image);var s=new ai(e[o.image]);s.needsUpdate=!0,s.uuid=o.uuid,void 0!==o.name&&(s.name=o.name),void 0!==o.mapping&&(s.mapping=i(o.mapping,uc)),void 0!==o.offset&&s.offset.fromArray(o.offset),void 0!==o.repeat&&s.repeat.fromArray(o.repeat),void 0!==o.center&&s.center.fromArray(o.center),void 0!==o.rotation&&(s.rotation=o.rotation),void 0!==o.wrap&&(s.wrapS=i(o.wrap[0],dc),s.wrapT=i(o.wrap[1],dc)),void 0!==o.format&&(s.format=o.format),void 0!==o.minFilter&&(s.minFilter=i(o.minFilter,pc)),void 0!==o.magFilter&&(s.magFilter=i(o.magFilter,pc)),void 0!==o.anisotropy&&(s.anisotropy=o.anisotropy),void 0!==o.flipY&&(s.flipY=o.flipY),n[o.uuid]=s}return n},parseObject:function(t,e,a){var i;function n(t){return void 0===e[t]&&console.warn("THREE.ObjectLoader: Undefined geometry",t),e[t]}function r(t){if(void 0!==t){if(Array.isArray(t)){for(var e=[],i=0,n=t.length;i<n;i++){var r=t[i];void 0===a[r]&&console.warn("THREE.ObjectLoader: Undefined material",r),e.push(a[r])}return e}return void 0===a[t]&&console.warn("THREE.ObjectLoader: Undefined material",t),a[t]}}switch(t.type){case"Scene":i=new uo,void 0!==t.background&&Number.isInteger(t.background)&&(i.background=new yi(t.background)),void 0!==t.fog&&("Fog"===t.fog.type?i.fog=new lo(t.fog.color,t.fog.near,t.fog.far):"FogExp2"===t.fog.type&&(i.fog=new co(t.fog.color,t.fog.density)));break;case"PerspectiveCamera":i=new ro(t.fov,t.aspect,t.near,t.far),void 0!==t.focus&&(i.focus=t.focus),void 0!==t.zoom&&(i.zoom=t.zoom),void 0!==t.filmGauge&&(i.filmGauge=t.filmGauge),void 0!==t.filmOffset&&(i.filmOffset=t.filmOffset),void 0!==t.view&&(i.view=Object.assign({},t.view));break;case"OrthographicCamera":i=new qi(t.left,t.right,t.top,t.bottom,t.near,t.far),void 0!==t.zoom&&(i.zoom=t.zoom),void 0!==t.view&&(i.view=Object.assign({},t.view));break;case"AmbientLight":i=new Bh(t.color,t.intensity);break;case"DirectionalLight":i=new Dh(t.color,t.intensity);break;case"PointLight":i=new Nh(t.color,t.intensity,t.distance,t.decay);break;case"RectAreaLight":i=new Fh(t.color,t.intensity,t.width,t.height);break;case"SpotLight":i=new Ih(t.color,t.intensity,t.distance,t.angle,t.penumbra,t.decay);break;case"HemisphereLight":i=new Ch(t.color,t.groundColor,t.intensity);break;case"SkinnedMesh":console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");case"Mesh":var o=n(t.geometry),s=r(t.material);i=o.bones&&0<o.bones.length?new yo(o,s):new lr(o,s);break;case"LOD":i=new mo;break;case"Line":i=new bo(n(t.geometry),r(t.material),t.mode);break;case"LineLoop":i=new wo(n(t.geometry),r(t.material));break;case"LineSegments":i=new _o(n(t.geometry),r(t.material));break;case"PointCloud":case"Points":i=new Eo(n(t.geometry),r(t.material));break;case"Sprite":i=new fo(r(t.material));break;case"Group":i=new To;break;default:i=new Wi}if(i.uuid=t.uuid,void 0!==t.name&&(i.name=t.name),void 0!==t.matrix?(i.matrix.fromArray(t.matrix),void 0!==t.matrixAutoUpdate&&(i.matrixAutoUpdate=t.matrixAutoUpdate),i.matrixAutoUpdate&&i.matrix.decompose(i.position,i.quaternion,i.scale)):(void 0!==t.position&&i.position.fromArray(t.position),void 0!==t.rotation&&i.rotation.fromArray(t.rotation),void 0!==t.quaternion&&i.quaternion.fromArray(t.quaternion),void 0!==t.scale&&i.scale.fromArray(t.scale)),void 0!==t.castShadow&&(i.castShadow=t.castShadow),void 0!==t.receiveShadow&&(i.receiveShadow=t.receiveShadow),t.shadow&&(void 0!==t.shadow.bias&&(i.shadow.bias=t.shadow.bias),void 0!==t.shadow.radius&&(i.shadow.radius=t.shadow.radius),void 0!==t.shadow.mapSize&&i.shadow.mapSize.fromArray(t.shadow.mapSize),void 0!==t.shadow.camera&&(i.shadow.camera=this.parseObject(t.shadow.camera))),void 0!==t.visible&&(i.visible=t.visible),void 0!==t.frustumCulled&&(i.frustumCulled=t.frustumCulled),void 0!==t.renderOrder&&(i.renderOrder=t.renderOrder),void 0!==t.userData&&(i.userData=t.userData),void 0!==t.children)for(var h=t.children,c=0;c<h.length;c++)i.add(this.parseObject(h[c],e,a));if("LOD"===t.type)for(var l=t.levels,u=0;u<l.length;u++){var d=l[u],p=i.getObjectByProperty("uuid",d.object);void 0!==p&&i.addLevel(p,d.distance)}return i}});var lc,uc={UVMapping:300,CubeReflectionMapping:pt,CubeRefractionMapping:ft,EquirectangularReflectionMapping:mt,EquirectangularRefractionMapping:gt,SphericalReflectionMapping:vt,CubeUVReflectionMapping:yt,CubeUVRefractionMapping:xt},dc={RepeatWrapping:bt,ClampToEdgeWrapping:_t,MirroredRepeatWrapping:wt},pc={NearestFilter:Mt,NearestMipMapNearestFilter:Et,NearestMipMapLinearFilter:Tt,LinearFilter:St,LinearMipMapNearestFilter:Ct,LinearMipMapLinearFilter:Pt};function fc(t){"undefined"==typeof createImageBitmap&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),"undefined"==typeof fetch&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.manager=void 0!==t?t:Ks,this.options=void 0}function mc(){this.type="ShapePath",this.color=new yi,this.subPaths=[],this.currentPath=null}function gc(t){this.type="Font",this.data=t}function vc(t,e,i,n,r,a){var o=a.glyphs[t]||a.glyphs["?"];if(o){var s,h,c,l,u,d,p,f,m=new mc;if(o.o)for(var g=o._cachedOutline||(o._cachedOutline=o.o.split(" ")),v=0,y=g.length;v<y;){switch(g[v++]){case"m":s=g[v++]*i+n,h=g[v++]*i+r,m.moveTo(s,h);break;case"l":s=g[v++]*i+n,h=g[v++]*i+r,m.lineTo(s,h);break;case"q":c=g[v++]*i+n,l=g[v++]*i+r,u=g[v++]*i+n,d=g[v++]*i+r,m.quadraticCurveTo(u,d,c,l);break;case"b":c=g[v++]*i+n,l=g[v++]*i+r,u=g[v++]*i+n,d=g[v++]*i+r,p=g[v++]*i+n,f=g[v++]*i+r,m.bezierCurveTo(u,d,p,f,c,l)}}return{offsetX:o.ha*i,path:m}}}function yc(t){this.manager=void 0!==t?t:Ks}fc.prototype={constructor:fc,setOptions:function(t){return this.options=t,this},load:function(e,i,t,n){void 0===e&&(e=""),void 0!==this.path&&(e=this.path+e),e=this.manager.resolveURL(e);var r=this,a=Js.get(e);if(void 0!==a)return r.manager.itemStart(e),setTimeout(function(){i&&i(a),r.manager.itemEnd(e)},0),a;fetch(e).then(function(t){return t.blob()}).then(function(t){return createImageBitmap(t,r.options)}).then(function(t){Js.add(e,t),i&&i(t),r.manager.itemEnd(e)}).catch(function(t){n&&n(t),r.manager.itemEnd(e),r.manager.itemError(e)})},setCrossOrigin:function(){return this},setPath:function(t){return this.path=t,this}},Object.assign(mc.prototype,{moveTo:function(t,e){this.currentPath=new Ah,this.subPaths.push(this.currentPath),this.currentPath.moveTo(t,e)},lineTo:function(t,e){this.currentPath.lineTo(t,e)},quadraticCurveTo:function(t,e,i,n){this.currentPath.quadraticCurveTo(t,e,i,n)},bezierCurveTo:function(t,e,i,n,r,a){this.currentPath.bezierCurveTo(t,e,i,n,r,a)},splineThru:function(t){this.currentPath.splineThru(t)},toShapes:function(t,e){function i(t){for(var e=[],i=0,n=t.length;i<n;i++){var r=t[i],a=new Lh;a.curves=r.curves,e.push(a)}return e}function n(t,e){for(var i=e.length,n=!1,r=i-1,a=0;a<i;r=a++){var o=e[r],s=e[a],h=s.x-o.x,c=s.y-o.y;if(Math.abs(c)>Number.EPSILON){if(c<0&&(o=e[a],h=-h,s=e[r],c=-c),t.y<o.y||t.y>s.y)continue;if(t.y===o.y){if(t.x===o.x)return!0}else{var l=c*(t.x-o.x)-h*(t.y-o.y);if(0===l)return!0;if(l<0)continue;n=!n}}else{if(t.y!==o.y)continue;if(s.x<=t.x&&t.x<=o.x||o.x<=t.x&&t.x<=s.x)return!0}}return n}var r=ms.isClockWise,a=this.subPaths;if(0===a.length)return[];if(!0===e)return i(a);var o,s,h,c=[];if(1===a.length)return s=a[0],(h=new Lh).curves=s.curves,c.push(h),c;var l=!r(a[0].getPoints());l=t?!l:l;var u,d,p=[],f=[],m=[],g=0;f[g]=void 0,m[g]=[];for(var v=0,y=a.length;v<y;v++)o=r(u=(s=a[v]).getPoints()),(o=t?!o:o)?(!l&&f[g]&&g++,f[g]={s:new Lh,p:u},f[g].s.curves=s.curves,l&&g++,m[g]=[]):m[g].push({h:s,p:u[0]});if(!f[0])return i(a);if(1<f.length){for(var x=!1,b=[],_=0,w=f.length;_<w;_++)p[_]=[];for(_=0,w=f.length;_<w;_++)for(var M=m[_],E=0;E<M.length;E++){for(var T=M[E],S=!0,A=0;A<f.length;A++)n(T.p,f[A].p)&&(_!==A&&b.push({froms:_,tos:A,hole:E}),S?(S=!1,p[A].push(T)):x=!0);S&&p[_].push(T)}0<b.length&&(x||(m=p))}v=0;for(var L=f.length;v<L;v++){h=f[v].s,c.push(h);for(var R=0,C=(d=m[v]).length;R<C;R++)h.holes.push(d[R].h)}return c}}),Object.assign(gc.prototype,{isFont:!0,generateShapes:function(t,e,i){void 0===e&&(e=100),void 0===i&&(i=4);for(var n=[],r=function(t,e,i,n){for(var r=String(t).split(""),a=e/n.resolution,o=(n.boundingBox.yMax-n.boundingBox.yMin+n.underlineThickness)*a,s=[],h=0,c=0,l=0;l<r.length;l++){var u=r[l];if("\n"===u)h=0,c-=o;else{var d=vc(u,i,a,h,c,n);h+=d.offsetX,s.push(d.path)}}return s}(t,e,i,this.data),a=0,o=r.length;a<o;a++)Array.prototype.push.apply(n,r[a].toShapes());return n}}),Object.assign(yc.prototype,{load:function(t,n,e,i){var r=this,a=new th(this.manager);a.setPath(this.path),a.load(t,function(e){var i;try{i=JSON.parse(e)}catch(t){console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."),i=JSON.parse(e.substring(65,e.length-2))}var t=r.parse(i);n&&n(t)},e,i)},parse:function(t){return new gc(t)},setPath:function(t){return this.path=t,this}});var xc,bc,_c,wc,Mc,Ec,Tc,Sc,Ac,Lc,Rc,Cc,Pc,Oc,Ic,Nc={getContext:function(){return void 0===lc&&(lc=new(window.AudioContext||window.webkitAudioContext)),lc},setContext:function(t){lc=t}};function Uc(t){this.manager=void 0!==t?t:Ks}function Dc(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new ro,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new ro,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1}function Bc(t,e,i){Wi.call(this),this.type="CubeCamera";var r=new ro(90,1,t,e);r.up.set(0,-1,0),r.lookAt(new Ge(1,0,0)),this.add(r);var a=new ro(90,1,t,e);a.up.set(0,-1,0),a.lookAt(new Ge(-1,0,0)),this.add(a);var o=new ro(90,1,t,e);o.up.set(0,0,1),o.lookAt(new Ge(0,1,0)),this.add(o);var s=new ro(90,1,t,e);s.up.set(0,0,-1),s.lookAt(new Ge(0,-1,0)),this.add(s);var h=new ro(90,1,t,e);h.up.set(0,-1,0),h.lookAt(new Ge(0,0,1)),this.add(h);var c=new ro(90,1,t,e);c.up.set(0,-1,0),c.lookAt(new Ge(0,0,-1)),this.add(c);var n={format:Wt,magFilter:St,minFilter:St};this.renderTarget=new hi(i,i,n),this.renderTarget.texture.name="CubeCamera",this.update=function(t,e){null===this.parent&&this.updateMatrixWorld();var i=this.renderTarget,n=i.texture.generateMipmaps;i.texture.generateMipmaps=!1,i.activeCubeFace=0,t.render(e,r,i),i.activeCubeFace=1,t.render(e,a,i),i.activeCubeFace=2,t.render(e,o,i),i.activeCubeFace=3,t.render(e,s,i),i.activeCubeFace=4,t.render(e,h,i),i.texture.generateMipmaps=n,i.activeCubeFace=5,t.render(e,c,i),t.setRenderTarget(null)},this.clear=function(t,e,i,n){for(var r=this.renderTarget,a=0;a<6;a++)r.activeCubeFace=a,t.setRenderTarget(r),t.clear(e,i,n);t.setRenderTarget(null)}}function Fc(){Wi.call(this),this.type="AudioListener",this.context=Nc.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null}function zc(t){Wi.call(this),this.type="Audio",this.context=t.context,this.gain=this.context.createGain(),this.gain.connect(t.getInput()),this.autoplay=!1,this.buffer=null,this.loop=!1,this.startTime=0,this.offset=0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.sourceType="empty",this.filters=[]}function Gc(t){zc.call(this,t),this.panner=this.context.createPanner(),this.panner.connect(this.gain)}function Hc(t,e){this.analyser=t.context.createAnalyser(),this.analyser.fftSize=void 0!==e?e:2048,this.data=new Uint8Array(this.analyser.frequencyBinCount),t.getOutput().connect(this.analyser)}function Vc(t,e,i){this.binding=t,this.valueSize=i;var n,r=Float64Array;switch(e){case"quaternion":n=this._slerp;break;case"string":case"bool":r=Array,n=this._select;break;default:n=this._lerp}this.buffer=new r(4*i),this._mixBufferRegion=n,this.cumulativeWeight=0,this.useCount=0,this.referenceCount=0}Object.assign(Uc.prototype,{load:function(t,e,i,n){var r=new th(this.manager);r.setResponseType("arraybuffer"),r.load(t,function(t){Nc.getContext().decodeAudioData(t,function(t){e(t)})},i,n)}}),Object.assign(Dc.prototype,{update:(Ac=new Fe,Lc=new Fe,function(t){if(xc!==this||bc!==t.focus||_c!==t.fov||wc!==t.aspect*this.aspect||Mc!==t.near||Ec!==t.far||Tc!==t.zoom||Sc!==this.eyeSep){xc=this,bc=t.focus,_c=t.fov,wc=t.aspect*this.aspect,Mc=t.near,Ec=t.far,Tc=t.zoom;var e,i,n=t.projectionMatrix.clone(),r=(Sc=this.eyeSep/2)*Mc/bc,a=Mc*Math.tan(De.DEG2RAD*_c*.5)/Tc;Lc.elements[12]=-Sc,Ac.elements[12]=Sc,e=-a*wc+r,i=a*wc+r,n.elements[0]=2*Mc/(i-e),n.elements[8]=(i+e)/(i-e),this.cameraL.projectionMatrix.copy(n),e=-a*wc-r,i=a*wc-r,n.elements[0]=2*Mc/(i-e),n.elements[8]=(i+e)/(i-e),this.cameraR.projectionMatrix.copy(n)}this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(Lc),this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(Ac)})}),(Bc.prototype=Object.create(Wi.prototype)).constructor=Bc,Fc.prototype=Object.assign(Object.create(Wi.prototype),{constructor:Fc,getInput:function(){return this.gain},removeFilter:function(){null!==this.filter&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null)},getFilter:function(){return this.filter},setFilter:function(t){null!==this.filter?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=t,this.gain.connect(this.filter),this.filter.connect(this.context.destination)},getMasterVolume:function(){return this.gain.gain.value},setMasterVolume:function(t){this.gain.gain.setTargetAtTime(t,this.context.currentTime,.01)},updateMatrixWorld:(Rc=new Ge,Cc=new ze,Pc=new Ge,Oc=new Ge,function(t){Wi.prototype.updateMatrixWorld.call(this,t);var e=this.context.listener,i=this.up;this.matrixWorld.decompose(Rc,Cc,Pc),Oc.set(0,0,-1).applyQuaternion(Cc),e.positionX?(e.positionX.setValueAtTime(Rc.x,this.context.currentTime),e.positionY.setValueAtTime(Rc.y,this.context.currentTime),e.positionZ.setValueAtTime(Rc.z,this.context.currentTime),e.forwardX.setValueAtTime(Oc.x,this.context.currentTime),e.forwardY.setValueAtTime(Oc.y,this.context.currentTime),e.forwardZ.setValueAtTime(Oc.z,this.context.currentTime),e.upX.setValueAtTime(i.x,this.context.currentTime),e.upY.setValueAtTime(i.y,this.context.currentTime),e.upZ.setValueAtTime(i.z,this.context.currentTime)):(e.setPosition(Rc.x,Rc.y,Rc.z),e.setOrientation(Oc.x,Oc.y,Oc.z,i.x,i.y,i.z))})}),zc.prototype=Object.assign(Object.create(Wi.prototype),{constructor:zc,getOutput:function(){return this.gain},setNodeSource:function(t){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=t,this.connect(),this},setMediaElementSource:function(t){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(t),this.connect(),this},setBuffer:function(t){return this.buffer=t,this.sourceType="buffer",this.autoplay&&this.play(),this},play:function(){if(!0!==this.isPlaying){if(!1!==this.hasPlaybackControl){var t=this.context.createBufferSource();return t.buffer=this.buffer,t.loop=this.loop,t.onended=this.onEnded.bind(this),t.playbackRate.setValueAtTime(this.playbackRate,this.startTime),this.startTime=this.context.currentTime,t.start(this.startTime,this.offset),this.isPlaying=!0,this.source=t,this.connect()}console.warn("THREE.Audio: this Audio has no playback control.")}else console.warn("THREE.Audio: Audio is already playing.")},pause:function(){if(!1!==this.hasPlaybackControl)return!0===this.isPlaying&&(this.source.stop(),this.offset+=(this.context.currentTime-this.startTime)*this.playbackRate,this.isPlaying=!1),this;console.warn("THREE.Audio: this Audio has no playback control.")},stop:function(){if(!1!==this.hasPlaybackControl)return this.source.stop(),this.offset=0,this.isPlaying=!1,this;console.warn("THREE.Audio: this Audio has no playback control.")},connect:function(){if(0<this.filters.length){this.source.connect(this.filters[0]);for(var t=1,e=this.filters.length;t<e;t++)this.filters[t-1].connect(this.filters[t]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this},disconnect:function(){if(0<this.filters.length){this.source.disconnect(this.filters[0]);for(var t=1,e=this.filters.length;t<e;t++)this.filters[t-1].disconnect(this.filters[t]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this},getFilters:function(){return this.filters},setFilters:function(t){return t||(t=[]),!0===this.isPlaying?(this.disconnect(),this.filters=t,this.connect()):this.filters=t,this},getFilter:function(){return this.getFilters()[0]},setFilter:function(t){return this.setFilters(t?[t]:[])},setPlaybackRate:function(t){if(!1!==this.hasPlaybackControl)return this.playbackRate=t,!0===this.isPlaying&&this.source.playbackRate.setValueAtTime(this.playbackRate,this.context.currentTime),this;console.warn("THREE.Audio: this Audio has no playback control.")},getPlaybackRate:function(){return this.playbackRate},onEnded:function(){this.isPlaying=!1},getLoop:function(){return!1===this.hasPlaybackControl?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop},setLoop:function(t){if(!1!==this.hasPlaybackControl)return this.loop=t,!0===this.isPlaying&&(this.source.loop=this.loop),this;console.warn("THREE.Audio: this Audio has no playback control.")},getVolume:function(){return this.gain.gain.value},setVolume:function(t){return this.gain.gain.setTargetAtTime(t,this.context.currentTime,.01),this}}),Gc.prototype=Object.assign(Object.create(zc.prototype),{constructor:Gc,getOutput:function(){return this.panner},getRefDistance:function(){return this.panner.refDistance},setRefDistance:function(t){this.panner.refDistance=t},getRolloffFactor:function(){return this.panner.rolloffFactor},setRolloffFactor:function(t){this.panner.rolloffFactor=t},getDistanceModel:function(){return this.panner.distanceModel},setDistanceModel:function(t){this.panner.distanceModel=t},getMaxDistance:function(){return this.panner.maxDistance},setMaxDistance:function(t){this.panner.maxDistance=t},updateMatrixWorld:(Ic=new Ge,function(t){Wi.prototype.updateMatrixWorld.call(this,t),Ic.setFromMatrixPosition(this.matrixWorld),this.panner.setPosition(Ic.x,Ic.y,Ic.z)})}),Object.assign(Hc.prototype,{getFrequencyData:function(){return this.analyser.getByteFrequencyData(this.data),this.data},getAverageFrequency:function(){for(var t=0,e=this.getFrequencyData(),i=0;i<e.length;i++)t+=e[i];return t/e.length}}),Object.assign(Vc.prototype,{accumulate:function(t,e){var i=this.buffer,n=this.valueSize,r=t*n+n,a=this.cumulativeWeight;if(0===a){for(var o=0;o!==n;++o)i[r+o]=i[o];a=e}else{var s=e/(a+=e);this._mixBufferRegion(i,r,0,s,n)}this.cumulativeWeight=a},apply:function(t){var e=this.valueSize,i=this.buffer,n=t*e+e,r=this.cumulativeWeight,a=this.binding;if(this.cumulativeWeight=0,r<1){var o=3*e;this._mixBufferRegion(i,n,o,1-r,e)}for(var s=e,h=e+e;s!==h;++s)if(i[s]!==i[s+e]){a.setValue(i,n);break}},saveOriginalState:function(){var t=this.binding,e=this.buffer,i=this.valueSize,n=3*i;t.getValue(e,n);for(var r=i,a=n;r!==a;++r)e[r]=e[n+r%i];this.cumulativeWeight=0},restoreOriginalState:function(){var t=3*this.valueSize;this.binding.setValue(this.buffer,t)},_select:function(t,e,i,n,r){if(.5<=n)for(var a=0;a!==r;++a)t[e+a]=t[i+a]},_slerp:function(t,e,i,n){ze.slerpFlat(t,e,t,e,t,i,n)},_lerp:function(t,e,i,n,r){for(var a=1-n,o=0;o!==r;++o){var s=e+o;t[s]=t[s]*a+t[i+o]*n}}});var kc,jc,Wc,Xc,qc,Yc,Zc,Jc,Qc,Kc,$c,tl,el,il,nl,rl,al,ol,sl,hl,cl,ll,ul,dl,pl,fl,ml,gl,vl,yl,xl,bl,_l,wl="\\[\\]\\.:\\/";function Ml(t,e,i){var n=i||El.parseTrackName(e);this._targetGroup=t,this._bindings=t.subscribe_(e,n)}function El(t,e,i){this.path=e,this.parsedPath=i||El.parseTrackName(e),this.node=El.findNode(t,this.parsedPath.nodeName)||t,this.rootNode=t}function Tl(){this.uuid=De.generateUUID(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;var t={};this._indicesByUUID=t;for(var e=0,i=arguments.length;e!==i;++e)t[arguments[e].uuid]=e;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};var n=this;this.stats={objects:{get total(){return n._objects.length},get inUse(){return this.total-n.nCachedObjects_}},get bindingsPerObject(){return n._bindings.length}}}function Sl(t,e,i){this._mixer=t,this._clip=e,this._localRoot=i||null;for(var n=e.tracks,r=n.length,a=new Array(r),o={endingStart:Me,endingEnd:Me},s=0;s!==r;++s){var h=n[s].createInterpolant(null);(a[s]=h).settings=o}this._interpolantSettings=o,this._interpolants=a,this._propertyBindings=new Array(r),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=2201,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}function Al(t){this._root=t,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}function Ll(t){"string"==typeof t&&(console.warn("THREE.Uniform: Type parameter is no longer needed."),t=arguments[1]),this.value=t}function Rl(){Ln.call(this),this.type="InstancedBufferGeometry",this.maxInstancedCount=void 0}function Cl(t,e,i,n){this.data=t,this.itemSize=e,this.offset=i,this.normalized=!0===n}function Pl(t,e){this.array=t,this.stride=e,this.count=void 0!==t?t.length/e:0,this.dynamic=!1,this.updateRange={offset:0,count:-1},this.version=0}function Ol(t,e,i){Pl.call(this,t,e),this.meshPerAttribute=i||1}function Il(t,e,i){an.call(this,t,e),this.meshPerAttribute=i||1}function Nl(t,e,i,n){this.ray=new sr(t,e),this.near=i||0,this.far=n||1/0,this.params={Mesh:{},Line:{},LOD:{},Points:{threshold:1},Sprite:{}},Object.defineProperties(this.params,{PointCloud:{get:function(){return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."),this.Points}}})}function Ul(t,e){return t.distance-e.distance}function Dl(t,e,i,n){if(!1!==t.visible&&(t.raycast(e,i),!0===n))for(var r=t.children,a=0,o=r.length;a<o;a++)Dl(r[a],e,i,!0)}function Bl(t){this.autoStart=void 0===t||t,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}function Fl(t,e,i){return this.radius=void 0!==t?t:1,this.phi=void 0!==e?e:0,this.theta=void 0!==i?i:0,this}function zl(t,e,i){return this.radius=void 0!==t?t:1,this.theta=void 0!==e?e:0,this.y=void 0!==i?i:0,this}function Gl(t,e){this.min=void 0!==t?t:new Be(1/0,1/0),this.max=void 0!==e?e:new Be(-1/0,-1/0)}function Hl(t){Wi.call(this),this.material=t,this.render=function(){}}function Vl(t,e,i,n){this.object=t,this.size=void 0!==e?e:1;var r=void 0!==i?i:16711680,a=void 0!==n?n:1,o=0,s=this.object.geometry;s&&s.isGeometry?o=3*s.faces.length:s&&s.isBufferGeometry&&(o=s.attributes.normal.count);var h=new Ln,c=new pn(2*o*3,3);h.addAttribute("position",c),_o.call(this,h,new xo({color:r,linewidth:a})),this.matrixAutoUpdate=!1,this.update()}function kl(t,e){Wi.call(this),this.light=t,this.light.updateMatrixWorld(),this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.color=e;for(var i=new Ln,n=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1],r=0,a=1;r<32;r++,a++){var o=r/32*Math.PI*2,s=a/32*Math.PI*2;n.push(Math.cos(o),Math.sin(o),1,Math.cos(s),Math.sin(s),1)}i.addAttribute("position",new pn(n,3));var h=new xo({fog:!1});this.cone=new _o(i,h),this.add(this.cone),this.update()}function jl(t){for(var e=function t(e){var i=[];e&&e.isBone&&i.push(e);for(var n=0;n<e.children.length;n++)i.push.apply(i,t(e.children[n]));return i}(t),i=new Ln,n=[],r=[],a=new yi(0,0,1),o=new yi(0,1,0),s=0;s<e.length;s++){var h=e[s];h.parent&&h.parent.isBone&&(n.push(0,0,0),n.push(0,0,0),r.push(a.r,a.g,a.b),r.push(o.r,o.g,o.b))}i.addAttribute("position",new pn(n,3)),i.addAttribute("color",new pn(r,3));var c=new xo({vertexColors:w,depthTest:!1,depthWrite:!1,transparent:!0});_o.call(this,i,c),this.root=t,this.bones=e,this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1}function Wl(t,e,i){this.light=t,this.light.updateMatrixWorld(),this.color=i;var n=new Es(e,4,2),r=new ar({wireframe:!0,fog:!1});lr.call(this,n,r),this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}function Xl(t,e){Wi.call(this),this.light=t,this.light.updateMatrixWorld(),this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.color=e;var i=new xo({fog:!1}),n=new Ln;n.addAttribute("position",new an(new Float32Array(15),3)),this.line=new bo(n,i),this.add(this.line),this.update()}function ql(t,e,i){Wi.call(this),this.light=t,this.light.updateMatrixWorld(),this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.color=i;var n=new Bo(e);n.rotateY(.5*Math.PI),this.material=new ar({wireframe:!0,fog:!1}),void 0===this.color&&(this.material.vertexColors=w);var r=n.getAttribute("position"),a=new Float32Array(3*r.count);n.addAttribute("color",new an(a,3)),this.add(new lr(n,this.material)),this.update()}function Yl(t,e,i,n){t=t||10,e=e||10,i=new yi(void 0!==i?i:4473924),n=new yi(void 0!==n?n:8947848);for(var r=e/2,a=t/e,o=t/2,s=[],h=[],c=0,l=0,u=-o;c<=e;c++,u+=a){s.push(-o,0,u,o,0,u),s.push(u,0,-o,u,0,o);var d=c===r?i:n;d.toArray(h,l),l+=3,d.toArray(h,l),l+=3,d.toArray(h,l),l+=3,d.toArray(h,l),l+=3}var p=new Ln;p.addAttribute("position",new pn(s,3)),p.addAttribute("color",new pn(h,3));var f=new xo({vertexColors:w});_o.call(this,p,f)}function Zl(t,e,i,n,r,a){t=t||10,e=e||16,i=i||8,n=n||64,r=new yi(void 0!==r?r:4473924),a=new yi(void 0!==a?a:8947848);var o,s,h,c,l,u,d,p=[],f=[];for(c=0;c<=e;c++)h=c/e*(2*Math.PI),o=Math.sin(h)*t,s=Math.cos(h)*t,p.push(0,0,0),p.push(o,0,s),d=1&c?r:a,f.push(d.r,d.g,d.b),f.push(d.r,d.g,d.b);for(c=0;c<=i;c++)for(d=1&c?r:a,u=t-t/i*c,l=0;l<n;l++)h=l/n*(2*Math.PI),o=Math.sin(h)*u,s=Math.cos(h)*u,p.push(o,0,s),f.push(d.r,d.g,d.b),h=(l+1)/n*(2*Math.PI),o=Math.sin(h)*u,s=Math.cos(h)*u,p.push(o,0,s),f.push(d.r,d.g,d.b);var m=new Ln;m.addAttribute("position",new pn(p,3)),m.addAttribute("color",new pn(f,3));var g=new xo({vertexColors:w});_o.call(this,m,g)}function Jl(t,e,i,n){this.object=t,this.size=void 0!==e?e:1;var r=void 0!==i?i:16776960,a=void 0!==n?n:1,o=0,s=this.object.geometry;s&&s.isGeometry?o=s.faces.length:console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");var h=new Ln,c=new pn(2*o*3,3);h.addAttribute("position",c),_o.call(this,h,new xo({color:r,linewidth:a})),this.matrixAutoUpdate=!1,this.update()}function Ql(t,e,i){Wi.call(this),this.light=t,this.light.updateMatrixWorld(),this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.color=i,void 0===e&&(e=1);var n=new Ln;n.addAttribute("position",new pn([-e,e,0,e,e,0,e,-e,0,-e,-e,0,-e,e,0],3));var r=new xo({fog:!1});this.lightPlane=new bo(n,r),this.add(this.lightPlane),(n=new Ln).addAttribute("position",new pn([0,0,0,0,0,1],3)),this.targetLine=new bo(n,r),this.add(this.targetLine),this.update()}function Kl(t){var e=new Ln,i=new xo({color:16777215,vertexColors:1}),n=[],r=[],a={},o=new yi(16755200),s=new yi(16711680),h=new yi(43775),c=new yi(16777215),l=new yi(3355443);function u(t,e,i){d(t,i),d(e,i)}function d(t,e){n.push(0,0,0),r.push(e.r,e.g,e.b),void 0===a[t]&&(a[t]=[]),a[t].push(n.length/3-1)}u("n1","n2",o),u("n2","n4",o),u("n4","n3",o),u("n3","n1",o),u("f1","f2",o),u("f2","f4",o),u("f4","f3",o),u("f3","f1",o),u("n1","f1",o),u("n2","f2",o),u("n3","f3",o),u("n4","f4",o),u("p","n1",s),u("p","n2",s),u("p","n3",s),u("p","n4",s),u("u1","u2",h),u("u2","u3",h),u("u3","u1",h),u("c","t",c),u("p","c",l),u("cn1","cn2",l),u("cn3","cn4",l),u("cf1","cf2",l),u("cf3","cf4",l),e.addAttribute("position",new pn(n,3)),e.addAttribute("color",new pn(r,3)),_o.call(this,e,i),this.camera=t,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=a,this.update()}function $l(t,e){this.object=t,void 0===e&&(e=16776960);var i=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),n=new Float32Array(24),r=new Ln;r.setIndex(new an(i,1)),r.addAttribute("position",new an(n,3)),_o.call(this,r,new xo({color:e})),this.matrixAutoUpdate=!1,this.update()}function tu(t,e){this.type="Box3Helper",this.box=t;var i=void 0!==e?e:16776960,n=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),r=new Ln;r.setIndex(new an(n,1)),r.addAttribute("position",new pn([1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],3)),_o.call(this,r,new xo({color:i})),this.geometry.computeBoundingSphere()}function eu(t,e,i){this.type="PlaneHelper",this.plane=t,this.size=void 0===e?1:e;var n=void 0!==i?i:16776960,r=new Ln;r.addAttribute("position",new pn([1,-1,1,-1,1,1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,0,0,1,0,0,0],3)),r.computeBoundingSphere(),bo.call(this,r,new xo({color:n}));var a=new Ln;a.addAttribute("position",new pn([1,1,1,-1,1,1,-1,-1,1,1,1,1,-1,-1,1,1,-1,1],3)),a.computeBoundingSphere(),this.add(new lr(a,new ar({color:n,opacity:.2,transparent:!0,depthWrite:!1})))}function iu(t,e,i,n,r,a){Wi.call(this),void 0===n&&(n=16776960),void 0===i&&(i=1),void 0===r&&(r=.2*i),void 0===a&&(a=.2*r),void 0===yl&&((yl=new Ln).addAttribute("position",new pn([0,0,0,0,1,0],3)),(xl=new Ns(0,.5,1,5,1)).translate(0,-.5,0)),this.position.copy(e),this.line=new bo(yl,new xo({color:n})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new lr(xl,new ar({color:n})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(t),this.setLength(i,r,a)}function nu(t){var e=[0,0,0,t=t||1,0,0,0,0,0,0,t,0,0,0,0,0,0,t],i=new Ln;i.addAttribute("position",new pn(e,3)),i.addAttribute("color",new pn([1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],3));var n=new xo({vertexColors:w});_o.call(this,i,n)}Object.assign(Ml.prototype,{getValue:function(t,e){this.bind();var i=this._targetGroup.nCachedObjects_,n=this._bindings[i];void 0!==n&&n.getValue(t,e)},setValue:function(t,e){for(var i=this._bindings,n=this._targetGroup.nCachedObjects_,r=i.length;n!==r;++n)i[n].setValue(t,e)},bind:function(){for(var t=this._bindings,e=this._targetGroup.nCachedObjects_,i=t.length;e!==i;++e)t[e].bind()},unbind:function(){for(var t=this._bindings,e=this._targetGroup.nCachedObjects_,i=t.length;e!==i;++e)t[e].unbind()}}),Object.assign(El,{Composite:Ml,create:function(t,e,i){return t&&t.isAnimationObjectGroup?new El.Composite(t,e,i):new El(t,e,i)},sanitizeNodeName:(Qc=new RegExp("["+wl+"]","g"),function(t){return t.replace(/\s/g,"_").replace(Qc,"")}),parseTrackName:(kc="[^"+wl+"]",jc="[^"+wl.replace("\\.","")+"]",Wc=/((?:WC+[\/:])*)/.source.replace("WC",kc),Xc=/(WCOD+)?/.source.replace("WCOD",jc),qc=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",kc),Yc=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",kc),Zc=new RegExp("^"+Wc+Xc+qc+Yc+"$"),Jc=["material","materials","bones"],function(t){var e=Zc.exec(t);if(!e)throw new Error("PropertyBinding: Cannot parse trackName: "+t);var i={nodeName:e[2],objectName:e[3],objectIndex:e[4],propertyName:e[5],propertyIndex:e[6]},n=i.nodeName&&i.nodeName.lastIndexOf(".");if(void 0!==n&&-1!==n){var r=i.nodeName.substring(n+1);-1!==Jc.indexOf(r)&&(i.nodeName=i.nodeName.substring(0,n),i.objectName=r)}if(null===i.propertyName||0===i.propertyName.length)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+t);return i}),findNode:function(t,r){if(!r||""===r||"root"===r||"."===r||-1===r||r===t.name||r===t.uuid)return t;if(t.skeleton){var e=t.skeleton.getBoneByName(r);if(void 0!==e)return e}if(t.children){var a=function(t){for(var e=0;e<t.length;e++){var i=t[e];if(i.name===r||i.uuid===r)return i;var n=a(i.children);if(n)return n}return null},i=a(t.children);if(i)return i}return null}}),Object.assign(El.prototype,{_getValue_unavailable:function(){},_setValue_unavailable:function(){},BindingType:{Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},Versioning:{None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},GetterByBindingType:[function(t,e){t[e]=this.node[this.propertyName]},function(t,e){for(var i=this.resolvedProperty,n=0,r=i.length;n!==r;++n)t[e++]=i[n]},function(t,e){t[e]=this.resolvedProperty[this.propertyIndex]},function(t,e){this.resolvedProperty.toArray(t,e)}],SetterByBindingTypeAndVersioning:[[function(t,e){this.targetObject[this.propertyName]=t[e]},function(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.needsUpdate=!0},function(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}],[function(t,e){for(var i=this.resolvedProperty,n=0,r=i.length;n!==r;++n)i[n]=t[e++]},function(t,e){for(var i=this.resolvedProperty,n=0,r=i.length;n!==r;++n)i[n]=t[e++];this.targetObject.needsUpdate=!0},function(t,e){for(var i=this.resolvedProperty,n=0,r=i.length;n!==r;++n)i[n]=t[e++];this.targetObject.matrixWorldNeedsUpdate=!0}],[function(t,e){this.resolvedProperty[this.propertyIndex]=t[e]},function(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.needsUpdate=!0},function(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}],[function(t,e){this.resolvedProperty.fromArray(t,e)},function(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.needsUpdate=!0},function(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.matrixWorldNeedsUpdate=!0}]],getValue:function(t,e){this.bind(),this.getValue(t,e)},setValue:function(t,e){this.bind(),this.setValue(t,e)},bind:function(){var t=this.node,e=this.parsedPath,i=e.objectName,n=e.propertyName,r=e.propertyIndex;if(t||(t=El.findNode(this.rootNode,e.nodeName)||this.rootNode,this.node=t),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,t){if(i){var a=e.objectIndex;switch(i){case"materials":if(!t.material)return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);if(!t.material.materials)return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);t=t.material.materials;break;case"bones":if(!t.skeleton)return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);t=t.skeleton.bones;for(var o=0;o<t.length;o++)if(t[o].name===a){a=o;break}break;default:if(void 0===t[i])return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);t=t[i]}if(void 0!==a){if(void 0===t[a])return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,t);t=t[a]}}var s=t[n];if(void 0!==s){var h=this.Versioning.None;void 0!==t.needsUpdate?(h=this.Versioning.NeedsUpdate,this.targetObject=t):void 0!==t.matrixWorldNeedsUpdate&&(h=this.Versioning.MatrixWorldNeedsUpdate,this.targetObject=t);var c=this.BindingType.Direct;if(void 0!==r){if("morphTargetInfluences"===n){if(!t.geometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);if(t.geometry.isBufferGeometry){if(!t.geometry.morphAttributes)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);for(o=0;o<this.node.geometry.morphAttributes.position.length;o++)if(t.geometry.morphAttributes.position[o].name===r){r=o;break}}else{if(!t.geometry.morphTargets)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.",this);for(o=0;o<this.node.geometry.morphTargets.length;o++)if(t.geometry.morphTargets[o].name===r){r=o;break}}}c=this.BindingType.ArrayElement,this.resolvedProperty=s,this.propertyIndex=r}else void 0!==s.fromArray&&void 0!==s.toArray?(c=this.BindingType.HasFromToArray,this.resolvedProperty=s):Array.isArray(s)?(c=this.BindingType.EntireArray,this.resolvedProperty=s):this.propertyName=n;this.getValue=this.GetterByBindingType[c],this.setValue=this.SetterByBindingTypeAndVersioning[c][h]}else{var l=e.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+l+"."+n+" but it wasn't found.",t)}}else console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.")},unbind:function(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}),Object.assign(El.prototype,{_getValue_unbound:El.prototype.getValue,_setValue_unbound:El.prototype.setValue}),Object.assign(Tl.prototype,{isAnimationObjectGroup:!0,add:function(){for(var t=this._objects,e=t.length,i=this.nCachedObjects_,n=this._indicesByUUID,r=this._paths,a=this._parsedPaths,o=this._bindings,s=o.length,h=void 0,c=0,l=arguments.length;c!==l;++c){var u=arguments[c],d=u.uuid,p=n[d];if(void 0===p){p=e++,n[d]=p,t.push(u);for(var f=0,m=s;f!==m;++f)o[f].push(new El(u,r[f],a[f]))}else if(p<i){h=t[p];var g=--i,v=t[g];t[n[v.uuid]=p]=v,t[n[d]=g]=u;for(f=0,m=s;f!==m;++f){var y=o[f],x=y[g],b=y[p];y[p]=x,void 0===b&&(b=new El(u,r[f],a[f])),y[g]=b}}else t[p]!==h&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=i},remove:function(){for(var t=this._objects,e=this.nCachedObjects_,i=this._indicesByUUID,n=this._bindings,r=n.length,a=0,o=arguments.length;a!==o;++a){var s=arguments[a],h=s.uuid,c=i[h];if(void 0!==c&&e<=c){var l=e++,u=t[l];t[i[u.uuid]=c]=u,t[i[h]=l]=s;for(var d=0,p=r;d!==p;++d){var f=n[d],m=f[l],g=f[c];f[c]=m,f[l]=g}}}this.nCachedObjects_=e},uncache:function(){for(var t=this._objects,e=t.length,i=this.nCachedObjects_,n=this._indicesByUUID,r=this._bindings,a=r.length,o=0,s=arguments.length;o!==s;++o){var h=arguments[o].uuid,c=n[h];if(void 0!==c)if(delete n[h],c<i){var l=--i,u=t[l],d=t[v=--e];t[n[u.uuid]=c]=u,t[n[d.uuid]=l]=d,t.pop();for(var p=0,f=a;p!==f;++p){var m=(y=r[p])[l],g=y[v];y[c]=m,y[l]=g,y.pop()}}else{var v;t[n[(d=t[v=--e]).uuid]=c]=d,t.pop();for(p=0,f=a;p!==f;++p){var y;(y=r[p])[c]=y[v],y.pop()}}}this.nCachedObjects_=i},subscribe_:function(t,e){var i=this._bindingsIndicesByPath,n=i[t],r=this._bindings;if(void 0!==n)return r[n];var a=this._paths,o=this._parsedPaths,s=this._objects,h=s.length,c=this.nCachedObjects_,l=new Array(h);n=r.length,i[t]=n,a.push(t),o.push(e),r.push(l);for(var u=c,d=s.length;u!==d;++u){var p=s[u];l[u]=new El(p,t,e)}return l},unsubscribe_:function(t){var e=this._bindingsIndicesByPath,i=e[t];if(void 0!==i){var n=this._paths,r=this._parsedPaths,a=this._bindings,o=a.length-1,s=a[o];a[e[t[o]]=i]=s,a.pop(),r[i]=r[o],r.pop(),n[i]=n[o],n.pop()}}}),Object.assign(Sl.prototype,{play:function(){return this._mixer._activateAction(this),this},stop:function(){return this._mixer._deactivateAction(this),this.reset()},reset:function(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()},isRunning:function(){return this.enabled&&!this.paused&&0!==this.timeScale&&null===this._startTime&&this._mixer._isActiveAction(this)},isScheduled:function(){return this._mixer._isActiveAction(this)},startAt:function(t){return this._startTime=t,this},setLoop:function(t,e){return this.loop=t,this.repetitions=e,this},setEffectiveWeight:function(t){return this.weight=t,this._effectiveWeight=this.enabled?t:0,this.stopFading()},getEffectiveWeight:function(){return this._effectiveWeight},fadeIn:function(t){return this._scheduleFading(t,0,1)},fadeOut:function(t){return this._scheduleFading(t,1,0)},crossFadeFrom:function(t,e,i){if(t.fadeOut(e),this.fadeIn(e),i){var n=this._clip.duration,r=t._clip.duration,a=r/n,o=n/r;t.warp(1,a,e),this.warp(o,1,e)}return this},crossFadeTo:function(t,e,i){return t.crossFadeFrom(this,e,i)},stopFading:function(){var t=this._weightInterpolant;return null!==t&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this},setEffectiveTimeScale:function(t){return this.timeScale=t,this._effectiveTimeScale=this.paused?0:t,this.stopWarping()},getEffectiveTimeScale:function(){return this._effectiveTimeScale},setDuration:function(t){return this.timeScale=this._clip.duration/t,this.stopWarping()},syncWith:function(t){return this.time=t.time,this.timeScale=t.timeScale,this.stopWarping()},halt:function(t){return this.warp(this._effectiveTimeScale,0,t)},warp:function(t,e,i){var n=this._mixer,r=n.time,a=this._timeScaleInterpolant,o=this.timeScale;null===a&&(a=n._lendControlInterpolant(),this._timeScaleInterpolant=a);var s=a.parameterPositions,h=a.sampleValues;return s[0]=r,s[1]=r+i,h[0]=t/o,h[1]=e/o,this},stopWarping:function(){var t=this._timeScaleInterpolant;return null!==t&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this},getMixer:function(){return this._mixer},getClip:function(){return this._clip},getRoot:function(){return this._localRoot||this._mixer._root},_update:function(t,e,i,n){if(this.enabled){var r=this._startTime;if(null!==r){var a=(t-r)*i;if(a<0||0===i)return;this._startTime=null,e=i*a}e*=this._updateTimeScale(t);var o=this._updateTime(e),s=this._updateWeight(t);if(0<s)for(var h=this._interpolants,c=this._propertyBindings,l=0,u=h.length;l!==u;++l)h[l].evaluate(o),c[l].accumulate(n,s)}else this._updateWeight(t)},_updateWeight:function(t){var e=0;if(this.enabled){e=this.weight;var i=this._weightInterpolant;if(null!==i){var n=i.evaluate(t)[0];e*=n,t>i.parameterPositions[1]&&(this.stopFading(),0===n&&(this.enabled=!1))}}return this._effectiveWeight=e},_updateTimeScale:function(t){var e=0;if(!this.paused){e=this.timeScale;var i=this._timeScaleInterpolant;if(null!==i)e*=i.evaluate(t)[0],t>i.parameterPositions[1]&&(this.stopWarping(),0===e?this.paused=!0:this.timeScale=e)}return this._effectiveTimeScale=e},_updateTime:function(t){var e=this.time+t;if(0===t)return e;var i=this._clip.duration,n=this.loop,r=this._loopCount;if(2200===n){-1===r&&(this._loopCount=0,this._setEndings(!0,!0,!1));t:{if(i<=e)e=i;else{if(!(e<0))break t;e=0}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this._mixer.dispatchEvent({type:"finished",action:this,direction:t<0?-1:1})}}else{var a=2202===n;if(-1===r&&(0<=t?(r=0,this._setEndings(!0,0===this.repetitions,a)):this._setEndings(0===this.repetitions,!0,a)),i<=e||e<0){var o=Math.floor(e/i);e-=i*o,r+=Math.abs(o);var s=this.repetitions-r;if(s<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,e=0<t?i:0,this._mixer.dispatchEvent({type:"finished",action:this,direction:0<t?1:-1});else{if(1===s){var h=t<0;this._setEndings(h,!h,a)}else this._setEndings(!1,!1,a);this._loopCount=r,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:o})}}if(a&&1==(1&r))return i-(this.time=e)}return this.time=e},_setEndings:function(t,e,i){var n=this._interpolantSettings;i?(n.endingStart=Ee,n.endingEnd=Ee):(n.endingStart=t?this.zeroSlopeAtStart?Ee:Me:Te,n.endingEnd=e?this.zeroSlopeAtEnd?Ee:Me:Te)},_scheduleFading:function(t,e,i){var n=this._mixer,r=n.time,a=this._weightInterpolant;null===a&&(a=n._lendControlInterpolant(),this._weightInterpolant=a);var o=a.parameterPositions,s=a.sampleValues;return o[0]=r,s[0]=e,o[1]=r+t,s[1]=i,this}}),Al.prototype=Object.assign(Object.create(e.prototype),{constructor:Al,_bindAction:function(t,e){var i=t._localRoot||this._root,n=t._clip.tracks,r=n.length,a=t._propertyBindings,o=t._interpolants,s=i.uuid,h=this._bindingsByRootAndName,c=h[s];void 0===c&&(c={},h[s]=c);for(var l=0;l!==r;++l){var u=n[l],d=u.name,p=c[d];if(void 0!==p)a[l]=p;else{if(void 0!==(p=a[l])){null===p._cacheIndex&&(++p.referenceCount,this._addInactiveBinding(p,s,d));continue}var f=e&&e._propertyBindings[l].binding.parsedPath;++(p=new Vc(El.create(i,d,f),u.ValueTypeName,u.getValueSize())).referenceCount,this._addInactiveBinding(p,s,d),a[l]=p}o[l].resultBuffer=p.buffer}},_activateAction:function(t){if(!this._isActiveAction(t)){if(null===t._cacheIndex){var e=(t._localRoot||this._root).uuid,i=t._clip.uuid,n=this._actionsByClip[i];this._bindAction(t,n&&n.knownActions[0]),this._addInactiveAction(t,i,e)}for(var r=t._propertyBindings,a=0,o=r.length;a!==o;++a){var s=r[a];0==s.useCount++&&(this._lendBinding(s),s.saveOriginalState())}this._lendAction(t)}},_deactivateAction:function(t){if(this._isActiveAction(t)){for(var e=t._propertyBindings,i=0,n=e.length;i!==n;++i){var r=e[i];0==--r.useCount&&(r.restoreOriginalState(),this._takeBackBinding(r))}this._takeBackAction(t)}},_initMemoryManager:function(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;var t=this;this.stats={actions:{get total(){return t._actions.length},get inUse(){return t._nActiveActions}},bindings:{get total(){return t._bindings.length},get inUse(){return t._nActiveBindings}},controlInterpolants:{get total(){return t._controlInterpolants.length},get inUse(){return t._nActiveControlInterpolants}}}},_isActiveAction:function(t){var e=t._cacheIndex;return null!==e&&e<this._nActiveActions},_addInactiveAction:function(t,e,i){var n=this._actions,r=this._actionsByClip,a=r[e];if(void 0===a)a={knownActions:[t],actionByRoot:{}},t._byClipCacheIndex=0,r[e]=a;else{var o=a.knownActions;t._byClipCacheIndex=o.length,o.push(t)}t._cacheIndex=n.length,n.push(t),a.actionByRoot[i]=t},_removeInactiveAction:function(t){var e=this._actions,i=e[e.length-1],n=t._cacheIndex;e[i._cacheIndex=n]=i,e.pop(),t._cacheIndex=null;var r=t._clip.uuid,a=this._actionsByClip,o=a[r],s=o.knownActions,h=s[s.length-1],c=t._byClipCacheIndex;s[h._byClipCacheIndex=c]=h,s.pop(),t._byClipCacheIndex=null,delete o.actionByRoot[(t._localRoot||this._root).uuid],0===s.length&&delete a[r],this._removeInactiveBindingsForAction(t)},_removeInactiveBindingsForAction:function(t){for(var e=t._propertyBindings,i=0,n=e.length;i!==n;++i){var r=e[i];0==--r.referenceCount&&this._removeInactiveBinding(r)}},_lendAction:function(t){var e=this._actions,i=t._cacheIndex,n=this._nActiveActions++,r=e[n];e[t._cacheIndex=n]=t,e[r._cacheIndex=i]=r},_takeBackAction:function(t){var e=this._actions,i=t._cacheIndex,n=--this._nActiveActions,r=e[n];e[t._cacheIndex=n]=t,e[r._cacheIndex=i]=r},_addInactiveBinding:function(t,e,i){var n=this._bindingsByRootAndName,r=n[e],a=this._bindings;void 0===r&&(r={},n[e]=r),(r[i]=t)._cacheIndex=a.length,a.push(t)},_removeInactiveBinding:function(t){var e=this._bindings,i=t.binding,n=i.rootNode.uuid,r=i.path,a=this._bindingsByRootAndName,o=a[n],s=e[e.length-1],h=t._cacheIndex;e[s._cacheIndex=h]=s,e.pop(),delete o[r];t:{for(var c in o)break t;delete a[n]}},_lendBinding:function(t){var e=this._bindings,i=t._cacheIndex,n=this._nActiveBindings++,r=e[n];e[t._cacheIndex=n]=t,e[r._cacheIndex=i]=r},_takeBackBinding:function(t){var e=this._bindings,i=t._cacheIndex,n=--this._nActiveBindings,r=e[n];e[t._cacheIndex=n]=t,e[r._cacheIndex=i]=r},_lendControlInterpolant:function(){var t=this._controlInterpolants,e=this._nActiveControlInterpolants++,i=t[e];return void 0===i&&(t[(i=new qh(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer)).__cacheIndex=e]=i),i},_takeBackControlInterpolant:function(t){var e=this._controlInterpolants,i=t.__cacheIndex,n=--this._nActiveControlInterpolants,r=e[n];e[t.__cacheIndex=n]=t,e[r.__cacheIndex=i]=r},_controlInterpolantsResultBuffer:new Float32Array(1),clipAction:function(t,e){var i=e||this._root,n=i.uuid,r="string"==typeof t?Kh.findByName(i,t):t,a=null!==r?r.uuid:t,o=this._actionsByClip[a],s=null;if(void 0!==o){var h=o.actionByRoot[n];if(void 0!==h)return h;s=o.knownActions[0],null===r&&(r=s._clip)}if(null===r)return null;var c=new Sl(this,r,e);return this._bindAction(c,s),this._addInactiveAction(c,a,n),c},existingAction:function(t,e){var i=e||this._root,n=i.uuid,r="string"==typeof t?Kh.findByName(i,t):t,a=r?r.uuid:t,o=this._actionsByClip[a];return void 0!==o&&o.actionByRoot[n]||null},stopAllAction:function(){var t=this._actions,e=this._nActiveActions,i=this._bindings,n=this._nActiveBindings;this._nActiveActions=0;for(var r=this._nActiveBindings=0;r!==e;++r)t[r].reset();for(r=0;r!==n;++r)i[r].useCount=0;return this},update:function(t){t*=this.timeScale;for(var e=this._actions,i=this._nActiveActions,n=this.time+=t,r=Math.sign(t),a=this._accuIndex^=1,o=0;o!==i;++o){e[o]._update(n,t,r,a)}var s=this._bindings,h=this._nActiveBindings;for(o=0;o!==h;++o)s[o].apply(a);return this},getRoot:function(){return this._root},uncacheClip:function(t){var e=this._actions,i=t.uuid,n=this._actionsByClip,r=n[i];if(void 0!==r){for(var a=r.knownActions,o=0,s=a.length;o!==s;++o){var h=a[o];this._deactivateAction(h);var c=h._cacheIndex,l=e[e.length-1];h._cacheIndex=null,h._byClipCacheIndex=null,e[l._cacheIndex=c]=l,e.pop(),this._removeInactiveBindingsForAction(h)}delete n[i]}},uncacheRoot:function(t){var e=t.uuid,i=this._actionsByClip;for(var n in i){var r=i[n].actionByRoot[e];void 0!==r&&(this._deactivateAction(r),this._removeInactiveAction(r))}var a=this._bindingsByRootAndName[e];if(void 0!==a)for(var o in a){var s=a[o];s.restoreOriginalState(),this._removeInactiveBinding(s)}},uncacheAction:function(t,e){var i=this.existingAction(t,e);null!==i&&(this._deactivateAction(i),this._removeInactiveAction(i))}}),Ll.prototype.clone=function(){return new Ll(void 0===this.value.clone?this.value:this.value.clone())},Rl.prototype=Object.assign(Object.create(Ln.prototype),{constructor:Rl,isInstancedBufferGeometry:!0,copy:function(t){return Ln.prototype.copy.call(this,t),this.maxInstancedCount=t.maxInstancedCount,this},clone:function(){return(new this.constructor).copy(this)}}),Object.defineProperties(Cl.prototype,{count:{get:function(){return this.data.count}},array:{get:function(){return this.data.array}}}),Object.assign(Cl.prototype,{isInterleavedBufferAttribute:!0,setX:function(t,e){return this.data.array[t*this.data.stride+this.offset]=e,this},setY:function(t,e){return this.data.array[t*this.data.stride+this.offset+1]=e,this},setZ:function(t,e){return this.data.array[t*this.data.stride+this.offset+2]=e,this},setW:function(t,e){return this.data.array[t*this.data.stride+this.offset+3]=e,this},getX:function(t){return this.data.array[t*this.data.stride+this.offset]},getY:function(t){return this.data.array[t*this.data.stride+this.offset+1]},getZ:function(t){return this.data.array[t*this.data.stride+this.offset+2]},getW:function(t){return this.data.array[t*this.data.stride+this.offset+3]},setXY:function(t,e,i){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=i,this},setXYZ:function(t,e,i,n){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=i,this.data.array[t+2]=n,this},setXYZW:function(t,e,i,n,r){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=i,this.data.array[t+2]=n,this.data.array[t+3]=r,this}}),Object.defineProperty(Pl.prototype,"needsUpdate",{set:function(t){!0===t&&this.version++}}),Object.assign(Pl.prototype,{isInterleavedBuffer:!0,onUploadCallback:function(){},setArray:function(t){if(Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");return this.count=void 0!==t?t.length/this.stride:0,this.array=t,this},setDynamic:function(t){return this.dynamic=t,this},copy:function(t){return this.array=new t.array.constructor(t.array),this.count=t.count,this.stride=t.stride,this.dynamic=t.dynamic,this},copyAt:function(t,e,i){t*=this.stride,i*=e.stride;for(var n=0,r=this.stride;n<r;n++)this.array[t+n]=e.array[i+n];return this},set:function(t,e){return void 0===e&&(e=0),this.array.set(t,e),this},clone:function(){return(new this.constructor).copy(this)},onUpload:function(t){return this.onUploadCallback=t,this}}),Ol.prototype=Object.assign(Object.create(Pl.prototype),{constructor:Ol,isInstancedInterleavedBuffer:!0,copy:function(t){return Pl.prototype.copy.call(this,t),this.meshPerAttribute=t.meshPerAttribute,this}}),Il.prototype=Object.assign(Object.create(an.prototype),{constructor:Il,isInstancedBufferAttribute:!0,copy:function(t){return an.prototype.copy.call(this,t),this.meshPerAttribute=t.meshPerAttribute,this}}),Object.assign(Nl.prototype,{linePrecision:1,set:function(t,e){this.ray.set(t,e)},setFromCamera:function(t,e){e&&e.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(e.matrixWorld),this.ray.direction.set(t.x,t.y,.5).unproject(e).sub(this.ray.origin).normalize()):e&&e.isOrthographicCamera?(this.ray.origin.set(t.x,t.y,(e.near+e.far)/(e.near-e.far)).unproject(e),this.ray.direction.set(0,0,-1).transformDirection(e.matrixWorld)):console.error("THREE.Raycaster: Unsupported camera type.")},intersectObject:function(t,e,i){var n=i||[];return Dl(t,this,n,e),n.sort(Ul),n},intersectObjects:function(t,e,i){var n=i||[];if(!1===Array.isArray(t))return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."),n;for(var r=0,a=t.length;r<a;r++)Dl(t[r],this,n,e);return n.sort(Ul),n}}),Object.assign(Bl.prototype,{start:function(){this.startTime=("undefined"==typeof performance?Date:performance).now(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0},stop:function(){this.getElapsedTime(),this.running=!1,this.autoStart=!1},getElapsedTime:function(){return this.getDelta(),this.elapsedTime},getDelta:function(){var t=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){var e=("undefined"==typeof performance?Date:performance).now();t=(e-this.oldTime)/1e3,this.oldTime=e,this.elapsedTime+=t}return t}}),Object.assign(Fl.prototype,{set:function(t,e,i){return this.radius=t,this.phi=e,this.theta=i,this},clone:function(){return(new this.constructor).copy(this)},copy:function(t){return this.radius=t.radius,this.phi=t.phi,this.theta=t.theta,this},makeSafe:function(){return this.phi=Math.max(1e-6,Math.min(Math.PI-1e-6,this.phi)),this},setFromVector3:function(t){return this.radius=t.length(),0===this.radius?(this.theta=0,this.phi=0):(this.theta=Math.atan2(t.x,t.z),this.phi=Math.acos(De.clamp(t.y/this.radius,-1,1))),this}}),Object.assign(zl.prototype,{set:function(t,e,i){return this.radius=t,this.theta=e,this.y=i,this},clone:function(){return(new this.constructor).copy(this)},copy:function(t){return this.radius=t.radius,this.theta=t.theta,this.y=t.y,this},setFromVector3:function(t){return this.radius=Math.sqrt(t.x*t.x+t.z*t.z),this.theta=Math.atan2(t.x,t.z),this.y=t.y,this}}),Object.assign(Gl.prototype,{set:function(t,e){return this.min.copy(t),this.max.copy(e),this},setFromPoints:function(t){this.makeEmpty();for(var e=0,i=t.length;e<i;e++)this.expandByPoint(t[e]);return this},setFromCenterAndSize:($c=new Be,function(t,e){var i=$c.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(i),this.max.copy(t).add(i),this}),clone:function(){return(new this.constructor).copy(this)},copy:function(t){return this.min.copy(t.min),this.max.copy(t.max),this},makeEmpty:function(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this},isEmpty:function(){return this.max.x<this.min.x||this.max.y<this.min.y},getCenter:function(t){return void 0===t&&(console.warn("THREE.Box2: .getCenter() target is now required"),t=new Be),this.isEmpty()?t.set(0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)},getSize:function(t){return void 0===t&&(console.warn("THREE.Box2: .getSize() target is now required"),t=new Be),this.isEmpty()?t.set(0,0):t.subVectors(this.max,this.min)},expandByPoint:function(t){return this.min.min(t),this.max.max(t),this},expandByVector:function(t){return this.min.sub(t),this.max.add(t),this},expandByScalar:function(t){return this.min.addScalar(-t),this.max.addScalar(t),this},containsPoint:function(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y)},containsBox:function(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y},getParameter:function(t,e){return void 0===e&&(console.warn("THREE.Box2: .getParameter() target is now required"),e=new Be),e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y))},intersectsBox:function(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y)},clampPoint:function(t,e){return void 0===e&&(console.warn("THREE.Box2: .clampPoint() target is now required"),e=new Be),e.copy(t).clamp(this.min,this.max)},distanceToPoint:(Kc=new Be,function(t){return Kc.copy(t).clamp(this.min,this.max).sub(t).length()}),intersect:function(t){return this.min.max(t.min),this.max.min(t.max),this},union:function(t){return this.min.min(t.min),this.max.max(t.max),this},translate:function(t){return this.min.add(t),this.max.add(t),this},equals:function(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}),((Hl.prototype=Object.create(Wi.prototype)).constructor=Hl).prototype.isImmediateRenderObject=!0,((Vl.prototype=Object.create(_o.prototype)).constructor=Vl).prototype.update=(tl=new Ge,el=new Ge,il=new He,function(){var t=["a","b","c"];this.object.updateMatrixWorld(!0),il.getNormalMatrix(this.object.matrixWorld);var e=this.object.matrixWorld,i=this.geometry.attributes.position,n=this.object.geometry;if(n&&n.isGeometry)for(var r=n.vertices,a=n.faces,o=0,s=0,h=a.length;s<h;s++)for(var c=a[s],l=0,u=c.vertexNormals.length;l<u;l++){var d=r[c[t[l]]],p=c.vertexNormals[l];tl.copy(d).applyMatrix4(e),el.copy(p).applyMatrix3(il).normalize().multiplyScalar(this.size).add(tl),i.setXYZ(o,tl.x,tl.y,tl.z),o+=1,i.setXYZ(o,el.x,el.y,el.z),o+=1}else if(n&&n.isBufferGeometry){var f=n.attributes.position,m=n.attributes.normal;for(l=o=0,u=f.count;l<u;l++)tl.set(f.getX(l),f.getY(l),f.getZ(l)).applyMatrix4(e),el.set(m.getX(l),m.getY(l),m.getZ(l)),el.applyMatrix3(il).normalize().multiplyScalar(this.size).add(tl),i.setXYZ(o,tl.x,tl.y,tl.z),o+=1,i.setXYZ(o,el.x,el.y,el.z),o+=1}i.needsUpdate=!0}),((kl.prototype=Object.create(Wi.prototype)).constructor=kl).prototype.dispose=function(){this.cone.geometry.dispose(),this.cone.material.dispose()},kl.prototype.update=(nl=new Ge,rl=new Ge,function(){this.light.updateMatrixWorld();var t=this.light.distance?this.light.distance:1e3,e=t*Math.tan(this.light.angle);this.cone.scale.set(e,e,t),nl.setFromMatrixPosition(this.light.matrixWorld),rl.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(rl.sub(nl)),void 0!==this.color?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}),((jl.prototype=Object.create(_o.prototype)).constructor=jl).prototype.updateMatrixWorld=(al=new Ge,ol=new Fe,sl=new Fe,function(t){var e=this.bones,i=this.geometry,n=i.getAttribute("position");sl.getInverse(this.root.matrixWorld);for(var r=0,a=0;r<e.length;r++){var o=e[r];o.parent&&o.parent.isBone&&(ol.multiplyMatrices(sl,o.matrixWorld),al.setFromMatrixPosition(ol),n.setXYZ(a,al.x,al.y,al.z),ol.multiplyMatrices(sl,o.parent.matrixWorld),al.setFromMatrixPosition(ol),n.setXYZ(a+1,al.x,al.y,al.z),a+=2)}i.getAttribute("position").needsUpdate=!0,Wi.prototype.updateMatrixWorld.call(this,t)}),((Wl.prototype=Object.create(lr.prototype)).constructor=Wl).prototype.dispose=function(){this.geometry.dispose(),this.material.dispose()},Wl.prototype.update=function(){void 0!==this.color?this.material.color.set(this.color):this.material.color.copy(this.light.color)},((Xl.prototype=Object.create(Wi.prototype)).constructor=Xl).prototype.dispose=function(){this.children[0].geometry.dispose(),this.children[0].material.dispose()},Xl.prototype.update=function(){var t=.5*this.light.width,e=.5*this.light.height,i=this.line.geometry.attributes.position,n=i.array;n[0]=t,n[1]=-e,n[2]=0,n[3]=t,n[4]=e,n[5]=0,n[6]=-t,n[7]=e,n[8]=0,n[9]=-t,n[10]=-e,n[11]=0,n[12]=t,n[13]=-e,n[14]=0,i.needsUpdate=!0,void 0!==this.color?this.line.material.color.set(this.color):this.line.material.color.copy(this.light.color)},((ql.prototype=Object.create(Wi.prototype)).constructor=ql).prototype.dispose=function(){this.children[0].geometry.dispose(),this.children[0].material.dispose()},ql.prototype.update=(hl=new Ge,cl=new yi,ll=new yi,function(){var t=this.children[0];if(void 0!==this.color)this.material.color.set(this.color);else{var e=t.geometry.getAttribute("color");cl.copy(this.light.color),ll.copy(this.light.groundColor);for(var i=0,n=e.count;i<n;i++){var r=i<n/2?cl:ll;e.setXYZ(i,r.r,r.g,r.b)}e.needsUpdate=!0}t.lookAt(hl.setFromMatrixPosition(this.light.matrixWorld).negate())}),(Yl.prototype=Object.create(_o.prototype)).constructor=Yl,(Zl.prototype=Object.create(_o.prototype)).constructor=Zl,((Jl.prototype=Object.create(_o.prototype)).constructor=Jl).prototype.update=(ul=new Ge,dl=new Ge,pl=new He,function(){this.object.updateMatrixWorld(!0),pl.getNormalMatrix(this.object.matrixWorld);for(var t=this.object.matrixWorld,e=this.geometry.attributes.position,i=this.object.geometry,n=i.vertices,r=i.faces,a=0,o=0,s=r.length;o<s;o++){var h=r[o],c=h.normal;ul.copy(n[h.a]).add(n[h.b]).add(n[h.c]).divideScalar(3).applyMatrix4(t),dl.copy(c).applyMatrix3(pl).normalize().multiplyScalar(this.size).add(ul),e.setXYZ(a,ul.x,ul.y,ul.z),a+=1,e.setXYZ(a,dl.x,dl.y,dl.z),a+=1}e.needsUpdate=!0}),((Ql.prototype=Object.create(Wi.prototype)).constructor=Ql).prototype.dispose=function(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()},Ql.prototype.update=(fl=new Ge,ml=new Ge,gl=new Ge,function(){fl.setFromMatrixPosition(this.light.matrixWorld),ml.setFromMatrixPosition(this.light.target.matrixWorld),gl.subVectors(ml,fl),this.lightPlane.lookAt(gl),void 0!==this.color?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(gl),this.targetLine.scale.z=gl.length()}),((Kl.prototype=Object.create(_o.prototype)).constructor=Kl).prototype.update=function(){var h,c,l=new Ge,u=new Xi;function t(t,e,i,n){l.set(e,i,n).unproject(u);var r=c[t];if(void 0!==r)for(var a=h.getAttribute("position"),o=0,s=r.length;o<s;o++)a.setXYZ(r[o],l.x,l.y,l.z)}return function(){h=this.geometry,c=this.pointMap;u.projectionMatrix.copy(this.camera.projectionMatrix),t("c",0,0,-1),t("t",0,0,1),t("n1",-1,-1,-1),t("n2",1,-1,-1),t("n3",-1,1,-1),t("n4",1,1,-1),t("f1",-1,-1,1),t("f2",1,-1,1),t("f3",-1,1,1),t("f4",1,1,1),t("u1",.7,1.1,-1),t("u2",-.7,1.1,-1),t("u3",0,2,-1),t("cf1",-1,0,1),t("cf2",1,0,1),t("cf3",0,-1,1),t("cf4",0,1,1),t("cn1",-1,0,-1),t("cn2",1,0,-1),t("cn3",0,-1,-1),t("cn4",0,1,-1),h.getAttribute("position").needsUpdate=!0}}(),(($l.prototype=Object.create(_o.prototype)).constructor=$l).prototype.update=(vl=new li,function(t){if(void 0!==t&&console.warn("THREE.BoxHelper: .update() has no longer arguments."),void 0!==this.object&&vl.setFromObject(this.object),!vl.isEmpty()){var e=vl.min,i=vl.max,n=this.geometry.attributes.position,r=n.array;r[0]=i.x,r[1]=i.y,r[2]=i.z,r[3]=e.x,r[4]=i.y,r[5]=i.z,r[6]=e.x,r[7]=e.y,r[8]=i.z,r[9]=i.x,r[10]=e.y,r[11]=i.z,r[12]=i.x,r[13]=i.y,r[14]=e.z,r[15]=e.x,r[16]=i.y,r[17]=e.z,r[18]=e.x,r[19]=e.y,r[20]=e.z,r[21]=i.x,r[22]=e.y,r[23]=e.z,n.needsUpdate=!0,this.geometry.computeBoundingSphere()}}),$l.prototype.setFromObject=function(t){return this.object=t,this.update(),this},((tu.prototype=Object.create(_o.prototype)).constructor=tu).prototype.updateMatrixWorld=function(t){var e=this.box;e.isEmpty()||(e.getCenter(this.position),e.getSize(this.scale),this.scale.multiplyScalar(.5),Wi.prototype.updateMatrixWorld.call(this,t))},((eu.prototype=Object.create(bo.prototype)).constructor=eu).prototype.updateMatrixWorld=function(t){var e=-this.plane.constant;Math.abs(e)<1e-8&&(e=1e-8),this.scale.set(.5*this.size,.5*this.size,e),this.children[0].material.side=e<0?At:U,this.lookAt(this.plane.normal),Wi.prototype.updateMatrixWorld.call(this,t)},((iu.prototype=Object.create(Wi.prototype)).constructor=iu).prototype.setDirection=(_l=new Ge,function(t){.99999<t.y?this.quaternion.set(0,0,0,1):t.y<-.99999?this.quaternion.set(1,0,0,0):(_l.set(t.z,0,-t.x).normalize(),bl=Math.acos(t.y),this.quaternion.setFromAxisAngle(_l,bl))}),iu.prototype.setLength=function(t,e,i){void 0===e&&(e=.2*t),void 0===i&&(i=.2*e),this.line.scale.set(1,Math.max(0,t-e),1),this.line.updateMatrix(),this.cone.scale.set(i,e,i),this.cone.position.y=t,this.cone.updateMatrix()},iu.prototype.setColor=function(t){this.line.material.color.copy(t),this.cone.material.color.copy(t)},(nu.prototype=Object.create(_o.prototype)).constructor=nu;var ru;function au(t){console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."),fh.call(this,t),this.type="catmullrom",this.closed=!0}function ou(t){console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."),fh.call(this,t),this.type="catmullrom"}function su(t){console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."),fh.call(this,t),this.type="catmullrom"}oh.create=function(t,e){return console.log("THREE.Curve.create() has been deprecated"),t.prototype=Object.create(oh.prototype),(t.prototype.constructor=t).prototype.getPoint=e,t},Object.assign(Sh.prototype,{createPointsGeometry:function(t){console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");var e=this.getPoints(t);return this.createGeometry(e)},createSpacedPointsGeometry:function(t){console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");var e=this.getSpacedPoints(t);return this.createGeometry(e)},createGeometry:function(t){console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");for(var e=new rn,i=0,n=t.length;i<n;i++){var r=t[i];e.vertices.push(new Ge(r.x,r.y,r.z||0))}return e}}),Object.assign(Ah.prototype,{fromPoints:function(t){console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),this.setFromPoints(t)}}),au.prototype=Object.create(fh.prototype),ou.prototype=Object.create(fh.prototype),su.prototype=Object.create(fh.prototype),Object.assign(su.prototype,{initFromArray:function(){console.error("THREE.Spline: .initFromArray() has been removed.")},getControlPointsArray:function(){console.error("THREE.Spline: .getControlPointsArray() has been removed.")},reparametrizeByArcLength:function(){console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")}}),Yl.prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")},jl.prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")},Object.assign(oc.prototype,{extractUrlBase:function(t){return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),sc.extractUrlBase(t)}}),Object.assign(Gl.prototype,{center:function(t){return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),this.getCenter(t)},empty:function(){return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),this.isEmpty()},isIntersectionBox:function(t){return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(t)},size:function(t){return console.warn("THREE.Box2: .size() has been renamed to .getSize()."),this.getSize(t)}}),Object.assign(li.prototype,{center:function(t){return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),this.getCenter(t)},empty:function(){return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),this.isEmpty()},isIntersectionBox:function(t){return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(t)},isIntersectionSphere:function(t){return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(t)},size:function(t){return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),this.getSize(t)}}),hr.prototype.center=function(t){return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."),this.getCenter(t)},Object.assign(De,{random16:function(){return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."),Math.random()},nearestPowerOfTwo:function(t){return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."),De.floorPowerOfTwo(t)},nextPowerOfTwo:function(t){return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."),De.ceilPowerOfTwo(t)}}),Object.assign(He.prototype,{flattenToArrayOffset:function(t,e){return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(t,e)},multiplyVector3:function(t){return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),t.applyMatrix3(this)},multiplyVector3Array:function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")},applyToBuffer:function(t){return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."),this.applyToBufferAttribute(t)},applyToVector3Array:function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")}}),Object.assign(Fe.prototype,{extractPosition:function(t){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(t)},flattenToArrayOffset:function(t,e){return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(t,e)},getPosition:function(){return void 0===ru&&(ru=new Ge),console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),ru.setFromMatrixColumn(this,3)},setRotationFromQuaternion:function(t){return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),this.makeRotationFromQuaternion(t)},multiplyToArray:function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")},multiplyVector3:function(t){return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),t.applyMatrix4(this)},multiplyVector4:function(t){return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),t.applyMatrix4(this)},multiplyVector3Array:function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")},rotateAxis:function(t){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),t.transformDirection(this)},crossVector:function(t){return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),t.applyMatrix4(this)},translate:function(){console.error("THREE.Matrix4: .translate() has been removed.")},rotateX:function(){console.error("THREE.Matrix4: .rotateX() has been removed.")},rotateY:function(){console.error("THREE.Matrix4: .rotateY() has been removed.")},rotateZ:function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")},rotateByAxis:function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")},applyToBuffer:function(t){return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."),this.applyToBufferAttribute(t)},applyToVector3Array:function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")},makeFrustum:function(t,e,i,n,r,a){return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),this.makePerspective(t,e,n,i,r,a)}}),di.prototype.isIntersectionLine=function(t){return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),this.intersectsLine(t)},ze.prototype.multiplyVector3=function(t){return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),t.applyQuaternion(this)},Object.assign(sr.prototype,{isIntersectionBox:function(t){return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(t)},isIntersectionPlane:function(t){return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),this.intersectsPlane(t)},isIntersectionSphere:function(t){return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(t)}}),Object.assign(cr.prototype,{area:function(){return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),this.getArea()},barycoordFromPoint:function(t,e){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),this.getBarycoord(t,e)},midpoint:function(t){return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),this.getMidpoint(t)},normal:function(t){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),this.getNormal(t)},plane:function(t){return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),this.getPlane(t)}}),Object.assign(cr,{barycoordFromPoint:function(t,e,i,n,r){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),cr.getBarycoord(t,e,i,n,r)},normal:function(t,e,i,n){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),cr.getNormal(t,e,i,n)}}),Object.assign(Lh.prototype,{extractAllPoints:function(t){return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),this.extractPoints(t)},extrude:function(t){return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),new ys(this,t)},makeGeometry:function(t){return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),new Rs(this,t)}}),Object.assign(Be.prototype,{fromAttribute:function(t,e,i){return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(t,e,i)},distanceToManhattan:function(t){return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(t)},lengthManhattan:function(){return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()}}),Object.assign(Ge.prototype,{setEulerFromRotationMatrix:function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")},setEulerFromQuaternion:function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")},getPositionFromMatrix:function(t){return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),this.setFromMatrixPosition(t)},getScaleFromMatrix:function(t){return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),this.setFromMatrixScale(t)},getColumnFromMatrix:function(t,e){return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),this.setFromMatrixColumn(e,t)},applyProjection:function(t){return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),this.applyMatrix4(t)},fromAttribute:function(t,e,i){return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(t,e,i)},distanceToManhattan:function(t){return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(t)},lengthManhattan:function(){return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()}}),Object.assign(oi.prototype,{fromAttribute:function(t,e,i){return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(t,e,i)},lengthManhattan:function(){return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()}}),Object.assign(rn.prototype,{computeTangents:function(){console.error("THREE.Geometry: .computeTangents() has been removed.")},computeLineDistances:function(){console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")}}),Object.assign(Wi.prototype,{getChildByName:function(t){return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),this.getObjectByName(t)},renderDepth:function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")},translate:function(t,e){return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),this.translateOnAxis(e,t)},getWorldRotation:function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")}}),Object.defineProperties(Wi.prototype,{eulerOrder:{get:function(){return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order},set:function(t){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order=t}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}}),Object.defineProperties(mo.prototype,{objects:{get:function(){return console.warn("THREE.LOD: .objects has been renamed to .levels."),this.levels}}}),Object.defineProperty(go.prototype,"useVertexTexture",{get:function(){console.warn("THREE.Skeleton: useVertexTexture has been removed.")},set:function(){console.warn("THREE.Skeleton: useVertexTexture has been removed.")}}),Object.defineProperty(oh.prototype,"__arcLengthDivisions",{get:function(){return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),this.arcLengthDivisions},set:function(t){console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),this.arcLengthDivisions=t}}),ro.prototype.setLens=function(t,e){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),void 0!==e&&(this.filmGauge=e),this.setFocalLength(t)},Object.defineProperties(Rh.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(t){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),this.shadow.camera.fov=t}},shadowCameraLeft:{set:function(t){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),this.shadow.camera.left=t}},shadowCameraRight:{set:function(t){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),this.shadow.camera.right=t}},shadowCameraTop:{set:function(t){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),this.shadow.camera.top=t}},shadowCameraBottom:{set:function(t){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),this.shadow.camera.bottom=t}},shadowCameraNear:{set:function(t){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),this.shadow.camera.near=t}},shadowCameraFar:{set:function(t){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),this.shadow.camera.far=t}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(t){console.warn("THREE.Light: .shadowBias is now .shadow.bias."),this.shadow.bias=t}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(t){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),this.shadow.mapSize.width=t}},shadowMapHeight:{set:function(t){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),this.shadow.mapSize.height=t}}}),Object.defineProperties(an.prototype,{length:{get:function(){return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),this.array.length}},copyIndicesArray:function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")}}),Object.assign(Ln.prototype,{addIndex:function(t){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),this.setIndex(t)},addDrawCall:function(t,e,i){void 0!==i&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),this.addGroup(t,e)},clearDrawCalls:function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),this.clearGroups()},computeTangents:function(){console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")},computeOffsets:function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")}}),Object.defineProperties(Ln.prototype,{drawcalls:{get:function(){return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),this.groups}},offsets:{get:function(){return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),this.groups}}}),Object.assign(xs.prototype,{getArrays:function(){console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.")},addShapeList:function(){console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.")},addShape:function(){console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.")}}),Object.defineProperties(Ll.prototype,{dynamic:{set:function(){console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")}},onUpdate:{value:function(){return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."),this}}}),Object.defineProperties(rr.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},wrapRGB:{get:function(){return console.warn("THREE.Material: .wrapRGB has been removed."),new yi}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(t){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=1===t}}}),Object.defineProperties(js.prototype,{metal:{get:function(){return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."),!1},set:function(){console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")}}}),Object.defineProperties(or.prototype,{derivatives:{get:function(){return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives},set:function(t){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives=t}}}),Object.assign(ho.prototype,{getCurrentRenderTarget:function(){return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),this.getRenderTarget()},getMaxAnisotropy:function(){return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),this.capabilities.getMaxAnisotropy()},getPrecision:function(){return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),this.capabilities.precision},resetGLState:function(){return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),this.state.reset()},supportsFloatTextures:function(){return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),this.extensions.get("OES_texture_float")},supportsHalfFloatTextures:function(){return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),this.extensions.get("OES_texture_half_float")},supportsStandardDerivatives:function(){return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),this.extensions.get("OES_standard_derivatives")},supportsCompressedTextureS3TC:function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),this.extensions.get("WEBGL_compressed_texture_s3tc")},supportsCompressedTexturePVRTC:function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),this.extensions.get("WEBGL_compressed_texture_pvrtc")},supportsBlendMinMax:function(){return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),this.extensions.get("EXT_blend_minmax")},supportsVertexTextures:function(){return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),this.capabilities.vertexTextures},supportsInstancedArrays:function(){return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),this.extensions.get("ANGLE_instanced_arrays")},enableScissorTest:function(t){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),this.setScissorTest(t)},initMaterial:function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")},addPrePlugin:function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")},addPostPlugin:function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")},updateShadowMap:function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")},setFaceCulling:function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")}}),Object.defineProperties(ho.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(t){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),this.shadowMap.enabled=t}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(t){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),this.shadowMap.type=t}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}}}),Object.defineProperties(Ka.prototype,{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}}),Object.defineProperties(si.prototype,{wrapS:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS},set:function(t){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS=t}},wrapT:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT},set:function(t){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT=t}},magFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter},set:function(t){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter=t}},minFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter},set:function(t){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter=t}},anisotropy:{get:function(){return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy},set:function(t){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy=t}},offset:{get:function(){return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset},set:function(t){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset=t}},repeat:{get:function(){return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat},set:function(t){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat=t}},format:{get:function(){return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format},set:function(t){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format=t}},type:{get:function(){return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type},set:function(t){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type=t}},generateMipmaps:{get:function(){return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps},set:function(t){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps=t}}}),Object.defineProperties(oo.prototype,{standing:{set:function(){console.warn("THREE.WebVRManager: .standing has been removed.")}}}),zc.prototype.load=function(t){console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");var e=this;return(new Uc).load(t,function(t){e.setBuffer(t)}),this},Hc.prototype.getData=function(){return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."),this.getFrequencyData()},Bc.prototype.updateCubeMap=function(t,e){return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),this.update(t,e)};var hu={merge:function(t,e,i){var n;console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."),e.isMesh&&(e.matrixAutoUpdate&&e.updateMatrix(),n=e.matrix,e=e.geometry),t.merge(e,n,i)},center:function(t){return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."),t.center()}},cu={crossOrigin:void 0,loadTexture:function(t,e,i,n){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");var r=new ah;r.setCrossOrigin(this.crossOrigin);var a=r.load(t,i,void 0,n);return e&&(a.mapping=e),a},loadTextureCube:function(t,e,i,n){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");var r=new rh;r.setCrossOrigin(this.crossOrigin);var a=r.load(t,i,void 0,n);return e&&(a.mapping=e),a},loadCompressedTexture:function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")},loadCompressedTextureCube:function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")}};var lu={createMultiMaterialObject:function(){console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")},detach:function(){console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")},attach:function(){console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")}};t.WebGLRenderTargetCube=hi,t.WebGLRenderTarget=si,t.WebGLRenderer=ho,t.ShaderLib=wi,t.UniformsLib=_i,t.UniformsUtils=gi,t.ShaderChunk=mi,t.FogExp2=co,t.Fog=lo,t.Scene=uo,t.Sprite=fo,t.LOD=mo,t.SkinnedMesh=yo,t.Skeleton=go,t.Bone=vo,t.Mesh=lr,t.LineSegments=_o,t.LineLoop=wo,t.Line=bo,t.Points=Eo,t.Group=To,t.VideoTexture=So,t.DataTexture=ci,t.CompressedTexture=Ao,t.CubeTexture=wr,t.CanvasTexture=$a,t.DepthTexture=Lo,t.Texture=ai,t.CompressedTextureLoader=eh,t.DataTextureLoader=ih,t.CubeTextureLoader=rh,t.TextureLoader=ah,t.ObjectLoader=cc,t.MaterialLoader=$h,t.BufferGeometryLoader=tc,t.DefaultLoadingManager=Ks,t.LoadingManager=Qs,t.JSONLoader=hc,t.ImageLoader=nh,t.ImageBitmapLoader=fc,t.FontLoader=yc,t.FileLoader=th,t.Loader=oc,t.LoaderUtils=sc,t.Cache=Js,t.AudioLoader=Uc,t.SpotLightShadow=Oh,t.SpotLight=Ih,t.PointLight=Nh,t.RectAreaLight=Fh,t.HemisphereLight=Ch,t.DirectionalLightShadow=Uh,t.DirectionalLight=Dh,t.AmbientLight=Bh,t.LightShadow=Ph,t.Light=Rh,t.StereoCamera=Dc,t.PerspectiveCamera=ro,t.OrthographicCamera=qi,t.CubeCamera=Bc,t.ArrayCamera=ao,t.Camera=Xi,t.AudioListener=Fc,t.PositionalAudio=Gc,t.AudioContext=Nc,t.AudioAnalyser=Hc,t.Audio=zc,t.VectorKeyframeTrack=Qh,t.StringKeyframeTrack=zh,t.QuaternionKeyframeTrack=kh,t.NumberKeyframeTrack=Wh,t.ColorKeyframeTrack=jh,t.BooleanKeyframeTrack=Gh,t.PropertyMixer=Vc,t.PropertyBinding=El,t.KeyframeTrack=Jh,t.AnimationUtils=Zh,t.AnimationObjectGroup=Tl,t.AnimationMixer=Al,t.AnimationClip=Kh,t.Uniform=Ll,t.InstancedBufferGeometry=Rl,t.BufferGeometry=Ln,t.Geometry=rn,t.InterleavedBufferAttribute=Cl,t.InstancedInterleavedBuffer=Ol,t.InterleavedBuffer=Pl,t.InstancedBufferAttribute=Il,t.Face3=Yi,t.Object3D=Wi,t.Raycaster=Nl,t.Layers=Ti,t.EventDispatcher=e,t.Clock=Bl,t.QuaternionLinearInterpolant=Vh,t.LinearInterpolant=qh,t.DiscreteInterpolant=Yh,t.CubicInterpolant=Xh,t.Interpolant=Hh,t.Triangle=cr,t.Math=De,t.Spherical=Fl,t.Cylindrical=zl,t.Plane=di,t.Frustum=pi,t.Sphere=ui,t.Ray=sr,t.Matrix4=Fe,t.Matrix3=He,t.Box3=li,t.Box2=Gl,t.Line3=hr,t.Euler=Ei,t.Vector4=oi,t.Vector3=Ge,t.Vector2=Be,t.Quaternion=ze,t.Color=yi,t.ImmediateRenderObject=Hl,t.VertexNormalsHelper=Vl,t.SpotLightHelper=kl,t.SkeletonHelper=jl,t.PointLightHelper=Wl,t.RectAreaLightHelper=Xl,t.HemisphereLightHelper=ql,t.GridHelper=Yl,t.PolarGridHelper=Zl,t.FaceNormalsHelper=Jl,t.DirectionalLightHelper=Ql,t.CameraHelper=Kl,t.BoxHelper=$l,t.Box3Helper=tu,t.PlaneHelper=eu,t.ArrowHelper=iu,t.AxesHelper=nu,t.Shape=Lh,t.Path=Ah,t.ShapePath=mc,t.Font=gc,t.CurvePath=Sh,t.Curve=oh,t.ShapeUtils=ms,t.WebGLUtils=no,t.WireframeGeometry=Ro,t.ParametricGeometry=Co,t.ParametricBufferGeometry=Po,t.TetrahedronGeometry=No,t.TetrahedronBufferGeometry=Uo,t.OctahedronGeometry=Do,t.OctahedronBufferGeometry=Bo,t.IcosahedronGeometry=Fo,t.IcosahedronBufferGeometry=zo,t.DodecahedronGeometry=Go,t.DodecahedronBufferGeometry=Ho,t.PolyhedronGeometry=Oo,t.PolyhedronBufferGeometry=Io,t.TubeGeometry=Vo,t.TubeBufferGeometry=ko,t.TorusKnotGeometry=jo,t.TorusKnotBufferGeometry=Wo,t.TorusGeometry=Xo,t.TorusBufferGeometry=qo,t.TextGeometry=_s,t.TextBufferGeometry=ws,t.SphereGeometry=Ms,t.SphereBufferGeometry=Es,t.RingGeometry=Ts,t.RingBufferGeometry=Ss,t.PlaneGeometry=Pn,t.PlaneBufferGeometry=On,t.LatheGeometry=As,t.LatheBufferGeometry=Ls,t.ShapeGeometry=Rs,t.ShapeBufferGeometry=Cs,t.ExtrudeGeometry=ys,t.ExtrudeBufferGeometry=xs,t.EdgesGeometry=Os,t.ConeGeometry=Us,t.ConeBufferGeometry=Ds,t.CylinderGeometry=Is,t.CylinderBufferGeometry=Ns,t.CircleGeometry=Bs,t.CircleBufferGeometry=Fs,t.BoxGeometry=Rn,t.BoxBufferGeometry=Cn,t.ShadowMaterial=Gs,t.SpriteMaterial=po,t.RawShaderMaterial=Hs,t.ShaderMaterial=or,t.PointsMaterial=Mo,t.MeshPhysicalMaterial=ks,t.MeshStandardMaterial=Vs,t.MeshPhongMaterial=js,t.MeshToonMaterial=Ws,t.MeshNormalMaterial=Xs,t.MeshLambertMaterial=qs,t.MeshDepthMaterial=Ja,t.MeshDistanceMaterial=Qa,t.MeshBasicMaterial=ar,t.LineDashedMaterial=Ys,t.LineBasicMaterial=xo,t.Material=rr,t.Float64BufferAttribute=fn,t.Float32BufferAttribute=pn,t.Uint32BufferAttribute=dn,t.Int32BufferAttribute=un,t.Uint16BufferAttribute=ln,t.Int16BufferAttribute=cn,t.Uint8ClampedBufferAttribute=hn,t.Uint8BufferAttribute=sn,t.Int8BufferAttribute=on,t.BufferAttribute=an,t.ArcCurve=hh,t.CatmullRomCurve3=fh,t.CubicBezierCurve=yh,t.CubicBezierCurve3=xh,t.EllipseCurve=sh,t.LineCurve=bh,t.LineCurve3=_h,t.QuadraticBezierCurve=wh,t.QuadraticBezierCurve3=Mh,t.SplineCurve=Eh,t.REVISION="93dev",t.MOUSE={LEFT:0,MIDDLE:1,RIGHT:2},t.CullFaceNone=j,t.CullFaceBack=W,t.CullFaceFront=X,t.CullFaceFrontBack=3,t.FrontFaceDirectionCW=0,t.FrontFaceDirectionCCW=1,t.BasicShadowMap=0,t.PCFShadowMap=B,t.PCFSoftShadowMap=F,t.FrontSide=U,t.BackSide=At,t.DoubleSide=Z,t.FlatShading=1,t.SmoothShading=2,t.NoColors=Lt,t.FaceColors=1,t.VertexColors=w,t.NoBlending=q,t.NormalBlending=Y,t.AdditiveBlending=J,t.SubtractiveBlending=Q,t.MultiplyBlending=K,t.CustomBlending=$,t.AddEquation=M,t.SubtractEquation=E,t.ReverseSubtractEquation=T,t.MinEquation=S,t.MaxEquation=A,t.ZeroFactor=L,t.OneFactor=R,t.SrcColorFactor=C,t.OneMinusSrcColorFactor=P,t.SrcAlphaFactor=O,t.OneMinusSrcAlphaFactor=I,t.DstAlphaFactor=N,t.OneMinusDstAlphaFactor=D,t.DstColorFactor=z,t.OneMinusDstColorFactor=G,t.SrcAlphaSaturateFactor=H,t.NeverDepth=tt,t.AlwaysDepth=et,t.LessDepth=it,t.LessEqualDepth=nt,t.EqualDepth=rt,t.GreaterEqualDepth=at,t.GreaterDepth=ot,t.NotEqualDepth=st,t.MultiplyOperation=V,t.MixOperation=k,t.AddOperation=ht,t.NoToneMapping=ct,t.LinearToneMapping=Rt,t.ReinhardToneMapping=lt,t.Uncharted2ToneMapping=ut,t.CineonToneMapping=dt,t.UVMapping=300,t.CubeReflectionMapping=pt,t.CubeRefractionMapping=ft,t.EquirectangularReflectionMapping=mt,t.EquirectangularRefractionMapping=gt,t.SphericalReflectionMapping=vt,t.CubeUVReflectionMapping=yt,t.CubeUVRefractionMapping=xt,t.RepeatWrapping=bt,t.ClampToEdgeWrapping=_t,t.MirroredRepeatWrapping=wt,t.NearestFilter=Mt,t.NearestMipMapNearestFilter=Et,t.NearestMipMapLinearFilter=Tt,t.LinearFilter=St,t.LinearMipMapNearestFilter=Ct,t.LinearMipMapLinearFilter=Pt,t.UnsignedByteType=Ot,t.ByteType=It,t.ShortType=Nt,t.UnsignedShortType=Ut,t.IntType=Dt,t.UnsignedIntType=Bt,t.FloatType=Ft,t.HalfFloatType=zt,t.UnsignedShort4444Type=Gt,t.UnsignedShort5551Type=Ht,t.UnsignedShort565Type=Vt,t.UnsignedInt248Type=kt,t.AlphaFormat=jt,t.RGBFormat=Wt,t.RGBAFormat=Xt,t.LuminanceFormat=qt,t.LuminanceAlphaFormat=Yt,t.RGBEFormat=Zt,t.DepthFormat=Jt,t.DepthStencilFormat=Qt,t.RGB_S3TC_DXT1_Format=Kt,t.RGBA_S3TC_DXT1_Format=$t,t.RGBA_S3TC_DXT3_Format=te,t.RGBA_S3TC_DXT5_Format=ee,t.RGB_PVRTC_4BPPV1_Format=ie,t.RGB_PVRTC_2BPPV1_Format=ne,t.RGBA_PVRTC_4BPPV1_Format=re,t.RGBA_PVRTC_2BPPV1_Format=ae,t.RGB_ETC1_Format=oe,t.RGBA_ASTC_4x4_Format=se,t.RGBA_ASTC_5x4_Format=he,t.RGBA_ASTC_5x5_Format=ce,t.RGBA_ASTC_6x5_Format=le,t.RGBA_ASTC_6x6_Format=ue,t.RGBA_ASTC_8x5_Format=de,t.RGBA_ASTC_8x6_Format=pe,t.RGBA_ASTC_8x8_Format=fe,t.RGBA_ASTC_10x5_Format=me,t.RGBA_ASTC_10x6_Format=ge,t.RGBA_ASTC_10x8_Format=ve,t.RGBA_ASTC_10x10_Format=ye,t.RGBA_ASTC_12x10_Format=xe,t.RGBA_ASTC_12x12_Format=be,t.LoopOnce=2200,t.LoopRepeat=2201,t.LoopPingPong=2202,t.InterpolateDiscrete=_e,t.InterpolateLinear=we,t.InterpolateSmooth=2302,t.ZeroCurvatureEnding=Me,t.ZeroSlopeEnding=Ee,t.WrapAroundEnding=Te,t.TrianglesDrawMode=Se,t.TriangleStripDrawMode=1,t.TriangleFanDrawMode=2,t.LinearEncoding=Ae,t.sRGBEncoding=Le,t.GammaEncoding=Re,t.RGBEEncoding=Ce,t.LogLuvEncoding=3003,t.RGBM7Encoding=Pe,t.RGBM16Encoding=Oe,t.RGBDEncoding=Ie,t.BasicDepthPacking=Ne,t.RGBADepthPacking=Ue,t.CubeGeometry=Rn,t.Face4=function(t,e,i,n,r,a,o){return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."),new Yi(t,e,i,r,a,o)},t.LineStrip=0,t.LinePieces=1,t.MeshFaceMaterial=function(t){return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."),t},t.MultiMaterial=function(t){return void 0===t&&(t=[]),console.warn("THREE.MultiMaterial has been removed. Use an Array instead."),t.isMultiMaterial=!0,(t.materials=t).clone=function(){return t.slice()},t},t.PointCloud=function(t,e){return console.warn("THREE.PointCloud has been renamed to THREE.Points."),new Eo(t,e)},t.Particle=function(t){return console.warn("THREE.Particle has been renamed to THREE.Sprite."),new fo(t)},t.ParticleSystem=function(t,e){return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."),new Eo(t,e)},t.PointCloudMaterial=function(t){return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."),new Mo(t)},t.ParticleBasicMaterial=function(t){return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."),new Mo(t)},t.ParticleSystemMaterial=function(t){return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."),new Mo(t)},t.Vertex=function(t,e,i){return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."),new Ge(t,e,i)},t.DynamicBufferAttribute=function(t,e){return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."),new an(t,e).setDynamic(!0)},t.Int8Attribute=function(t,e){return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."),new on(t,e)},t.Uint8Attribute=function(t,e){return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."),new sn(t,e)},t.Uint8ClampedAttribute=function(t,e){return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."),new hn(t,e)},t.Int16Attribute=function(t,e){return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."),new cn(t,e)},t.Uint16Attribute=function(t,e){return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."),new ln(t,e)},t.Int32Attribute=function(t,e){return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."),new un(t,e)},t.Uint32Attribute=function(t,e){return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."),new dn(t,e)},t.Float32Attribute=function(t,e){return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."),new pn(t,e)},t.Float64Attribute=function(t,e){return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."),new fn(t,e)},t.ClosedSplineCurve3=au,t.SplineCurve3=ou,t.Spline=su,t.AxisHelper=function(t){return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."),new nu(t)},t.BoundingBoxHelper=function(t,e){return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."),new $l(t,e)},t.EdgesHelper=function(t,e){return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."),new _o(new Os(t.geometry),new xo({color:void 0!==e?e:16777215}))},t.WireframeHelper=function(t,e){return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."),new _o(new Ro(t.geometry),new xo({color:void 0!==e?e:16777215}))},t.XHRLoader=function(t){return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."),new th(t)},t.BinaryTextureLoader=function(t){return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."),new ih(t)},t.GeometryUtils=hu,t.ImageUtils=cu,t.Projector=function(){console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."),this.projectVector=function(t,e){console.warn("THREE.Projector: .projectVector() is now vector.project()."),t.project(e)},this.unprojectVector=function(t,e){console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."),t.unproject(e)},this.pickingRay=function(){console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")}},t.CanvasRenderer=function(){console.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js"),this.domElement=document.createElementNS("http://www.w3.org/1999/xhtml","canvas"),this.clear=function(){},this.render=function(){},this.setClearColor=function(){},this.setSize=function(){}},t.SceneUtils=lu,t.LensFlare=function(){console.error("THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js")},Object.defineProperty(t,"__esModule",{value:!0})});

/*
 * @author Daosheng Mu / https://github.com/DaoshengMu/
 * @author mrdoob / http://mrdoob.com/
 * @author takahirox / https://github.com/takahirox/
 */

THREE.TGALoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.TGALoader.prototype = {

	constructor: THREE.TGALoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var texture = new THREE.Texture();

		var loader = new THREE.FileLoader( this.manager );
		loader.setResponseType( 'arraybuffer' );

		loader.load( url, function ( buffer ) {

			texture.image = scope.parse( buffer );
			texture.needsUpdate = true;

			if ( onLoad !== undefined ) {

				onLoad( texture );

			}

		}, onProgress, onError );

		return texture;

	},

	parse: function ( buffer ) {

		// reference from vthibault, https://github.com/vthibault/roBrowser/blob/master/src/Loaders/Targa.js

		function tgaCheckHeader( header ) {

			switch ( header.image_type ) {

				// check indexed type

				case TGA_TYPE_INDEXED:
				case TGA_TYPE_RLE_INDEXED:
					if ( header.colormap_length > 256 || header.colormap_size !== 24 || header.colormap_type !== 1 ) {

						console.log( 'THREE.TGALoader: Invalid type colormap data for indexed type.' );

					}
					break;

				// check colormap type

				case TGA_TYPE_RGB:
				case TGA_TYPE_GREY:
				case TGA_TYPE_RLE_RGB:
				case TGA_TYPE_RLE_GREY:
					if ( header.colormap_type ) {

						console.log( 'THREE.TGALoader: Invalid type colormap data for colormap type.' );

					}
					break;

				// What the need of a file without data ?

				case TGA_TYPE_NO_DATA:
					console.log( 'THREE.TGALoader: No data.' );

				// Invalid type ?

				default:
					console.log( 'THREE.TGALoader: Invalid type "%s".', header.image_type );

			}

			// check image width and height

			if ( header.width <= 0 || header.height <= 0 ) {

				console.log( 'THREE.TGALoader: Invalid image size.' );

			}

			// check image pixel size

			if ( header.pixel_size !== 8 && header.pixel_size !== 16 &&
				header.pixel_size !== 24 && header.pixel_size !== 32 ) {

				console.log( 'THREE.TGALoader: Invalid pixel size "%s".', header.pixel_size );

			}

		}

		// parse tga image buffer

		function tgaParse( use_rle, use_pal, header, offset, data ) {

			var pixel_data,
				pixel_size,
				pixel_total,
				palettes;

			pixel_size = header.pixel_size >> 3;
			pixel_total = header.width * header.height * pixel_size;

			 // read palettes

			 if ( use_pal ) {

				 palettes = data.subarray( offset, offset += header.colormap_length * ( header.colormap_size >> 3 ) );

			 }

			 // read RLE

			 if ( use_rle ) {

				 pixel_data = new Uint8Array( pixel_total );

				var c, count, i;
				var shift = 0;
				var pixels = new Uint8Array( pixel_size );

				while ( shift < pixel_total ) {

					c = data[ offset ++ ];
					count = ( c & 0x7f ) + 1;

					// RLE pixels

					if ( c & 0x80 ) {

						// bind pixel tmp array

						for ( i = 0; i < pixel_size; ++ i ) {

							pixels[ i ] = data[ offset ++ ];

						}

						// copy pixel array

						for ( i = 0; i < count; ++ i ) {

							pixel_data.set( pixels, shift + i * pixel_size );

						}

						shift += pixel_size * count;

					} else {

						// raw pixels

						count *= pixel_size;
						for ( i = 0; i < count; ++ i ) {

							pixel_data[ shift + i ] = data[ offset ++ ];

						}
						shift += count;

					}

				}

			 } else {

				// raw pixels

				pixel_data = data.subarray(
					 offset, offset += ( use_pal ? header.width * header.height : pixel_total )
				);

			 }

			 return {
				pixel_data: pixel_data,
				palettes: palettes
			 };

		}

		function tgaGetImageData8bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image, palettes ) {

			var colormap = palettes;
			var color, i = 0, x, y;
			var width = header.width;

			for ( y = y_start; y !== y_end; y += y_step ) {

				for ( x = x_start; x !== x_end; x += x_step, i ++ ) {

					color = image[ i ];
					imageData[ ( x + width * y ) * 4 + 3 ] = 255;
					imageData[ ( x + width * y ) * 4 + 2 ] = colormap[ ( color * 3 ) + 0 ];
					imageData[ ( x + width * y ) * 4 + 1 ] = colormap[ ( color * 3 ) + 1 ];
					imageData[ ( x + width * y ) * 4 + 0 ] = colormap[ ( color * 3 ) + 2 ];

				}

			}

			return imageData;

		}

		function tgaGetImageData16bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {

			var color, i = 0, x, y;
			var width = header.width;

			for ( y = y_start; y !== y_end; y += y_step ) {

				for ( x = x_start; x !== x_end; x += x_step, i += 2 ) {

					color = image[ i + 0 ] + ( image[ i + 1 ] << 8 ); // Inversed ?
					imageData[ ( x + width * y ) * 4 + 0 ] = ( color & 0x7C00 ) >> 7;
					imageData[ ( x + width * y ) * 4 + 1 ] = ( color & 0x03E0 ) >> 2;
					imageData[ ( x + width * y ) * 4 + 2 ] = ( color & 0x001F ) >> 3;
					imageData[ ( x + width * y ) * 4 + 3 ] = ( color & 0x8000 ) ? 0 : 255;

				}

			}

			return imageData;

		}

		function tgaGetImageData24bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {

			var i = 0, x, y;
			var width = header.width;

			for ( y = y_start; y !== y_end; y += y_step ) {

				for ( x = x_start; x !== x_end; x += x_step, i += 3 ) {

					imageData[ ( x + width * y ) * 4 + 3 ] = 255;
					imageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];
					imageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 1 ];
					imageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 2 ];

				}

			}

			return imageData;

		}

		function tgaGetImageData32bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {

			var i = 0, x, y;
			var width = header.width;

			for ( y = y_start; y !== y_end; y += y_step ) {

				for ( x = x_start; x !== x_end; x += x_step, i += 4 ) {

					imageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];
					imageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 1 ];
					imageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 2 ];
					imageData[ ( x + width * y ) * 4 + 3 ] = image[ i + 3 ];

				}

			}

			return imageData;

		}

		function tgaGetImageDataGrey8bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {

			var color, i = 0, x, y;
			var width = header.width;

			for ( y = y_start; y !== y_end; y += y_step ) {

				for ( x = x_start; x !== x_end; x += x_step, i ++ ) {

					color = image[ i ];
					imageData[ ( x + width * y ) * 4 + 0 ] = color;
					imageData[ ( x + width * y ) * 4 + 1 ] = color;
					imageData[ ( x + width * y ) * 4 + 2 ] = color;
					imageData[ ( x + width * y ) * 4 + 3 ] = 255;

				}

			}

			return imageData;

		}

		function tgaGetImageDataGrey16bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {

			var i = 0, x, y;
			var width = header.width;

			for ( y = y_start; y !== y_end; y += y_step ) {

				for ( x = x_start; x !== x_end; x += x_step, i += 2 ) {

					imageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 0 ];
					imageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 0 ];
					imageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];
					imageData[ ( x + width * y ) * 4 + 3 ] = image[ i + 1 ];

				}

			}

			return imageData;

		}

		function getTgaRGBA( data, width, height, image, palette ) {

			var x_start,
				y_start,
				x_step,
				y_step,
				x_end,
				y_end;

			switch ( ( header.flags & TGA_ORIGIN_MASK ) >> TGA_ORIGIN_SHIFT ) {

				default:
				case TGA_ORIGIN_UL:
					x_start = 0;
					x_step = 1;
					x_end = width;
					y_start = 0;
					y_step = 1;
					y_end = height;
					break;

				case TGA_ORIGIN_BL:
					x_start = 0;
					x_step = 1;
					x_end = width;
					y_start = height - 1;
					y_step = - 1;
					y_end = - 1;
					break;

				case TGA_ORIGIN_UR:
					x_start = width - 1;
					x_step = - 1;
					x_end = - 1;
					y_start = 0;
					y_step = 1;
					y_end = height;
					break;

				case TGA_ORIGIN_BR:
					x_start = width - 1;
					x_step = - 1;
					x_end = - 1;
					y_start = height - 1;
					y_step = - 1;
					y_end = - 1;
					break;

			}

			if ( use_grey ) {

				switch ( header.pixel_size ) {

					case 8:
						tgaGetImageDataGrey8bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );
						break;

					case 16:
						tgaGetImageDataGrey16bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );
						break;

					default:
						console.log( 'THREE.TGALoader: Format not supported.' );
						break;

				}

			} else {

				switch ( header.pixel_size ) {

					case 8:
						tgaGetImageData8bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image, palette );
						break;

					case 16:
						tgaGetImageData16bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );
						break;

					case 24:
						tgaGetImageData24bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );
						break;

					case 32:
						tgaGetImageData32bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );
						break;

					default:
						console.log( 'THREE.TGALoader: Format not supported.' );
						break;

				}

			}

			// Load image data according to specific method
			// var func = 'tgaGetImageData' + (use_grey ? 'Grey' : '') + (header.pixel_size) + 'bits';
			// func(data, y_start, y_step, y_end, x_start, x_step, x_end, width, image, palette );
			return data;

		}

		// TGA constants

		var TGA_TYPE_NO_DATA = 0,
			TGA_TYPE_INDEXED = 1,
			TGA_TYPE_RGB = 2,
			TGA_TYPE_GREY = 3,
			TGA_TYPE_RLE_INDEXED = 9,
			TGA_TYPE_RLE_RGB = 10,
			TGA_TYPE_RLE_GREY = 11,

			TGA_ORIGIN_MASK = 0x30,
			TGA_ORIGIN_SHIFT = 0x04,
			TGA_ORIGIN_BL = 0x00,
			TGA_ORIGIN_BR = 0x01,
			TGA_ORIGIN_UL = 0x02,
			TGA_ORIGIN_UR = 0x03;

		if ( buffer.length < 19 ) console.log( 'THREE.TGALoader: Not enough data to contain header.' );

		var content = new Uint8Array( buffer ),
			offset = 0,
			header = {
				id_length: content[ offset ++ ],
				colormap_type: content[ offset ++ ],
				image_type: content[ offset ++ ],
				colormap_index: content[ offset ++ ] | content[ offset ++ ] << 8,
				colormap_length: content[ offset ++ ] | content[ offset ++ ] << 8,
				colormap_size: content[ offset ++ ],
				origin: [
					content[ offset ++ ] | content[ offset ++ ] << 8,
					content[ offset ++ ] | content[ offset ++ ] << 8
				],
				width: content[ offset ++ ] | content[ offset ++ ] << 8,
				height: content[ offset ++ ] | content[ offset ++ ] << 8,
				pixel_size: content[ offset ++ ],
				flags: content[ offset ++ ]
			};

			// check tga if it is valid format

		tgaCheckHeader( header );

		if ( header.id_length + offset > buffer.length ) {

			console.log( 'THREE.TGALoader: No data.' );

		}

		// skip the needn't data

		offset += header.id_length;

		// get targa information about RLE compression and palette

		var use_rle = false,
			use_pal = false,
			use_grey = false;

		switch ( header.image_type ) {

			case TGA_TYPE_RLE_INDEXED:
				use_rle = true;
				use_pal = true;
				break;

			case TGA_TYPE_INDEXED:
				use_pal = true;
				break;

			case TGA_TYPE_RLE_RGB:
				use_rle = true;
				break;

			case TGA_TYPE_RGB:
				break;

			case TGA_TYPE_RLE_GREY:
				use_rle = true;
				use_grey = true;
				break;

			case TGA_TYPE_GREY:
				use_grey = true;
				break;

		}

		//

		var canvas = document.createElement( 'canvas' );
		canvas.width = header.width;
		canvas.height = header.height;

		var context = canvas.getContext( '2d' );
		var imageData = context.createImageData( header.width, header.height );

		var result = tgaParse( use_rle, use_pal, header, offset, content );
		var rgbaData = getTgaRGBA( imageData.data, header.width, header.height, result.pixel_data, result.palettes );

		context.putImageData( imageData, 0, 0 );

		return canvas;

	}

};

/*
 * @author mrdoob / http://mrdoob.com/
 */

THREE.DDSLoader = function ( manager ) {

	THREE.CompressedTextureLoader.call( this, manager );

	this._parser = THREE.DDSLoader.parse;

};

THREE.DDSLoader.prototype = Object.create( THREE.CompressedTextureLoader.prototype );
THREE.DDSLoader.prototype.constructor = THREE.DDSLoader;

THREE.DDSLoader.parse = function ( buffer, loadMipmaps ) {

	var dds = { mipmaps: [], width: 0, height: 0, format: null, mipmapCount: 1 };

	// Adapted from @toji's DDS utils
	// https://github.com/toji/webgl-texture-utils/blob/master/texture-util/dds.js

	// All values and structures referenced from:
	// http://msdn.microsoft.com/en-us/library/bb943991.aspx/

	var DDS_MAGIC = 0x20534444;

	var DDSD_CAPS = 0x1,
		DDSD_HEIGHT = 0x2,
		DDSD_WIDTH = 0x4,
		DDSD_PITCH = 0x8,
		DDSD_PIXELFORMAT = 0x1000,
		DDSD_MIPMAPCOUNT = 0x20000,
		DDSD_LINEARSIZE = 0x80000,
		DDSD_DEPTH = 0x800000;

	var DDSCAPS_COMPLEX = 0x8,
		DDSCAPS_MIPMAP = 0x400000,
		DDSCAPS_TEXTURE = 0x1000;

	var DDSCAPS2_CUBEMAP = 0x200,
		DDSCAPS2_CUBEMAP_POSITIVEX = 0x400,
		DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800,
		DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000,
		DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000,
		DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000,
		DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000,
		DDSCAPS2_VOLUME = 0x200000;

	var DDPF_ALPHAPIXELS = 0x1,
		DDPF_ALPHA = 0x2,
		DDPF_FOURCC = 0x4,
		DDPF_RGB = 0x40,
		DDPF_YUV = 0x200,
		DDPF_LUMINANCE = 0x20000;

	function fourCCToInt32( value ) {

		return value.charCodeAt( 0 ) +
			( value.charCodeAt( 1 ) << 8 ) +
			( value.charCodeAt( 2 ) << 16 ) +
			( value.charCodeAt( 3 ) << 24 );

	}

	function int32ToFourCC( value ) {

		return String.fromCharCode(
			value & 0xff,
			( value >> 8 ) & 0xff,
			( value >> 16 ) & 0xff,
			( value >> 24 ) & 0xff
		);

	}

	function loadARGBMip( buffer, dataOffset, width, height ) {

		var dataLength = width * height * 4;
		var srcBuffer = new Uint8Array( buffer, dataOffset, dataLength );
		var byteArray = new Uint8Array( dataLength );
		var dst = 0;
		var src = 0;
		for ( var y = 0; y < height; y ++ ) {

			for ( var x = 0; x < width; x ++ ) {

				var b = srcBuffer[ src ]; src ++;
				var g = srcBuffer[ src ]; src ++;
				var r = srcBuffer[ src ]; src ++;
				var a = srcBuffer[ src ]; src ++;
				byteArray[ dst ] = r; dst ++;	//r
				byteArray[ dst ] = g; dst ++;	//g
				byteArray[ dst ] = b; dst ++;	//b
				byteArray[ dst ] = a; dst ++;	//a

			}

		}
		return byteArray;

	}

	var FOURCC_DXT1 = fourCCToInt32( "DXT1" );
	var FOURCC_DXT3 = fourCCToInt32( "DXT3" );
	var FOURCC_DXT5 = fourCCToInt32( "DXT5" );
	var FOURCC_ETC1 = fourCCToInt32( "ETC1" );

	var headerLengthInt = 31; // The header length in 32 bit ints

	// Offsets into the header array

	var off_magic = 0;

	var off_size = 1;
	var off_flags = 2;
	var off_height = 3;
	var off_width = 4;

	var off_mipmapCount = 7;

	var off_pfFlags = 20;
	var off_pfFourCC = 21;
	var off_RGBBitCount = 22;
	var off_RBitMask = 23;
	var off_GBitMask = 24;
	var off_BBitMask = 25;
	var off_ABitMask = 26;

	var off_caps = 27;
	var off_caps2 = 28;
	var off_caps3 = 29;
	var off_caps4 = 30;

	// Parse header

	var header = new Int32Array( buffer, 0, headerLengthInt );

	if ( header[ off_magic ] !== DDS_MAGIC ) {

		console.error( 'THREE.DDSLoader.parse: Invalid magic number in DDS header.' );
		return dds;

	}

	if ( ! header[ off_pfFlags ] & DDPF_FOURCC ) {

		console.error( 'THREE.DDSLoader.parse: Unsupported format, must contain a FourCC code.' );
		return dds;

	}

	var blockBytes;

	var fourCC = header[ off_pfFourCC ];

	var isRGBAUncompressed = false;

	switch ( fourCC ) {

		case FOURCC_DXT1:

			blockBytes = 8;
			dds.format = THREE.RGB_S3TC_DXT1_Format;
			break;

		case FOURCC_DXT3:

			blockBytes = 16;
			dds.format = THREE.RGBA_S3TC_DXT3_Format;
			break;

		case FOURCC_DXT5:

			blockBytes = 16;
			dds.format = THREE.RGBA_S3TC_DXT5_Format;
			break;

		case FOURCC_ETC1:

			blockBytes = 8;
			dds.format = THREE.RGB_ETC1_Format;
			break;

		default:

			if ( header[ off_RGBBitCount ] === 32
				&& header[ off_RBitMask ] & 0xff0000
				&& header[ off_GBitMask ] & 0xff00
				&& header[ off_BBitMask ] & 0xff
				&& header[ off_ABitMask ] & 0xff000000 ) {

				isRGBAUncompressed = true;
				blockBytes = 64;
				dds.format = THREE.RGBAFormat;

			} else {

				console.error( 'THREE.DDSLoader.parse: Unsupported FourCC code ', int32ToFourCC( fourCC ) );
				return dds;

			}

	}

	dds.mipmapCount = 1;

	if ( header[ off_flags ] & DDSD_MIPMAPCOUNT && loadMipmaps !== false ) {

		dds.mipmapCount = Math.max( 1, header[ off_mipmapCount ] );

	}

	var caps2 = header[ off_caps2 ];
	dds.isCubemap = caps2 & DDSCAPS2_CUBEMAP ? true : false;
	if ( dds.isCubemap && (
		! ( caps2 & DDSCAPS2_CUBEMAP_POSITIVEX ) ||
		! ( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEX ) ||
		! ( caps2 & DDSCAPS2_CUBEMAP_POSITIVEY ) ||
		! ( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEY ) ||
		! ( caps2 & DDSCAPS2_CUBEMAP_POSITIVEZ ) ||
		! ( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ )
	) ) {

		console.error( 'THREE.DDSLoader.parse: Incomplete cubemap faces' );
		return dds;

	}

	dds.width = header[ off_width ];
	dds.height = header[ off_height ];

	var dataOffset = header[ off_size ] + 4;

	// Extract mipmaps buffers

	var faces = dds.isCubemap ? 6 : 1;

	for ( var face = 0; face < faces; face ++ ) {

		var width = dds.width;
		var height = dds.height;

		for ( var i = 0; i < dds.mipmapCount; i ++ ) {

			if ( isRGBAUncompressed ) {

				var byteArray = loadARGBMip( buffer, dataOffset, width, height );
				var dataLength = byteArray.length;

			} else {

				var dataLength = Math.max( 4, width ) / 4 * Math.max( 4, height ) / 4 * blockBytes;
				var byteArray = new Uint8Array( buffer, dataOffset, dataLength );

			}

			var mipmap = { "data": byteArray, "width": width, "height": height };
			dds.mipmaps.push( mipmap );

			dataOffset += dataLength;

			width = Math.max( width >> 1, 1 );
			height = Math.max( height >> 1, 1 );

		}

	}

	return dds;

};

/*
 * Copyright (c) 2015 cannon.js Authors
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&false)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.CANNON=e()}}(function(){return function e(f,n,o){function d(t,l){if(!n[t]){if(!f[t]){var u="function"==typeof require&&require;if(!l&&u)return u(t,!0);if(i)return i(t,!0);throw new Error("Cannot find module '"+t+"'")}var p=n[t]={exports:{}};f[t][0].call(p.exports,function(e){var n=f[t][1][e];return d(n?n:e)},p,p.exports,e,f,n,o)}return n[t].exports}for(var i="function"==typeof require&&require,t=0;t<o.length;t++)d(o[t]);return d}({1:[function(e,f){f.exports={name:"cannon",version:"0.6.2",description:"A lightweight 3D physics engine written in JavaScript.",homepage:"https://github.com/schteppe/cannon.js",author:"Stefan Hedman <schteppe@gmail.com> (http://steffe.se)",keywords:["cannon.js","cannon","physics","engine","3d"],main:"./build/cannon.js",engines:{node:"*"},repository:{type:"git",url:"https://github.com/schteppe/cannon.js.git"},bugs:{url:"https://github.com/schteppe/cannon.js/issues"},licenses:[{type:"MIT"}],devDependencies:{jshint:"latest","uglify-js":"latest",nodeunit:"^0.9.0",grunt:"~0.4.0","grunt-contrib-jshint":"~0.1.1","grunt-contrib-nodeunit":"^0.4.1","grunt-contrib-concat":"~0.1.3","grunt-contrib-uglify":"^0.5.1","grunt-browserify":"^2.1.4","grunt-contrib-yuidoc":"^0.5.2",browserify:"*"},dependencies:{}}},{}],2:[function(e,f){f.exports={version:e("../package.json").version,AABB:e("./collision/AABB"),ArrayCollisionMatrix:e("./collision/ArrayCollisionMatrix"),Body:e("./objects/Body"),Box:e("./shapes/Box"),Broadphase:e("./collision/Broadphase"),Constraint:e("./constraints/Constraint"),ContactEquation:e("./equations/ContactEquation"),Narrowphase:e("./world/Narrowphase"),ConeTwistConstraint:e("./constraints/ConeTwistConstraint"),ContactMaterial:e("./material/ContactMaterial"),ConvexPolyhedron:e("./shapes/ConvexPolyhedron"),Cylinder:e("./shapes/Cylinder"),DistanceConstraint:e("./constraints/DistanceConstraint"),Equation:e("./equations/Equation"),EventTarget:e("./utils/EventTarget"),FrictionEquation:e("./equations/FrictionEquation"),GSSolver:e("./solver/GSSolver"),GridBroadphase:e("./collision/GridBroadphase"),Heightfield:e("./shapes/Heightfield"),HingeConstraint:e("./constraints/HingeConstraint"),LockConstraint:e("./constraints/LockConstraint"),Mat3:e("./math/Mat3"),Material:e("./material/Material"),NaiveBroadphase:e("./collision/NaiveBroadphase"),ObjectCollisionMatrix:e("./collision/ObjectCollisionMatrix"),Pool:e("./utils/Pool"),Particle:e("./shapes/Particle"),Plane:e("./shapes/Plane"),PointToPointConstraint:e("./constraints/PointToPointConstraint"),Quaternion:e("./math/Quaternion"),Ray:e("./collision/Ray"),RaycastVehicle:e("./objects/RaycastVehicle"),RaycastResult:e("./collision/RaycastResult"),RigidVehicle:e("./objects/RigidVehicle"),RotationalEquation:e("./equations/RotationalEquation"),RotationalMotorEquation:e("./equations/RotationalMotorEquation"),SAPBroadphase:e("./collision/SAPBroadphase"),SPHSystem:e("./objects/SPHSystem"),Shape:e("./shapes/Shape"),Solver:e("./solver/Solver"),Sphere:e("./shapes/Sphere"),SplitSolver:e("./solver/SplitSolver"),Spring:e("./objects/Spring"),Trimesh:e("./shapes/Trimesh"),Vec3:e("./math/Vec3"),Vec3Pool:e("./utils/Vec3Pool"),World:e("./world/World")}},{"../package.json":1,"./collision/AABB":3,"./collision/ArrayCollisionMatrix":4,"./collision/Broadphase":5,"./collision/GridBroadphase":6,"./collision/NaiveBroadphase":7,"./collision/ObjectCollisionMatrix":8,"./collision/Ray":9,"./collision/RaycastResult":10,"./collision/SAPBroadphase":11,"./constraints/ConeTwistConstraint":12,"./constraints/Constraint":13,"./constraints/DistanceConstraint":14,"./constraints/HingeConstraint":15,"./constraints/LockConstraint":16,"./constraints/PointToPointConstraint":17,"./equations/ContactEquation":19,"./equations/Equation":20,"./equations/FrictionEquation":21,"./equations/RotationalEquation":22,"./equations/RotationalMotorEquation":23,"./material/ContactMaterial":24,"./material/Material":25,"./math/Mat3":27,"./math/Quaternion":28,"./math/Vec3":30,"./objects/Body":31,"./objects/RaycastVehicle":32,"./objects/RigidVehicle":33,"./objects/SPHSystem":34,"./objects/Spring":35,"./shapes/Box":37,"./shapes/ConvexPolyhedron":38,"./shapes/Cylinder":39,"./shapes/Heightfield":40,"./shapes/Particle":41,"./shapes/Plane":42,"./shapes/Shape":43,"./shapes/Sphere":44,"./shapes/Trimesh":45,"./solver/GSSolver":46,"./solver/Solver":47,"./solver/SplitSolver":48,"./utils/EventTarget":49,"./utils/Pool":51,"./utils/Vec3Pool":54,"./world/Narrowphase":55,"./world/World":56}],3:[function(e,f){function n(e){e=e||{},this.lowerBound=new o,e.lowerBound&&this.lowerBound.copy(e.lowerBound),this.upperBound=new o,e.upperBound&&this.upperBound.copy(e.upperBound)}{var o=e("../math/Vec3");e("../utils/Utils")}f.exports=n;var d=new o;n.prototype.setFromPoints=function(e,f,n,o){var i=this.lowerBound,t=this.upperBound,l=n;i.copy(e[0]),l&&l.vmult(i,i),t.copy(i);for(var u=1;u<e.length;u++){var p=e[u];l&&(l.vmult(p,d),p=d),p.x>t.x&&(t.x=p.x),p.x<i.x&&(i.x=p.x),p.y>t.y&&(t.y=p.y),p.y<i.y&&(i.y=p.y),p.z>t.z&&(t.z=p.z),p.z<i.z&&(i.z=p.z)}return f&&(f.vadd(i,i),f.vadd(t,t)),o&&(i.x-=o,i.y-=o,i.z-=o,t.x+=o,t.y+=o,t.z+=o),this},n.prototype.copy=function(e){return this.lowerBound.copy(e.lowerBound),this.upperBound.copy(e.upperBound),this},n.prototype.clone=function(){return(new n).copy(this)},n.prototype.extend=function(e){var f=e.lowerBound.x;this.lowerBound.x>f&&(this.lowerBound.x=f);var n=e.upperBound.x;this.upperBound.x<n&&(this.upperBound.x=n);var f=e.lowerBound.y;this.lowerBound.y>f&&(this.lowerBound.y=f);var n=e.upperBound.y;this.upperBound.y<n&&(this.upperBound.y=n);var f=e.lowerBound.z;this.lowerBound.z>f&&(this.lowerBound.z=f);var n=e.upperBound.z;this.upperBound.z<n&&(this.upperBound.z=n)},n.prototype.overlaps=function(e){var f=this.lowerBound,n=this.upperBound,o=e.lowerBound,d=e.upperBound;return(o.x<=n.x&&n.x<=d.x||f.x<=d.x&&d.x<=n.x)&&(o.y<=n.y&&n.y<=d.y||f.y<=d.y&&d.y<=n.y)&&(o.z<=n.z&&n.z<=d.z||f.z<=d.z&&d.z<=n.z)},n.prototype.contains=function(e){var f=this.lowerBound,n=this.upperBound,o=e.lowerBound,d=e.upperBound;return f.x<=o.x&&n.x>=d.x&&f.y<=o.y&&n.y>=d.y&&f.z<=o.z&&n.z>=d.z},n.prototype.getCorners=function(e,f,n,o,d,i,t,l){var u=this.lowerBound,p=this.upperBound;e.copy(u),f.set(p.x,u.y,u.z),n.set(p.x,p.y,u.z),o.set(u.x,p.y,p.z),d.set(p.x,u.y,u.z),i.set(u.x,p.y,u.z),t.set(u.x,u.y,p.z),l.copy(p)};var i=[new o,new o,new o,new o,new o,new o,new o,new o];n.prototype.toLocalFrame=function(e,f){var n=i,o=n[0],d=n[1],t=n[2],l=n[3],u=n[4],p=n[5],s=n[6],y=n[7];this.getCorners(o,d,t,l,u,p,s,y);for(var c=0;8!==c;c++){var a=n[c];e.pointToLocal(a,a)}return f.setFromPoints(n)},n.prototype.toWorldFrame=function(e,f){var n=i,o=n[0],d=n[1],t=n[2],l=n[3],u=n[4],p=n[5],s=n[6],y=n[7];this.getCorners(o,d,t,l,u,p,s,y);for(var c=0;8!==c;c++){var a=n[c];e.pointToWorld(a,a)}return f.setFromPoints(n)}},{"../math/Vec3":30,"../utils/Utils":53}],4:[function(e,f){function n(){this.matrix=[]}f.exports=n,n.prototype.get=function(e,f){if(e=e.index,f=f.index,f>e){var n=f;f=e,e=n}return this.matrix[(e*(e+1)>>1)+f-1]},n.prototype.set=function(e,f,n){if(e=e.index,f=f.index,f>e){var o=f;f=e,e=o}this.matrix[(e*(e+1)>>1)+f-1]=n?1:0},n.prototype.reset=function(){for(var e=0,f=this.matrix.length;e!==f;e++)this.matrix[e]=0},n.prototype.setNumObjects=function(e){this.matrix.length=e*(e-1)>>1}},{}],5:[function(e,f){function n(){this.world=null,this.useBoundingBoxes=!1,this.dirty=!0}{var o=e("../objects/Body"),d=e("../math/Vec3"),i=e("../math/Quaternion");e("../shapes/Shape"),e("../shapes/Plane")}f.exports=n,n.prototype.collisionPairs=function(){throw new Error("collisionPairs not implemented for this BroadPhase class!")};var t=o.STATIC|o.KINEMATIC;n.prototype.needBroadphaseCollision=function(e,f){return 0===(e.collisionFilterGroup&f.collisionFilterMask)||0===(f.collisionFilterGroup&e.collisionFilterMask)?!1:0===(e.type&t)&&e.sleepState!==o.SLEEPING||0===(f.type&t)&&f.sleepState!==o.SLEEPING?!0:!1},n.prototype.intersectionTest=function(e,f,n,o){this.useBoundingBoxes?this.doBoundingBoxBroadphase(e,f,n,o):this.doBoundingSphereBroadphase(e,f,n,o)};{var l=new d;new d,new i,new d}n.prototype.doBoundingSphereBroadphase=function(e,f,n,o){var d=l;f.position.vsub(e.position,d);var i=Math.pow(e.boundingRadius+f.boundingRadius,2),t=d.norm2();i>t&&(n.push(e),o.push(f))},n.prototype.doBoundingBoxBroadphase=function(e,f,n,o){e.aabbNeedsUpdate&&e.computeAABB(),f.aabbNeedsUpdate&&f.computeAABB(),e.aabb.overlaps(f.aabb)&&(n.push(e),o.push(f))};var u={keys:[]},p=[],s=[];n.prototype.makePairsUnique=function(e,f){for(var n=u,o=p,d=s,i=e.length,t=0;t!==i;t++)o[t]=e[t],d[t]=f[t];e.length=0,f.length=0;for(var t=0;t!==i;t++){var l=o[t].id,y=d[t].id,c=y>l?l+","+y:y+","+l;n[c]=t,n.keys.push(c)}for(var t=0;t!==n.keys.length;t++){var c=n.keys.pop(),a=n[c];e.push(o[a]),f.push(d[a]),delete n[c]}},n.prototype.setWorld=function(){};var y=new d;n.boundingSphereCheck=function(e,f){var n=y;return e.position.vsub(f.position,n),Math.pow(e.shape.boundingSphereRadius+f.shape.boundingSphereRadius,2)>n.norm2()},n.prototype.aabbQuery=function(){return console.warn(".aabbQuery is not implemented in this Broadphase subclass."),[]}},{"../math/Quaternion":28,"../math/Vec3":30,"../objects/Body":31,"../shapes/Plane":42,"../shapes/Shape":43}],6:[function(e,f){function n(e,f,n,i,t){o.apply(this),this.nx=n||10,this.ny=i||10,this.nz=t||10,this.aabbMin=e||new d(100,100,100),this.aabbMax=f||new d(-100,-100,-100);var l=this.nx*this.ny*this.nz;if(0>=l)throw"GridBroadphase: Each dimension's n must be >0";this.bins=[],this.binLengths=[],this.bins.length=l,this.binLengths.length=l;for(var u=0;l>u;u++)this.bins[u]=[],this.binLengths[u]=0}f.exports=n;var o=e("./Broadphase"),d=e("../math/Vec3"),i=e("../shapes/Shape");n.prototype=new o,n.prototype.constructor=n;{var t=new d;new d}n.prototype.collisionPairs=function(e,f,n){function o(e,f,n,o,d,i,t){var l=(e-g)*v|0,u=(f-x)*A|0,p=(n-j)*C|0,b=I((o-g)*v),m=I((d-x)*A),N=I((i-j)*C);0>l?l=0:l>=s&&(l=s-1),0>u?u=0:u>=y&&(u=y-1),0>p?p=0:p>=c&&(p=c-1),0>b?b=0:b>=s&&(b=s-1),0>m?m=0:m>=y&&(m=y-1),0>N?N=0:N>=c&&(N=c-1),l*=a,u*=r,p*=w,b*=a,m*=r,N*=w;for(var O=l;b>=O;O+=a)for(var h=u;m>=h;h+=r)for(var k=p;N>=k;k+=w){var q=O+h+k;E[q][F[q]++]=t}}for(var d=e.numObjects(),l=e.bodies,u=this.aabbMax,p=this.aabbMin,s=this.nx,y=this.ny,c=this.nz,a=y*c,r=c,w=1,b=u.x,m=u.y,N=u.z,g=p.x,x=p.y,j=p.z,v=s/(b-g),A=y/(m-x),C=c/(N-j),O=(b-g)/s,h=(m-x)/y,k=(N-j)/c,q=.5*Math.sqrt(O*O+h*h+k*k),z=i.types,B=z.SPHERE,D=z.PLANE,E=(z.BOX,z.COMPOUND,z.CONVEXPOLYHEDRON,this.bins),F=this.binLengths,G=this.bins.length,H=0;H!==G;H++)F[H]=0;for(var I=Math.ceil,p=Math.min,u=Math.max,H=0;H!==d;H++){var J=l[H],K=J.shape;switch(K.type){case B:var L=J.position.x,M=J.position.y,P=J.position.z,Q=K.radius;o(L-Q,M-Q,P-Q,L+Q,M+Q,P+Q,J);break;case D:K.worldNormalNeedsUpdate&&K.computeWorldNormal(J.quaternion);var R=K.worldNormal,S=g+.5*O-J.position.x,T=x+.5*h-J.position.y,U=j+.5*k-J.position.z,V=t;V.set(S,T,U);for(var W=0,X=0;W!==s;W++,X+=a,V.y=T,V.x+=O)for(var Y=0,Z=0;Y!==y;Y++,Z+=r,V.z=U,V.y+=h)for(var $=0,_=0;$!==c;$++,_+=w,V.z+=k)if(V.dot(R)<q){var ef=X+Z+_;E[ef][F[ef]++]=J}break;default:J.aabbNeedsUpdate&&J.computeAABB(),o(J.aabb.lowerBound.x,J.aabb.lowerBound.y,J.aabb.lowerBound.z,J.aabb.upperBound.x,J.aabb.upperBound.y,J.aabb.upperBound.z,J)}}for(var H=0;H!==G;H++){var ff=F[H];if(ff>1)for(var nf=E[H],W=0;W!==ff;W++)for(var J=nf[W],Y=0;Y!==W;Y++){var of=nf[Y];this.needBroadphaseCollision(J,of)&&this.intersectionTest(J,of,f,n)}}this.makePairsUnique(f,n)}},{"../math/Vec3":30,"../shapes/Shape":43,"./Broadphase":5}],7:[function(e,f){function n(){o.apply(this)}f.exports=n;var o=e("./Broadphase"),d=e("./AABB");n.prototype=new o,n.prototype.constructor=n,n.prototype.collisionPairs=function(e,f,n){var o,d,i,t,l=e.bodies,u=l.length;for(o=0;o!==u;o++)for(d=0;d!==o;d++)i=l[o],t=l[d],this.needBroadphaseCollision(i,t)&&this.intersectionTest(i,t,f,n)};new d;n.prototype.aabbQuery=function(e,f,n){n=n||[];for(var o=0;o<e.bodies.length;o++){var d=e.bodies[o];d.aabbNeedsUpdate&&d.computeAABB(),d.aabb.overlaps(f)&&n.push(d)}return n}},{"./AABB":3,"./Broadphase":5}],8:[function(e,f){function n(){this.matrix={}}f.exports=n,n.prototype.get=function(e,f){if(e=e.id,f=f.id,f>e){var n=f;f=e,e=n}return e+"-"+f in this.matrix},n.prototype.set=function(e,f,n){if(e=e.id,f=f.id,f>e){var o=f;f=e,e=o}n?this.matrix[e+"-"+f]=!0:delete this.matrix[e+"-"+f]},n.prototype.reset=function(){this.matrix={}},n.prototype.setNumObjects=function(){}},{}],9:[function(e,f){function n(e,f){this.from=e?e.clone():new i,this.to=f?f.clone():new i,this._direction=new i,this.precision=1e-4,this.checkCollisionResponse=!0,this.skipBackfaces=!1,this.collisionFilterMask=-1,this.collisionFilterGroup=-1,this.mode=n.ANY,this.result=new u,this.hasHit=!1,this.callback=function(){}}function o(e,f,n,o){o.vsub(f,G),n.vsub(f,a),e.vsub(f,r);var d,i,t=G.dot(G),l=G.dot(a),u=G.dot(r),p=a.dot(a),s=a.dot(r);return(d=p*u-l*s)>=0&&(i=t*s-l*u)>=0&&t*p-l*l>d+i}function d(e,f,n){n.vsub(e,G);var o=G.dot(f);f.mult(o,H),H.vadd(e,H);var d=n.distanceTo(H);return d}f.exports=n;var i=e("../math/Vec3"),t=e("../math/Quaternion"),l=e("../math/Transform"),u=(e("../shapes/ConvexPolyhedron"),e("../shapes/Box"),e("../collision/RaycastResult")),p=e("../shapes/Shape"),s=e("../collision/AABB");n.prototype.constructor=n,n.CLOSEST=1,n.ANY=2,n.ALL=4;var y=new s,c=[];n.prototype.intersectWorld=function(e,f){return this.mode=f.mode||n.ANY,this.result=f.result||new u,this.skipBackfaces=!!f.skipBackfaces,this.collisionFilterMask="undefined"!=typeof f.collisionFilterMask?f.collisionFilterMask:-1,this.collisionFilterGroup="undefined"!=typeof f.collisionFilterGroup?f.collisionFilterGroup:-1,f.from&&this.from.copy(f.from),f.to&&this.to.copy(f.to),this.callback=f.callback||function(){},this.hasHit=!1,this.result.reset(),this._updateDirection(),this.getAABB(y),c.length=0,e.broadphase.aabbQuery(e,y,c),this.intersectBodies(c),this.hasHit};var a=new i,r=new i;n.pointInTriangle=o;var w=new i,b=new t;n.prototype.intersectBody=function(e,f){f&&(this.result=f,this._updateDirection());var n=this.checkCollisionResponse;if((!n||e.collisionResponse)&&0!==(this.collisionFilterGroup&e.collisionFilterMask)&&0!==(e.collisionFilterGroup&this.collisionFilterMask))for(var o=w,d=b,i=0,t=e.shapes.length;t>i;i++){var l=e.shapes[i];if((!n||l.collisionResponse)&&(e.quaternion.mult(e.shapeOrientations[i],d),e.quaternion.vmult(e.shapeOffsets[i],o),o.vadd(e.position,o),this.intersectShape(l,d,o,e),this.result._shouldStop))break}},n.prototype.intersectBodies=function(e,f){f&&(this.result=f,this._updateDirection());for(var n=0,o=e.length;!this.result._shouldStop&&o>n;n++)this.intersectBody(e[n])},n.prototype._updateDirection=function(){this.to.vsub(this.from,this._direction),this._direction.normalize()},n.prototype.intersectShape=function(e,f,n,o){var i=this.from,t=d(i,this._direction,n);if(!(t>e.boundingSphereRadius)){var l=this[e.type];l&&l.call(this,e,f,n,o)}};{var m=(new i,new i,new i),N=new i,g=new i,x=new i;new i,new u}n.prototype.intersectBox=function(e,f,n,o){return this.intersectConvex(e.convexPolyhedronRepresentation,f,n,o)},n.prototype[p.types.BOX]=n.prototype.intersectBox,n.prototype.intersectPlane=function(e,f,n,o){var d=this.from,t=this.to,l=this._direction,u=new i(0,0,1);f.vmult(u,u);var p=new i;d.vsub(n,p);var s=p.dot(u);t.vsub(n,p);var y=p.dot(u);if(!(s*y>0||d.distanceTo(t)<s)){var c=u.dot(l);if(!(Math.abs(c)<this.precision)){var a=new i,r=new i,w=new i;d.vsub(n,a);var b=-u.dot(a)/c;l.scale(b,r),d.vadd(r,w),this.reportIntersection(u,w,e,o,-1)}}},n.prototype[p.types.PLANE]=n.prototype.intersectPlane,n.prototype.getAABB=function(e){var f=this.to,n=this.from;e.lowerBound.x=Math.min(f.x,n.x),e.lowerBound.y=Math.min(f.y,n.y),e.lowerBound.z=Math.min(f.z,n.z),e.upperBound.x=Math.max(f.x,n.x),e.upperBound.y=Math.max(f.y,n.y),e.upperBound.z=Math.max(f.z,n.z)};var j={faceList:[0]};n.prototype.intersectHeightfield=function(e,f,o,d){var t=(e.data,e.elementSize,new i),u=new n(this.from,this.to);l.pointToLocalFrame(o,f,u.from,u.from),l.pointToLocalFrame(o,f,u.to,u.to);var p=[],s=null,y=null,c=null,a=null,r=e.getIndexOfPosition(u.from.x,u.from.y,p,!1);if(r&&(s=p[0],y=p[1],c=p[0],a=p[1]),r=e.getIndexOfPosition(u.to.x,u.to.y,p,!1),r&&((null===s||p[0]<s)&&(s=p[0]),(null===c||p[0]>c)&&(c=p[0]),(null===y||p[1]<y)&&(y=p[1]),(null===a||p[1]>a)&&(a=p[1])),null!==s){var w=[];e.getRectMinMax(s,y,c,a,w);for(var b=(w[0],w[1],s);c>=b;b++)for(var m=y;a>=m;m++){if(this.result._shouldStop)return;if(e.getConvexTrianglePillar(b,m,!1),l.pointToWorldFrame(o,f,e.pillarOffset,t),this.intersectConvex(e.pillarConvex,f,t,d,j),this.result._shouldStop)return;e.getConvexTrianglePillar(b,m,!0),l.pointToWorldFrame(o,f,e.pillarOffset,t),this.intersectConvex(e.pillarConvex,f,t,d,j)}}},n.prototype[p.types.HEIGHTFIELD]=n.prototype.intersectHeightfield;var v=new i,A=new i;n.prototype.intersectSphere=function(e,f,n,o){var d=this.from,i=this.to,t=e.radius,l=Math.pow(i.x-d.x,2)+Math.pow(i.y-d.y,2)+Math.pow(i.z-d.z,2),u=2*((i.x-d.x)*(d.x-n.x)+(i.y-d.y)*(d.y-n.y)+(i.z-d.z)*(d.z-n.z)),p=Math.pow(d.x-n.x,2)+Math.pow(d.y-n.y,2)+Math.pow(d.z-n.z,2)-Math.pow(t,2),s=Math.pow(u,2)-4*l*p,y=v,c=A;if(!(0>s))if(0===s)d.lerp(i,s,y),y.vsub(n,c),c.normalize(),this.reportIntersection(c,y,e,o,-1);else{var a=(-u-Math.sqrt(s))/(2*l),r=(-u+Math.sqrt(s))/(2*l);if(a>=0&&1>=a&&(d.lerp(i,a,y),y.vsub(n,c),c.normalize(),this.reportIntersection(c,y,e,o,-1)),this.result._shouldStop)return;r>=0&&1>=r&&(d.lerp(i,r,y),y.vsub(n,c),c.normalize(),this.reportIntersection(c,y,e,o,-1))}},n.prototype[p.types.SPHERE]=n.prototype.intersectSphere;var C=new i,O=(new i,new i,new i);n.prototype.intersectConvex=function(e,f,n,d,i){for(var t=C,l=O,u=i&&i.faceList||null,p=e.faces,s=e.vertices,y=e.faceNormals,c=this._direction,a=this.from,r=this.to,w=a.distanceTo(r),b=u?u.length:p.length,j=this.result,v=0;!j._shouldStop&&b>v;v++){var A=u?u[v]:v,h=p[A],k=y[A],q=f,z=n;l.copy(s[h[0]]),q.vmult(l,l),l.vadd(z,l),l.vsub(a,l),q.vmult(k,t);var B=c.dot(t);if(!(Math.abs(B)<this.precision)){var D=t.dot(l)/B;if(!(0>D)){c.mult(D,m),m.vadd(a,m),N.copy(s[h[0]]),q.vmult(N,N),z.vadd(N,N);for(var E=1;!j._shouldStop&&E<h.length-1;E++){g.copy(s[h[E]]),x.copy(s[h[E+1]]),q.vmult(g,g),q.vmult(x,x),z.vadd(g,g),z.vadd(x,x);var F=m.distanceTo(a);!o(m,N,g,x)&&!o(m,g,N,x)||F>w||this.reportIntersection(t,m,e,d,A)}}}}},n.prototype[p.types.CONVEXPOLYHEDRON]=n.prototype.intersectConvex;var h=new i,k=new i,q=new i,z=new i,B=new i,D=new i,E=(new s,[]),F=new l;n.prototype.intersectTrimesh=function(e,f,n,d,i){var t=h,u=E,p=F,s=O,y=k,c=q,a=z,r=D,w=B,b=(i&&i.faceList||null,e.indices),j=(e.vertices,e.faceNormals,this.from),v=this.to,A=this._direction;p.position.copy(n),p.quaternion.copy(f),l.vectorToLocalFrame(n,f,A,y),l.pointToLocalFrame(n,f,j,c),l.pointToLocalFrame(n,f,v,a);var C=c.distanceSquared(a);e.tree.rayQuery(this,p,u);for(var G=0,H=u.length;!this.result._shouldStop&&G!==H;G++){var I=u[G];e.getNormal(I,t),e.getVertex(b[3*I],N),N.vsub(c,s);var J=y.dot(t),K=t.dot(s)/J;if(!(0>K)){y.scale(K,m),m.vadd(c,m),e.getVertex(b[3*I+1],g),e.getVertex(b[3*I+2],x);var L=m.distanceSquared(c);!o(m,g,N,x)&&!o(m,N,g,x)||L>C||(l.vectorToWorldFrame(f,t,w),l.pointToWorldFrame(n,f,m,r),this.reportIntersection(w,r,e,d,I))}}u.length=0},n.prototype[p.types.TRIMESH]=n.prototype.intersectTrimesh,n.prototype.reportIntersection=function(e,f,o,d,i){var t=this.from,l=this.to,u=t.distanceTo(f),p=this.result;if(!(this.skipBackfaces&&e.dot(this._direction)>0))switch(p.hitFaceIndex="undefined"!=typeof i?i:-1,this.mode){case n.ALL:this.hasHit=!0,p.set(t,l,e,f,o,d,u),p.hasHit=!0,this.callback(p);break;case n.CLOSEST:(u<p.distance||!p.hasHit)&&(this.hasHit=!0,p.hasHit=!0,p.set(t,l,e,f,o,d,u));break;case n.ANY:this.hasHit=!0,p.hasHit=!0,p.set(t,l,e,f,o,d,u),p._shouldStop=!0}};var G=new i,H=new i},{"../collision/AABB":3,"../collision/RaycastResult":10,"../math/Quaternion":28,"../math/Transform":29,"../math/Vec3":30,"../shapes/Box":37,"../shapes/ConvexPolyhedron":38,"../shapes/Shape":43}],10:[function(e,f){function n(){this.rayFromWorld=new o,this.rayToWorld=new o,this.hitNormalWorld=new o,this.hitPointWorld=new o,this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this._shouldStop=!1}var o=e("../math/Vec3");f.exports=n,n.prototype.reset=function(){this.rayFromWorld.setZero(),this.rayToWorld.setZero(),this.hitNormalWorld.setZero(),this.hitPointWorld.setZero(),this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this._shouldStop=!1},n.prototype.abort=function(){this._shouldStop=!0},n.prototype.set=function(e,f,n,o,d,i,t){this.rayFromWorld.copy(e),this.rayToWorld.copy(f),this.hitNormalWorld.copy(n),this.hitPointWorld.copy(o),this.shape=d,this.body=i,this.distance=t}},{"../math/Vec3":30}],11:[function(e,f){function n(e){o.apply(this),this.axisList=[],this.world=null,this.axisIndex=0;var f=this.axisList;this._addBodyHandler=function(e){f.push(e.body)},this._removeBodyHandler=function(e){var n=f.indexOf(e.body);-1!==n&&f.splice(n,1)},e&&this.setWorld(e)}var o=(e("../shapes/Shape"),e("../collision/Broadphase"));f.exports=n,n.prototype=new o,n.prototype.setWorld=function(e){this.axisList.length=0;for(var f=0;f<e.bodies.length;f++)this.axisList.push(e.bodies[f]);e.removeEventListener("addBody",this._addBodyHandler),e.removeEventListener("removeBody",this._removeBodyHandler),e.addEventListener("addBody",this._addBodyHandler),e.addEventListener("removeBody",this._removeBodyHandler),this.world=e,this.dirty=!0},n.insertionSortX=function(e){for(var f=1,n=e.length;n>f;f++){for(var o=e[f],d=f-1;d>=0&&!(e[d].aabb.lowerBound.x<=o.aabb.lowerBound.x);d--)e[d+1]=e[d];e[d+1]=o}return e},n.insertionSortY=function(e){for(var f=1,n=e.length;n>f;f++){for(var o=e[f],d=f-1;d>=0&&!(e[d].aabb.lowerBound.y<=o.aabb.lowerBound.y);d--)e[d+1]=e[d];e[d+1]=o}return e},n.insertionSortZ=function(e){for(var f=1,n=e.length;n>f;f++){for(var o=e[f],d=f-1;d>=0&&!(e[d].aabb.lowerBound.z<=o.aabb.lowerBound.z);d--)e[d+1]=e[d];e[d+1]=o}return e},n.prototype.collisionPairs=function(e,f,o){var d,i,t=this.axisList,l=t.length,u=this.axisIndex;for(this.dirty&&(this.sortList(),this.dirty=!1),d=0;d!==l;d++){var p=t[d];for(i=d+1;l>i;i++){var s=t[i];if(this.needBroadphaseCollision(p,s)){if(!n.checkBounds(p,s,u))break;this.intersectionTest(p,s,f,o)}}}},n.prototype.sortList=function(){for(var e=this.axisList,f=this.axisIndex,o=e.length,d=0;d!==o;d++){var i=e[d];i.aabbNeedsUpdate&&i.computeAABB()}0===f?n.insertionSortX(e):1===f?n.insertionSortY(e):2===f&&n.insertionSortZ(e)},n.checkBounds=function(e,f,n){var o,d;0===n?(o=e.position.x,d=f.position.x):1===n?(o=e.position.y,d=f.position.y):2===n&&(o=e.position.z,d=f.position.z);var i=e.boundingRadius,t=f.boundingRadius,l=o+i,u=d-t;return l>u},n.prototype.autoDetectAxis=function(){for(var e=0,f=0,n=0,o=0,d=0,i=0,t=this.axisList,l=t.length,u=1/l,p=0;p!==l;p++){var s=t[p],y=s.position.x;e+=y,f+=y*y;var c=s.position.y;n+=c,o+=c*c;var a=s.position.z;d+=a,i+=a*a}var r=f-e*e*u,w=o-n*n*u,b=i-d*d*u;this.axisIndex=r>w?r>b?0:2:w>b?1:2},n.prototype.aabbQuery=function(e,f,n){n=n||[],this.dirty&&(this.sortList(),this.dirty=!1);var o=this.axisIndex,d="x";1===o&&(d="y"),2===o&&(d="z");for(var i=this.axisList,t=(f.lowerBound[d],f.upperBound[d],0);t<i.length;t++){var l=i[t];l.aabbNeedsUpdate&&l.computeAABB(),l.aabb.overlaps(f)&&n.push(l)}return n}},{"../collision/Broadphase":5,"../shapes/Shape":43}],12:[function(e,f){function n(e,f,n){n=n||{};var l="undefined"!=typeof n.maxForce?n.maxForce:1e6,u=n.pivotA?n.pivotA.clone():new t,p=n.pivotB?n.pivotB.clone():new t;this.axisA=n.axisA?n.axisA.clone():new t,this.axisB=n.axisB?n.axisB.clone():new t,o.call(this,e,u,f,p,l),this.collideConnected=!!n.collideConnected,this.angle="undefined"!=typeof n.angle?n.angle:0;var s=this.coneEquation=new d(e,f,n),y=this.twistEquation=new i(e,f,n);this.twistAngle="undefined"!=typeof n.twistAngle?n.twistAngle:0,s.maxForce=0,s.minForce=-l,y.maxForce=0,y.minForce=-l,this.equations.push(s,y)}f.exports=n;var o=(e("./Constraint"),e("./PointToPointConstraint")),d=e("../equations/ConeEquation"),i=e("../equations/RotationalEquation"),t=(e("../equations/ContactEquation"),e("../math/Vec3"));n.prototype=new o,n.constructor=n;new t,new t;n.prototype.update=function(){var e=this.bodyA,f=this.bodyB,n=this.coneEquation,d=this.twistEquation;o.prototype.update.call(this),e.vectorToWorldFrame(this.axisA,n.axisA),f.vectorToWorldFrame(this.axisB,n.axisB),this.axisA.tangents(d.axisA,d.axisA),e.vectorToWorldFrame(d.axisA,d.axisA),this.axisB.tangents(d.axisB,d.axisB),f.vectorToWorldFrame(d.axisB,d.axisB),n.angle=this.angle,d.maxAngle=this.twistAngle}},{"../equations/ConeEquation":18,"../equations/ContactEquation":19,"../equations/RotationalEquation":22,"../math/Vec3":30,"./Constraint":13,"./PointToPointConstraint":17}],13:[function(e,f){function n(e,f,d){d=o.defaults(d,{collideConnected:!0,wakeUpBodies:!0}),this.equations=[],this.bodyA=e,this.bodyB=f,this.id=n.idCounter++,this.collideConnected=d.collideConnected,d.wakeUpBodies&&(e&&e.wakeUp(),f&&f.wakeUp())}f.exports=n;var o=e("../utils/Utils");n.prototype.update=function(){throw new Error("method update() not implmemented in this Constraint subclass!")},n.prototype.enable=function(){for(var e=this.equations,f=0;f<e.length;f++)e[f].enabled=!0},n.prototype.disable=function(){for(var e=this.equations,f=0;f<e.length;f++)e[f].enabled=!1},n.idCounter=0},{"../utils/Utils":53}],14:[function(e,f){function n(e,f,n,i){o.call(this,e,f),"undefined"==typeof n&&(n=e.position.distanceTo(f.position)),"undefined"==typeof i&&(i=1e6),this.distance=n;var t=this.distanceEquation=new d(e,f);this.equations.push(t),t.minForce=-i,t.maxForce=i}f.exports=n;var o=e("./Constraint"),d=e("../equations/ContactEquation");n.prototype=new o,n.prototype.update=function(){var e=this.bodyA,f=this.bodyB,n=this.distanceEquation,o=.5*this.distance,d=n.ni;f.position.vsub(e.position,d),d.normalize(),d.mult(o,n.ri),d.mult(-o,n.rj)}},{"../equations/ContactEquation":19,"./Constraint":13}],15:[function(e,f){function n(e,f,n){n=n||{};var l="undefined"!=typeof n.maxForce?n.maxForce:1e6,u=n.pivotA?n.pivotA.clone():new t,p=n.pivotB?n.pivotB.clone():new t;o.call(this,e,u,f,p,l);var s=this.axisA=n.axisA?n.axisA.clone():new t(1,0,0);s.normalize();var y=this.axisB=n.axisB?n.axisB.clone():new t(1,0,0);y.normalize();var c=this.rotationalEquation1=new d(e,f,n),a=this.rotationalEquation2=new d(e,f,n),r=this.motorEquation=new i(e,f,l);r.enabled=!1,this.equations.push(c,a,r)}f.exports=n;var o=(e("./Constraint"),e("./PointToPointConstraint")),d=e("../equations/RotationalEquation"),i=e("../equations/RotationalMotorEquation"),t=(e("../equations/ContactEquation"),e("../math/Vec3"));n.prototype=new o,n.constructor=n,n.prototype.enableMotor=function(){this.motorEquation.enabled=!0},n.prototype.disableMotor=function(){this.motorEquation.enabled=!1},n.prototype.setMotorSpeed=function(e){this.motorEquation.targetVelocity=e},n.prototype.setMotorMaxForce=function(e){this.motorEquation.maxForce=e,this.motorEquation.minForce=-e};var l=new t,u=new t;n.prototype.update=function(){var e=this.bodyA,f=this.bodyB,n=this.motorEquation,d=this.rotationalEquation1,i=this.rotationalEquation2,t=l,p=u,s=this.axisA,y=this.axisB;o.prototype.update.call(this),e.quaternion.vmult(s,t),f.quaternion.vmult(y,p),t.tangents(d.axisA,i.axisA),d.axisB.copy(p),i.axisB.copy(p),this.motorEquation.enabled&&(e.quaternion.vmult(this.axisA,n.axisA),f.quaternion.vmult(this.axisB,n.axisB))}},{"../equations/ContactEquation":19,"../equations/RotationalEquation":22,"../equations/RotationalMotorEquation":23,"../math/Vec3":30,"./Constraint":13,"./PointToPointConstraint":17}],16:[function(e,f){function n(e,f,n){n=n||{};var t="undefined"!=typeof n.maxForce?n.maxForce:1e6,l=new i,u=new i,p=new i;e.position.vadd(f.position,p),p.scale(.5,p),f.pointToLocalFrame(p,u),e.pointToLocalFrame(p,l),o.call(this,e,l,f,u,t);var s=this.rotationalEquation1=new d(e,f,n),y=this.rotationalEquation2=new d(e,f,n),c=this.rotationalEquation3=new d(e,f,n);this.equations.push(s,y,c)}f.exports=n;var o=(e("./Constraint"),e("./PointToPointConstraint")),d=e("../equations/RotationalEquation"),i=(e("../equations/RotationalMotorEquation"),e("../equations/ContactEquation"),e("../math/Vec3"));n.prototype=new o,n.constructor=n;new i,new i;n.prototype.update=function(){var e=this.bodyA,f=this.bodyB,n=(this.motorEquation,this.rotationalEquation1),d=this.rotationalEquation2,t=this.rotationalEquation3;o.prototype.update.call(this),e.vectorToWorldFrame(i.UNIT_X,n.axisA),f.vectorToWorldFrame(i.UNIT_Y,n.axisB),e.vectorToWorldFrame(i.UNIT_Y,d.axisA),f.vectorToWorldFrame(i.UNIT_Z,d.axisB),e.vectorToWorldFrame(i.UNIT_Z,t.axisA),f.vectorToWorldFrame(i.UNIT_X,t.axisB)}},{"../equations/ContactEquation":19,"../equations/RotationalEquation":22,"../equations/RotationalMotorEquation":23,"../math/Vec3":30,"./Constraint":13,"./PointToPointConstraint":17}],17:[function(e,f){function n(e,f,n,t,l){o.call(this,e,n),l="undefined"!=typeof l?l:1e6,this.pivotA=f?f.clone():new i,this.pivotB=t?t.clone():new i;var u=this.equationX=new d(e,n),p=this.equationY=new d(e,n),s=this.equationZ=new d(e,n);this.equations.push(u,p,s),u.minForce=p.minForce=s.minForce=-l,u.maxForce=p.maxForce=s.maxForce=l,u.ni.set(1,0,0),p.ni.set(0,1,0),s.ni.set(0,0,1)}f.exports=n;var o=e("./Constraint"),d=e("../equations/ContactEquation"),i=e("../math/Vec3");n.prototype=new o,n.prototype.update=function(){var e=this.bodyA,f=this.bodyB,n=this.equationX,o=this.equationY,d=this.equationZ;e.quaternion.vmult(this.pivotA,n.ri),f.quaternion.vmult(this.pivotB,n.rj),o.ri.copy(n.ri),o.rj.copy(n.rj),d.ri.copy(n.ri),d.rj.copy(n.rj)}},{"../equations/ContactEquation":19,"../math/Vec3":30,"./Constraint":13}],18:[function(e,f){function n(e,f,n){n=n||{};var i="undefined"!=typeof n.maxForce?n.maxForce:1e6;d.call(this,e,f,-i,i),this.axisA=n.axisA?n.axisA.clone():new o(1,0,0),this.axisB=n.axisB?n.axisB.clone():new o(0,1,0),this.angle="undefined"!=typeof n.angle?n.angle:0}f.exports=n;var o=e("../math/Vec3"),d=(e("../math/Mat3"),e("./Equation"));n.prototype=new d,n.prototype.constructor=n;var i=new o,t=new o;n.prototype.computeB=function(e){var f=this.a,n=this.b,o=this.axisA,d=this.axisB,l=i,u=t,p=this.jacobianElementA,s=this.jacobianElementB;o.cross(d,l),d.cross(o,u),p.rotational.copy(u),s.rotational.copy(l);var y=Math.cos(this.angle)-o.dot(d),c=this.computeGW(),a=this.computeGiMf(),r=-y*f-c*n-e*a;return r}},{"../math/Mat3":27,"../math/Vec3":30,"./Equation":20}],19:[function(e,f){function n(e,f,n){n="undefined"!=typeof n?n:1e6,o.call(this,e,f,0,n),this.restitution=0,this.ri=new d,this.rj=new d,this.ni=new d}f.exports=n;{var o=e("./Equation"),d=e("../math/Vec3");e("../math/Mat3")}n.prototype=new o,n.prototype.constructor=n;var i=new d,t=new d,l=new d;n.prototype.computeB=function(e){var f=this.a,n=this.b,o=this.bi,d=this.bj,u=this.ri,p=this.rj,s=i,y=t,c=o.velocity,a=o.angularVelocity,r=(o.force,o.torque,d.velocity),w=d.angularVelocity,b=(d.force,d.torque,l),m=this.jacobianElementA,N=this.jacobianElementB,g=this.ni;u.cross(g,s),p.cross(g,y),g.negate(m.spatial),s.negate(m.rotational),N.spatial.copy(g),N.rotational.copy(y),b.copy(d.position),b.vadd(p,b),b.vsub(o.position,b),b.vsub(u,b);var x=g.dot(b),j=this.restitution+1,v=j*r.dot(g)-j*c.dot(g)+w.dot(y)-a.dot(s),A=this.computeGiMf(),C=-x*f-v*n-e*A;return C};var u=new d,p=new d,s=new d,y=new d,c=new d;n.prototype.getImpactVelocityAlongNormal=function(){var e=u,f=p,n=s,o=y,d=c;return this.bi.position.vadd(this.ri,n),this.bj.position.vadd(this.rj,o),this.bi.getVelocityAtWorldPoint(n,e),this.bj.getVelocityAtWorldPoint(o,f),e.vsub(f,d),this.ni.dot(d)}},{"../math/Mat3":27,"../math/Vec3":30,"./Equation":20}],20:[function(e,f){function n(e,f,d,i){this.id=n.id++,this.minForce="undefined"==typeof d?-1e6:d,this.maxForce="undefined"==typeof i?1e6:i,this.bi=e,this.bj=f,this.a=0,this.b=0,this.eps=0,this.jacobianElementA=new o,this.jacobianElementB=new o,this.enabled=!0,this.setSpookParams(1e7,4,1/60)
}f.exports=n;var o=e("../math/JacobianElement"),d=e("../math/Vec3");n.prototype.constructor=n,n.id=0,n.prototype.setSpookParams=function(e,f,n){var o=f,d=e,i=n;this.a=4/(i*(1+4*o)),this.b=4*o/(1+4*o),this.eps=4/(i*i*d*(1+4*o))},n.prototype.computeB=function(e,f,n){var o=this.computeGW(),d=this.computeGq(),i=this.computeGiMf();return-d*e-o*f-i*n},n.prototype.computeGq=function(){var e=this.jacobianElementA,f=this.jacobianElementB,n=this.bi,o=this.bj,d=n.position,i=o.position;return e.spatial.dot(d)+f.spatial.dot(i)};var i=new d;n.prototype.computeGW=function(){var e=this.jacobianElementA,f=this.jacobianElementB,n=this.bi,o=this.bj,d=n.velocity,t=o.velocity,l=n.angularVelocity||i,u=o.angularVelocity||i;return e.multiplyVectors(d,l)+f.multiplyVectors(t,u)},n.prototype.computeGWlambda=function(){var e=this.jacobianElementA,f=this.jacobianElementB,n=this.bi,o=this.bj,d=n.vlambda,t=o.vlambda,l=n.wlambda||i,u=o.wlambda||i;return e.multiplyVectors(d,l)+f.multiplyVectors(t,u)};var t=new d,l=new d,u=new d,p=new d;n.prototype.computeGiMf=function(){var e=this.jacobianElementA,f=this.jacobianElementB,n=this.bi,o=this.bj,d=n.force,i=n.torque,s=o.force,y=o.torque,c=n.invMassSolve,a=o.invMassSolve;return n.invInertiaWorldSolve?n.invInertiaWorldSolve.vmult(i,u):u.set(0,0,0),o.invInertiaWorldSolve?o.invInertiaWorldSolve.vmult(y,p):p.set(0,0,0),d.mult(c,t),s.mult(a,l),e.multiplyVectors(t,u)+f.multiplyVectors(l,p)};var s=new d;n.prototype.computeGiMGt=function(){var e=this.jacobianElementA,f=this.jacobianElementB,n=this.bi,o=this.bj,d=n.invMassSolve,i=o.invMassSolve,t=n.invInertiaWorldSolve,l=o.invInertiaWorldSolve,u=d+i;return t&&(t.vmult(e.rotational,s),u+=s.dot(e.rotational)),l&&(l.vmult(f.rotational,s),u+=s.dot(f.rotational)),u};{var y=new d;new d,new d,new d,new d,new d}n.prototype.addToWlambda=function(e){var f=this.jacobianElementA,n=this.jacobianElementB,o=this.bi,d=this.bj,i=y;f.spatial.mult(o.invMassSolve*e,i),o.vlambda.vadd(i,o.vlambda),n.spatial.mult(d.invMassSolve*e,i),d.vlambda.vadd(i,d.vlambda),o.invInertiaWorldSolve&&(o.invInertiaWorldSolve.vmult(f.rotational,i),i.mult(e,i),o.wlambda.vadd(i,o.wlambda)),d.invInertiaWorldSolve&&(d.invInertiaWorldSolve.vmult(n.rotational,i),i.mult(e,i),d.wlambda.vadd(i,d.wlambda))},n.prototype.computeC=function(){return this.computeGiMGt()+this.eps}},{"../math/JacobianElement":26,"../math/Vec3":30}],21:[function(e,f){function n(e,f,n){o.call(this,e,f,-n,n),this.ri=new d,this.rj=new d,this.t=new d}f.exports=n;{var o=e("./Equation"),d=e("../math/Vec3");e("../math/Mat3")}n.prototype=new o,n.prototype.constructor=n;var i=new d,t=new d;n.prototype.computeB=function(e){var f=(this.a,this.b),n=(this.bi,this.bj,this.ri),o=this.rj,d=i,l=t,u=this.t;n.cross(u,d),o.cross(u,l);var p=this.jacobianElementA,s=this.jacobianElementB;u.negate(p.spatial),d.negate(p.rotational),s.spatial.copy(u),s.rotational.copy(l);var y=this.computeGW(),c=this.computeGiMf(),a=-y*f-e*c;return a}},{"../math/Mat3":27,"../math/Vec3":30,"./Equation":20}],22:[function(e,f){function n(e,f,n){n=n||{};var i="undefined"!=typeof n.maxForce?n.maxForce:1e6;d.call(this,e,f,-i,i),this.axisA=n.axisA?n.axisA.clone():new o(1,0,0),this.axisB=n.axisB?n.axisB.clone():new o(0,1,0),this.maxAngle=Math.PI/2}f.exports=n;var o=e("../math/Vec3"),d=(e("../math/Mat3"),e("./Equation"));n.prototype=new d,n.prototype.constructor=n;var i=new o,t=new o;n.prototype.computeB=function(e){var f=this.a,n=this.b,o=this.axisA,d=this.axisB,l=i,u=t,p=this.jacobianElementA,s=this.jacobianElementB;o.cross(d,l),d.cross(o,u),p.rotational.copy(u),s.rotational.copy(l);var y=Math.cos(this.maxAngle)-o.dot(d),c=this.computeGW(),a=this.computeGiMf(),r=-y*f-c*n-e*a;return r}},{"../math/Mat3":27,"../math/Vec3":30,"./Equation":20}],23:[function(e,f){function n(e,f,n){n="undefined"!=typeof n?n:1e6,d.call(this,e,f,-n,n),this.axisA=new o,this.axisB=new o,this.targetVelocity=0}f.exports=n;var o=e("../math/Vec3"),d=(e("../math/Mat3"),e("./Equation"));n.prototype=new d,n.prototype.constructor=n,n.prototype.computeB=function(e){var f=(this.a,this.b),n=(this.bi,this.bj,this.axisA),o=this.axisB,d=this.jacobianElementA,i=this.jacobianElementB;d.rotational.copy(n),o.negate(i.rotational);var t=this.computeGW()-this.targetVelocity,l=this.computeGiMf(),u=-t*f-e*l;return u}},{"../math/Mat3":27,"../math/Vec3":30,"./Equation":20}],24:[function(e,f){function n(e,f,d){d=o.defaults(d,{friction:.3,restitution:.3,contactEquationStiffness:1e7,contactEquationRelaxation:3,frictionEquationStiffness:1e7,frictionEquationRelaxation:3}),this.id=n.idCounter++,this.materials=[e,f],this.friction=d.friction,this.restitution=d.restitution,this.contactEquationStiffness=d.contactEquationStiffness,this.contactEquationRelaxation=d.contactEquationRelaxation,this.frictionEquationStiffness=d.frictionEquationStiffness,this.frictionEquationRelaxation=d.frictionEquationRelaxation}var o=e("../utils/Utils");f.exports=n,n.idCounter=0},{"../utils/Utils":53}],25:[function(e,f){function n(e){var f="";e=e||{},"string"==typeof e?(f=e,e={}):"object"==typeof e&&(f=""),this.name=f,this.id=n.idCounter++,this.friction="undefined"!=typeof e.friction?e.friction:-1,this.restitution="undefined"!=typeof e.restitution?e.restitution:-1}f.exports=n,n.idCounter=0},{}],26:[function(e,f){function n(){this.spatial=new o,this.rotational=new o}f.exports=n;var o=e("./Vec3");n.prototype.multiplyElement=function(e){return e.spatial.dot(this.spatial)+e.rotational.dot(this.rotational)},n.prototype.multiplyVectors=function(e,f){return e.dot(this.spatial)+f.dot(this.rotational)}},{"./Vec3":30}],27:[function(e,f){function n(e){this.elements=e?e:[0,0,0,0,0,0,0,0,0]}f.exports=n;var o=e("./Vec3");n.prototype.identity=function(){var e=this.elements;e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1},n.prototype.setZero=function(){var e=this.elements;e[0]=0,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=0,e[6]=0,e[7]=0,e[8]=0},n.prototype.setTrace=function(e){var f=this.elements;f[0]=e.x,f[4]=e.y,f[8]=e.z},n.prototype.getTrace=function(e){var e=e||new o,f=this.elements;e.x=f[0],e.y=f[4],e.z=f[8]},n.prototype.vmult=function(e,f){f=f||new o;var n=this.elements,d=e.x,i=e.y,t=e.z;return f.x=n[0]*d+n[1]*i+n[2]*t,f.y=n[3]*d+n[4]*i+n[5]*t,f.z=n[6]*d+n[7]*i+n[8]*t,f},n.prototype.smult=function(e){for(var f=0;f<this.elements.length;f++)this.elements[f]*=e},n.prototype.mmult=function(e,f){for(var o=f||new n,d=0;3>d;d++)for(var i=0;3>i;i++){for(var t=0,l=0;3>l;l++)t+=e.elements[d+3*l]*this.elements[l+3*i];o.elements[d+3*i]=t}return o},n.prototype.scale=function(e,f){f=f||new n;for(var o=this.elements,d=f.elements,i=0;3!==i;i++)d[3*i+0]=e.x*o[3*i+0],d[3*i+1]=e.y*o[3*i+1],d[3*i+2]=e.z*o[3*i+2];return f},n.prototype.solve=function(e,f){f=f||new o;for(var n=3,d=4,i=[],t=0;n*d>t;t++)i.push(0);var t,l;for(t=0;3>t;t++)for(l=0;3>l;l++)i[t+d*l]=this.elements[t+3*l];i[3]=e.x,i[7]=e.y,i[11]=e.z;var u,p,s=3,y=s,c=4;do{if(t=y-s,0===i[t+d*t])for(l=t+1;y>l;l++)if(0!==i[t+d*l]){u=c;do p=c-u,i[p+d*t]+=i[p+d*l];while(--u);break}if(0!==i[t+d*t])for(l=t+1;y>l;l++){var a=i[t+d*l]/i[t+d*t];u=c;do p=c-u,i[p+d*l]=t>=p?0:i[p+d*l]-i[p+d*t]*a;while(--u)}}while(--s);if(f.z=i[2*d+3]/i[2*d+2],f.y=(i[1*d+3]-i[1*d+2]*f.z)/i[1*d+1],f.x=(i[0*d+3]-i[0*d+2]*f.z-i[0*d+1]*f.y)/i[0*d+0],isNaN(f.x)||isNaN(f.y)||isNaN(f.z)||1/0===f.x||1/0===f.y||1/0===f.z)throw"Could not solve equation! Got x=["+f.toString()+"], b=["+e.toString()+"], A=["+this.toString()+"]";return f},n.prototype.e=function(e,f,n){return void 0===n?this.elements[f+3*e]:void(this.elements[f+3*e]=n)},n.prototype.copy=function(e){for(var f=0;f<e.elements.length;f++)this.elements[f]=e.elements[f];return this},n.prototype.toString=function(){for(var e="",f=",",n=0;9>n;n++)e+=this.elements[n]+f;return e},n.prototype.reverse=function(e){e=e||new n;for(var f=3,o=6,d=[],i=0;f*o>i;i++)d.push(0);var i,t;for(i=0;3>i;i++)for(t=0;3>t;t++)d[i+o*t]=this.elements[i+3*t];d[3]=1,d[9]=0,d[15]=0,d[4]=0,d[10]=1,d[16]=0,d[5]=0,d[11]=0,d[17]=1;var l,u,p=3,s=p,y=o;do{if(i=s-p,0===d[i+o*i])for(t=i+1;s>t;t++)if(0!==d[i+o*t]){l=y;do u=y-l,d[u+o*i]+=d[u+o*t];while(--l);break}if(0!==d[i+o*i])for(t=i+1;s>t;t++){var c=d[i+o*t]/d[i+o*i];l=y;do u=y-l,d[u+o*t]=i>=u?0:d[u+o*t]-d[u+o*i]*c;while(--l)}}while(--p);i=2;do{t=i-1;do{var c=d[i+o*t]/d[i+o*i];l=o;do u=o-l,d[u+o*t]=d[u+o*t]-d[u+o*i]*c;while(--l)}while(t--)}while(--i);i=2;do{var c=1/d[i+o*i];l=o;do u=o-l,d[u+o*i]=d[u+o*i]*c;while(--l)}while(i--);i=2;do{t=2;do{if(u=d[f+t+o*i],isNaN(u)||1/0===u)throw"Could not reverse! A=["+this.toString()+"]";e.e(i,t,u)}while(t--)}while(i--);return e},n.prototype.setRotationFromQuaternion=function(e){var f=e.x,n=e.y,o=e.z,d=e.w,i=f+f,t=n+n,l=o+o,u=f*i,p=f*t,s=f*l,y=n*t,c=n*l,a=o*l,r=d*i,w=d*t,b=d*l,m=this.elements;return m[0]=1-(y+a),m[1]=p-b,m[2]=s+w,m[3]=p+b,m[4]=1-(u+a),m[5]=c-r,m[6]=s-w,m[7]=c+r,m[8]=1-(u+y),this},n.prototype.transpose=function(e){e=e||new n;for(var f=e.elements,o=this.elements,d=0;3!==d;d++)for(var i=0;3!==i;i++)f[3*d+i]=o[3*i+d];return e}},{"./Vec3":30}],28:[function(e,f){function n(e,f,n,o){this.x=void 0!==e?e:0,this.y=void 0!==f?f:0,this.z=void 0!==n?n:0,this.w=void 0!==o?o:1}f.exports=n;var o=e("./Vec3");n.prototype.set=function(e,f,n,o){this.x=e,this.y=f,this.z=n,this.w=o},n.prototype.toString=function(){return this.x+","+this.y+","+this.z+","+this.w},n.prototype.toArray=function(){return[this.x,this.y,this.z,this.w]},n.prototype.setFromAxisAngle=function(e,f){var n=Math.sin(.5*f);this.x=e.x*n,this.y=e.y*n,this.z=e.z*n,this.w=Math.cos(.5*f)},n.prototype.toAxisAngle=function(e){e=e||new o,this.normalize();var f=2*Math.acos(this.w),n=Math.sqrt(1-this.w*this.w);return.001>n?(e.x=this.x,e.y=this.y,e.z=this.z):(e.x=this.x/n,e.y=this.y/n,e.z=this.z/n),[e,f]};var d=new o,i=new o;n.prototype.setFromVectors=function(e,f){if(e.isAntiparallelTo(f)){var n=d,o=i;e.tangents(n,o),this.setFromAxisAngle(n,Math.PI)}else{var t=e.cross(f);this.x=t.x,this.y=t.y,this.z=t.z,this.w=Math.sqrt(Math.pow(e.norm(),2)*Math.pow(f.norm(),2))+e.dot(f),this.normalize()}};var t=new o,l=new o,u=new o;n.prototype.mult=function(e,f){f=f||new n;var o=this.w,d=t,i=l,p=u;return d.set(this.x,this.y,this.z),i.set(e.x,e.y,e.z),f.w=o*e.w-d.dot(i),d.cross(i,p),f.x=o*i.x+e.w*d.x+p.x,f.y=o*i.y+e.w*d.y+p.y,f.z=o*i.z+e.w*d.z+p.z,f},n.prototype.inverse=function(e){var f=this.x,o=this.y,d=this.z,i=this.w;e=e||new n,this.conjugate(e);var t=1/(f*f+o*o+d*d+i*i);return e.x*=t,e.y*=t,e.z*=t,e.w*=t,e},n.prototype.conjugate=function(e){return e=e||new n,e.x=-this.x,e.y=-this.y,e.z=-this.z,e.w=this.w,e},n.prototype.normalize=function(){var e=Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);0===e?(this.x=0,this.y=0,this.z=0,this.w=0):(e=1/e,this.x*=e,this.y*=e,this.z*=e,this.w*=e)},n.prototype.normalizeFast=function(){var e=(3-(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w))/2;0===e?(this.x=0,this.y=0,this.z=0,this.w=0):(this.x*=e,this.y*=e,this.z*=e,this.w*=e)},n.prototype.vmult=function(e,f){f=f||new o;var n=e.x,d=e.y,i=e.z,t=this.x,l=this.y,u=this.z,p=this.w,s=p*n+l*i-u*d,y=p*d+u*n-t*i,c=p*i+t*d-l*n,a=-t*n-l*d-u*i;return f.x=s*p+a*-t+y*-u-c*-l,f.y=y*p+a*-l+c*-t-s*-u,f.z=c*p+a*-u+s*-l-y*-t,f},n.prototype.copy=function(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w,this},n.prototype.toEuler=function(e,f){f=f||"YZX";var n,o,d,i=this.x,t=this.y,l=this.z,u=this.w;switch(f){case"YZX":var p=i*t+l*u;if(p>.499&&(n=2*Math.atan2(i,u),o=Math.PI/2,d=0),-.499>p&&(n=-2*Math.atan2(i,u),o=-Math.PI/2,d=0),isNaN(n)){var s=i*i,y=t*t,c=l*l;n=Math.atan2(2*t*u-2*i*l,1-2*y-2*c),o=Math.asin(2*p),d=Math.atan2(2*i*u-2*t*l,1-2*s-2*c)}break;default:throw new Error("Euler order "+f+" not supported yet.")}e.y=n,e.z=o,e.x=d},n.prototype.setFromEuler=function(e,f,n,o){o=o||"XYZ";var d=Math.cos(e/2),i=Math.cos(f/2),t=Math.cos(n/2),l=Math.sin(e/2),u=Math.sin(f/2),p=Math.sin(n/2);return"XYZ"===o?(this.x=l*i*t+d*u*p,this.y=d*u*t-l*i*p,this.z=d*i*p+l*u*t,this.w=d*i*t-l*u*p):"YXZ"===o?(this.x=l*i*t+d*u*p,this.y=d*u*t-l*i*p,this.z=d*i*p-l*u*t,this.w=d*i*t+l*u*p):"ZXY"===o?(this.x=l*i*t-d*u*p,this.y=d*u*t+l*i*p,this.z=d*i*p+l*u*t,this.w=d*i*t-l*u*p):"ZYX"===o?(this.x=l*i*t-d*u*p,this.y=d*u*t+l*i*p,this.z=d*i*p-l*u*t,this.w=d*i*t+l*u*p):"YZX"===o?(this.x=l*i*t+d*u*p,this.y=d*u*t+l*i*p,this.z=d*i*p-l*u*t,this.w=d*i*t-l*u*p):"XZY"===o&&(this.x=l*i*t-d*u*p,this.y=d*u*t-l*i*p,this.z=d*i*p+l*u*t,this.w=d*i*t+l*u*p),this},n.prototype.clone=function(){return new n(this.x,this.y,this.z,this.w)}},{"./Vec3":30}],29:[function(e,f){function n(e){e=e||{},this.position=new o,e.position&&this.position.copy(e.position),this.quaternion=new d,e.quaternion&&this.quaternion.copy(e.quaternion)}var o=e("./Vec3"),d=e("./Quaternion");f.exports=n;var i=new d;n.pointToLocalFrame=function(e,f,n,d){var d=d||new o;return n.vsub(e,d),f.conjugate(i),i.vmult(d,d),d},n.prototype.pointToLocal=function(e,f){return n.pointToLocalFrame(this.position,this.quaternion,e,f)},n.pointToWorldFrame=function(e,f,n,d){var d=d||new o;return f.vmult(n,d),d.vadd(e,d),d},n.prototype.pointToWorld=function(e,f){return n.pointToWorldFrame(this.position,this.quaternion,e,f)},n.prototype.vectorToWorldFrame=function(e,f){var f=f||new o;return this.quaternion.vmult(e,f),f},n.vectorToWorldFrame=function(e,f,n){return e.vmult(f,n),n},n.vectorToLocalFrame=function(e,f,n,d){var d=d||new o;return f.w*=-1,f.vmult(n,d),f.w*=-1,d}},{"./Quaternion":28,"./Vec3":30}],30:[function(e,f){function n(e,f,n){this.x=e||0,this.y=f||0,this.z=n||0}f.exports=n;var o=e("./Mat3");n.ZERO=new n(0,0,0),n.UNIT_X=new n(1,0,0),n.UNIT_Y=new n(0,1,0),n.UNIT_Z=new n(0,0,1),n.prototype.cross=function(e,f){var o=e.x,d=e.y,i=e.z,t=this.x,l=this.y,u=this.z;return f=f||new n,f.x=l*i-u*d,f.y=u*o-t*i,f.z=t*d-l*o,f},n.prototype.set=function(e,f,n){return this.x=e,this.y=f,this.z=n,this},n.prototype.setZero=function(){this.x=this.y=this.z=0},n.prototype.vadd=function(e,f){return f?(f.x=e.x+this.x,f.y=e.y+this.y,f.z=e.z+this.z,void 0):new n(this.x+e.x,this.y+e.y,this.z+e.z)},n.prototype.vsub=function(e,f){return f?(f.x=this.x-e.x,f.y=this.y-e.y,f.z=this.z-e.z,void 0):new n(this.x-e.x,this.y-e.y,this.z-e.z)},n.prototype.crossmat=function(){return new o([0,-this.z,this.y,this.z,0,-this.x,-this.y,this.x,0])},n.prototype.normalize=function(){var e=this.x,f=this.y,n=this.z,o=Math.sqrt(e*e+f*f+n*n);if(o>0){var d=1/o;this.x*=d,this.y*=d,this.z*=d}else this.x=0,this.y=0,this.z=0;return o},n.prototype.unit=function(e){e=e||new n;var f=this.x,o=this.y,d=this.z,i=Math.sqrt(f*f+o*o+d*d);return i>0?(i=1/i,e.x=f*i,e.y=o*i,e.z=d*i):(e.x=1,e.y=0,e.z=0),e},n.prototype.norm=function(){var e=this.x,f=this.y,n=this.z;return Math.sqrt(e*e+f*f+n*n)},n.prototype.length=n.prototype.norm,n.prototype.norm2=function(){return this.dot(this)},n.prototype.lengthSquared=n.prototype.norm2,n.prototype.distanceTo=function(e){var f=this.x,n=this.y,o=this.z,d=e.x,i=e.y,t=e.z;return Math.sqrt((d-f)*(d-f)+(i-n)*(i-n)+(t-o)*(t-o))},n.prototype.distanceSquared=function(e){var f=this.x,n=this.y,o=this.z,d=e.x,i=e.y,t=e.z;return(d-f)*(d-f)+(i-n)*(i-n)+(t-o)*(t-o)},n.prototype.mult=function(e,f){f=f||new n;var o=this.x,d=this.y,i=this.z;return f.x=e*o,f.y=e*d,f.z=e*i,f},n.prototype.scale=n.prototype.mult,n.prototype.dot=function(e){return this.x*e.x+this.y*e.y+this.z*e.z},n.prototype.isZero=function(){return 0===this.x&&0===this.y&&0===this.z},n.prototype.negate=function(e){return e=e||new n,e.x=-this.x,e.y=-this.y,e.z=-this.z,e};var d=new n,i=new n;n.prototype.tangents=function(e,f){var n=this.norm();if(n>0){var o=d,t=1/n;o.set(this.x*t,this.y*t,this.z*t);var l=i;Math.abs(o.x)<.9?(l.set(1,0,0),o.cross(l,e)):(l.set(0,1,0),o.cross(l,e)),o.cross(e,f)}else e.set(1,0,0),f.set(0,1,0)},n.prototype.toString=function(){return this.x+","+this.y+","+this.z},n.prototype.toArray=function(){return[this.x,this.y,this.z]},n.prototype.copy=function(e){return this.x=e.x,this.y=e.y,this.z=e.z,this},n.prototype.lerp=function(e,f,n){var o=this.x,d=this.y,i=this.z;n.x=o+(e.x-o)*f,n.y=d+(e.y-d)*f,n.z=i+(e.z-i)*f},n.prototype.almostEquals=function(e,f){return void 0===f&&(f=1e-6),Math.abs(this.x-e.x)>f||Math.abs(this.y-e.y)>f||Math.abs(this.z-e.z)>f?!1:!0},n.prototype.almostZero=function(e){return void 0===e&&(e=1e-6),Math.abs(this.x)>e||Math.abs(this.y)>e||Math.abs(this.z)>e?!1:!0};var t=new n;n.prototype.isAntiparallelTo=function(e,f){return this.negate(t),t.almostEquals(e,f)},n.prototype.clone=function(){return new n(this.x,this.y,this.z)}},{"./Mat3":27}],31:[function(e,f){function n(e){e=e||{},o.apply(this),this.id=n.idCounter++,this.world=null,this.preStep=null,this.postStep=null,this.vlambda=new d,this.collisionFilterGroup="number"==typeof e.collisionFilterGroup?e.collisionFilterGroup:1,this.collisionFilterMask="number"==typeof e.collisionFilterMask?e.collisionFilterMask:1,this.collisionResponse=!0,this.position=new d,e.position&&this.position.copy(e.position),this.previousPosition=new d,this.initPosition=new d,this.velocity=new d,e.velocity&&this.velocity.copy(e.velocity),this.initVelocity=new d,this.force=new d;var f="number"==typeof e.mass?e.mass:0;this.mass=f,this.invMass=f>0?1/f:0,this.material=e.material||null,this.linearDamping="number"==typeof e.linearDamping?e.linearDamping:.01,this.type=0>=f?n.STATIC:n.DYNAMIC,typeof e.type==typeof n.STATIC&&(this.type=e.type),this.allowSleep="undefined"!=typeof e.allowSleep?e.allowSleep:!0,this.sleepState=0,this.sleepSpeedLimit="undefined"!=typeof e.sleepSpeedLimit?e.sleepSpeedLimit:.1,this.sleepTimeLimit="undefined"!=typeof e.sleepTimeLimit?e.sleepTimeLimit:1,this.timeLastSleepy=0,this._wakeUpAfterNarrowphase=!1,this.torque=new d,this.quaternion=new t,e.quaternion&&this.quaternion.copy(e.quaternion),this.initQuaternion=new t,this.angularVelocity=new d,e.angularVelocity&&this.angularVelocity.copy(e.angularVelocity),this.initAngularVelocity=new d,this.interpolatedPosition=new d,this.interpolatedQuaternion=new t,this.shapes=[],this.shapeOffsets=[],this.shapeOrientations=[],this.inertia=new d,this.invInertia=new d,this.invInertiaWorld=new i,this.invMassSolve=0,this.invInertiaSolve=new d,this.invInertiaWorldSolve=new i,this.fixedRotation="undefined"!=typeof e.fixedRotation?e.fixedRotation:!1,this.angularDamping="undefined"!=typeof e.angularDamping?e.angularDamping:.01,this.aabb=new l,this.aabbNeedsUpdate=!0,this.wlambda=new d,e.shape&&this.addShape(e.shape),this.updateMassProperties()}f.exports=n;var o=e("../utils/EventTarget"),d=(e("../shapes/Shape"),e("../math/Vec3")),i=e("../math/Mat3"),t=e("../math/Quaternion"),l=(e("../material/Material"),e("../collision/AABB")),u=e("../shapes/Box");n.prototype=new o,n.prototype.constructor=n,n.DYNAMIC=1,n.STATIC=2,n.KINEMATIC=4,n.AWAKE=0,n.SLEEPY=1,n.SLEEPING=2,n.idCounter=0,n.prototype.wakeUp=function(){var e=this.sleepState;this.sleepState=0,e===n.SLEEPING&&this.dispatchEvent({type:"wakeup"})},n.prototype.sleep=function(){this.sleepState=n.SLEEPING,this.velocity.set(0,0,0),this.angularVelocity.set(0,0,0)},n.sleepyEvent={type:"sleepy"},n.sleepEvent={type:"sleep"},n.prototype.sleepTick=function(e){if(this.allowSleep){var f=this.sleepState,o=this.velocity.norm2()+this.angularVelocity.norm2(),d=Math.pow(this.sleepSpeedLimit,2);f===n.AWAKE&&d>o?(this.sleepState=n.SLEEPY,this.timeLastSleepy=e,this.dispatchEvent(n.sleepyEvent)):f===n.SLEEPY&&o>d?this.wakeUp():f===n.SLEEPY&&e-this.timeLastSleepy>this.sleepTimeLimit&&(this.sleep(),this.dispatchEvent(n.sleepEvent))}},n.prototype.updateSolveMassProperties=function(){this.sleepState===n.SLEEPING||this.type===n.KINEMATIC?(this.invMassSolve=0,this.invInertiaSolve.setZero(),this.invInertiaWorldSolve.setZero()):(this.invMassSolve=this.invMass,this.invInertiaSolve.copy(this.invInertia),this.invInertiaWorldSolve.copy(this.invInertiaWorld))},n.prototype.pointToLocalFrame=function(e,f){var f=f||new d;return e.vsub(this.position,f),this.quaternion.conjugate().vmult(f,f),f},n.prototype.vectorToLocalFrame=function(e,f){var f=f||new d;return this.quaternion.conjugate().vmult(e,f),f},n.prototype.pointToWorldFrame=function(e,f){var f=f||new d;return this.quaternion.vmult(e,f),f.vadd(this.position,f),f},n.prototype.vectorToWorldFrame=function(e,f){var f=f||new d;return this.quaternion.vmult(e,f),f};var p=new d,s=new t;n.prototype.addShape=function(e,f,n){var o=new d,i=new t;return f&&o.copy(f),n&&i.copy(n),this.shapes.push(e),this.shapeOffsets.push(o),this.shapeOrientations.push(i),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,this},n.prototype.updateBoundingRadius=function(){for(var e=this.shapes,f=this.shapeOffsets,n=e.length,o=0,d=0;d!==n;d++){var i=e[d];i.updateBoundingSphereRadius();var t=f[d].norm(),l=i.boundingSphereRadius;t+l>o&&(o=t+l)}this.boundingRadius=o};var y=new l;n.prototype.computeAABB=function(){for(var e=this.shapes,f=this.shapeOffsets,n=this.shapeOrientations,o=e.length,d=p,i=s,t=this.quaternion,l=this.aabb,u=y,c=0;c!==o;c++){var a=e[c];n[c].mult(t,i),i.vmult(f[c],d),d.vadd(this.position,d),a.calculateWorldAABB(d,i,u.lowerBound,u.upperBound),0===c?l.copy(u):l.extend(u)}this.aabbNeedsUpdate=!1};{var c=new i,a=new i;new i}n.prototype.updateInertiaWorld=function(e){var f=this.invInertia;if(f.x!==f.y||f.y!==f.z||e){var n=c,o=a;n.setRotationFromQuaternion(this.quaternion),n.transpose(o),n.scale(f,n),n.mmult(o,this.invInertiaWorld)}else;};var r=new d,w=new d;n.prototype.applyForce=function(e,f){if(this.type===n.DYNAMIC){var o=r;f.vsub(this.position,o);var d=w;o.cross(e,d),this.force.vadd(e,this.force),this.torque.vadd(d,this.torque)}};var b=new d,m=new d;n.prototype.applyLocalForce=function(e,f){if(this.type===n.DYNAMIC){var o=b,d=m;this.vectorToWorldFrame(e,o),this.pointToWorldFrame(f,d),this.applyForce(o,d)}};var N=new d,g=new d,x=new d;n.prototype.applyImpulse=function(e,f){if(this.type===n.DYNAMIC){var o=N;f.vsub(this.position,o);var d=g;d.copy(e),d.mult(this.invMass,d),this.velocity.vadd(d,this.velocity);var i=x;o.cross(e,i),this.invInertiaWorld.vmult(i,i),this.angularVelocity.vadd(i,this.angularVelocity)}};var j=new d,v=new d;n.prototype.applyLocalImpulse=function(e,f){if(this.type===n.DYNAMIC){var o=j,d=v;this.vectorToWorldFrame(e,o),this.pointToWorldFrame(f,d),this.applyImpulse(o,d)}};var A=new d;n.prototype.updateMassProperties=function(){var e=A;this.invMass=this.mass>0?1/this.mass:0;var f=this.inertia,n=this.fixedRotation;this.computeAABB(),e.set((this.aabb.upperBound.x-this.aabb.lowerBound.x)/2,(this.aabb.upperBound.y-this.aabb.lowerBound.y)/2,(this.aabb.upperBound.z-this.aabb.lowerBound.z)/2),u.calculateInertia(e,this.mass,f),this.invInertia.set(f.x>0&&!n?1/f.x:0,f.y>0&&!n?1/f.y:0,f.z>0&&!n?1/f.z:0),this.updateInertiaWorld(!0)},n.prototype.getVelocityAtWorldPoint=function(e,f){var n=new d;return e.vsub(this.position,n),this.angularVelocity.cross(n,f),this.velocity.vadd(f,f),f}},{"../collision/AABB":3,"../material/Material":25,"../math/Mat3":27,"../math/Quaternion":28,"../math/Vec3":30,"../shapes/Box":37,"../shapes/Shape":43,"../utils/EventTarget":49}],32:[function(e,f){function n(e){this.chassisBody=e.chassisBody,this.wheelInfos=[],this.sliding=!1,this.world=null,this.indexRightAxis="undefined"!=typeof e.indexRightAxis?e.indexRightAxis:1,this.indexForwardAxis="undefined"!=typeof e.indexForwardAxis?e.indexForwardAxis:0,this.indexUpAxis="undefined"!=typeof e.indexUpAxis?e.indexUpAxis:2}function o(e,f,n,o,i){var t=0,l=n,u=x,p=j,s=v;e.getVelocityAtWorldPoint(l,u),f.getVelocityAtWorldPoint(l,p),u.vsub(p,s);var y=o.dot(s),c=d(e,n,o),a=d(f,n,o),r=1,w=r/(c+a);return t=-y*w,t>i&&(t=i),-i>t&&(t=-i),t}function d(e,f,n){var o=A,d=C,i=O,t=h;return f.vsub(e.position,o),o.cross(n,d),e.invInertiaWorld.vmult(d,t),t.cross(o,i),e.invMass+n.dot(i)}function i(e,f,n,o,d,i){var t=d.norm2();if(t>1.1)return 0;var l=k,u=q,p=z;e.getVelocityAtWorldPoint(f,l),n.getVelocityAtWorldPoint(o,u),l.vsub(u,p);var s=d.dot(p),y=.2,c=1/(e.invMass+n.invMass),i=-y*s*c;return i}var t=(e("./Body"),e("../math/Vec3")),l=e("../math/Quaternion"),u=(e("../collision/RaycastResult"),e("../collision/Ray")),p=e("../objects/WheelInfo");f.exports=n;{var s=(new t,new t,new t,new t),y=new t,c=new t;new u}n.prototype.addWheel=function(e){e=e||{};var f=new p(e),n=this.wheelInfos.length;return this.wheelInfos.push(f),n},n.prototype.setSteeringValue=function(e,f){var n=this.wheelInfos[f];n.steering=e};new t;n.prototype.applyEngineForce=function(e,f){this.wheelInfos[f].engineForce=e},n.prototype.setBrake=function(e,f){this.wheelInfos[f].brake=e},n.prototype.addToWorld=function(e){this.constraints;e.add(this.chassisBody);var f=this;this.preStepCallback=function(){f.updateVehicle(e.dt)},e.addEventListener("preStep",this.preStepCallback),this.world=e},n.prototype.getVehicleAxisWorld=function(e,f){f.set(0===e?1:0,1===e?1:0,2===e?1:0),this.chassisBody.vectorToWorldFrame(f,f)},n.prototype.updateVehicle=function(e){for(var f=this.wheelInfos,n=f.length,o=this.chassisBody,d=0;n>d;d++)this.updateWheelTransform(d);this.currentVehicleSpeedKmHour=3.6*o.velocity.norm();var i=new t;this.getVehicleAxisWorld(this.indexForwardAxis,i),i.dot(o.velocity)<0&&(this.currentVehicleSpeedKmHour*=-1);for(var d=0;n>d;d++)this.castRay(f[d]);this.updateSuspension(e);for(var l=new t,u=new t,d=0;n>d;d++){var p=f[d],s=p.suspensionForce;s>p.maxSuspensionForce&&(s=p.maxSuspensionForce),p.raycastResult.hitNormalWorld.scale(s*e,l),p.raycastResult.hitPointWorld.vsub(o.position,u),o.applyImpulse(l,p.raycastResult.hitPointWorld)}this.updateFriction(e);var y=new t,c=new t,a=new t;for(d=0;n>d;d++){var p=f[d];o.getVelocityAtWorldPoint(p.chassisConnectionPointWorld,a);var r=1;switch(this.indexUpAxis){case 1:r=-1}if(p.isInContact){this.getVehicleAxisWorld(this.indexForwardAxis,c);var w=c.dot(p.raycastResult.hitNormalWorld);p.raycastResult.hitNormalWorld.scale(w,y),c.vsub(y,c);var b=c.dot(a);p.deltaRotation=r*b*e/p.radius}!p.sliding&&p.isInContact||0===p.engineForce||!p.useCustomSlidingRotationalSpeed||(p.deltaRotation=(p.engineForce>0?1:-1)*p.customSlidingRotationalSpeed*e),Math.abs(p.brake)>Math.abs(p.engineForce)&&(p.deltaRotation=0),p.rotation+=p.deltaRotation,p.deltaRotation*=.99}},n.prototype.updateSuspension=function(){for(var e=this.chassisBody,f=e.mass,n=this.wheelInfos,o=n.length,d=0;o>d;d++){var i=n[d];if(i.isInContact){var t,l=i.suspensionRestLength,u=i.suspensionLength,p=l-u;t=i.suspensionStiffness*p*i.clippedInvContactDotSuspension;var s,y=i.suspensionRelativeVelocity;s=0>y?i.dampingCompression:i.dampingRelaxation,t-=s*y,i.suspensionForce=t*f,i.suspensionForce<0&&(i.suspensionForce=0)}else i.suspensionForce=0}},n.prototype.removeFromWorld=function(e){this.constraints;e.remove(this.chassisBody),e.removeEventListener("preStep",this.preStepCallback),this.world=null};var a=new t,r=new t;n.prototype.castRay=function(e){var f=a,n=r;this.updateWheelTransformWorld(e);var o=this.chassisBody,d=-1,i=e.suspensionRestLength+e.radius;e.directionWorld.scale(i,f);var l=e.chassisConnectionPointWorld;l.vadd(f,n);var u=e.raycastResult;u.reset();var p=o.collisionResponse;o.collisionResponse=!1,this.world.rayTest(l,n,u),o.collisionResponse=p;var s=u.body;if(e.raycastResult.groundObject=0,s){d=u.distance,e.raycastResult.hitNormalWorld=u.hitNormalWorld,e.isInContact=!0;var y=u.distance;e.suspensionLength=y-e.radius;var c=e.suspensionRestLength-e.maxSuspensionTravel,w=e.suspensionRestLength+e.maxSuspensionTravel;e.suspensionLength<c&&(e.suspensionLength=c),e.suspensionLength>w&&(e.suspensionLength=w,e.raycastResult.reset());var b=e.raycastResult.hitNormalWorld.dot(e.directionWorld),m=new t;o.getVelocityAtWorldPoint(e.raycastResult.hitPointWorld,m);var N=e.raycastResult.hitNormalWorld.dot(m);if(b>=-.1)e.suspensionRelativeVelocity=0,e.clippedInvContactDotSuspension=10;else{var g=-1/b;e.suspensionRelativeVelocity=N*g,e.clippedInvContactDotSuspension=g}}else e.suspensionLength=e.suspensionRestLength+0*e.maxSuspensionTravel,e.suspensionRelativeVelocity=0,e.directionWorld.scale(-1,e.raycastResult.hitNormalWorld),e.clippedInvContactDotSuspension=1;return d},n.prototype.updateWheelTransformWorld=function(e){e.isInContact=!1;var f=this.chassisBody;f.pointToWorldFrame(e.chassisConnectionPointLocal,e.chassisConnectionPointWorld),f.vectorToWorldFrame(e.directionLocal,e.directionWorld),f.vectorToWorldFrame(e.axleLocal,e.axleWorld)},n.prototype.updateWheelTransform=function(e){var f=s,n=y,o=c,d=this.wheelInfos[e];this.updateWheelTransformWorld(d),d.directionLocal.scale(-1,f),n.copy(d.axleLocal),f.cross(n,o),o.normalize(),n.normalize();var i=d.steering,t=new l;t.setFromAxisAngle(f,i);var u=new l;u.setFromAxisAngle(n,d.rotation);var p=d.worldTransform.quaternion;this.chassisBody.quaternion.mult(t,p),p.mult(u,p),p.normalize();var a=d.worldTransform.position;a.copy(d.directionWorld),a.scale(d.suspensionLength,a),a.vadd(d.chassisConnectionPointWorld,a)};var w=[new t(1,0,0),new t(0,1,0),new t(0,0,1)];n.prototype.getWheelTransformWorld=function(e){return this.wheelInfos[e].worldTransform};var b=new t,m=[],N=[],g=1;n.prototype.updateFriction=function(e){for(var f=b,n=this.wheelInfos,d=n.length,l=this.chassisBody,u=N,p=m,s=0,y=0;d>y;y++){var c=n[y],a=c.raycastResult.body;a&&s++,c.sideImpulse=0,c.forwardImpulse=0,u[y]||(u[y]=new t),p[y]||(p[y]=new t)}for(var y=0;d>y;y++){var c=n[y],a=c.raycastResult.body;if(a){var r=p[y],x=this.getWheelTransformWorld(y);x.vectorToWorldFrame(w[this.indexRightAxis],r);var j=c.raycastResult.hitNormalWorld,v=r.dot(j);j.scale(v,f),r.vsub(f,r),r.normalize(),j.cross(r,u[y]),u[y].normalize(),c.sideImpulse=i(l,c.raycastResult.hitPointWorld,a,c.raycastResult.hitPointWorld,r),c.sideImpulse*=g}}var A=1,C=.5;this.sliding=!1;for(var y=0;d>y;y++){var c=n[y],a=c.raycastResult.body,O=0;if(c.slipInfo=1,a){var h=0,k=c.brake?c.brake:h;O=o(l,a,c.raycastResult.hitPointWorld,u[y],k),O+=c.engineForce*e;var q=k/O;c.slipInfo*=q}if(c.forwardImpulse=0,c.skidInfo=1,a){c.skidInfo=1;var z=c.suspensionForce*e*c.frictionSlip,B=z,D=z*B;c.forwardImpulse=O;var E=c.forwardImpulse*C,F=c.sideImpulse*A,G=E*E+F*F;if(c.sliding=!1,G>D){this.sliding=!0,c.sliding=!0;var q=z/Math.sqrt(G);c.skidInfo*=q}}}if(this.sliding)for(var y=0;d>y;y++){var c=n[y];0!==c.sideImpulse&&c.skidInfo<1&&(c.forwardImpulse*=c.skidInfo,c.sideImpulse*=c.skidInfo)}for(var y=0;d>y;y++){var c=n[y],H=new t;if(H.copy(c.raycastResult.hitPointWorld),0!==c.forwardImpulse){var I=new t;u[y].scale(c.forwardImpulse,I),l.applyImpulse(I,H)}if(0!==c.sideImpulse){var a=c.raycastResult.body,J=new t;J.copy(c.raycastResult.hitPointWorld);var K=new t;p[y].scale(c.sideImpulse,K),l.pointToLocalFrame(H,H),H["xyz"[this.indexUpAxis]]*=c.rollInfluence,l.pointToWorldFrame(H,H),l.applyImpulse(K,H),K.scale(-1,K),a.applyImpulse(K,J)}}};var x=new t,j=new t,v=new t,A=new t,C=new t,O=new t,h=new t,k=new t,q=new t,z=new t},{"../collision/Ray":9,"../collision/RaycastResult":10,"../math/Quaternion":28,"../math/Vec3":30,"../objects/WheelInfo":36,"./Body":31}],33:[function(e,f){function n(e){if(this.wheelBodies=[],this.coordinateSystem="undefined"==typeof e.coordinateSystem?new t(1,2,3):e.coordinateSystem.clone(),this.chassisBody=e.chassisBody,!this.chassisBody){var f=new i(new t(5,2,.5));this.chassisBody=new o(1,f)}this.constraints=[],this.wheelAxes=[],this.wheelForces=[]}var o=e("./Body"),d=e("../shapes/Sphere"),i=e("../shapes/Box"),t=e("../math/Vec3"),l=e("../constraints/HingeConstraint");f.exports=n,n.prototype.addWheel=function(e){e=e||{};var f=e.body;f||(f=new o(1,new d(1.2))),this.wheelBodies.push(f),this.wheelForces.push(0);var n=(new t,"undefined"!=typeof e.position?e.position.clone():new t),i=new t;this.chassisBody.pointToWorldFrame(n,i),f.position.set(i.x,i.y,i.z);var u="undefined"!=typeof e.axis?e.axis.clone():new t(0,1,0);this.wheelAxes.push(u);var p=new l(this.chassisBody,f,{pivotA:n,axisA:u,pivotB:t.ZERO,axisB:u,collideConnected:!1});return this.constraints.push(p),this.wheelBodies.length-1},n.prototype.setSteeringValue=function(e,f){var n=this.wheelAxes[f],o=Math.cos(e),d=Math.sin(e),i=n.x,t=n.y;this.constraints[f].axisA.set(o*i-d*t,d*i+o*t,0)},n.prototype.setMotorSpeed=function(e,f){var n=this.constraints[f];n.enableMotor(),n.motorTargetVelocity=e},n.prototype.disableMotor=function(e){var f=this.constraints[e];
f.disableMotor()};var u=new t;n.prototype.setWheelForce=function(e,f){this.wheelForces[f]=e},n.prototype.applyWheelForce=function(e,f){var n=this.wheelAxes[f],o=this.wheelBodies[f],d=o.torque;n.scale(e,u),o.vectorToWorldFrame(u,u),d.vadd(u,d)},n.prototype.addToWorld=function(e){for(var f=this.constraints,n=this.wheelBodies.concat([this.chassisBody]),o=0;o<n.length;o++)e.add(n[o]);for(var o=0;o<f.length;o++)e.addConstraint(f[o]);e.addEventListener("preStep",this._update.bind(this))},n.prototype._update=function(){for(var e=this.wheelForces,f=0;f<e.length;f++)this.applyWheelForce(e[f],f)},n.prototype.removeFromWorld=function(e){for(var f=this.constraints,n=this.wheelBodies.concat([this.chassisBody]),o=0;o<n.length;o++)e.remove(n[o]);for(var o=0;o<f.length;o++)e.removeConstraint(f[o])};var p=new t;n.prototype.getWheelSpeed=function(e){var f=this.wheelAxes[e],n=this.wheelBodies[e],o=n.angularVelocity;return this.chassisBody.vectorToWorldFrame(f,p),o.dot(p)}},{"../constraints/HingeConstraint":15,"../math/Vec3":30,"../shapes/Box":37,"../shapes/Sphere":44,"./Body":31}],34:[function(e,f){function n(){this.particles=[],this.density=1,this.smoothingRadius=1,this.speedOfSound=1,this.viscosity=.01,this.eps=1e-6,this.pressures=[],this.densities=[],this.neighbors=[]}f.exports=n;{var o=(e("../shapes/Shape"),e("../math/Vec3"));e("../math/Quaternion"),e("../shapes/Particle"),e("../objects/Body"),e("../material/Material")}n.prototype.add=function(e){this.particles.push(e),this.neighbors.length<this.particles.length&&this.neighbors.push([])},n.prototype.remove=function(e){var f=this.particles.indexOf(e);-1!==f&&(this.particles.splice(f,1),this.neighbors.length>this.particles.length&&this.neighbors.pop())};var d=new o;n.prototype.getNeighbors=function(e,f){for(var n=this.particles.length,o=e.id,i=this.smoothingRadius*this.smoothingRadius,t=d,l=0;l!==n;l++){var u=this.particles[l];u.position.vsub(e.position,t),o!==u.id&&t.norm2()<i&&f.push(u)}};var i=new o,t=new o,l=new o,u=new o,p=new o,s=new o;n.prototype.update=function(){for(var e=this.particles.length,f=i,n=this.speedOfSound,o=this.eps,d=0;d!==e;d++){var y=this.particles[d],c=this.neighbors[d];c.length=0,this.getNeighbors(y,c),c.push(this.particles[d]);for(var a=c.length,r=0,w=0;w!==a;w++){y.position.vsub(c[w].position,f);var b=f.norm(),m=this.w(b);r+=c[w].mass*m}this.densities[d]=r,this.pressures[d]=n*n*(this.densities[d]-this.density)}for(var N=t,g=l,x=u,j=p,v=s,d=0;d!==e;d++){var A=this.particles[d];N.set(0,0,0),g.set(0,0,0);for(var C,O,c=this.neighbors[d],a=c.length,w=0;w!==a;w++){var h=c[w];A.position.vsub(h.position,j);var k=j.norm();C=-h.mass*(this.pressures[d]/(this.densities[d]*this.densities[d]+o)+this.pressures[w]/(this.densities[w]*this.densities[w]+o)),this.gradw(j,x),x.mult(C,x),N.vadd(x,N),h.velocity.vsub(A.velocity,v),v.mult(1/(1e-4+this.densities[d]*this.densities[w])*this.viscosity*h.mass,v),O=this.nablaw(k),v.mult(O,v),g.vadd(v,g)}g.mult(A.mass,g),N.mult(A.mass,N),A.force.vadd(g,A.force),A.force.vadd(N,A.force)}},n.prototype.w=function(e){var f=this.smoothingRadius;return 315/(64*Math.PI*Math.pow(f,9))*Math.pow(f*f-e*e,3)},n.prototype.gradw=function(e,f){var n=e.norm(),o=this.smoothingRadius;e.mult(945/(32*Math.PI*Math.pow(o,9))*Math.pow(o*o-n*n,2),f)},n.prototype.nablaw=function(e){var f=this.smoothingRadius,n=945/(32*Math.PI*Math.pow(f,9))*(f*f-e*e)*(7*e*e-3*f*f);return n}},{"../material/Material":25,"../math/Quaternion":28,"../math/Vec3":30,"../objects/Body":31,"../shapes/Particle":41,"../shapes/Shape":43}],35:[function(e,f){function n(e,f,n){n=n||{},this.restLength="number"==typeof n.restLength?n.restLength:1,this.stiffness=n.stiffness||100,this.damping=n.damping||1,this.bodyA=e,this.bodyB=f,this.localAnchorA=new o,this.localAnchorB=new o,n.localAnchorA&&this.localAnchorA.copy(n.localAnchorA),n.localAnchorB&&this.localAnchorB.copy(n.localAnchorB),n.worldAnchorA&&this.setWorldAnchorA(n.worldAnchorA),n.worldAnchorB&&this.setWorldAnchorB(n.worldAnchorB)}var o=e("../math/Vec3");f.exports=n,n.prototype.setWorldAnchorA=function(e){this.bodyA.pointToLocalFrame(e,this.localAnchorA)},n.prototype.setWorldAnchorB=function(e){this.bodyB.pointToLocalFrame(e,this.localAnchorB)},n.prototype.getWorldAnchorA=function(e){this.bodyA.pointToWorldFrame(this.localAnchorA,e)},n.prototype.getWorldAnchorB=function(e){this.bodyB.pointToWorldFrame(this.localAnchorB,e)};var d=new o,i=new o,t=new o,l=new o,u=new o,p=new o,s=new o,y=new o,c=new o,a=new o,r=new o;n.prototype.applyForce=function(){var e=this.stiffness,f=this.damping,n=this.restLength,o=this.bodyA,w=this.bodyB,b=d,m=i,N=t,g=l,x=r,j=u,v=p,A=s,C=y,O=c,h=a;this.getWorldAnchorA(j),this.getWorldAnchorB(v),j.vsub(o.position,A),v.vsub(w.position,C),v.vsub(j,b);var k=b.norm();m.copy(b),m.normalize(),w.velocity.vsub(o.velocity,N),w.angularVelocity.cross(C,x),N.vadd(x,N),o.angularVelocity.cross(A,x),N.vsub(x,N),m.mult(-e*(k-n)-f*N.dot(m),g),o.force.vsub(g,o.force),w.force.vadd(g,w.force),A.cross(g,O),C.cross(g,h),o.torque.vsub(O,o.torque),w.torque.vadd(h,w.torque)}},{"../math/Vec3":30}],36:[function(e,f){function n(e){e=t.defaults(e,{chassisConnectionPointLocal:new o,chassisConnectionPointWorld:new o,directionLocal:new o,directionWorld:new o,axleLocal:new o,axleWorld:new o,suspensionRestLength:1,suspensionMaxLength:2,radius:1,suspensionStiffness:100,dampingCompression:10,dampingRelaxation:10,frictionSlip:1e4,steering:0,rotation:0,deltaRotation:0,rollInfluence:.01,maxSuspensionForce:Number.MAX_VALUE,isFrontWheel:!0,clippedInvContactDotSuspension:1,suspensionRelativeVelocity:0,suspensionForce:0,skidInfo:0,suspensionLength:0,maxSuspensionTravel:1,useCustomSlidingRotationalSpeed:!1,customSlidingRotationalSpeed:-.1}),this.maxSuspensionTravel=e.maxSuspensionTravel,this.customSlidingRotationalSpeed=e.customSlidingRotationalSpeed,this.useCustomSlidingRotationalSpeed=e.useCustomSlidingRotationalSpeed,this.sliding=!1,this.chassisConnectionPointLocal=e.chassisConnectionPointLocal.clone(),this.chassisConnectionPointWorld=e.chassisConnectionPointWorld.clone(),this.directionLocal=e.directionLocal.clone(),this.directionWorld=e.directionWorld.clone(),this.axleLocal=e.axleLocal.clone(),this.axleWorld=e.axleWorld.clone(),this.suspensionRestLength=e.suspensionRestLength,this.suspensionMaxLength=e.suspensionMaxLength,this.radius=e.radius,this.suspensionStiffness=e.suspensionStiffness,this.dampingCompression=e.dampingCompression,this.dampingRelaxation=e.dampingRelaxation,this.frictionSlip=e.frictionSlip,this.steering=0,this.rotation=0,this.deltaRotation=0,this.rollInfluence=e.rollInfluence,this.maxSuspensionForce=e.maxSuspensionForce,this.engineForce=0,this.brake=0,this.isFrontWheel=e.isFrontWheel,this.clippedInvContactDotSuspension=1,this.suspensionRelativeVelocity=0,this.suspensionForce=0,this.skidInfo=0,this.suspensionLength=0,this.sideImpulse=0,this.forwardImpulse=0,this.raycastResult=new i,this.worldTransform=new d,this.isInContact=!1}var o=e("../math/Vec3"),d=e("../math/Transform"),i=e("../collision/RaycastResult"),t=e("../utils/Utils");f.exports=n;var l=new o,u=new o,l=new o;n.prototype.updateWheel=function(e){var f=this.raycastResult;if(this.isInContact){var n=f.hitNormalWorld.dot(f.directionWorld);f.hitPointWorld.vsub(e.position,u),e.getVelocityAtWorldPoint(u,l);var o=f.hitNormalWorld.dot(l);if(n>=-.1)this.suspensionRelativeVelocity=0,this.clippedInvContactDotSuspension=10;else{var d=-1/n;this.suspensionRelativeVelocity=o*d,this.clippedInvContactDotSuspension=d}}else f.suspensionLength=this.suspensionRestLength,this.suspensionRelativeVelocity=0,f.directionWorld.scale(-1,f.hitNormalWorld),this.clippedInvContactDotSuspension=1}},{"../collision/RaycastResult":10,"../math/Transform":29,"../math/Vec3":30,"../utils/Utils":53}],37:[function(e,f){function n(e){o.call(this),this.type=o.types.BOX,this.halfExtents=e,this.convexPolyhedronRepresentation=null,this.updateConvexPolyhedronRepresentation(),this.updateBoundingSphereRadius()}f.exports=n;var o=e("./Shape"),d=e("../math/Vec3"),i=e("./ConvexPolyhedron");n.prototype=new o,n.prototype.constructor=n,n.prototype.updateConvexPolyhedronRepresentation=function(){var e=this.halfExtents.x,f=this.halfExtents.y,n=this.halfExtents.z,o=d,t=[new o(-e,-f,-n),new o(e,-f,-n),new o(e,f,-n),new o(-e,f,-n),new o(-e,-f,n),new o(e,-f,n),new o(e,f,n),new o(-e,f,n)],l=[[3,2,1,0],[4,5,6,7],[5,4,0,1],[2,3,7,6],[0,4,7,3],[1,2,6,5]],u=([new o(0,0,1),new o(0,1,0),new o(1,0,0)],new i(t,l));this.convexPolyhedronRepresentation=u,u.material=this.material},n.prototype.calculateLocalInertia=function(e,f){return f=f||new d,n.calculateInertia(this.halfExtents,e,f),f},n.calculateInertia=function(e,f,n){var o=e;n.x=1/12*f*(2*o.y*2*o.y+2*o.z*2*o.z),n.y=1/12*f*(2*o.x*2*o.x+2*o.z*2*o.z),n.z=1/12*f*(2*o.y*2*o.y+2*o.x*2*o.x)},n.prototype.getSideNormals=function(e,f){var n=e,o=this.halfExtents;if(n[0].set(o.x,0,0),n[1].set(0,o.y,0),n[2].set(0,0,o.z),n[3].set(-o.x,0,0),n[4].set(0,-o.y,0),n[5].set(0,0,-o.z),void 0!==f)for(var d=0;d!==n.length;d++)f.vmult(n[d],n[d]);return n},n.prototype.volume=function(){return 8*this.halfExtents.x*this.halfExtents.y*this.halfExtents.z},n.prototype.updateBoundingSphereRadius=function(){this.boundingSphereRadius=this.halfExtents.norm()};{var t=new d;new d}n.prototype.forEachWorldCorner=function(e,f,n){for(var o=this.halfExtents,d=[[o.x,o.y,o.z],[-o.x,o.y,o.z],[-o.x,-o.y,o.z],[-o.x,-o.y,-o.z],[o.x,-o.y,-o.z],[o.x,o.y,-o.z],[-o.x,o.y,-o.z],[o.x,-o.y,o.z]],i=0;i<d.length;i++)t.set(d[i][0],d[i][1],d[i][2]),f.vmult(t,t),e.vadd(t,t),n(t.x,t.y,t.z)};var l=[new d,new d,new d,new d,new d,new d,new d,new d];n.prototype.calculateWorldAABB=function(e,f,n,o){var d=this.halfExtents;l[0].set(d.x,d.y,d.z),l[1].set(-d.x,d.y,d.z),l[2].set(-d.x,-d.y,d.z),l[3].set(-d.x,-d.y,-d.z),l[4].set(d.x,-d.y,-d.z),l[5].set(d.x,d.y,-d.z),l[6].set(-d.x,d.y,-d.z),l[7].set(d.x,-d.y,d.z);var i=l[0];f.vmult(i,i),e.vadd(i,i),o.copy(i),n.copy(i);for(var t=1;8>t;t++){var i=l[t];f.vmult(i,i),e.vadd(i,i);var u=i.x,p=i.y,s=i.z;u>o.x&&(o.x=u),p>o.y&&(o.y=p),s>o.z&&(o.z=s),u<n.x&&(n.x=u),p<n.y&&(n.y=p),s<n.z&&(n.z=s)}}},{"../math/Vec3":30,"./ConvexPolyhedron":38,"./Shape":43}],38:[function(e,f){function n(e,f,n){o.call(this),this.type=o.types.CONVEXPOLYHEDRON,this.vertices=e||[],this.worldVertices=[],this.worldVerticesNeedsUpdate=!0,this.faces=f||[],this.faceNormals=[],this.computeNormals(),this.worldFaceNormalsNeedsUpdate=!0,this.worldFaceNormals=[],this.uniqueEdges=[],this.uniqueAxes=n?n.slice():null,this.computeEdges(),this.updateBoundingSphereRadius()}f.exports=n;var o=e("./Shape"),d=e("../math/Vec3"),i=(e("../math/Quaternion"),e("../math/Transform"));n.prototype=new o,n.prototype.constructor=n;var t=new d;n.prototype.computeEdges=function(){var e=this.faces,f=this.vertices,n=(f.length,this.uniqueEdges);n.length=0;for(var o=t,d=0;d!==e.length;d++)for(var i=e[d],l=i.length,u=0;u!==l;u++){var p=(u+1)%l;f[i[u]].vsub(f[i[p]],o),o.normalize();for(var s=!1,y=0;y!==n.length;y++)if(n[y].almostEquals(o)||n[y].almostEquals(o)){s=!0;break}s||n.push(o.clone())}},n.prototype.computeNormals=function(){this.faceNormals.length=this.faces.length;for(var e=0;e<this.faces.length;e++){for(var f=0;f<this.faces[e].length;f++)if(!this.vertices[this.faces[e][f]])throw new Error("Vertex "+this.faces[e][f]+" not found!");var n=this.faceNormals[e]||new d;this.getFaceNormal(e,n),n.negate(n),this.faceNormals[e]=n;var o=this.vertices[this.faces[e][0]];if(n.dot(o)<0){console.error(".faceNormals["+e+"] = Vec3("+n.toString()+") looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.");for(var f=0;f<this.faces[e].length;f++)console.warn(".vertices["+this.faces[e][f]+"] = Vec3("+this.vertices[this.faces[e][f]].toString()+")")}}};var l=new d,u=new d;n.computeNormal=function(e,f,n,o){f.vsub(e,u),n.vsub(f,l),l.cross(u,o),o.isZero()||o.normalize()},n.prototype.getFaceNormal=function(e,f){var o=this.faces[e],d=this.vertices[o[0]],i=this.vertices[o[1]],t=this.vertices[o[2]];return n.computeNormal(d,i,t,f)};var p=new d;n.prototype.clipAgainstHull=function(e,f,n,o,i,t,l,u,s){for(var y=p,c=-1,a=-Number.MAX_VALUE,r=0;r<n.faces.length;r++){y.copy(n.faceNormals[r]),i.vmult(y,y);var w=y.dot(t);w>a&&(a=w,c=r)}for(var b=[],m=n.faces[c],N=m.length,g=0;N>g;g++){var x=n.vertices[m[g]],j=new d;j.copy(x),i.vmult(j,j),o.vadd(j,j),b.push(j)}c>=0&&this.clipFaceAgainstHull(t,e,f,b,l,u,s)};var s=new d,y=new d,c=new d,a=new d,r=new d,w=new d;n.prototype.findSeparatingAxis=function(e,f,n,o,d,i,t,l){var u=s,p=y,b=c,m=a,N=r,g=w,x=Number.MAX_VALUE,j=this,v=0;if(j.uniqueAxes)for(var A=0;A!==j.uniqueAxes.length;A++){n.vmult(j.uniqueAxes[A],u);var C=j.testSepAxis(u,e,f,n,o,d);if(C===!1)return!1;x>C&&(x=C,i.copy(u))}else for(var O=t?t.length:j.faces.length,A=0;O>A;A++){var h=t?t[A]:A;u.copy(j.faceNormals[h]),n.vmult(u,u);var C=j.testSepAxis(u,e,f,n,o,d);if(C===!1)return!1;x>C&&(x=C,i.copy(u))}if(e.uniqueAxes)for(var A=0;A!==e.uniqueAxes.length;A++){d.vmult(e.uniqueAxes[A],p),v++;var C=j.testSepAxis(p,e,f,n,o,d);if(C===!1)return!1;x>C&&(x=C,i.copy(p))}else for(var k=l?l.length:e.faces.length,A=0;k>A;A++){var h=l?l[A]:A;p.copy(e.faceNormals[h]),d.vmult(p,p),v++;var C=j.testSepAxis(p,e,f,n,o,d);if(C===!1)return!1;x>C&&(x=C,i.copy(p))}for(var q=0;q!==j.uniqueEdges.length;q++){n.vmult(j.uniqueEdges[q],m);for(var z=0;z!==e.uniqueEdges.length;z++)if(d.vmult(e.uniqueEdges[z],N),m.cross(N,g),!g.almostZero()){g.normalize();var B=j.testSepAxis(g,e,f,n,o,d);if(B===!1)return!1;x>B&&(x=B,i.copy(g))}}return o.vsub(f,b),b.dot(i)>0&&i.negate(i),!0};var b=[],m=[];n.prototype.testSepAxis=function(e,f,o,d,i,t){var l=this;n.project(l,e,o,d,b),n.project(f,e,i,t,m);var u=b[0],p=b[1],s=m[0],y=m[1];if(y>u||p>s)return!1;var c=u-y,a=s-p,r=a>c?c:a;return r};var N=new d,g=new d;n.prototype.calculateLocalInertia=function(e,f){this.computeLocalAABB(N,g);var n=g.x-N.x,o=g.y-N.y,d=g.z-N.z;f.x=1/12*e*(2*o*2*o+2*d*2*d),f.y=1/12*e*(2*n*2*n+2*d*2*d),f.z=1/12*e*(2*o*2*o+2*n*2*n)},n.prototype.getPlaneConstantOfFace=function(e){var f=this.faces[e],n=this.faceNormals[e],o=this.vertices[f[0]],d=-n.dot(o);return d};var x=new d,j=new d,v=new d,A=new d,C=new d,O=new d,h=new d,k=new d;n.prototype.clipFaceAgainstHull=function(e,f,n,o,d,i,t){for(var l=x,u=j,p=v,s=A,y=C,c=O,a=h,r=k,w=this,b=[],m=o,N=b,g=-1,q=Number.MAX_VALUE,z=0;z<w.faces.length;z++){l.copy(w.faceNormals[z]),n.vmult(l,l);var B=l.dot(e);q>B&&(q=B,g=z)}if(!(0>g)){var D=w.faces[g];D.connectedFaces=[];for(var E=0;E<w.faces.length;E++)for(var F=0;F<w.faces[E].length;F++)-1!==D.indexOf(w.faces[E][F])&&E!==g&&-1===D.connectedFaces.indexOf(E)&&D.connectedFaces.push(E);for(var G=(m.length,D.length),H=0;G>H;H++){var I=w.vertices[D[H]],J=w.vertices[D[(H+1)%G]];I.vsub(J,u),p.copy(u),n.vmult(p,p),f.vadd(p,p),s.copy(this.faceNormals[g]),n.vmult(s,s),f.vadd(s,s),p.cross(s,y),y.negate(y),c.copy(I),n.vmult(c,c),f.vadd(c,c);var K,L=(-c.dot(y),D.connectedFaces[H]);a.copy(this.faceNormals[L]);var M=this.getPlaneConstantOfFace(L);r.copy(a),n.vmult(r,r);var K=M-r.dot(f);for(this.clipFaceAgainstPlane(m,N,r,K);m.length;)m.shift();for(;N.length;)m.push(N.shift())}a.copy(this.faceNormals[g]);var M=this.getPlaneConstantOfFace(g);r.copy(a),n.vmult(r,r);for(var K=M-r.dot(f),E=0;E<m.length;E++){var P=r.dot(m[E])+K;if(d>=P&&(console.log("clamped: depth="+P+" to minDist="+(d+"")),P=d),i>=P){var Q=m[E];if(0>=P){var R={point:Q,normal:r,depth:P};t.push(R)}}}}},n.prototype.clipFaceAgainstPlane=function(e,f,n,o){var i,t,l=e.length;if(2>l)return f;var u=e[e.length-1],p=e[0];i=n.dot(u)+o;for(var s=0;l>s;s++){if(p=e[s],t=n.dot(p)+o,0>i)if(0>t){var y=new d;y.copy(p),f.push(y)}else{var y=new d;u.lerp(p,i/(i-t),y),f.push(y)}else if(0>t){var y=new d;u.lerp(p,i/(i-t),y),f.push(y),f.push(p)}u=p,i=t}return f},n.prototype.computeWorldVertices=function(e,f){for(var n=this.vertices.length;this.worldVertices.length<n;)this.worldVertices.push(new d);for(var o=this.vertices,i=this.worldVertices,t=0;t!==n;t++)f.vmult(o[t],i[t]),e.vadd(i[t],i[t]);this.worldVerticesNeedsUpdate=!1};new d;n.prototype.computeLocalAABB=function(e,f){var n=this.vertices.length,o=this.vertices;e.set(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),f.set(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);for(var d=0;n>d;d++){var i=o[d];i.x<e.x?e.x=i.x:i.x>f.x&&(f.x=i.x),i.y<e.y?e.y=i.y:i.y>f.y&&(f.y=i.y),i.z<e.z?e.z=i.z:i.z>f.z&&(f.z=i.z)}},n.prototype.computeWorldFaceNormals=function(e){for(var f=this.faceNormals.length;this.worldFaceNormals.length<f;)this.worldFaceNormals.push(new d);for(var n=this.faceNormals,o=this.worldFaceNormals,i=0;i!==f;i++)e.vmult(n[i],o[i]);this.worldFaceNormalsNeedsUpdate=!1},n.prototype.updateBoundingSphereRadius=function(){for(var e=0,f=this.vertices,n=0,o=f.length;n!==o;n++){var d=f[n].norm2();d>e&&(e=d)}this.boundingSphereRadius=Math.sqrt(e)};var q=new d;n.prototype.calculateWorldAABB=function(e,f,n,o){for(var d,i,t,l,u,p,s=this.vertices.length,y=this.vertices,c=0;s>c;c++){q.copy(y[c]),f.vmult(q,q),e.vadd(q,q);var a=q;a.x<d||void 0===d?d=a.x:(a.x>l||void 0===l)&&(l=a.x),a.y<i||void 0===i?i=a.y:(a.y>u||void 0===u)&&(u=a.y),a.z<t||void 0===t?t=a.z:(a.z>p||void 0===p)&&(p=a.z)}n.set(d,i,t),o.set(l,u,p)},n.prototype.volume=function(){return 4*Math.PI*this.boundingSphereRadius/3},n.prototype.getAveragePointLocal=function(e){e=e||new d;for(var f=this.vertices.length,n=this.vertices,o=0;f>o;o++)e.vadd(n[o],e);return e.mult(1/f,e),e},n.prototype.transformAllPoints=function(e,f){var n=this.vertices.length,o=this.vertices;if(f){for(var d=0;n>d;d++){var i=o[d];f.vmult(i,i)}for(var d=0;d<this.faceNormals.length;d++){var i=this.faceNormals[d];f.vmult(i,i)}}if(e)for(var d=0;n>d;d++){var i=o[d];i.vadd(e,i)}};var z=new d,B=new d,D=new d;n.prototype.pointIsInside=function(e){var f=this.vertices.length,n=this.vertices,o=this.faces,d=this.faceNormals,i=null,t=this.faces.length,l=z;this.getAveragePointLocal(l);for(var u=0;t>u;u++){var f=(this.faces[u].length,d[u]),p=n[o[u][0]],s=B;e.vsub(p,s);var y=f.dot(s),c=D;l.vsub(p,c);var a=f.dot(c);if(0>y&&a>0||y>0&&0>a)return!1}return i?1:-1};var E=(new d,new d),F=new d;n.project=function(e,f,n,o,d){var t=e.vertices.length,l=E,u=0,p=0,s=F,y=e.vertices;s.setZero(),i.vectorToLocalFrame(n,o,f,l),i.pointToLocalFrame(n,o,s,s);var c=s.dot(l);p=u=y[0].dot(l);for(var a=1;t>a;a++){var r=y[a].dot(l);r>u&&(u=r),p>r&&(p=r)}if(p-=c,u-=c,p>u){var w=p;p=u,u=w}d[0]=u,d[1]=p}},{"../math/Quaternion":28,"../math/Transform":29,"../math/Vec3":30,"./Shape":43}],39:[function(e,f){function n(e,f,n,t){var l=t,u=[],p=[],s=[],y=[],c=[],a=Math.cos,r=Math.sin;u.push(new d(f*a(0),f*r(0),.5*-n)),y.push(0),u.push(new d(e*a(0),e*r(0),.5*n)),c.push(1);for(var w=0;l>w;w++){var b=2*Math.PI/l*(w+1),m=2*Math.PI/l*(w+.5);l-1>w?(u.push(new d(f*a(b),f*r(b),.5*-n)),y.push(2*w+2),u.push(new d(e*a(b),e*r(b),.5*n)),c.push(2*w+3),s.push([2*w+2,2*w+3,2*w+1,2*w])):s.push([0,1,2*w+1,2*w]),(l%2===1||l/2>w)&&p.push(new d(a(m),r(m),0))}s.push(c),p.push(new d(0,0,1));for(var N=[],w=0;w<y.length;w++)N.push(y[y.length-w-1]);s.push(N),this.type=o.types.CONVEXPOLYHEDRON,i.call(this,u,s,p)}f.exports=n;var o=e("./Shape"),d=e("../math/Vec3"),i=(e("../math/Quaternion"),e("./ConvexPolyhedron"));n.prototype=new i},{"../math/Quaternion":28,"../math/Vec3":30,"./ConvexPolyhedron":38,"./Shape":43}],40:[function(e,f){function n(e,f){f=t.defaults(f,{maxValue:null,minValue:null,elementSize:1}),this.data=e,this.maxValue=f.maxValue,this.minValue=f.minValue,this.elementSize=f.elementSize,null===f.minValue&&this.updateMinValue(),null===f.maxValue&&this.updateMaxValue(),this.cacheEnabled=!0,o.call(this),this.pillarConvex=new d,this.pillarOffset=new i,this.type=o.types.HEIGHTFIELD,this.updateBoundingSphereRadius(),this._cachedPillars={}}var o=e("./Shape"),d=e("./ConvexPolyhedron"),i=e("../math/Vec3"),t=e("../utils/Utils");f.exports=n,n.prototype=new o,n.prototype.update=function(){this._cachedPillars={}},n.prototype.updateMinValue=function(){for(var e=this.data,f=e[0][0],n=0;n!==e.length;n++)for(var o=0;o!==e[n].length;o++){var d=e[n][o];f>d&&(f=d)}this.minValue=f},n.prototype.updateMaxValue=function(){for(var e=this.data,f=e[0][0],n=0;n!==e.length;n++)for(var o=0;o!==e[n].length;o++){var d=e[n][o];d>f&&(f=d)}this.maxValue=f},n.prototype.setHeightValueAtIndex=function(e,f,n){var o=this.data;o[e][f]=n,this.clearCachedConvexTrianglePillar(e,f,!1),e>0&&(this.clearCachedConvexTrianglePillar(e-1,f,!0),this.clearCachedConvexTrianglePillar(e-1,f,!1)),f>0&&(this.clearCachedConvexTrianglePillar(e,f-1,!0),this.clearCachedConvexTrianglePillar(e,f-1,!1)),f>0&&e>0&&this.clearCachedConvexTrianglePillar(e-1,f-1,!0)},n.prototype.getRectMinMax=function(e,f,n,o,d){d=d||[];for(var i=this.data,t=this.minValue,l=e;n>=l;l++)for(var u=f;o>=u;u++){var p=i[l][u];p>t&&(t=p)}d[0]=this.minValue,d[1]=t},n.prototype.getIndexOfPosition=function(e,f,n,o){var d=this.elementSize,i=this.data,t=Math.floor(e/d),l=Math.floor(f/d);return n[0]=t,n[1]=l,o&&(0>t&&(t=0),0>l&&(l=0),t>=i.length-1&&(t=i.length-1),l>=i[0].length-1&&(l=i[0].length-1)),0>t||0>l||t>=i.length-1||l>=i[0].length-1?!1:!0},n.prototype.getHeightAt=function(e,f,n){var o=[];this.getIndexOfPosition(e,f,o,n);var d=[];return this.getRectMinMax(o[0],o[1]+1,o[0],o[1]+1,d),(d[0]+d[1])/2},n.prototype.getCacheConvexTrianglePillarKey=function(e,f,n){return e+"_"+f+"_"+(n?1:0)},n.prototype.getCachedConvexTrianglePillar=function(e,f,n){return this._cachedPillars[this.getCacheConvexTrianglePillarKey(e,f,n)]},n.prototype.setCachedConvexTrianglePillar=function(e,f,n,o,d){this._cachedPillars[this.getCacheConvexTrianglePillarKey(e,f,n)]={convex:o,offset:d}},n.prototype.clearCachedConvexTrianglePillar=function(e,f,n){delete this._cachedPillars[this.getCacheConvexTrianglePillarKey(e,f,n)]},n.prototype.getConvexTrianglePillar=function(e,f,n){var o=this.pillarConvex,t=this.pillarOffset;if(this.cacheEnabled){var l=this.getCachedConvexTrianglePillar(e,f,n);if(l)return this.pillarConvex=l.convex,void(this.pillarOffset=l.offset);o=new d,t=new i,this.pillarConvex=o,this.pillarOffset=t}var l=this.data,u=this.elementSize,p=o.faces;o.vertices.length=6;for(var s=0;6>s;s++)o.vertices[s]||(o.vertices[s]=new i);p.length=5;for(var s=0;5>s;s++)p[s]||(p[s]=[]);var y=o.vertices,c=(Math.min(l[e][f],l[e+1][f],l[e][f+1],l[e+1][f+1])-this.minValue)/2+this.minValue;n?(t.set((e+.75)*u,(f+.75)*u,c),y[0].set(.25*u,.25*u,l[e+1][f+1]-c),y[1].set(-.75*u,.25*u,l[e][f+1]-c),y[2].set(.25*u,-.75*u,l[e+1][f]-c),y[3].set(.25*u,.25*u,-c-1),y[4].set(-.75*u,.25*u,-c-1),y[5].set(.25*u,-.75*u,-c-1),p[0][0]=0,p[0][1]=1,p[0][2]=2,p[1][0]=5,p[1][1]=4,p[1][2]=3,p[2][0]=2,p[2][1]=5,p[2][2]=3,p[2][3]=0,p[3][0]=3,p[3][1]=4,p[3][2]=1,p[3][3]=0,p[4][0]=1,p[4][1]=4,p[4][2]=5,p[4][3]=2):(t.set((e+.25)*u,(f+.25)*u,c),y[0].set(-.25*u,-.25*u,l[e][f]-c),y[1].set(.75*u,-.25*u,l[e+1][f]-c),y[2].set(-.25*u,.75*u,l[e][f+1]-c),y[3].set(-.25*u,-.25*u,-c-1),y[4].set(.75*u,-.25*u,-c-1),y[5].set(-.25*u,.75*u,-c-1),p[0][0]=0,p[0][1]=1,p[0][2]=2,p[1][0]=5,p[1][1]=4,p[1][2]=3,p[2][0]=0,p[2][1]=2,p[2][2]=5,p[2][3]=3,p[3][0]=1,p[3][1]=0,p[3][2]=3,p[3][3]=4,p[4][0]=4,p[4][1]=5,p[4][2]=2,p[4][3]=1),o.computeNormals(),o.computeEdges(),o.updateBoundingSphereRadius(),this.setCachedConvexTrianglePillar(e,f,n,o,t)},n.prototype.calculateLocalInertia=function(e,f){return f=f||new i,f.set(0,0,0),f},n.prototype.volume=function(){return Number.MAX_VALUE},n.prototype.calculateWorldAABB=function(e,f,n,o){n.set(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),o.set(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE)},n.prototype.updateBoundingSphereRadius=function(){var e=this.data,f=this.elementSize;this.boundingSphereRadius=new i(e.length*f,e[0].length*f,Math.max(Math.abs(this.maxValue),Math.abs(this.minValue))).norm()}},{"../math/Vec3":30,"../utils/Utils":53,"./ConvexPolyhedron":38,"./Shape":43}],41:[function(e,f){function n(){o.call(this),this.type=o.types.PARTICLE}f.exports=n;var o=e("./Shape"),d=e("../math/Vec3");n.prototype=new o,n.prototype.constructor=n,n.prototype.calculateLocalInertia=function(e,f){return f=f||new d,f.set(0,0,0),f},n.prototype.volume=function(){return 0},n.prototype.updateBoundingSphereRadius=function(){this.boundingSphereRadius=0},n.prototype.calculateWorldAABB=function(e,f,n,o){n.copy(e),o.copy(e)}},{"../math/Vec3":30,"./Shape":43}],42:[function(e,f){function n(){o.call(this),this.type=o.types.PLANE,this.worldNormal=new d,this.worldNormalNeedsUpdate=!0,this.boundingSphereRadius=Number.MAX_VALUE}f.exports=n;var o=e("./Shape"),d=e("../math/Vec3");n.prototype=new o,n.prototype.constructor=n,n.prototype.computeWorldNormal=function(e){var f=this.worldNormal;f.set(0,0,1),e.vmult(f,f),this.worldNormalNeedsUpdate=!1},n.prototype.calculateLocalInertia=function(e,f){return f=f||new d},n.prototype.volume=function(){return Number.MAX_VALUE};var i=new d;n.prototype.calculateWorldAABB=function(e,f,n,o){i.set(0,0,1),f.vmult(i,i);var d=Number.MAX_VALUE;n.set(-d,-d,-d),o.set(d,d,d),1===i.x&&(o.x=e.x),1===i.y&&(o.y=e.y),1===i.z&&(o.z=e.z),-1===i.x&&(n.x=e.x),-1===i.y&&(n.y=e.y),-1===i.z&&(n.z=e.z)},n.prototype.updateBoundingSphereRadius=function(){this.boundingSphereRadius=Number.MAX_VALUE}},{"../math/Vec3":30,"./Shape":43}],43:[function(e,f){function n(){this.id=n.idCounter++,this.type=0,this.boundingSphereRadius=0,this.collisionResponse=!0,this.material=null}f.exports=n;{var n=e("./Shape");e("../math/Vec3"),e("../math/Quaternion"),e("../material/Material")}n.prototype.constructor=n,n.prototype.updateBoundingSphereRadius=function(){throw"computeBoundingSphereRadius() not implemented for shape type "+this.type},n.prototype.volume=function(){throw"volume() not implemented for shape type "+this.type},n.prototype.calculateLocalInertia=function(){throw"calculateLocalInertia() not implemented for shape type "+this.type},n.idCounter=0,n.types={SPHERE:1,PLANE:2,BOX:4,COMPOUND:8,CONVEXPOLYHEDRON:16,HEIGHTFIELD:32,PARTICLE:64,CYLINDER:128,TRIMESH:256}},{"../material/Material":25,"../math/Quaternion":28,"../math/Vec3":30,"./Shape":43}],44:[function(e,f){function n(e){if(o.call(this),this.radius=void 0!==e?Number(e):1,this.type=o.types.SPHERE,this.radius<0)throw new Error("The sphere radius cannot be negative.");this.updateBoundingSphereRadius()}f.exports=n;var o=e("./Shape"),d=e("../math/Vec3");n.prototype=new o,n.prototype.constructor=n,n.prototype.calculateLocalInertia=function(e,f){f=f||new d;var n=2*e*this.radius*this.radius/5;return f.x=n,f.y=n,f.z=n,f},n.prototype.volume=function(){return 4*Math.PI*this.radius/3},n.prototype.updateBoundingSphereRadius=function(){this.boundingSphereRadius=this.radius},n.prototype.calculateWorldAABB=function(e,f,n,o){for(var d=this.radius,i=["x","y","z"],t=0;t<i.length;t++){var l=i[t];n[l]=e[l]-d,o[l]=e[l]+d}}},{"../math/Vec3":30,"./Shape":43}],45:[function(e,f){function n(e,f){o.call(this),this.type=o.types.TRIMESH,this.vertices=new Float32Array(e),this.indices=new Int16Array(f),this.normals=new Float32Array(f.length),this.aabb=new t,this.edges=null,this.scale=new d(1,1,1),this.tree=new l,this.updateEdges(),this.updateNormals(),this.updateAABB(),this.updateBoundingSphereRadius(),this.updateTree()}f.exports=n;var o=e("./Shape"),d=e("../math/Vec3"),i=(e("../math/Quaternion"),e("../math/Transform")),t=e("../collision/AABB"),l=e("../utils/Octree");n.prototype=new o,n.prototype.constructor=n;var u=new d;n.prototype.updateTree=function(){var e=this.tree;e.reset(),e.aabb.copy(this.aabb);var f=this.scale;e.aabb.lowerBound.x*=1/f.x,e.aabb.lowerBound.y*=1/f.y,e.aabb.lowerBound.z*=1/f.z,e.aabb.upperBound.x*=1/f.x,e.aabb.upperBound.y*=1/f.y,e.aabb.upperBound.z*=1/f.z;for(var n=new t,o=new d,i=new d,l=new d,u=[o,i,l],p=0;p<this.indices.length/3;p++){var s=3*p;this._getUnscaledVertex(this.indices[s],o),this._getUnscaledVertex(this.indices[s+1],i),this._getUnscaledVertex(this.indices[s+2],l),n.setFromPoints(u),e.insert(n,p)}e.removeEmptyNodes()};var p=new t;n.prototype.getTrianglesInAABB=function(e,f){p.copy(e);var n=this.scale,o=n.x,d=n.y,i=n.z,t=p.lowerBound,l=p.upperBound;return t.x/=o,t.y/=d,t.z/=i,l.x/=o,l.y/=d,l.z/=i,this.tree.aabbQuery(p,f)},n.prototype.setScale=function(e){var f=this.scale.x===this.scale.y===this.scale.z,n=e.x===e.y===e.z;f&&n||this.updateNormals(),this.scale.copy(e),this.updateAABB(),this.updateBoundingSphereRadius()},n.prototype.updateNormals=function(){for(var e=u,f=this.normals,o=0;o<this.indices.length/3;o++){var d=3*o,i=this.indices[d],t=this.indices[d+1],l=this.indices[d+2];this.getVertex(i,r),this.getVertex(t,w),this.getVertex(l,b),n.computeNormal(w,r,b,e),f[d]=e.x,f[d+1]=e.y,f[d+2]=e.z}},n.prototype.updateEdges=function(){for(var e={},f=function(){var f=i>d?d+"_"+i:i+"_"+d;e[f]=!0},n=0;n<this.indices.length/3;n++){var o=3*n,d=this.indices[o],i=this.indices[o+1],t=this.indices[o+2];f(d,i),f(i,t),f(t,d)}var l=Object.keys(e);this.edges=new Int16Array(2*l.length);for(var n=0;n<l.length;n++){var u=l[n].split("_");this.edges[2*n]=parseInt(u[0],10),this.edges[2*n+1]=parseInt(u[1],10)}},n.prototype.getEdgeVertex=function(e,f,n){var o=this.edges[2*e+(f?1:0)];this.getVertex(o,n)};var s=new d,y=new d;n.prototype.getEdgeVector=function(e,f){var n=s,o=y;this.getEdgeVertex(e,0,n),this.getEdgeVertex(e,1,o),o.vsub(n,f)};var c=new d,a=new d;n.computeNormal=function(e,f,n,o){f.vsub(e,a),n.vsub(f,c),c.cross(a,o),o.isZero()||o.normalize()};var r=new d,w=new d,b=new d;n.prototype.getVertex=function(e,f){var n=this.scale;return this._getUnscaledVertex(e,f),f.x*=n.x,f.y*=n.y,f.z*=n.z,f},n.prototype._getUnscaledVertex=function(e,f){var n=3*e,o=this.vertices;return f.set(o[n],o[n+1],o[n+2])},n.prototype.getWorldVertex=function(e,f,n,o){return this.getVertex(e,o),i.pointToWorldFrame(f,n,o,o),o},n.prototype.getTriangleVertices=function(e,f,n,o){var d=3*e;this.getVertex(this.indices[d],f),this.getVertex(this.indices[d+1],n),this.getVertex(this.indices[d+2],o)},n.prototype.getNormal=function(e,f){var n=3*e;return f.set(this.normals[n],this.normals[n+1],this.normals[n+2])};var m=new t;n.prototype.calculateLocalInertia=function(e,f){this.computeLocalAABB(m);var n=m.upperBound.x-m.lowerBound.x,o=m.upperBound.y-m.lowerBound.y,d=m.upperBound.z-m.lowerBound.z;return f.set(1/12*e*(2*o*2*o+2*d*2*d),1/12*e*(2*n*2*n+2*d*2*d),1/12*e*(2*o*2*o+2*n*2*n))};var N=new d;n.prototype.computeLocalAABB=function(e){var f=e.lowerBound,n=e.upperBound,o=this.vertices.length,d=(this.vertices,N);this.getVertex(0,d),f.copy(d),n.copy(d);for(var i=0;i!==o;i++)this.getVertex(i,d),d.x<f.x?f.x=d.x:d.x>n.x&&(n.x=d.x),d.y<f.y?f.y=d.y:d.y>n.y&&(n.y=d.y),d.z<f.z?f.z=d.z:d.z>n.z&&(n.z=d.z)},n.prototype.updateAABB=function(){this.computeLocalAABB(this.aabb)},n.prototype.updateBoundingSphereRadius=function(){for(var e=0,f=this.vertices,n=new d,o=0,i=f.length/3;o!==i;o++){this.getVertex(o,n);var t=n.norm2();t>e&&(e=t)}this.boundingSphereRadius=Math.sqrt(e)};var g=(new d,new i),x=new t;n.prototype.calculateWorldAABB=function(e,f,n,o){var d=g,i=x;d.position=e,d.quaternion=f,this.aabb.toWorldFrame(d,i),n.copy(i.lowerBound),o.copy(i.upperBound)},n.prototype.volume=function(){return 4*Math.PI*this.boundingSphereRadius/3},n.createTorus=function(e,f,o,d,i){e=e||1,f=f||.5,o=o||8,d=d||6,i=i||2*Math.PI;for(var t=[],l=[],u=0;o>=u;u++)for(var p=0;d>=p;p++){var s=p/d*i,y=u/o*Math.PI*2,c=(e+f*Math.cos(y))*Math.cos(s),a=(e+f*Math.cos(y))*Math.sin(s),r=f*Math.sin(y);t.push(c,a,r)}for(var u=1;o>=u;u++)for(var p=1;d>=p;p++){var w=(d+1)*u+p-1,b=(d+1)*(u-1)+p-1,m=(d+1)*(u-1)+p,N=(d+1)*u+p;l.push(w,b,N),l.push(b,m,N)}return new n(t,l)}},{"../collision/AABB":3,"../math/Quaternion":28,"../math/Transform":29,"../math/Vec3":30,"../utils/Octree":50,"./Shape":43}],46:[function(e,f){function n(){o.call(this),this.iterations=10,this.tolerance=1e-7}f.exports=n;var o=(e("../math/Vec3"),e("../math/Quaternion"),e("./Solver"));n.prototype=new o;var d=[],i=[],t=[];n.prototype.solve=function(e,f){var n,o,l,u,p,s,y=0,c=this.iterations,a=this.tolerance*this.tolerance,r=this.equations,w=r.length,b=f.bodies,m=b.length,N=e;if(0!==w)for(var g=0;g!==m;g++)b[g].updateSolveMassProperties();var x=i,j=t,v=d;
x.length=w,j.length=w,v.length=w;for(var g=0;g!==w;g++){var A=r[g];v[g]=0,j[g]=A.computeB(N),x[g]=1/A.computeC()}if(0!==w){for(var g=0;g!==m;g++){var C=b[g],O=C.vlambda,h=C.wlambda;O.set(0,0,0),h&&h.set(0,0,0)}for(y=0;y!==c;y++){u=0;for(var k=0;k!==w;k++){var A=r[k];n=j[k],o=x[k],s=v[k],p=A.computeGWlambda(),l=o*(n-p-A.eps*s),s+l<A.minForce?l=A.minForce-s:s+l>A.maxForce&&(l=A.maxForce-s),v[k]+=l,u+=l>0?l:-l,A.addToWlambda(l)}if(a>u*u)break}for(var g=0;g!==m;g++){var C=b[g],q=C.velocity,z=C.angularVelocity;q.vadd(C.vlambda,q),z&&z.vadd(C.wlambda,z)}}return y}},{"../math/Quaternion":28,"../math/Vec3":30,"./Solver":47}],47:[function(e,f){function n(){this.equations=[]}f.exports=n,n.prototype.solve=function(){return 0},n.prototype.addEquation=function(e){e.enabled&&this.equations.push(e)},n.prototype.removeEquation=function(e){var f=this.equations,n=f.indexOf(e);-1!==n&&f.splice(n,1)},n.prototype.removeAllEquations=function(){this.equations.length=0}},{}],48:[function(e,f){function n(e){for(l.call(this),this.iterations=10,this.tolerance=1e-7,this.subsolver=e,this.nodes=[],this.nodePool=[];this.nodePool.length<128;)this.nodePool.push(this.createNode())}function o(e){for(var f=e.length,n=0;n!==f;n++){var o=e[n];if(!(o.visited||o.body.type&c))return o}return!1}function d(e,f,n,d){for(a.push(e),e.visited=!0,f(e,n,d);a.length;)for(var i,t=a.pop();i=o(t.children);)i.visited=!0,f(i,n,d),a.push(i)}function i(e,f,n){f.push(e.body);for(var o=e.eqs.length,d=0;d!==o;d++){var i=e.eqs[d];-1===n.indexOf(i)&&n.push(i)}}function t(e,f){return f.id-e.id}f.exports=n;var l=(e("../math/Vec3"),e("../math/Quaternion"),e("./Solver")),u=e("../objects/Body");n.prototype=new l;var p=[],s=[],y={bodies:[]},c=u.STATIC,a=[];n.prototype.createNode=function(){return{body:null,children:[],eqs:[],visited:!1}},n.prototype.solve=function(e,f){for(var n=p,l=this.nodePool,u=f.bodies,c=this.equations,a=c.length,r=u.length,w=this.subsolver;l.length<r;)l.push(this.createNode());n.length=r;for(var b=0;r>b;b++)n[b]=l[b];for(var b=0;b!==r;b++){var m=n[b];m.body=u[b],m.children.length=0,m.eqs.length=0,m.visited=!1}for(var N=0;N!==a;N++){var g=c[N],b=u.indexOf(g.bi),x=u.indexOf(g.bj),j=n[b],v=n[x];j.children.push(v),j.eqs.push(g),v.children.push(j),v.eqs.push(g)}var A,C=0,O=s;w.tolerance=this.tolerance,w.iterations=this.iterations;for(var h=y;A=o(n);){O.length=0,h.bodies.length=0,d(A,i,h.bodies,O);var k=O.length;O=O.sort(t);for(var b=0;b!==k;b++)w.addEquation(O[b]);{w.solve(e,h)}w.removeAllEquations(),C++}return C}},{"../math/Quaternion":28,"../math/Vec3":30,"../objects/Body":31,"./Solver":47}],49:[function(e,f){var n=function(){};f.exports=n,n.prototype={constructor:n,addEventListener:function(e,f){void 0===this._listeners&&(this._listeners={});var n=this._listeners;return void 0===n[e]&&(n[e]=[]),-1===n[e].indexOf(f)&&n[e].push(f),this},hasEventListener:function(e,f){if(void 0===this._listeners)return!1;var n=this._listeners;return void 0!==n[e]&&-1!==n[e].indexOf(f)?!0:!1},removeEventListener:function(e,f){if(void 0===this._listeners)return this;var n=this._listeners;if(void 0===n[e])return this;var o=n[e].indexOf(f);return-1!==o&&n[e].splice(o,1),this},dispatchEvent:function(e){if(void 0===this._listeners)return this;var f=this._listeners,n=f[e.type];if(void 0!==n){e.target=this;for(var o=0,d=n.length;d>o;o++)n[o].call(this,e)}return this}}},{}],50:[function(e,f){function n(e){e=e||{},this.root=e.root||null,this.aabb=e.aabb?e.aabb.clone():new d,this.data=[],this.children=[]}function o(e,f){f=f||{},f.root=null,f.aabb=e,n.call(this,f),this.maxDepth="undefined"!=typeof f.maxDepth?f.maxDepth:8}var d=e("../collision/AABB"),i=e("../math/Vec3");f.exports=o,o.prototype=new n,n.prototype.reset=function(){this.children.length=this.data.length=0},n.prototype.insert=function(e,f,n){var o=this.data;if(n=n||0,!this.aabb.contains(e))return!1;var d=this.children;if(n<(this.maxDepth||this.root.maxDepth)){var i=!1;d.length||(this.subdivide(),i=!0);for(var t=0;8!==t;t++)if(d[t].insert(e,f,n+1))return!0;i&&(d.length=0)}return o.push(f),!0};var t=new i;n.prototype.subdivide=function(){var e=this.aabb,f=e.lowerBound,o=e.upperBound,l=this.children;l.push(new n({aabb:new d({lowerBound:new i(0,0,0)})}),new n({aabb:new d({lowerBound:new i(1,0,0)})}),new n({aabb:new d({lowerBound:new i(1,1,0)})}),new n({aabb:new d({lowerBound:new i(1,1,1)})}),new n({aabb:new d({lowerBound:new i(0,1,1)})}),new n({aabb:new d({lowerBound:new i(0,0,1)})}),new n({aabb:new d({lowerBound:new i(1,0,1)})}),new n({aabb:new d({lowerBound:new i(0,1,0)})})),o.vsub(f,t),t.scale(.5,t);for(var u=this.root||this,p=0;8!==p;p++){var s=l[p];s.root=u;var y=s.aabb.lowerBound;y.x*=t.x,y.y*=t.y,y.z*=t.z,y.vadd(f,y),y.vadd(t,s.aabb.upperBound)}},n.prototype.aabbQuery=function(e,f){for(var n=(this.data,this.children,[this]);n.length;){var o=n.pop();o.aabb.overlaps(e)&&Array.prototype.push.apply(f,o.data),Array.prototype.push.apply(n,o.children)}return f};var l=new d;n.prototype.rayQuery=function(e,f,n){return e.getAABB(l),l.toLocalFrame(f,l),this.aabbQuery(l,n),n},n.prototype.removeEmptyNodes=function(){for(var e=[this];e.length;){for(var f=e.pop(),n=f.children.length-1;n>=0;n--)f.children[n].data.length||f.children.splice(n,1);Array.prototype.push.apply(e,f.children)}}},{"../collision/AABB":3,"../math/Vec3":30}],51:[function(e,f){function n(){this.objects=[],this.type=Object}f.exports=n,n.prototype.release=function(){for(var e=arguments.length,f=0;f!==e;f++)this.objects.push(arguments[f])},n.prototype.get=function(){return 0===this.objects.length?this.constructObject():this.objects.pop()},n.prototype.constructObject=function(){throw new Error("constructObject() not implemented in this Pool subclass yet!")}},{}],52:[function(e,f){function n(){this.data={keys:[]}}f.exports=n,n.prototype.get=function(e,f){if(e>f){var n=f;f=e,e=n}return this.data[e+"-"+f]},n.prototype.set=function(e,f,n){if(e>f){var o=f;f=e,e=o}var d=e+"-"+f;this.get(e,f)||this.data.keys.push(d),this.data[d]=n},n.prototype.reset=function(){for(var e=this.data,f=e.keys;f.length>0;){var n=f.pop();delete e[n]}}},{}],53:[function(e,f){function n(){}f.exports=n,n.defaults=function(e,f){e=e||{};for(var n in f)n in e||(e[n]=f[n]);return e}},{}],54:[function(e,f){function n(){d.call(this),this.type=o}f.exports=n;var o=e("../math/Vec3"),d=e("./Pool");n.prototype=new d,n.prototype.constructObject=function(){return new o}},{"../math/Vec3":30,"./Pool":51}],55:[function(e,f){function n(e){this.contactPointPool=[],this.frictionEquationPool=[],this.result=[],this.frictionResult=[],this.v3pool=new s,this.world=e,this.currentContactMaterial=null,this.enableFrictionReduction=!1}function o(e,f,n){for(var o=null,d=e.length,i=0;i!==d;i++){var t=e[i],l=M;e[(i+1)%d].vsub(t,l);var u=P;l.cross(f,u);var p=Q;n.vsub(t,p);var s=u.dot(p);if(!(null===o||s>0&&o===!0||0>=s&&o===!1))return!1;null===o&&(o=s>0)}return!0}f.exports=n;var d=e("../collision/AABB"),i=e("../shapes/Shape"),t=e("../collision/Ray"),l=e("../math/Vec3"),u=e("../math/Transform"),p=(e("../shapes/ConvexPolyhedron"),e("../math/Quaternion")),s=(e("../solver/Solver"),e("../utils/Vec3Pool")),y=e("../equations/ContactEquation"),c=e("../equations/FrictionEquation");n.prototype.createContactEquation=function(e,f,n,o,d,i){var t;this.contactPointPool.length?(t=this.contactPointPool.pop(),t.bi=e,t.bj=f):t=new y(e,f),t.enabled=e.collisionResponse&&f.collisionResponse&&n.collisionResponse&&o.collisionResponse;var l=this.currentContactMaterial;t.restitution=l.restitution,t.setSpookParams(l.contactEquationStiffness,l.contactEquationRelaxation,this.world.dt);var u=n.material||e.material,p=o.material||f.material;return u&&p&&u.restitution>=0&&p.restitution>=0&&(t.restitution=u.restitution*p.restitution),t.si=d||n,t.sj=i||o,t},n.prototype.createFrictionEquationsFromContact=function(e,f){var n=e.bi,o=e.bj,d=e.si,i=e.sj,t=this.world,l=this.currentContactMaterial,u=l.friction,p=d.material||n.material,s=i.material||o.material;if(p&&s&&p.friction>=0&&s.friction>=0&&(u=p.friction*s.friction),u>0){var y=u*t.gravity.length(),a=n.invMass+o.invMass;a>0&&(a=1/a);var r=this.frictionEquationPool,w=r.length?r.pop():new c(n,o,y*a),b=r.length?r.pop():new c(n,o,y*a);return w.bi=b.bi=n,w.bj=b.bj=o,w.minForce=b.minForce=-y*a,w.maxForce=b.maxForce=y*a,w.ri.copy(e.ri),w.rj.copy(e.rj),b.ri.copy(e.ri),b.rj.copy(e.rj),e.ni.tangents(w.t,b.t),w.setSpookParams(l.frictionEquationStiffness,l.frictionEquationRelaxation,t.dt),b.setSpookParams(l.frictionEquationStiffness,l.frictionEquationRelaxation,t.dt),w.enabled=b.enabled=e.enabled,f.push(w,b),!0}return!1};var a=new l,r=new l,w=new l;n.prototype.createFrictionFromAverage=function(e){var f=this.result[this.result.length-1];if(this.createFrictionEquationsFromContact(f,this.frictionResult)&&1!==e){var n=this.frictionResult[this.frictionResult.length-2],o=this.frictionResult[this.frictionResult.length-1];a.setZero(),r.setZero(),w.setZero();for(var d=f.bi,i=(f.bj,0);i!==e;i++)f=this.result[this.result.length-1-i],f.bodyA!==d?(a.vadd(f.ni,a),r.vadd(f.ri,r),w.vadd(f.rj,w)):(a.vsub(f.ni,a),r.vadd(f.rj,r),w.vadd(f.ri,w));var t=1/e;r.scale(t,n.ri),w.scale(t,n.rj),o.ri.copy(n.ri),o.rj.copy(n.rj),a.normalize(),a.tangents(n.t,o.t)}};var b=new l,m=new l,N=new p,g=new p;n.prototype.getContacts=function(e,f,n,o,d,i,t){this.contactPointPool=d,this.frictionEquationPool=t,this.result=o,this.frictionResult=i;for(var l=N,u=g,p=b,s=m,y=0,c=e.length;y!==c;y++){var a=e[y],r=f[y],w=null;a.material&&r.material&&(w=n.getContactMaterial(a.material,r.material)||null);for(var x=0;x<a.shapes.length;x++){a.quaternion.mult(a.shapeOrientations[x],l),a.quaternion.vmult(a.shapeOffsets[x],p),p.vadd(a.position,p);for(var j=a.shapes[x],v=0;v<r.shapes.length;v++){r.quaternion.mult(r.shapeOrientations[v],u),r.quaternion.vmult(r.shapeOffsets[v],s),s.vadd(r.position,s);var A=r.shapes[v];if(!(p.distanceTo(s)>j.boundingSphereRadius+A.boundingSphereRadius)){var C=null;j.material&&A.material&&(C=n.getContactMaterial(j.material,A.material)||null),this.currentContactMaterial=C||w||n.defaultContactMaterial;var O=this[j.type|A.type];O&&(j.type<A.type?O.call(this,j,A,p,s,l,u,a,r,j,A):O.call(this,A,j,s,p,u,l,r,a,j,A))}}}}};n.prototype[i.types.BOX|i.types.BOX]=n.prototype.boxBox=function(e,f,n,o,d,i,t,l){e.convexPolyhedronRepresentation.material=e.material,f.convexPolyhedronRepresentation.material=f.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,f.convexPolyhedronRepresentation.collisionResponse=f.collisionResponse,this.convexConvex(e.convexPolyhedronRepresentation,f.convexPolyhedronRepresentation,n,o,d,i,t,l,e,f)},n.prototype[i.types.BOX|i.types.CONVEXPOLYHEDRON]=n.prototype.boxConvex=function(e,f,n,o,d,i,t,l){e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexConvex(e.convexPolyhedronRepresentation,f,n,o,d,i,t,l,e,f)},n.prototype[i.types.BOX|i.types.PARTICLE]=n.prototype.boxParticle=function(e,f,n,o,d,i,t,l){e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexParticle(e.convexPolyhedronRepresentation,f,n,o,d,i,t,l,e,f)},n.prototype[i.types.SPHERE]=n.prototype.sphereSphere=function(e,f,n,o,d,i,t,l){var u=this.createContactEquation(t,l,e,f);o.vsub(n,u.ni),u.ni.normalize(),u.ri.copy(u.ni),u.rj.copy(u.ni),u.ri.mult(e.radius,u.ri),u.rj.mult(-f.radius,u.rj),u.ri.vadd(n,u.ri),u.ri.vsub(t.position,u.ri),u.rj.vadd(o,u.rj),u.rj.vsub(l.position,u.rj),this.result.push(u),this.createFrictionEquationsFromContact(u,this.frictionResult)};var x=new l,j=new l,v=new l;n.prototype[i.types.PLANE|i.types.TRIMESH]=n.prototype.planeTrimesh=function(e,f,n,o,d,i,t,p){var s=new l,y=x;y.set(0,0,1),d.vmult(y,y);for(var c=0;c<f.vertices.length/3;c++){f.getVertex(c,s);var a=new l;a.copy(s),u.pointToWorldFrame(o,i,a,s);var r=j;s.vsub(n,r);var w=y.dot(r);if(0>=w){var b=this.createContactEquation(t,p,e,f);b.ni.copy(y);var m=v;y.scale(r.dot(y),m),s.vsub(m,m),b.ri.copy(m),b.ri.vsub(t.position,b.ri),b.rj.copy(s),b.rj.vsub(p.position,b.rj),this.result.push(b),this.createFrictionEquationsFromContact(b,this.frictionResult)}}};var A=new l,C=new l,O=(new l,new l),h=new l,k=new l,q=new l,z=new l,B=new l,D=new l,E=new l,F=new l,G=new l,H=new l,I=new d,J=[];n.prototype[i.types.SPHERE|i.types.TRIMESH]=n.prototype.sphereTrimesh=function(e,f,n,o,d,i,l,p){var s=k,y=q,c=z,a=B,r=D,w=E,b=I,m=h,N=C,g=J;u.pointToLocalFrame(o,i,n,r);var x=e.radius;b.lowerBound.set(r.x-x,r.y-x,r.z-x),b.upperBound.set(r.x+x,r.y+x,r.z+x),f.getTrianglesInAABB(b,g);for(var j=O,v=e.radius*e.radius,K=0;K<g.length;K++)for(var L=0;3>L;L++)if(f.getVertex(f.indices[3*g[K]+L],j),j.vsub(r,N),N.norm2()<=v){m.copy(j),u.pointToWorldFrame(o,i,m,j),j.vsub(n,N);var M=this.createContactEquation(l,p,e,f);M.ni.copy(N),M.ni.normalize(),M.ri.copy(M.ni),M.ri.scale(e.radius,M.ri),M.ri.vadd(n,M.ri),M.ri.vsub(l.position,M.ri),M.rj.copy(j),M.rj.vsub(p.position,M.rj),this.result.push(M),this.createFrictionEquationsFromContact(M,this.frictionResult)}for(var K=0;K<g.length;K++)for(var L=0;3>L;L++){f.getVertex(f.indices[3*g[K]+L],s),f.getVertex(f.indices[3*g[K]+(L+1)%3],y),y.vsub(s,c),r.vsub(y,w);var P=w.dot(c);r.vsub(s,w);var Q=w.dot(c);if(Q>0&&0>P){r.vsub(s,w),a.copy(c),a.normalize(),Q=w.dot(a),a.scale(Q,w),w.vadd(s,w);var R=w.distanceTo(r);if(R<e.radius){var M=this.createContactEquation(l,p,e,f);w.vsub(r,M.ni),M.ni.normalize(),M.ni.scale(e.radius,M.ri),u.pointToWorldFrame(o,i,w,w),w.vsub(p.position,M.rj),u.vectorToWorldFrame(i,M.ni,M.ni),u.vectorToWorldFrame(i,M.ri,M.ri),this.result.push(M),this.createFrictionEquationsFromContact(M,this.frictionResult)}}}for(var S=F,T=G,U=H,V=A,K=0,W=g.length;K!==W;K++){f.getTriangleVertices(g[K],S,T,U),f.getNormal(g[K],V),r.vsub(S,w);var R=w.dot(V);if(V.scale(R,w),r.vsub(w,w),R=w.distanceTo(r),t.pointInTriangle(w,S,T,U)&&R<e.radius){var M=this.createContactEquation(l,p,e,f);w.vsub(r,M.ni),M.ni.normalize(),M.ni.scale(e.radius,M.ri),u.pointToWorldFrame(o,i,w,w),w.vsub(p.position,M.rj),u.vectorToWorldFrame(i,M.ni,M.ni),u.vectorToWorldFrame(i,M.ri,M.ri),this.result.push(M),this.createFrictionEquationsFromContact(M,this.frictionResult)}}g.length=0};var K=new l,L=new l;n.prototype[i.types.SPHERE|i.types.PLANE]=n.prototype.spherePlane=function(e,f,n,o,d,i,t,l){var u=this.createContactEquation(t,l,e,f);if(u.ni.set(0,0,1),i.vmult(u.ni,u.ni),u.ni.negate(u.ni),u.ni.normalize(),u.ni.mult(e.radius,u.ri),n.vsub(o,K),u.ni.mult(u.ni.dot(K),L),K.vsub(L,u.rj),-K.dot(u.ni)<=e.radius){var p=u.ri,s=u.rj;p.vadd(n,p),p.vsub(t.position,p),s.vadd(o,s),s.vsub(l.position,s),this.result.push(u),this.createFrictionEquationsFromContact(u,this.frictionResult)}};var M=new l,P=new l,Q=new l,R=new l,S=new l,T=new l,U=new l,V=[new l,new l,new l,new l,new l,new l],W=new l,X=new l,Y=new l,Z=new l;n.prototype[i.types.SPHERE|i.types.BOX]=n.prototype.sphereBox=function(e,f,n,o,d,i,t,l){var u=this.v3pool,p=V;n.vsub(o,R),f.getSideNormals(p,i);for(var s=e.radius,y=!1,c=X,a=Y,r=Z,w=null,b=0,m=0,N=0,g=null,x=0,j=p.length;x!==j&&y===!1;x++){var v=S;v.copy(p[x]);var A=v.norm();v.normalize();var C=R.dot(v);if(A+s>C&&C>0){var O=T,h=U;O.copy(p[(x+1)%3]),h.copy(p[(x+2)%3]);var k=O.norm(),q=h.norm();O.normalize(),h.normalize();var z=R.dot(O),B=R.dot(h);if(k>z&&z>-k&&q>B&&B>-q){var D=Math.abs(C-A-s);(null===g||g>D)&&(g=D,m=z,N=B,w=A,c.copy(v),a.copy(O),r.copy(h),b++)}}}if(b){y=!0;var E=this.createContactEquation(t,l,e,f);c.mult(-s,E.ri),E.ni.copy(c),E.ni.negate(E.ni),c.mult(w,c),a.mult(m,a),c.vadd(a,c),r.mult(N,r),c.vadd(r,E.rj),E.ri.vadd(n,E.ri),E.ri.vsub(t.position,E.ri),E.rj.vadd(o,E.rj),E.rj.vsub(l.position,E.rj),this.result.push(E),this.createFrictionEquationsFromContact(E,this.frictionResult)}for(var F=u.get(),G=W,H=0;2!==H&&!y;H++)for(var I=0;2!==I&&!y;I++)for(var J=0;2!==J&&!y;J++)if(F.set(0,0,0),H?F.vadd(p[0],F):F.vsub(p[0],F),I?F.vadd(p[1],F):F.vsub(p[1],F),J?F.vadd(p[2],F):F.vsub(p[2],F),o.vadd(F,G),G.vsub(n,G),G.norm2()<s*s){y=!0;var E=this.createContactEquation(t,l,e,f);E.ri.copy(G),E.ri.normalize(),E.ni.copy(E.ri),E.ri.mult(s,E.ri),E.rj.copy(F),E.ri.vadd(n,E.ri),E.ri.vsub(t.position,E.ri),E.rj.vadd(o,E.rj),E.rj.vsub(l.position,E.rj),this.result.push(E),this.createFrictionEquationsFromContact(E,this.frictionResult)}u.release(F),F=null;for(var K=u.get(),L=u.get(),E=u.get(),M=u.get(),D=u.get(),P=p.length,H=0;H!==P&&!y;H++)for(var I=0;I!==P&&!y;I++)if(H%3!==I%3){p[I].cross(p[H],K),K.normalize(),p[H].vadd(p[I],L),E.copy(n),E.vsub(L,E),E.vsub(o,E);var Q=E.dot(K);K.mult(Q,M);for(var J=0;J===H%3||J===I%3;)J++;D.copy(n),D.vsub(M,D),D.vsub(L,D),D.vsub(o,D);var $=Math.abs(Q),_=D.norm();if($<p[J].norm()&&s>_){y=!0;var ef=this.createContactEquation(t,l,e,f);L.vadd(M,ef.rj),ef.rj.copy(ef.rj),D.negate(ef.ni),ef.ni.normalize(),ef.ri.copy(ef.rj),ef.ri.vadd(o,ef.ri),ef.ri.vsub(n,ef.ri),ef.ri.normalize(),ef.ri.mult(s,ef.ri),ef.ri.vadd(n,ef.ri),ef.ri.vsub(t.position,ef.ri),ef.rj.vadd(o,ef.rj),ef.rj.vsub(l.position,ef.rj),this.result.push(ef),this.createFrictionEquationsFromContact(ef,this.frictionResult)}}u.release(K,L,E,M,D)};var $=new l,_=new l,ef=new l,ff=new l,nf=new l,of=new l,df=new l,tf=new l,lf=new l,uf=new l;n.prototype[i.types.SPHERE|i.types.CONVEXPOLYHEDRON]=n.prototype.sphereConvex=function(e,f,n,d,i,t,l,u){var p=this.v3pool;n.vsub(d,$);for(var s=f.faceNormals,y=f.faces,c=f.vertices,a=e.radius,r=0;r!==c.length;r++){var w=c[r],b=nf;t.vmult(w,b),d.vadd(b,b);var m=ff;if(b.vsub(n,m),m.norm2()<a*a){g=!0;var N=this.createContactEquation(l,u,e,f);return N.ri.copy(m),N.ri.normalize(),N.ni.copy(N.ri),N.ri.mult(a,N.ri),b.vsub(d,N.rj),N.ri.vadd(n,N.ri),N.ri.vsub(l.position,N.ri),N.rj.vadd(d,N.rj),N.rj.vsub(u.position,N.rj),this.result.push(N),void this.createFrictionEquationsFromContact(N,this.frictionResult)}}for(var g=!1,r=0,x=y.length;r!==x&&g===!1;r++){var j=s[r],v=y[r],A=of;t.vmult(j,A);var C=df;t.vmult(c[v[0]],C),C.vadd(d,C);var O=tf;A.mult(-a,O),n.vadd(O,O);var h=lf;O.vsub(C,h);var k=h.dot(A),q=uf;if(n.vsub(C,q),0>k&&q.dot(A)>0){for(var z=[],B=0,D=v.length;B!==D;B++){var E=p.get();t.vmult(c[v[B]],E),d.vadd(E,E),z.push(E)}if(o(z,A,n)){g=!0;var N=this.createContactEquation(l,u,e,f);A.mult(-a,N.ri),A.negate(N.ni);var F=p.get();A.mult(-k,F);var G=p.get();A.mult(-a,G),n.vsub(d,N.rj),N.rj.vadd(G,N.rj),N.rj.vadd(F,N.rj),N.rj.vadd(d,N.rj),N.rj.vsub(u.position,N.rj),N.ri.vadd(n,N.ri),N.ri.vsub(l.position,N.ri),p.release(F),p.release(G),this.result.push(N),this.createFrictionEquationsFromContact(N,this.frictionResult);for(var B=0,H=z.length;B!==H;B++)p.release(z[B]);return}for(var B=0;B!==v.length;B++){var I=p.get(),J=p.get();t.vmult(c[v[(B+1)%v.length]],I),t.vmult(c[v[(B+2)%v.length]],J),d.vadd(I,I),d.vadd(J,J);var K=_;J.vsub(I,K);var L=ef;K.unit(L);var M=p.get(),P=p.get();n.vsub(I,P);var Q=P.dot(L);L.mult(Q,M),M.vadd(I,M);var R=p.get();if(M.vsub(n,R),Q>0&&Q*Q<K.norm2()&&R.norm2()<a*a){var N=this.createContactEquation(l,u,e,f);M.vsub(d,N.rj),M.vsub(n,N.ni),N.ni.normalize(),N.ni.mult(a,N.ri),N.rj.vadd(d,N.rj),N.rj.vsub(u.position,N.rj),N.ri.vadd(n,N.ri),N.ri.vsub(l.position,N.ri),this.result.push(N),this.createFrictionEquationsFromContact(N,this.frictionResult);for(var B=0,H=z.length;B!==H;B++)p.release(z[B]);return p.release(I),p.release(J),p.release(M),p.release(R),void p.release(P)}p.release(I),p.release(J),p.release(M),p.release(R),p.release(P)}for(var B=0,H=z.length;B!==H;B++)p.release(z[B])}}};new l,new l;n.prototype[i.types.PLANE|i.types.BOX]=n.prototype.planeBox=function(e,f,n,o,d,i,t,l){f.convexPolyhedronRepresentation.material=f.material,f.convexPolyhedronRepresentation.collisionResponse=f.collisionResponse,this.planeConvex(e,f.convexPolyhedronRepresentation,n,o,d,i,t,l)};var pf=new l,sf=new l,yf=new l,cf=new l;n.prototype[i.types.PLANE|i.types.CONVEXPOLYHEDRON]=n.prototype.planeConvex=function(e,f,n,o,d,i,t,l){var u=pf,p=sf;p.set(0,0,1),d.vmult(p,p);for(var s=0,y=yf,c=0;c!==f.vertices.length;c++){u.copy(f.vertices[c]),i.vmult(u,u),o.vadd(u,u),u.vsub(n,y);var a=p.dot(y);if(0>=a){var r=this.createContactEquation(t,l,e,f),w=cf;p.mult(p.dot(y),w),u.vsub(w,w),w.vsub(n,r.ri),r.ni.copy(p),u.vsub(o,r.rj),r.ri.vadd(n,r.ri),r.ri.vsub(t.position,r.ri),r.rj.vadd(o,r.rj),r.rj.vsub(l.position,r.rj),this.result.push(r),s++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(r,this.frictionResult)}}this.enableFrictionReduction&&s&&this.createFrictionFromAverage(s)};var af=new l,rf=new l;n.prototype[i.types.CONVEXPOLYHEDRON]=n.prototype.convexConvex=function(e,f,n,o,d,i,t,l,u,p,s,y){var c=af;if(!(n.distanceTo(o)>e.boundingSphereRadius+f.boundingSphereRadius)&&e.findSeparatingAxis(f,n,d,o,i,c,s,y)){var a=[],r=rf;e.clipAgainstHull(n,d,f,o,i,c,-100,100,a);for(var w=0,b=0;b!==a.length;b++){var m=this.createContactEquation(t,l,e,f,u,p),N=m.ri,g=m.rj;c.negate(m.ni),a[b].normal.negate(r),r.mult(a[b].depth,r),a[b].point.vadd(r,N),g.copy(a[b].point),N.vsub(n,N),g.vsub(o,g),N.vadd(n,N),N.vsub(t.position,N),g.vadd(o,g),g.vsub(l.position,g),this.result.push(m),w++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(m,this.frictionResult)}this.enableFrictionReduction&&w&&this.createFrictionFromAverage(w)}};var wf=new l,bf=new l,mf=new l;n.prototype[i.types.PLANE|i.types.PARTICLE]=n.prototype.planeParticle=function(e,f,n,o,d,i,t,l){var u=wf;u.set(0,0,1),t.quaternion.vmult(u,u);var p=bf;o.vsub(t.position,p);var s=u.dot(p);if(0>=s){var y=this.createContactEquation(l,t,f,e);y.ni.copy(u),y.ni.negate(y.ni),y.ri.set(0,0,0);var c=mf;u.mult(u.dot(o),c),o.vsub(c,c),y.rj.copy(c),this.result.push(y),this.createFrictionEquationsFromContact(y,this.frictionResult)}};var Nf=new l;n.prototype[i.types.PARTICLE|i.types.SPHERE]=n.prototype.sphereParticle=function(e,f,n,o,d,i,t,l){var u=Nf;u.set(0,0,1),o.vsub(n,u);var p=u.norm2();if(p<=e.radius*e.radius){var s=this.createContactEquation(l,t,f,e);u.normalize(),s.rj.copy(u),s.rj.mult(e.radius,s.rj),s.ni.copy(u),s.ni.negate(s.ni),s.ri.set(0,0,0),this.result.push(s),this.createFrictionEquationsFromContact(s,this.frictionResult)}};var gf=new p,xf=new l,jf=(new l,new l),vf=new l,Af=new l;n.prototype[i.types.PARTICLE|i.types.CONVEXPOLYHEDRON]=n.prototype.convexParticle=function(e,f,n,o,d,i,t,l){var u=-1,p=jf,s=Af,y=null,c=0,a=xf;if(a.copy(o),a.vsub(n,a),d.conjugate(gf),gf.vmult(a,a),e.pointIsInside(a)){e.worldVerticesNeedsUpdate&&e.computeWorldVertices(n,d),e.worldFaceNormalsNeedsUpdate&&e.computeWorldFaceNormals(d);for(var r=0,w=e.faces.length;r!==w;r++){var b=[e.worldVertices[e.faces[r][0]]],m=e.worldFaceNormals[r];o.vsub(b[0],vf);var N=-m.dot(vf);(null===y||Math.abs(N)<Math.abs(y))&&(y=N,u=r,p.copy(m),c++)}if(-1!==u){var g=this.createContactEquation(l,t,f,e);p.mult(y,s),s.vadd(o,s),s.vsub(n,s),g.rj.copy(s),p.negate(g.ni),g.ri.set(0,0,0);var x=g.ri,j=g.rj;x.vadd(o,x),x.vsub(l.position,x),j.vadd(n,j),j.vsub(t.position,j),this.result.push(g),this.createFrictionEquationsFromContact(g,this.frictionResult)}else console.warn("Point found inside convex, but did not find penetrating face!")}},n.prototype[i.types.BOX|i.types.HEIGHTFIELD]=n.prototype.boxHeightfield=function(e,f,n,o,d,i,t,l){e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexHeightfield(e.convexPolyhedronRepresentation,f,n,o,d,i,t,l)};var Cf=new l,Of=new l,hf=[0];n.prototype[i.types.CONVEXPOLYHEDRON|i.types.HEIGHTFIELD]=n.prototype.convexHeightfield=function(e,f,n,o,d,i,t,l){var p=f.data,s=f.elementSize,y=e.boundingSphereRadius,c=Of,a=hf,r=Cf;u.pointToLocalFrame(o,i,n,r);var w=Math.floor((r.x-y)/s)-1,b=Math.ceil((r.x+y)/s)+1,m=Math.floor((r.y-y)/s)-1,N=Math.ceil((r.y+y)/s)+1;if(!(0>b||0>N||w>p.length||m>p[0].length)){0>w&&(w=0),0>b&&(b=0),0>m&&(m=0),0>N&&(N=0),w>=p.length&&(w=p.length-1),b>=p.length&&(b=p.length-1),N>=p[0].length&&(N=p[0].length-1),m>=p[0].length&&(m=p[0].length-1);var g=[];f.getRectMinMax(w,m,b,N,g);var x=g[0],j=g[1];if(!(r.z-y>j||r.z+y<x))for(var v=w;b>v;v++)for(var A=m;N>A;A++)f.getConvexTrianglePillar(v,A,!1),u.pointToWorldFrame(o,i,f.pillarOffset,c),n.distanceTo(c)<f.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&this.convexConvex(e,f.pillarConvex,n,c,d,i,t,l,null,null,a,null),f.getConvexTrianglePillar(v,A,!0),u.pointToWorldFrame(o,i,f.pillarOffset,c),n.distanceTo(c)<f.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&this.convexConvex(e,f.pillarConvex,n,c,d,i,t,l,null,null,a,null)}};var kf=new l,qf=new l;n.prototype[i.types.SPHERE|i.types.HEIGHTFIELD]=n.prototype.sphereHeightfield=function(e,f,n,o,d,i,t,l){var p=f.data,s=e.radius,y=f.elementSize,c=qf,a=kf;u.pointToLocalFrame(o,i,n,a);var r=Math.floor((a.x-s)/y)-1,w=Math.ceil((a.x+s)/y)+1,b=Math.floor((a.y-s)/y)-1,m=Math.ceil((a.y+s)/y)+1;if(!(0>w||0>m||r>p.length||m>p[0].length)){0>r&&(r=0),0>w&&(w=0),0>b&&(b=0),0>m&&(m=0),r>=p.length&&(r=p.length-1),w>=p.length&&(w=p.length-1),m>=p[0].length&&(m=p[0].length-1),b>=p[0].length&&(b=p[0].length-1);var N=[];f.getRectMinMax(r,b,w,m,N);var g=N[0],x=N[1];if(!(a.z-s>x||a.z+s<g))for(var j=this.result,v=r;w>v;v++)for(var A=b;m>A;A++){var C=j.length;f.getConvexTrianglePillar(v,A,!1),u.pointToWorldFrame(o,i,f.pillarOffset,c),n.distanceTo(c)<f.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&this.sphereConvex(e,f.pillarConvex,n,c,d,i,t,l),f.getConvexTrianglePillar(v,A,!0),u.pointToWorldFrame(o,i,f.pillarOffset,c),n.distanceTo(c)<f.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&this.sphereConvex(e,f.pillarConvex,n,c,d,i,t,l);var O=j.length-C;if(O>2)return}}}},{"../collision/AABB":3,"../collision/Ray":9,"../equations/ContactEquation":19,"../equations/FrictionEquation":21,"../math/Quaternion":28,"../math/Transform":29,"../math/Vec3":30,"../shapes/ConvexPolyhedron":38,"../shapes/Shape":43,"../solver/Solver":47,"../utils/Vec3Pool":54}],56:[function(e,f){function n(){u.apply(this),this.dt=-1,this.allowSleep=!1,this.contacts=[],this.frictionEquations=[],this.quatNormalizeSkip=0,this.quatNormalizeFast=!1,this.time=0,this.stepnumber=0,this.default_dt=1/60,this.nextId=0,this.gravity=new d,this.broadphase=new m,this.bodies=[],this.solver=new t,this.constraints=[],this.narrowphase=new l(this),this.collisionMatrix=new p,this.collisionMatrixPrevious=new p,this.materials=[],this.contactmaterials=[],this.contactMaterialTable=new a,this.defaultMaterial=new s("default"),this.defaultContactMaterial=new y(this.defaultMaterial,this.defaultMaterial,{friction:.3,restitution:0}),this.doProfiling=!1,this.profile={solve:0,makeContactConstraints:0,broadphase:0,integrate:0,narrowphase:0},this.subsystems=[],this.addBodyEvent={type:"addBody",body:null},this.removeBodyEvent={type:"removeBody",body:null}}f.exports=n;var o=e("../shapes/Shape"),d=e("../math/Vec3"),i=e("../math/Quaternion"),t=e("../solver/GSSolver"),l=(e("../utils/Vec3Pool"),e("../equations/ContactEquation"),e("../equations/FrictionEquation"),e("./Narrowphase")),u=e("../utils/EventTarget"),p=e("../collision/ArrayCollisionMatrix"),s=e("../material/Material"),y=e("../material/ContactMaterial"),c=e("../objects/Body"),a=e("../utils/TupleDictionary"),r=e("../collision/RaycastResult"),w=e("../collision/AABB"),b=e("../collision/Ray"),m=e("../collision/NaiveBroadphase");n.prototype=new u;var N=(new w,new b);if(n.prototype.getContactMaterial=function(e,f){return this.contactMaterialTable.get(e.id,f.id)},n.prototype.numObjects=function(){return this.bodies.length},n.prototype.collisionMatrixTick=function(){var e=this.collisionMatrixPrevious;this.collisionMatrixPrevious=this.collisionMatrix,this.collisionMatrix=e,this.collisionMatrix.reset()},n.prototype.add=n.prototype.addBody=function(e){-1===this.bodies.indexOf(e)&&(e.index=this.bodies.length,this.bodies.push(e),e.world=this,e.initPosition.copy(e.position),e.initVelocity.copy(e.velocity),e.timeLastSleepy=this.time,e instanceof c&&(e.initAngularVelocity.copy(e.angularVelocity),e.initQuaternion.copy(e.quaternion)),this.collisionMatrix.setNumObjects(this.bodies.length),this.addBodyEvent.body=e,this.dispatchEvent(this.addBodyEvent))},n.prototype.addConstraint=function(e){this.constraints.push(e)},n.prototype.removeConstraint=function(e){var f=this.constraints.indexOf(e);-1!==f&&this.constraints.splice(f,1)},n.prototype.rayTest=function(e,f,n){n instanceof r?this.raycastClosest(e,f,{skipBackfaces:!0},n):this.raycastAll(e,f,{skipBackfaces:!0},n)},n.prototype.raycastAll=function(e,f,n,o){return n.mode=b.ALL,n.from=e,n.to=f,n.callback=o,N.intersectWorld(this,n)},n.prototype.raycastAny=function(e,f,n,o){return n.mode=b.ANY,n.from=e,n.to=f,n.result=o,N.intersectWorld(this,n)},n.prototype.raycastClosest=function(e,f,n,o){return n.mode=b.CLOSEST,n.from=e,n.to=f,n.result=o,N.intersectWorld(this,n)},n.prototype.remove=function(e){e.world=null;var f=this.bodies.length-1,n=this.bodies,o=n.indexOf(e);if(-1!==o){n.splice(o,1);for(var d=0;d!==n.length;d++)n[d].index=d;this.collisionMatrix.setNumObjects(f),this.removeBodyEvent.body=e,this.dispatchEvent(this.removeBodyEvent)}},n.prototype.removeBody=n.prototype.remove,n.prototype.addMaterial=function(e){this.materials.push(e)},n.prototype.addContactMaterial=function(e){this.contactmaterials.push(e),this.contactMaterialTable.set(e.materials[0].id,e.materials[1].id,e)},"undefined"==typeof performance&&(performance={}),!performance.now){var g=Date.now();performance.timing&&performance.timing.navigationStart&&(g=performance.timing.navigationStart),performance.now=function(){return Date.now()-g}}var x=new d;n.prototype.step=function(e,f,n){if(n=n||10,f=f||0,0===f)this.internalStep(e),this.time+=e;else{var o=Math.floor((this.time+f)/e)-Math.floor(this.time/e);o=Math.min(o,n);for(var d=performance.now(),i=0;i!==o&&(this.internalStep(e),!(performance.now()-d>1e3*e));i++);this.time+=f;for(var t=this.time%e,l=t/e,u=x,p=this.bodies,s=0;s!==p.length;s++){var y=p[s];y.type!==c.STATIC&&y.sleepState!==c.SLEEPING?(y.position.vsub(y.previousPosition,u),u.scale(l,u),y.position.vadd(u,y.interpolatedPosition)):(y.interpolatedPosition.copy(y.position),y.interpolatedQuaternion.copy(y.quaternion))}}};var j={type:"postStep"},v={type:"preStep"},A={type:"collide",body:null,contact:null},C=[],O=[],h=[],k=[],q=(new d,new d,new d,new d,new d,new d,new d,new d,new d,new i,new i),z=new i,B=new d;n.prototype.internalStep=function(e){this.dt=e;var f,n=this.contacts,d=h,i=k,t=this.numObjects(),l=this.bodies,u=this.solver,p=this.gravity,s=this.doProfiling,y=this.profile,a=c.DYNAMIC,r=this.constraints,w=O,b=(p.norm(),p.x),m=p.y,N=p.z,g=0;for(s&&(f=performance.now()),g=0;g!==t;g++){var x=l[g];if(x.type&a){var D=x.force,E=x.mass;D.x+=E*b,D.y+=E*m,D.z+=E*N}}for(var g=0,F=this.subsystems.length;g!==F;g++)this.subsystems[g].update();s&&(f=performance.now()),d.length=0,i.length=0,this.broadphase.collisionPairs(this,d,i),s&&(y.broadphase=performance.now()-f);var G=r.length;for(g=0;g!==G;g++){var H=r[g];if(!H.collideConnected)for(var I=d.length-1;I>=0;I-=1)(H.bodyA===d[I]&&H.bodyB===i[I]||H.bodyB===d[I]&&H.bodyA===i[I])&&(d.splice(I,1),i.splice(I,1))}this.collisionMatrixTick(),s&&(f=performance.now());var J=C,K=n.length;for(g=0;g!==K;g++)J.push(n[g]);n.length=0;var L=this.frictionEquations.length;for(g=0;g!==L;g++)w.push(this.frictionEquations[g]);this.frictionEquations.length=0,this.narrowphase.getContacts(d,i,this,n,J,this.frictionEquations,w),s&&(y.narrowphase=performance.now()-f),s&&(f=performance.now());for(var g=0;g<this.frictionEquations.length;g++)u.addEquation(this.frictionEquations[g]);for(var M=n.length,P=0;P!==M;P++){{var Q,H=n[P],x=H.bi,R=H.bj;H.si,H.sj}Q=x.material&&R.material?this.getContactMaterial(x.material,R.material)||this.defaultContactMaterial:this.defaultContactMaterial;var S=Q.friction;if(x.material&&R.material&&(x.material.friction>=0&&R.material.friction>=0&&(S=x.material.friction*R.material.friction),x.material.restitution>=0&&R.material.restitution>=0&&(H.restitution=x.material.restitution*R.material.restitution)),u.addEquation(H),x.allowSleep&&x.type===c.DYNAMIC&&x.sleepState===c.SLEEPING&&R.sleepState===c.AWAKE&&R.type!==c.STATIC){var T=R.velocity.norm2()+R.angularVelocity.norm2(),U=Math.pow(R.sleepSpeedLimit,2);
T>=2*U&&(x._wakeUpAfterNarrowphase=!0)}if(R.allowSleep&&R.type===c.DYNAMIC&&R.sleepState===c.SLEEPING&&x.sleepState===c.AWAKE&&x.type!==c.STATIC){var V=x.velocity.norm2()+x.angularVelocity.norm2(),W=Math.pow(x.sleepSpeedLimit,2);V>=2*W&&(R._wakeUpAfterNarrowphase=!0)}this.collisionMatrix.set(x,R,!0),this.collisionMatrixPrevious.get(x,R)||(A.body=R,A.contact=H,x.dispatchEvent(A),A.body=x,R.dispatchEvent(A))}for(s&&(y.makeContactConstraints=performance.now()-f,f=performance.now()),g=0;g!==t;g++){var x=l[g];x._wakeUpAfterNarrowphase&&(x.wakeUp(),x._wakeUpAfterNarrowphase=!1)}var G=r.length;for(g=0;g!==G;g++){var H=r[g];H.update();for(var I=0,X=H.equations.length;I!==X;I++){var Y=H.equations[I];u.addEquation(Y)}}u.solve(e,this),s&&(y.solve=performance.now()-f),u.removeAllEquations();var Z=Math.pow;for(g=0;g!==t;g++){var x=l[g];if(x.type&a){var $=Z(1-x.linearDamping,e),_=x.velocity;_.mult($,_);var ef=x.angularVelocity;if(ef){var ff=Z(1-x.angularDamping,e);ef.mult(ff,ef)}}}for(this.dispatchEvent(v),g=0;g!==t;g++){var x=l[g];x.preStep&&x.preStep.call(x)}s&&(f=performance.now());{var nf=q,of=z,df=this.stepnumber,tf=c.DYNAMIC|c.KINEMATIC,lf=df%(this.quatNormalizeSkip+1)===0,uf=this.quatNormalizeFast,pf=.5*e;o.types.PLANE,o.types.CONVEXPOLYHEDRON}for(g=0;g!==t;g++){var sf=l[g],yf=sf.force,cf=sf.torque;if(sf.type&tf&&sf.sleepState!==c.SLEEPING){var af=sf.velocity,rf=sf.angularVelocity,wf=sf.position,bf=sf.quaternion,mf=sf.invMass,Nf=sf.invInertiaWorld;af.x+=yf.x*mf*e,af.y+=yf.y*mf*e,af.z+=yf.z*mf*e,sf.angularVelocity&&(Nf.vmult(cf,B),B.mult(e,B),B.vadd(rf,rf)),wf.x+=af.x*e,wf.y+=af.y*e,wf.z+=af.z*e,sf.angularVelocity&&(nf.set(rf.x,rf.y,rf.z,0),nf.mult(bf,of),bf.x+=pf*of.x,bf.y+=pf*of.y,bf.z+=pf*of.z,bf.w+=pf*of.w,lf&&(uf?bf.normalizeFast():bf.normalize())),sf.aabb&&(sf.aabbNeedsUpdate=!0),sf.updateInertiaWorld&&sf.updateInertiaWorld()}}for(this.clearForces(),this.broadphase.dirty=!0,s&&(y.integrate=performance.now()-f),this.time+=e,this.stepnumber+=1,this.dispatchEvent(j),g=0;g!==t;g++){var x=l[g],gf=x.postStep;gf&&gf.call(x)}if(this.allowSleep)for(g=0;g!==t;g++)l[g].sleepTick(this.time)},n.prototype.clearForces=function(){for(var e=this.bodies,f=e.length,n=0;n!==f;n++){{var o=e[n];o.force,o.torque}o.force.set(0,0,0),o.torque.set(0,0,0)}}},{"../collision/AABB":3,"../collision/ArrayCollisionMatrix":4,"../collision/NaiveBroadphase":7,"../collision/Ray":9,"../collision/RaycastResult":10,"../equations/ContactEquation":19,"../equations/FrictionEquation":21,"../material/ContactMaterial":24,"../material/Material":25,"../math/Quaternion":28,"../math/Vec3":30,"../objects/Body":31,"../shapes/Shape":43,"../solver/GSSolver":46,"../utils/EventTarget":49,"../utils/TupleDictionary":52,"../utils/Vec3Pool":54,"./Narrowphase":55}]},{},[2])(2)});
/* global CANNON,THREE,Detector */

/**
 * Adds Three.js primitives into the scene where all the Cannon bodies and shapes are.
 * @class CannonDebugRenderer
 * @param {THREE.Scene} scene
 * @param {CANNON.World} world
 * @param {object} [options]
 */
THREE.CannonDebugRenderer = function(scene, world, options){
    options = options || {};

    this.scene = scene;
    this.world = world;

    this._meshes = [];

    this._material = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
    this._sphereGeometry = new THREE.SphereGeometry(1);
    this._boxGeometry = new THREE.BoxGeometry(1, 1, 1);
    this._planeGeometry = new THREE.PlaneGeometry( 10, 10, 10, 10 );
    this._cylinderGeometry = new THREE.CylinderGeometry( 1, 1, 10, 10 );
};

THREE.CannonDebugRenderer.prototype = {

    tmpVec0: new CANNON.Vec3(),
    tmpVec1: new CANNON.Vec3(),
    tmpVec2: new CANNON.Vec3(),
    tmpQuat0: new CANNON.Vec3(),

    update: function(){

        var bodies = this.world.bodies;
        var meshes = this._meshes;
        var shapeWorldPosition = this.tmpVec0;
        var shapeWorldQuaternion = this.tmpQuat0;

        var meshIndex = 0;

        for (var i = 0; i !== bodies.length; i++) {
            var body = bodies[i];

            for (var j = 0; j !== body.shapes.length; j++) {
                var shape = body.shapes[j];

                this._updateMesh(meshIndex, body, shape);

                var mesh = meshes[meshIndex];

                if(mesh){

                    // Get world position
                    body.quaternion.vmult(body.shapeOffsets[j], shapeWorldPosition);
                    body.position.vadd(shapeWorldPosition, shapeWorldPosition);

                    // Get world quaternion
                    body.quaternion.mult(body.shapeOrientations[j], shapeWorldQuaternion);

                    // Copy to meshes
                    mesh.position.copy(shapeWorldPosition);
                    mesh.quaternion.copy(shapeWorldQuaternion);
                }

                meshIndex++;
            }
        }

        for(var i = meshIndex; i < meshes.length; i++){
            var mesh = meshes[i];
            if(mesh){
                this.scene.remove(mesh);
            }
        }

        meshes.length = meshIndex;
    },

    _updateMesh: function(index, body, shape){
        var mesh = this._meshes[index];
        if(!this._typeMatch(mesh, shape)){
            if(mesh){
                this.scene.remove(mesh);
            }
            mesh = this._meshes[index] = this._createMesh(shape);
        }
        this._scaleMesh(mesh, shape);
    },

    _typeMatch: function(mesh, shape){
        if(!mesh){
            return false;
        }
        var geo = mesh.geometry;
        return (
            (geo instanceof THREE.SphereGeometry && shape instanceof CANNON.Sphere) ||
            (geo instanceof THREE.BoxGeometry && shape instanceof CANNON.Box) ||
            (geo instanceof THREE.PlaneGeometry && shape instanceof CANNON.Plane) ||
            (shape instanceof CANNON.ConvexPolyhedron) ||
            (geo.id === shape.geometryId && shape instanceof CANNON.Trimesh) ||
            (geo.id === shape.geometryId && shape instanceof CANNON.Heightfield)
        );
    },

    _createMesh: function(shape){
        var mesh;
        var material = this._material;

        switch(shape.type){

        case CANNON.Shape.types.SPHERE:
            mesh = new THREE.Mesh(this._sphereGeometry, material);
            break;

        case CANNON.Shape.types.BOX:
            mesh = new THREE.Mesh(this._boxGeometry, material);
            break;

        case CANNON.Shape.types.PLANE:
            mesh = new THREE.Mesh(this._planeGeometry, material);
            break;

        case CANNON.Shape.types.CONVEXPOLYHEDRON:
            // Create mesh
            var geo = new THREE.Geometry();
            // Add vertices
            for (var i = 0; i < shape.vertices.length; i++) {
                var v = shape.vertices[i];
                geo.vertices.push(new THREE.Vector3(v.x, v.y, v.z));
            }

            for(var i=0; i < shape.faces.length; i++){
                var face = shape.faces[i];

                // add triangles
                var a = face[0];
                for (var j = 1; j < face.length - 1; j++) {
                    var b = face[j];
                    var c = face[j + 1];
                    geo.faces.push(new THREE.Face3(a, b, c));
                }
            }
            geo.computeBoundingSphere();
            geo.computeFaceNormals();

            mesh = new THREE.Mesh(geo, material);
            //shape.geometryId = geo.id;
            break;

        case CANNON.Shape.types.TRIMESH:
            var geometry = new THREE.Geometry();
            var v0 = this.tmpVec0;
            var v1 = this.tmpVec1;
            var v2 = this.tmpVec2;
            for (var i = 0; i < shape.indices.length / 3; i++) {
                shape.getTriangleVertices(i, v0, v1, v2);
                geometry.vertices.push(
                    new THREE.Vector3(v0.x, v0.y, v0.z),
                    new THREE.Vector3(v1.x, v1.y, v1.z),
                    new THREE.Vector3(v2.x, v2.y, v2.z)
                );
                var j = geometry.vertices.length - 3;
                geometry.faces.push(new THREE.Face3(j, j+1, j+2));
            }
            geometry.computeBoundingSphere();
            geometry.computeFaceNormals();
            mesh = new THREE.Mesh(geometry, material);
            shape.geometryId = geometry.id;
            break;

        case CANNON.Shape.types.HEIGHTFIELD:
            var geometry = new THREE.Geometry();

            var v0 = this.tmpVec0;
            var v1 = this.tmpVec1;
            var v2 = this.tmpVec2;
            for (var xi = 0; xi < shape.data.length - 1; xi++) {
                for (var yi = 0; yi < shape.data[xi].length - 1; yi++) {
                    for (var k = 0; k < 2; k++) {
                        shape.getConvexTrianglePillar(xi, yi, k===0);
                        v0.copy(shape.pillarConvex.vertices[0]);
                        v1.copy(shape.pillarConvex.vertices[1]);
                        v2.copy(shape.pillarConvex.vertices[2]);
                        v0.vadd(shape.pillarOffset, v0);
                        v1.vadd(shape.pillarOffset, v1);
                        v2.vadd(shape.pillarOffset, v2);
                        geometry.vertices.push(
                            new THREE.Vector3(v0.x, v0.y, v0.z),
                            new THREE.Vector3(v1.x, v1.y, v1.z),
                            new THREE.Vector3(v2.x, v2.y, v2.z)
                        );
                        var i = geometry.vertices.length - 3;
                        geometry.faces.push(new THREE.Face3(i, i+1, i+2));
                    }
                }
            }
            geometry.computeBoundingSphere();
            geometry.computeFaceNormals();
            mesh = new THREE.Mesh(geometry, material);
            shape.geometryId = geometry.id;
            break;
        }

        if(mesh){
            mesh.forDebugPurposes = true;
            this.scene.add(mesh);
        }

        return mesh;
    },

    _scaleMesh: function(mesh, shape){
        switch(shape.type){

        case CANNON.Shape.types.SPHERE:
            var radius = shape.radius;
            mesh.scale.set(radius, radius, radius);
            break;

        case CANNON.Shape.types.BOX:
            mesh.scale.copy(shape.halfExtents);
            mesh.scale.multiplyScalar(2);
            break;

        case CANNON.Shape.types.CONVEXPOLYHEDRON:
            mesh.scale.set(1,1,1);
            break;

        case CANNON.Shape.types.TRIMESH:
            mesh.scale.copy(shape.scale);
            break;

        case CANNON.Shape.types.HEIGHTFIELD:
            mesh.scale.set(1,1,1);
            break;

        }
    }
};

var ShaderContent = function(){

    this.particleVertexShader = 0;
    this.particleFragmentShader = 0;
    this.objectTrailVertexShader = 0;
    this.objectTrailFragmentShader = 0;
    this.crossHairVertexShader = 0;
    this.crossHairFragmentShader = 0;
    this.basicMaterialVertexShader = 0;
    this.basicMaterialFragmentShader = 0;
    this.mergedBasicMaterialVertexShader = 0;
    this.mergedBasicMaterialFragmentShader = 0;
    this.instancedBasicMaterialVertexShader = 0;
    this.instancedBasicMaterialFragmentShader = 0;
    this.skyboxVertexShader = 0;
    this.skyboxFragmentShader = 0;
    this.textVertexShader = 0;
    this.textFragmentShader = 0;
    this.rectangleVertexShader = 0;
    this.rectangleFragmentShader = 0;

    this.totalLoadCount = 18;
    this.currentLoadCount = 0;

    this.allShadersReadyCallback = function(){
      if (!isDeployment){
        canvas.style.visibility = "";
        terminal.enable();
        terminal.clear();
        terminal.print("Type help for list of commands.");
      }else{
        appendtoDeploymentConsole("Shaders loaded.");
        appendtoDeploymentConsole("");
        startDeployment();
      }
    }
    this.aShaderLoadedCallback = function(){
      this.currentLoadCount ++;
      if (this.currentLoadCount == this.totalLoadCount){
        this.allShadersReadyCallback();
      }
    }
    this.load();
}

ShaderContent.prototype.load = function(){
  var particleVertexShaderRequest = new XMLHttpRequest();
  var particleFragmentShaderRequest = new XMLHttpRequest();
  var objectTrailVertexShaderRequest = new XMLHttpRequest();
  var objectTrailFragmentShaderRequest = new XMLHttpRequest();
  var crossHairVertexShaderRequest = new XMLHttpRequest();
  var crossHairFragmentShaderRequest = new XMLHttpRequest();
  var basicMaterialVertexShaderRequest = new XMLHttpRequest();
  var basicMaterialFragmentShaderRequest = new XMLHttpRequest();
  var mergedBasicMaterialVertexShaderRequest = new XMLHttpRequest();
  var mergedBasicMaterialFragmentShaderRequest = new XMLHttpRequest();
  var instancedBasicMaterialVertexShaderRequest = new XMLHttpRequest();
  var instancedBasicMaterialFragmentShaderRequest = new XMLHttpRequest();
  var skyboxVertexShaderRequest = new XMLHttpRequest();
  var skyboxFragmentShaderRequest = new XMLHttpRequest();
  var textVertexShaderRequest = new XMLHttpRequest();
  var textFragmentShaderRequest = new XMLHttpRequest();
  var rectangleVertexShaderRequest = new XMLHttpRequest();
  var rectangleFragmentShaderRequest = new XMLHttpRequest();

  particleVertexShaderRequest.open('GET', "./shader/particle/vertexShader.shader");
  particleFragmentShaderRequest.open('GET', "./shader/particle/fragmentShader.shader");
  objectTrailVertexShaderRequest.open('GET', "./shader/object_trail/vertexShader.shader");
  objectTrailFragmentShaderRequest.open('GET', "./shader/object_trail/fragmentShader.shader");
  crossHairVertexShaderRequest.open('GET', "./shader/crosshair/vertexShader.shader");
  crossHairFragmentShaderRequest.open('GET', "./shader/crosshair/fragmentShader.shader");
  basicMaterialVertexShaderRequest.open('GET', "./shader/materials/basic_material/vertexShader.shader");
  basicMaterialFragmentShaderRequest.open('GET', "./shader/materials/basic_material/fragmentShader.shader");
  mergedBasicMaterialVertexShaderRequest.open('GET', "./shader/materials/merged_basic_material/vertexShader.shader");
  mergedBasicMaterialFragmentShaderRequest.open('GET', "./shader/materials/merged_basic_material/fragmentShader.shader");
  instancedBasicMaterialVertexShaderRequest.open('GET', "./shader/materials/instanced_basic_material/vertexShader.shader");
  instancedBasicMaterialFragmentShaderRequest.open('GET', "./shader/materials/instanced_basic_material/fragmentShader.shader");
  skyboxVertexShaderRequest.open('GET', "./shader/skybox/vertexShader.shader");
  skyboxFragmentShaderRequest.open('GET', "./shader/skybox/fragmentShader.shader");
  textVertexShaderRequest.open('GET', "./shader/text/vertexShader.shader");
  textFragmentShaderRequest.open('GET', "./shader/text/fragmentShader.shader");
  rectangleVertexShaderRequest.open('GET', "./shader/rectangle/vertexShader.shader");
  rectangleFragmentShaderRequest.open('GET', "./shader/rectangle/fragmentShader.shader");

  var that = this;
  particleVertexShaderRequest.addEventListener("load", function(){
    that.particleVertexShader = particleVertexShaderRequest.responseText;
    that.aShaderLoadedCallback();
  });
  particleFragmentShaderRequest.addEventListener("load", function(){
    that.particleFragmentShader = particleFragmentShaderRequest.responseText;
    that.aShaderLoadedCallback();
  });
  objectTrailVertexShaderRequest.addEventListener("load", function(){
    that.objectTrailVertexShader= objectTrailVertexShaderRequest.responseText;
    that.aShaderLoadedCallback();
  });
  objectTrailFragmentShaderRequest.addEventListener("load", function(){
    that.objectTrailFragmentShader = objectTrailFragmentShaderRequest.responseText;
    that.aShaderLoadedCallback();
  });
  crossHairVertexShaderRequest.addEventListener("load", function(){
    that.crossHairVertexShader = crossHairVertexShaderRequest.responseText;
    that.aShaderLoadedCallback();
  });
  crossHairFragmentShaderRequest.addEventListener("load", function(){
    that.crossHairFragmentShader = crossHairFragmentShaderRequest.responseText;
    that.aShaderLoadedCallback();
  });
  basicMaterialVertexShaderRequest.addEventListener("load", function(){
    that.basicMaterialVertexShader = basicMaterialVertexShaderRequest.responseText;
    that.aShaderLoadedCallback();
  });
  basicMaterialFragmentShaderRequest.addEventListener("load", function(){
    that.basicMaterialFragmentShader = basicMaterialFragmentShaderRequest.responseText;
    that.aShaderLoadedCallback();
  });
  mergedBasicMaterialVertexShaderRequest.addEventListener("load", function(){
    that.mergedBasicMaterialVertexShader = mergedBasicMaterialVertexShaderRequest.responseText;
    that.aShaderLoadedCallback();
  });
  mergedBasicMaterialFragmentShaderRequest.addEventListener("load", function(){
    that.mergedBasicMaterialFragmentShader = mergedBasicMaterialFragmentShaderRequest.responseText;
    that.aShaderLoadedCallback();
  });
  instancedBasicMaterialVertexShaderRequest.addEventListener("load", function(){
    that.instancedBasicMaterialVertexShader = instancedBasicMaterialVertexShaderRequest.responseText;
    that.aShaderLoadedCallback();
  });
  instancedBasicMaterialFragmentShaderRequest.addEventListener("load", function(){
    that.instancedBasicMaterialFragmentShader = instancedBasicMaterialFragmentShaderRequest.responseText;
    that.aShaderLoadedCallback();
  });
  skyboxVertexShaderRequest.addEventListener("load", function(){
    that.skyboxVertexShader = skyboxVertexShaderRequest.responseText;
    that.aShaderLoadedCallback();
  });
  skyboxFragmentShaderRequest.addEventListener("load", function(){
    that.skyboxFragmentShader = skyboxFragmentShaderRequest.responseText;
    that.aShaderLoadedCallback();
  });
  textVertexShaderRequest.addEventListener("load", function(){
    that.textVertexShader = textVertexShaderRequest.responseText;
    that.aShaderLoadedCallback();
  });
  textFragmentShaderRequest.addEventListener("load", function(){
    that.textFragmentShader = textFragmentShaderRequest.responseText;
    that.aShaderLoadedCallback();
  });
  rectangleVertexShaderRequest.addEventListener("load", function(){
    that.rectangleVertexShader = rectangleVertexShaderRequest.responseText;
    that.aShaderLoadedCallback();
  });
  rectangleFragmentShaderRequest.addEventListener("load", function(){
    that.rectangleFragmentShader = rectangleFragmentShaderRequest.responseText;
    that.aShaderLoadedCallback();
  });

  particleVertexShaderRequest.send();
  particleFragmentShaderRequest.send();
  objectTrailVertexShaderRequest.send();
  objectTrailFragmentShaderRequest.send();
  crossHairVertexShaderRequest.send();
  crossHairFragmentShaderRequest.send();
  basicMaterialVertexShaderRequest.send();
  basicMaterialFragmentShaderRequest.send();
  mergedBasicMaterialVertexShaderRequest.send();
  mergedBasicMaterialFragmentShaderRequest.send();
  instancedBasicMaterialVertexShaderRequest.send();
  instancedBasicMaterialFragmentShaderRequest.send();
  skyboxVertexShaderRequest.send();
  skyboxFragmentShaderRequest.send();
  textVertexShaderRequest.send();
  textFragmentShaderRequest.send();
  rectangleVertexShaderRequest.send();
  rectangleFragmentShaderRequest.send();

}

var CollisionInfo = function(targetObjectName, x, y, z, collisionImpact, quaternionX, quaternionY, quaternionZ, quaternionW, faceNormal, time){
  this.set(targetObjectName, x, y, z, collisionImpact, quaternionX, quaternionY, quaternionZ, quaternionW, faceNormal, time);
}

CollisionInfo.prototype.set = function(targetObjectName, x, y, z, collisionImpact, quaternionX, quaternionY, quaternionZ, quaternionW, faceNormal, time){
  this.targetObjectName = targetObjectName;
  this.x = x;
  this.y = y;
  this.z = z;

  // Set only for object collisions
  this.collisionImpact = collisionImpact;

  this.quaternionX = quaternionX;
  this.quaternionY = quaternionY;
  this.quaternionZ = quaternionZ;
  this.quaternionW = quaternionW;

  // Set only for particle collisions
  if (faceNormal){
    this.faceNormalX = faceNormal.x;
    this.faceNormalY = faceNormal.y;
    this.faceNormalZ = faceNormal.z;
  }

  // Set only for particle system collisions
  if (!(typeof time == "undefined")){
    this.particleSystemTime = time;
  }
  return this;
}

var isDeployment = true;

// CLI
var terminal;
var cliInnerDiv;
var cliDivheader;
var scriptCreatorDiv;
var scriptCreatorCancelButton;
var scriptCreatorSaveButton;
var scriptCreatorTextArea;
var commandArgumentsExpectedCount;
var commandArgumentsExpectedExplanation;
var commands;
var commandInfo;
var keyboardInfo;
var deprecatedCommandIndices;
if (!isDeployment){
  terminal = new Terminal();
  commandArgumentsExpectedCount = [
      0, //help
      9, //newGridSystem
      0, //printCameraPosition
      0, //printCameraDirection
      0, //printGridSystems
      1, //printGridSystemInfo
      1, //destroyGridSystem
      0, //printKeyboardInfo
      0, //printSelectedGrids
      0, //resetSelectedGrids
      1, //selectAllGrids
      0, //cropGridSystem
      6, //pasteCroppedGridSystem
      0, //switchView
      2, //newBasicMaterial
      0, //printMaterials
      1, //destroyMaterial
      2, //newSurface
      0, //printObjects
      1, //printMetaData
      1, //destroyObject
      2, //newTexture
      0, //printTextures
      1, //destroyTexture
      2, //mapTexture
      3, //adjustTextureRepeat
      8, //newPhysicsBoxTest
      6, //newPhysicsSphereTest
      0, //printPhysicsTests
      0, //switchPhysicsDebugMode
      4, //newRamp
      0, //setAnchor
      1, //restartPhysicsTest
      3, //mirror
      3, //newBox
      3, //newWallCollection
      0, //printWallCollections
      1, //destroyWallCollection
      0, //destroySelectedGrids
      1, //remakeGridSystem
      0, //resetCamera
      1, //uploadImage
      0, //printImages
      2, //mapSpecular
      2, //mapEnvironment
      2, //mapAmbientOcculsion
      2, //mapAlpha
      1, //setDefaultMaterial
      2, //newAmbientLight
      0, //printLights
      1, //selectLight
      1, //destroyLight
      2, //newPhongMaterial
      2, //mapNormal
      2, //mapEmissive
      2, //newLambertMaterial
      3, //newTexturePack
      0, //printTexturePacks
      1, //printTexturePackInfo
      2, //mapTexturePack
      1, //destroyTexturePack
      1, //refreshTexturePack
      2, //mapHeight
      1, //resetMaps
      2, //segmentObject
      4, //superposeGridSystem
      1, //postProcessing
      3, //sliceGrid
      5, //newPointLight
      3, //newSkybox
      0, //printSkyboxes
      1, //printSkyboxInfo
      1, //mapSkybox
      1, //destroySkybox
      1, //skybox
      1, //scaleSkybox
      0, //save
      0, //load
      0, //undo
      0, //redo
      1, //selectObject
      2, //setMass
      3, //rotateObject
      1, //newScript
      1, //runScript
      1, //stopScript
      0, //printScripts
      1, //editScript
      1, //destroyScript
      3, //translateObject
      2, //setFog
      0, //removeFog
      2, //glue
      1, //detach
      4, //mark
      1, //unmark
      0, //printMarkedPoints
      0, //toggleMarkedPoints
      1, //runAutomatically
      2, //uploadScript
      1, //runManually
      1, //physicsWorkerMode
      0, //printPhysicsWorkerMode
      1, //explain
      0, //printScriptingFunctions
      0, //printPerformance
      1, //search
      3, //rescaleTexture
      3, //rescaleTexturePack
      1, //destroyImage
      2, //setBlending
      0, //about
      0, //resetKeyboardBuffer
      6, //setWorldLimits
      1, //setBinSize
      0, //printWorldLimits
      0, //printBinSize
      1, //particleCollisionWorkerMode
      0, //printParticleCollisionWorkerMode
      1, //particleSystemCollisionWorkerMode
      0, //printParticleSystemCollisionWorkerMode
      0, //logFrameDrops
      3, //addPaddingToTexture
      3, //newSphere
      0, //printFogInfo
      4, //applyDisplacementMap
      2, //setSlipperiness
      2, //setAtlasTextureSize
      0, //printAtlasTextureSize
      2, //sync
      2, //newArea
      0, //toggleAreas
      1, //destroyArea
      1, //areaConfigurations
      1, //setResolution
      1, //configureArea
      4, //newAreaConfiguration
      1, //autoConfigureArea
      0, //stopAreaConfigurations
      0, //startAreaConfigurations
      6, //newCylinder
      4, //setRotationPivot
      2, //printChildPosition
      1, //unsetRotationPivot
      6, //copyObject
      2, //build
      1, //skyboxConfigurations
      1, //fogConfigurations
      1, //noMobile
      2, //setMaxViewport
      1, //keepAspect
      2, //newFont
      1, //destroyFont
      0, //printFonts
      6, //newText
      1, //selectText
      1, //destroyText
      0 //printTexts
  ];
  commandArgumentsExpectedExplanation = [
    "help", //help
    "newGridSystem name sizeX sizeZ centerX centerY centerZ color cellSize axis", //newGridSystem
    "printCameraPosition", //printCameraPosition
    "printCameraDirection", //printCameraDirection
    "printGridSystems", //printGridSystems
    "printGridSystemInfo name", //printGridSystemInfo
    "destroyGridSystem name", //destroyGridSystem
    "printKeyboardInfo", //printKeyboardInfo
    "printSelectedGrids", //printSelectedGrids
    "resetSelectedGrids", //resetSelectedGrids
    "selectAllGrids name", //selectAllGrids
    "cropGridSystem", // cropGridSystem
    "pasteCroppedGridSystem name xTranslation yTranslation zTranslation outlineColor cellSize", //pasteCroppedGridSystem
    "switchView", //switchView
    "newBasicMaterial name color", //newBasicMaterial
    "printMaterials", //printMaterials
    "destroyMaterial name", //destroyMaterial
    "newSurface name material", //newSurface
    "printObjects", //printObjects
    "printMetaData name", //printMetaData
    "destroyObject name", //destroyObject
    "newTexture name fileName", //newTexture
    "printTextures", //printTextures
    "destroyTexture name", //destroyTexture
    "mapTexture textureName objectName", //mapTexture
    "adjustTextureRepeat objectName repeatU repeatV", //adjustTextureRepeat
    "newPhysicsBoxTest duration sizeX sizeY sizeZ mass positionX positionY positionZ", //newPhysicsBoxTest
    "newPhysicsSphereTest duration radius mass positionX positionY positionZ", //newPhysicsSphereTest
    "printPhysicsTests", //printPhysicsTests
    "switchPhysicsDebugMode", //switchPhysicsDebugMode
    "newRamp name material axis height", //newRamp
    "setAnchor", //setAnchor
    "restartPhysicsTest physicsTestIndex", //restartPhysicsTest
    "mirror objectName on/off s/t/st", //mirror
    "newBox name material height", //newBox
    "newWallCollection name height outlineColor", //newWallCollection
    "printWallCollections", //printWallCollections
    "destroyWallCollection name", //destroyWallCollection
    "destroySelectedGrids", //destroySelectedGrids
    "remakeGridSystem name", //remakeGridSystem
    "resetCamera", //resetCamera
    "uploadImage name", //uploadImage
    "printImages", //printImages
    "mapSpecular textureName objectName", //mapSpecular
    "mapEnvironment textureName objectName", //mapEnvironment
    "mapAmbientOcculsion textureName objectName", //mapAmbientOcculsion
    "mapAlpha textureName objectName", //mapAlpha
    "setDefaultMaterial basic/phong", //setDefaultMaterial"
    "newAmbientLight name color", //newAmbientLight
    "printLights", //printLights
    "selectLight name", //selectLight
    "destroyLight name", //destroyLight
    "newPhongMaterial name color", //newPhongMaterial
    "mapNormal textureName objectName", //mapNormal
    "mapEmissive textureName objectName", //mapEmissive
    "newLambertMaterial name color", //newLambertMaterial
    "newTexturePack name directoryName fileExtension", //newTexturePack
    "printTexturePacks", //printTexturePacks
    "printTexturePackInfo name", //printTexturePackInfo
    "mapTexturePack texturePackName objectName", //mapTexturePack
    "destroyTexturePack name", //destroyTexturePack
    "refreshTexturePack name", //refreshTexturePack
    "mapHeight textureName objectName", //mapHeight
    "resetMaps name", //resetMaps
    "segmentObject name count", //segmentObject
    "superposeGridSystem gridSystemName outlineColor cellSize objectName", //superposeGridSystem
    "postProcessing hide/show", //postProcessing
    "sliceGrid newName cellSize outlineColor", //sliceGrid
    "newPointLight name color offsetX offsetY offsetZ", //newPointLight
    "newSkybox name directory fileExtension", //newSkybox
    "printSkyboxes", //printSkyboxes
    "printSkyboxInfo name", //printSkyboxInfo
    "mapSkybox name", //mapSkybox
    "destroySkybox name", //destroySkybox
    "skybox show/hide", //skybox
    "scaleSkybox amount", //scaleSkybox
    "save", //save
    "load", //load
    "undo", //undo
    "redo", //redo
    "selectObject name", //selectObject
    "setMass name mass", //setMass
    "rotateObject name axis radian", //rotateObject
    "newScript name", //newScript
    "runScript name", //runScript
    "stopScript name", //stopScript
    "printScripts", //printScripts
    "editScript name", //editScript
    "destroyScript name", //destroyScript
    "translateObject name axis amount", //translateObject
    "setFog fogColor fogDensity", //setFog
    "removeFog", //removeFog
    "glue newName objectName[1],objectName[2],...objectName[n]", //glue
    "detach name", //detach
    "mark name offsetX offsetY offsetZ", //mark
    "unmark name", //unmark
    "printMarkedPoints", //printMarkedPoints
    "toggleMarkedPoints", //toggleMarkedPoints
    "runAutomatically scriptName", //runAutomatically
    "uploadScript scriptName filePath", //uploadScript
    "runManually scriptName", //runManually
    "physicsWorkerMode on/off", //physicsWorkerMode
    "printPhysicsWorkerMode", //printPhysicsWorkerMode
    "explain functionName", //explain
    "printScriptingFunctions", //printScriptingFunctions
    "printPerformance", //printPerformance
    "search textToSearch", // search
    "rescaleTexture textureName scale newTextureName", //rescaleTexture
    "rescaleTexturePack texturePackName scale newTexturePackName", //rescaleTexturePack
    "destroyImage imageName", //destroyImage
    "setBlending objectName mode", //setBlending
    "about", //about
    "resetKeyboardBuffer", //resetKeyboardBuffer
    "setWorldLimits minX minY minZ maxX maxY maxZ", //setWorldLimits
    "setBinSize size", //setBinSize
    "printWorldLimits", //printWorldLimits
    "printBinSize", //printBinSize
    "particleCollisionWorkerMode on/off", //particleCollisionWorkerMode
    "printParticleCollisionWorkerMode", //printParticleCollisionWorkerMode
    "particleSystemCollisionWorkerMode on/off", //particleSystemCollisionWorkerMode
    "printParticleSystemCollisionWorkerMode", //printParticleSystemCollisionWorkerMode
    "logFrameDrops", //logFrameDrops
    "addPaddingToTexture textureName padding newTextureName", //addPaddingToTexture
    "newSphere name material radius", //newSphere
    "printFogInfo", //printFogInfo
    "applyDisplacementMap objectName textureName scale bias", //applyDisplacementMap
    "setSlipperiness objectName on/off", //setSlipperiness
    "setAtlasTextureSize width height", //setAtlasTextureSize
    "printAtlasTextureSize", //printAtlasTextureSize
    "sync sourceObject targetObject", //sync
    "newArea areaName height", //newArea
    "toggleAreas", //toggleAreas
    "destroyArea areaName", //destroyArea
    "areaConfigurations show/hide", //areaConfigurations
    "setResolution resolution", //setResolution
    "configureArea areaName", //configureArea
    "newAreaConfiguration areaName objectName isVisible sides", //newAreaConfiguration
    "autoConfigureArea areaName", //autoConfigureArea
    "stopAreaConfigurations", //stopAreaConfigurations
    "startAreaConfigurations", //startAreaConfigurations
    "newCylinder name materialName topRadius bottomRadius height isOpenEnded", //newCylinder
    "setRotationPivot objectName offsetX offsetY offsetZ", //setRotationPivot
    "printChildPosition objectName childObjectName", //printChildPosition
    "unsetRotationPivot objectName", //unsetRotationPivot
    "copyObject sourceName targetName offsetX offsetY offsetZ isHardCopy", //copyObject
    "build projectName author", //build
    "skyboxConfigurations show/hide", //skyboxConfigurations
    "fogConfigurations show/hide", //fogConfigurations
    "noMobile on/off", //noMobile
    "setMaxViewport widthInPx heightInPx", //setMaxViewport
    "keepAspect ratio", //keepAspect
    "newFont fontName path", //newFont
    "destroyFont fontName", //destroyFont
    "printFonts", //printFonts
    "newText textName fontName maxCharacterLength offsetX offsetY offsetZ", //newText
    "selectText textName", //selectText
    "destroyText textName", //destroyText
    "printTexts" //printTexts
  ];
  commands = [
    "help",
    "newGridSystem",
    "printCameraPosition",
    "printCameraDirection",
    "printGridSystems",
    "printGridSystemInfo",
    "destroyGridSystem",
    "printKeyboardInfo",
    "printSelectedGrids",
    "resetSelectedGrids",
    "selectAllGrids",
    "cropGridSystem",
    "pasteCroppedGridSystem",
    "switchView",
    "newBasicMaterial",
    "printMaterials",
    "destroyMaterial",
    "newSurface",
    "printObjects",
    "printMetaData",
    "destroyObject",
    "newTexture",
    "printTextures",
    "destroyTexture",
    "mapTexture",
    "adjustTextureRepeat",
    "newPhysicsBoxTest",
    "newPhysicsSphereTest",
    "printPhysicsTests",
    "switchPhysicsDebugMode",
    "newRamp",
    "setAnchor",
    "restartPhysicsTest",
    "mirror",
    "newBox",
    "newWallCollection",
    "printWallCollections",
    "destroyWallCollection",
    "destroySelectedGrids",
    "remakeGridSystem",
    "resetCamera",
    "uploadImage",
    "printImages",
    "mapSpecular",
    "mapEnvironment",
    "mapAmbientOcculsion",
    "mapAlpha",
    "setDefaultMaterial",
    "newAmbientLight",
    "printLights",
    "selectLight",
    "destroyLight",
    "newPhongMaterial",
    "mapNormal",
    "mapEmissive",
    "newLambertMaterial",
    "newTexturePack",
    "printTexturePacks",
    "printTexturePackInfo",
    "mapTexturePack",
    "destroyTexturePack",
    "refreshTexturePack",
    "mapHeight",
    "resetMaps",
    "segmentObject",
    "superposeGridSystem",
    "postProcessing",
    "sliceGrid",
    "newPointLight",
    "newSkybox",
    "printSkyboxes",
    "printSkyboxInfo",
    "mapSkybox",
    "destroySkybox",
    "skybox",
    "scaleSkybox",
    "save",
    "load",
    "undo",
    "redo",
    "selectObject",
    "setMass",
    "rotateObject",
    "newScript",
    "runScript",
    "stopScript",
    "printScripts",
    "editScript",
    "destroyScript",
    "translateObject",
    "setFog",
    "removeFog",
    "glue",
    "detach",
    "mark",
    "unmark",
    "printMarkedPoints",
    "toggleMarkedPoints",
    "runAutomatically",
    "uploadScript",
    "runManually",
    "physicsWorkerMode",
    "printPhysicsWorkerMode",
    "explain",
    "printScriptingFunctions",
    "printPerformance",
    "search",
    "rescaleTexture",
    "rescaleTexturePack",
    "destroyImage",
    "setBlending",
    "about",
    "resetKeyboardBuffer",
    "setWorldLimits",
    "setBinSize",
    "printWorldLimits",
    "printBinSize",
    "particleCollisionWorkerMode",
    "printParticleCollisionWorkerMode",
    "particleSystemCollisionWorkerMode",
    "printParticleSystemCollisionWorkerMode",
    "logFrameDrops",
    "addPaddingToTexture",
    "newSphere",
    "printFogInfo",
    "applyDisplacementMap",
    "setSlipperiness",
    "setAtlasTextureSize",
    "printAtlasTextureSize",
    "sync",
    "newArea",
    "toggleAreas",
    "destroyArea",
    "areaConfigurations",
    "setResolution",
    "configureArea",
    "newAreaConfiguration",
    "autoConfigureArea",
    "stopAreaConfigurations",
    "startAreaConfigurations",
    "newCylinder",
    "setRotationPivot",
    "printChildPosition",
    "unsetRotationPivot",
    "copyObject",
    "build",
    "skyboxConfigurations",
    "fogConfigurations",
    "noMobile",
    "setMaxViewport",
    "keepAspect",
    "newFont",
    "destroyFont",
    "printFonts",
    "newText",
    "selectText",
    "destroyText",
    "printTexts"
  ];
  commandInfo = [
    "help: Prints command list.",
    "newGridSystem: Creates a new GridSystem.",
    "printCameraPosition: Prints the camera position.",
    "printCameraDirection: Prints the camera direction vector.",
    "printGridSystems: Prints existent grid system names.",
    "printGridSystemInfo: Prints a grid system information.",
    "destroyGridSystem: Destroys a grid system.",
    "printKeyboardInfo: Prints information about keyboard shortcuts.",
    "printSelectedGrids: Prints selected grid names.",
    "resetSelectedGrids: Resets all selected grids.",
    "selectAllGrids: Select all grids of a grid system.",
    "cropGridSystem: Crops selected part of a grid system.",
    "pasteCroppedGridSystem: Draws a cropped grid system.",
    "switchView: Switches between views (design/preview).",
    "newBasicMaterial: Creates a new basic material.",
    "printMaterials: Prints created materials.",
    "destroyMaterial: Destroys a material.",
    "newSurface: Creates a new surface.",
    "printObjects: Prints objects.",
    "printMetaData: Prints the metadata of an object.",
    "destroyObject: Destroys an object",
    "newTexture: Creates a new texture.",
    "printTextures: Prints textures.",
    "destroyTexture: Destroys a texture.",
    "mapTexture: Maps a diffuse/color texture to an object.",
    "adjustTextureRepeat: Modifies the repeat amount of a texture/texture pack.",
    "newPhysicsBoxTest: Simulates a box in a physical world.",
    "newPhysicsSphereTest: Simulates a sphere in a physical world.",
    "printPhysicsTests: Prints physics tests statuses.",
    "switchPhysicsDebugMode: Switches physics debug mode (on/off).",
    "newRamp: Creates a new inclined plane.",
    "setAnchor: Sets an anchor grid.",
    "restartPhysicsTest: Restarts a physics test.",
    "mirror: Sets on/off a mapped textures mirrored repeat property.",
    "newBox: Creates a new box.",
    "newWallCollection: Creates a new wall collection, a set of grid systems.",
    "printWallCollections: Prints created wall collections.",
    "destroyWallCollection: Destroys a wall collection.",
    "destroySelectedGrids: Destroys selected grids.",
    "remakeGridSystem: Remakes destroyed grids of a grid system.",
    "resetCamera: Resets camera position and rotation.",
    "uploadImage: Uploads an image from the local filesystem (TGA images not supported).",
    "printImages: Prints uploaded images.",
    "mapSpecular: Sets a specular map of an object.",
    "mapEnvironment: Sets an environment map of an object.",
    "mapAmbientOcculsion: Sets an ambient occulsion map of an object.",
    "mapAlpha: Sets an alpha map of an object.",
    "setDefaultMaterial: Sets the type of the default material (basic/phong).",
    "newAmbientLight: Creates a new ambient light.",
    "printLights: Prints created lights.",
    "selectLight: Selects a created light.",
    "destroyLight: Destroys a created light.",
    "newPhongMaterial: Creates a new Phong material (light sensitive).",
    "mapNormal: Sets a normal map of an object.",
    "mapEmissive: Sets an emissive map of an object.",
    "newLambertMaterial: Creates a new Lambert material (light sensitive).",
    "newTexturePack: Cretes a new Texture Pack.",
    "printTexturePacks: Prints created texture packs.",
    "printTexturePackInfo: Prints information about a texture pack.",
    "mapTexturePack: Maps a texture pack to an object.",
    "destroyTexturePack: Destroys a texture pack.",
    "refreshTexturePack: Reloads a texture pack.",
    "mapHeight: Set a displacement/height map of an object.",
    "resetMaps: Resets all textures of an object.",
    "segmentObject: Segments an object (width/height/depth).",
    "superposeGridSystem: Creates a new grid system above a specific object.",
    "postProcessing: Shows/hides post processing effects GUI.",
    "sliceGrid: Slices a grid into equal parts and creates a new Grid System with the pieces.",
    "newPointLight: Creates a new point light.",
    "newSkybox: Creates a new Skybox",
    "printSkyboxes: Prints created skyboxes.",
    "printSkyboxInfo: Prints information about a Skybox.",
    "mapSkybox: Maps a Skybox to the scene.",
    "destroySkybox: Destroys a Skybox.",
    "skybox: Shows/hides the skybox cube.",
    "scaleSkybox: Modifies the scale of the Skybox cube.",
    "save: Saves the current state of the engine as a JSON file and initiates the download process.",
    "load: Loads a project saved in JSON format (via the save command).",
    "undo: Undo the last successful command.",
    "redo: Redo the last successful command.",
    "selectObject: Selects an object.",
    "setMass: Sets the mass of an object.",
    "rotateObject: Rotates an object around given axis.",
    "newScript: Creates a new script.",
    "runScript: Runs a script.",
    "stopScript: Stops a running script.",
    "printScripts: Prints created scripts.",
    "editScript: Edits a script.",
    "destroyScript: Destroys a script.",
    "translateObject: Translates an object along given axis.",
    "setFog: Sets the fog attributes of the scene.",
    "removeFog: Removes the fog from the scene.",
    "glue: Creates a new object, gluing given objects together.",
    "detach: Detaches a group of objects glued together using the glue command.",
    "mark: Marks a specific point.",
    "unmark: Unmarks a marked point.",
    "printMarkedPoints: Prints marked points.",
    "toggleMarkedPoints: Hides or shows the marked points on the screen.",
    "runAutomatically: Makes a script start automatically when switched to the preview mode.",
    "uploadScript: Uploads a script from the local file system.",
    "runManually: Makes a script wait for the runScript command to start the execution.",
    "physicsWorkerMode: Enables or disables the usage of web workers for physics iterations.",
    "printPhysicsWorkerMode: Prints if the physics web worker is enabled or not.",
    "explain: Prints information about given scripting API function.",
    "printScriptingFunctions: Prints a list of ROYGBIV scripting API functions.",
    "printPerformance: Prints the performance of rendering functions for the last rendered frame.",
    "search: Finds related commands.",
    "rescaleTexture: Rescales a texture and creates a new texture from the rescaled version.",
    "rescaleTexturePack: Rescales a texture pack and creates a new texture pack from the rescaled version.",
    "destroyImage: Destroys an uploaded image.",
    "setBlending: Sets the blending mode of an object. Mode can be one of NO_BLENDING, NORMAL_BLENDING, ADDITIVE_BLENDING, SUBTRACTIVE_BLENDING,\n  MULTIPLY_BLENDING.",
    "about: Prints info about this engine.",
    "resetKeyboardBuffer: Resets the keyboard buffer.",
    "setWorldLimits: Sets the limits of the scene. Objects outside of this limit will be ignored for collisions with particles/particle systems\n  and area calculations.",
    "setBinSize: Sets the size of the bin. Bins are imaginary cubes that split the scene into segments to help particle/particle system\n  collision detections and area calculations.Larger the size worse the performance but better the collision detection performs\n  for fast particles.",
    "printWorldLimits: Prints the limit info of the world. Objects outside of this limit will be ignored for collisions with particles/particle systems.",
    "printBinSize: Prints the size of the bin. Bins are imaginary cubes that split the scene into segments to help particle collision detections.",
    "particleCollisionWorkerMode: Enables or disables the usage of web workers for particle collision detection.",
    "printParticleCollisionWorkerMode: Prints if the particle collision web worker is enabled or not.",
    "particleSystemCollisionWorkerMode: Enables or disables the usage of web workers for particle system collision detection.",
    "printParticleSystemCollisionWorkerMode: Prints if the particle system collision web worker is enabled or not.",
    "logFrameDrops: Records frame drops for a minute and prints exactly how many frames are missed within a minute to Javascript console.",
    "addPaddingToTexture: Adds padding to a texture. This can be useful for crosshair rotations to prevent visual errors.",
    "newSphere: Creates a new sphere.",
    "printFogInfo: Prints the fog info.",
    "applyDisplacementMap: Applies a displacement map to an object and modifies its geometry.",
    "setSlipperiness: Sets the slipperiness of an object.",
    "setAtlasTextureSize: Sets the size of each texture/texture pack when creating object groups.",
    "printAtlasTextureSize: Prints the atlas texture size set with setAtlasTextureSize command.",
    "sync: Sets the material properties of the target object according to the source object.",
    "newArea: Creates a new area.",
    "toggleAreas: Show/hides the areas.",
    "destroyArea: Destroys an area.",
    "areaConfigurations: Show/hides the area configuration window.",
    "setResolution: Sets the screen resolution.",
    "configureArea: Shows the area configuration window for a certain area.",
    "newAreaConfiguration: Creates a new area configuration for an area and object.",
    "autoConfigureArea: Automatically configures an area using ray tests. Manual corrections may be necesary after using this command.",
    "stopAreaConfigurations: Stops area configurations handling.",
    "startAreaConfigurations: Starts area configurations handling.",
    "newCylinder: Creates a new cylinder.",
    "setRotationPivot: Defines a pivot point of rotation for an object in its local axis system.",
    "printChildPosition: Prints the world position of a child object of an object group.",
    "unsetRotationPivot: Unsets the rotation pivot point of an object set by using setRotationPivot command.",
    "copyObject: Creates a clone of an object.",
    "build: Builds the project for release.",
    "skyboxConfigurations: Shows/hides the skybox configuration GUI.",
    "fogConfigurations: Shows/hides the fog configuration GUI.",
    "noMobile: Prevents the application from loading and alerts a warning message in deployment mode for mobile devices if used with on parameter.",
    "setMaxViewport: Sets the maximum viewport of the renderer. Use 0 or a negative number for unlimited width/height.",
    "keepAspect: Modifies the renderer aspect in the browser of the client in a way where width/height = ratio. If ratio<0 the aspect is not kept.",
    "newFont: Creates a new font.",
    "destroyFont: Destroys a font.",
    "printFonts: Prints all created fonts.",
    "newText: Allocates a new text object.",
    "selectText: Selects a text for modification.",
    "destroyText: Destroys a text.",
    "printTexts: Prints a list of created texts."
  ];
  keyboardInfo = [
    "W/S : Translates the camera on axis Z.",
    "A/D : Translates the camera on axis X.",
    "Up/Down : Rotates the camera around axis X.",
    "Left/Right : Rotates the camera around axis Y.",
    "E/Q : Translates the camera on axis Y.",
    "Z/C: Rotates the camera around axis Z.",
    "Backspace: Destroys selected object.",
    ". : Shows corner coordinates of selected grids.",
    "SHIFT: Activates grid selection mode.",
    "TE: Opens the ROYGBIV terminal if closed."
  ];

  deprecatedCommandIndices = [
    26, //newPhysicsBoxTest -> Deprecated due to lack of use cases. This command is implemented to test if the physics bodies fit the meshes. After the implementation of switchPhysicsDebugMode, this command is no longer needed.
    27, //newPhysicsSphereTest -> Deprecated due to lack of use cases. This command is implemented to test if the physics bodies fit the meshes. After the implementation of switchPhysicsDebugMode, this command is no longer needed.
    28, //printPhysicsTests -> Since box and sphere physics tests are deprecated, this command is no longer needed.
    32, //restartPhysicsTest -> Since box and sphere physics tests are deprecated, this command is no longer needed.
    38, //destroySelectedGrids -> Deprecated due to architectural changes during development. Grids are no longer rendered as seperate objects due to performance issues.
    39, //remakeGridSystem -> Deprecated due to architectural changes during development. Since grids are no longer destroyable, this command has no use case anymore.
    43, //mapSpecular -> Specular maps are not supported for now.
    44, //mapEnvironment -> Deprecated due to lack of use cases of environment maps in the ROYGBIV engine. Will implement mirror materials for better visual effects.
    47, //setDefaultMaterial -> Only BASIC materials are supported for now.
    48, //newAmbientLight -> Lights are not supported for now.
    49, //printLights -> Lights are not supported for now.
    50, //selectLight -> Lights are not supported for now.
    51, //destroyLight -> Lights are not supported for now.
    52, //newPhongMaterial -> Phong materials are not supported for now.
    53, //mapNormal -> Normal maps are not supported for now.
    55, //newLambertMaterial -> Deprecated due to lack of uses cases. Phong is fine for light affected objects.
    68, //newPointLight -> Lights are not supported for now.
    78, //undo -> Deprecated because causes memory issues for big projects.
    79, //redo -> Deprecated because causes memory issues for big projects.
    89, //translateObject -> Deprecated due to architectural conflicts. Objects can only be translated using animations. Instead of translating the object in the design mode, a new grid system should be created at the specific position. Every object should be associated with certain grids.
    105, //printPerformance -> Deprecated because calling performance.now() multiple times on each render is costly.
    121, //logFrameDrops -> No need for such functionality after the usage of Stats.js
    125, //applyDisplacementMap -> Deprecated because causes problems with geometry caching.
    127, //setAtlasTextureSize -> Deprecated because has no use cases after deprecation of TextureMerger class
    128 //printAtlasTextureSize -> Deprecated due to same reasons as setAtlasTextureSize
  ];

  if (commandInfo.length != commands.length){
    console.error("CommandInfo & commands mismatch");
  }
  if (commandArgumentsExpectedCount.length != commands.length){
    console.error("commandArgumentsExpectedCount & commands mismatch");
    console.error(commandArgumentsExpectedCount.length+", "+commands.length);
  }

  for (var i=0; i<commands.length; i++){
    var splitted = commandArgumentsExpectedExplanation[i].split(" ");
    if (splitted.length != (commandArgumentsExpectedCount[i] + 1)){
      console.error("commandArgumentsExpectedExplanation commandArgumentsExpectedCount mismatch: "+i);
    }
  }
}

// VERSION
var ROYGBIV_ENGINE_VERSION = 1;

//IMAGE UPLOADER
var imageUploaderInput;

// LOAD
var loadInput;

// WINDOW
var windowLoaded;
var cliFocused = true;
var omGUIFocused = false;
var tmGUIFocused = false;
var cliIsBeingDragged = false;
var requestID;
var boundingClientRect;
var pointerLockSupported = false;
var defaultAspect = 1.9174434087882823;
var onFullScreen = false;
var isScreenVisible = true;
var inactiveCounter = 0;
var maxInactiveTime = 0;

// STATS.JS
var stats;
var fpsHandler;

// THREE.JS VARIABLES
var renderer;
var scene;
var camera;
var canvas;
var sceneBackgroundColor = 0x000000 ;
var textureLoader = new THREE.TextureLoader();
var tgaLoader = new THREE.TGALoader();
var ddsLoader = new THREE.DDSLoader();
var axesHelper = new THREE.AxesHelper(20000);
var pointerLockRequested = false;
var fullScreenRequested = false;
var viewportMaxWidth = 0;
var viewportMaxHeight = 0;
var currentViewport = new Object();
var fixedAspect = 0;

// PHYSICS
var debugRenderer;
var physicsWorld = new CANNON.World();
var physicsSolver = new CANNON.GSSolver();
var quatNormalizeSkip = 0;
var quatNormalizeFast = false;
var contactEquationStiffness = 1e9;
var contactEquationRelaxation = 4;
var physicsIterations = 7;
var physicsTolerance = 0.1;
var gravityY = -900;
var physicsStepAmount = 1/60;
var friction = 1;
var surfacePhysicalThickness = 1;

// POST PROCESSING
var renderPass;
var copyPass;
var composer;
var bloomPass;
var bloomStrength = 0.4; // 0 - 3
var bloomRadius = 0; // 0 - 1
var bloomThreshold = 1; // 0 - 1
var bloomResolutionScale = 1; // 0.1 - 1
var bloomOn = false;
var originalBloomConfigurations = new Object();

// CAMERA CONFIGURATIONS
var initialCameraX = 0;
var initialCameraY = 50;
var initialCameraZ = 0;
var rotationYDelta = 0.07;
var rotationXDelta = 0.07;
var rotationZDelta = 0.07;
var translateZAmount = 3;
var translateXAmount = 3;
var translateYAmount = 3;

// FOG
var fogActive = false;
var fogColor = "black";
var fogDensity = 0;
var fogColorRGB = new THREE.Color(fogColor);
var fogBlendWithSkybox = false;

// ENGINE VARIABLES
var keyboardBuffer = new Object();
var cameraRotationBuffer = {
  "x": 0,
  "y":0,
  "z": 0
}
var gridSystems = new Object();
var gridSelections = new Object();
var materials = new Object();
var addedObjects = new Object();
var addedTexts = new Object();
var addedTexts2D = new Object();
var clickableAddedTexts = new Object();
var clickableAddedTexts2D = new Object();
var textures = new Object();
var textureURLs = new Object();
var wallCollections = new Object();
var uploadedImages = new Object();
var modifiedTextures = new Object();
var texturePacks = new Object();
var skyBoxes = new Object();
var scripts = new Object();
var scriptsToRun = new Object();
var objectGroups = new Object();
var disabledObjectNames = new Object();
var markedPoints = new Object();
var collisionCallbackRequests = new Object();
var particleCollisionCallbackRequests = new Object();
var particleSystemCollisionCallbackRequests = new Object();
var particleSystems = new Object();
var mergedParticleSystems = new Object();
var particleSystemPool = new Object();
var particleSystemPools = new Object();
var objectTrails = new Object();
var activeObjectTrails = new Object();
var dynamicObjects = new Object();
var dynamicObjectGroups = new Object();
var addedObjectsInsideGroups = new Object();
var trackingObjects = new Object();
var ShaderContent;
var commandDescriptor;
var ColorNames;
var anchorGrid = 0;
var croppedGridSystemBuffer;
var mode = 0; // 0 -> DESIGN, 1-> PREVIEW
var PHYSICS_TEST_TYPE_BOX = "BOX", PHYSICS_TEST_TYPE_SPHERE = "SPHERE";
var physicsTestObjectMaterialColor = 0xFFFFFF;
var physicsDebugMode = false;
var textureOffsetAdjustmentDX = 0.01;
var textureOffsetAdjustmentDY = 0.01;
var opacityDelta = 0.01;
var heightMapScaleDelta = 0.1;
var heightMapBiasDelta = 0.1;
var superposeYOffset = 1;
var shininessDelta = 1;
var selectedAddedObject = 0;
var selectedObjectGroup = 0;
var selectedAddedText = 0;
var planeWidthSegments = 10;
var planeHeightSegments = 10;
var boxWidthSegments = 10;
var boxHeightSegments = 10;
var boxDepthSegments = 10;
var sphereWidthSegments = 10;
var sphereHeightSegments = 10;
var cylinderWidthSegments = 10;
var cylinderHeightSegments = 10;
var defaultMaterialType = "BASIC"; //BASIC / PHONG
var texturePackRootDirectory = "texture_packs/";
var skyBoxRootDirectory = "skybox/";
var dataPrefix = "text/json;charset=utf-8,";
var skyboxDistance = 4000;
var skyboxMesh;
var skyboxPreviewMesh;
var skyboxVisible = false;
var skyboxConfigurationsVisible = false;
var fogConfigurationsVisible = false;
var mappedSkyboxName = 0;
var gridCounter = 0;
var MAX_GRIDS_ALLOWED = 1000000;
var MIN_CELLSIZE_ALLOWED = 5;
var diffuseTextureCache = new Object();
var heightTextureCache = new Object();
var ambientOcculsionTextureCache = new Object();
var alphaTextureCache = new Object();
var emissiveTextureCache = new Object();
var CACHE_NOT_PRESENT = "CACHE_NOT_PRESENT";
var THREE_AXIS_VECTOR_X = new THREE.Vector3(1, 0, 0);
var THREE_AXIS_VECTOR_Y = new THREE.Vector3(0, 1, 0);
var THREE_AXIS_VECTOR_Z = new THREE.Vector3(0, 0, 1);
var CANNON_AXIS_VECTOR_X = new CANNON.Vec3(1, 0, 0);
var CANNON_AXIS_VECTOR_Y = new CANNON.Vec3(0, 1, 0);
var CANNON_AXIS_VECTOR_Z = new CANNON.Vec3(0, 0, 1);
var CANNON_ZERO_VECTOR = new CANNON.Vec3(0, 0, 0);
var REUSABLE_CANNON_QUATERNION = new CANNON.Quaternion();
var REUSABLE_CANNON_QUATERNION_2 = new CANNON.Quaternion();
var scriptEditorShowing = false;
var NO_BLENDING = THREE.NoBlending;
var NORMAL_BLENDING = THREE.NormalBlending;
var ADDITIVE_BLENDING = THREE.AdditiveBlending;
var SUBTRACTIVE_BLENDING = THREE.SubtractiveBlending;
var MULTIPLY_BLENDING = THREE.MultiplyBlending;
var COLLISION_BOUNDING_BOX = new THREE.Box3();
var REUSABLE_LINE = new THREE.Line3();
var REUSABLE_VECTOR = new THREE.Vector3();
var REUSABLE_VECTOR_2 = new THREE.Vector3();
var REUSABLE_VECTOR_3 = new THREE.Vector3();
var REUSABLE_VECTOR_4 = new THREE.Vector3();
var REUSABLE_VECTOR_5 = new THREE.Vector3();
var REUSABLE_VECTOR_6 = new THREE.Vector3();
var REUSABLE_VECTOR_7 = new THREE.Vector3();
var REUSABLE_2_VECTOR = new THREE.Vector2();
var REUSABLE_CANNON_VECTOR = new CANNON.Vec3();
var REUSABLE_CANNON_VECTOR_2 = new CANNON.Vec3();
var REUSABLE_MATRIX_3 = new THREE.Matrix3();
var REUSABLE_MATRIX_4 = new THREE.Matrix4();
var REUSABLE_QUATERNION = new THREE.Quaternion();
var REUSABLE_QUATERNION2 = new THREE.Quaternion();
var REUSABLE_COLOR = new THREE.Color();
var MAX_VERTICES_ALLOWED_IN_A_PARTICLE_SYSTEM = 1000000;
var tempSlicedGridExport;
var ALPHA_VARIATION_MODE_NORMAL = 0;
var ALPHA_VARIATION_MODE_SIN = 1;
var ALPHA_VARIATION_MODE_COS = 2;
var MOTION_MODE_NORMAL = 0;
var MOTION_MODE_CIRCULAR = 1;
var OBJECT_TRAIL_MAX_TIME_IN_SECS_DEFAULT = 0.25;
var cameraOperationsDone = false;
var LIMIT_BOUNDING_BOX = new THREE.Box3(new THREE.Vector3(-4000, -4000, -4000), new THREE.Vector3(4000, 4000, 4000));
var DEFAULT_OBJECT_OCTREE_SEGMENTS = 2;
var DEFAULT_OCTREE_MAX_DEPTH = 8;
var BIN_SIZE = 50;
var INTERSECTION_NORMAL = new THREE.Vector3();
var MAX_PARTICLE_SYSTEM_COUNT = 1000; // MUST BE DIVISIBLE BY 10
var MAX_PARTICLE_COLLISION_LISTEN_COUNT = 10000;
var TOTAL_PARTICLE_SYSTEM_COUNT = 0;
var TOTAL_PARTICLE_COLLISION_LISTEN_COUNT = 0;
var TOTAL_PARTICLE_SYSTEM_COLLISION_LISTEN_COUNT = 0;
var PARTICLE_POSITION_HISTORY_SIZE = 2;
var MAX_OBJECT_SEGMENT_COUNT = 200;
var MAX_PARTICLE_SYSTEMS_WITH_PARTICLE_COLLISIONS = 50;
var TOTAL_PARTICLE_SYSTEMS_WITH_PARTICLE_COLLISIONS = 0;
var SCRIPT_STATUS_STARTED = 1;
var SCRIPT_STATUS_STOPPED = 2;
var SCRIPT_STATUS_ERROR = 0;
var MESSAGE_TYPE_BASIC = 0;
var MESSAGE_TYPE_BUFFER = 1;
var UNDEFINED = "undefined";
var PIPE = "|";
var mergedTextureCache = new Object();
var reusableCollisionInfo = new CollisionInfo();
var TOTAL_OBJECT_COLLISION_LISTENER_COUNT = 0;
var MAX_OBJECT_COLLISION_LISTENER_COUNT = 50;
var MAX_VERTEX_UNIFORM_VECTORS;
var MAX_PS_COMPRESS_AMOUNT_4096 = 200;
var TOTAL_MERGED_COUNT = 0;
var MAX_TEXTURE_SIZE = 4096;
var MAX_PS_TIME = 100000;
var crosshairs = new Object();
var selectedCrosshair;
var GLOBAL_FOG_UNIFORM = new THREE.Uniform(new THREE.Vector4(-100.0, 0, 0, 0));
var GLOBAL_PROJECTION_UNIFORM = new THREE.Uniform(new THREE.Vector3());
var GLOBAL_VIEW_UNIFORM = new THREE.Uniform(new THREE.Matrix4());
var GLOBAL_CAMERA_POSITION_UNIFORM = new THREE.Uniform(new THREE.Vector3());
var GLOBAL_CAMERA_QUATERNION_UNIFORM = new THREE.Uniform(new THREE.Quaternion());
var GLOBAL_CUBE_TEXTURE_UNIFORM;
var GLOBAL_ADDEDTEXT_VIEWPORT_UNIFORM = new THREE.Uniform(new THREE.Vector4(0, 0, window.innerWidth, window.innerHeight));
var GLOBAL_SKYBOX_ALPHA_UNIFORM = new THREE.Uniform(1.0);
var VERTEX_SHADER_TEXTURE_FETCH_SUPPORTED;
var DDS_SUPPORTED;
var INSTANCING_SUPPORTED;
var jobHandlerSelectedGrid = 0;
var jobHandlerWorking = false;
var geometryCache = new Object();
var physicsShapeCache = new Object();
var MAX_TEXTURE_COUNT = 8;
var nullTexture;
var nullCubeTexture;
var compressedTextureFallbackFormat = ".png";
var areaBinHandler;
var areas = new Object();
var areasVisible = true;
var areaConfigurationsVisible = false;
var areaConfigurationsHandler;
var markedPointsVisible = true;
var frustum = new THREE.Frustum();
var SIDE_BOTH = "Both";
var SIDE_FRONT = "Front";
var SIDE_BACK = "Back";
var textureUniformCache = new Object();
var screenResolution = 1;
var rayCaster;
var objectPicker2D;
var intersectionPoint = 0;
var intersectionObject = 0;
var projectLoaded = true;
var stopAreaConfigurationsHandler = false;
var jobHandlerInternalCounter = 0;
var jobHandlerInternalMaxExecutionCount = 0;
var screenClickCallbackFunction = 0;
var screenMouseDownCallbackFunction = 0;
var screenMouseUpCallbackFunction = 0;
var screenMouseMoveCallbackFunction = 0;
var screenPointerLockChangedCallbackFunction = 0;
var screenFullScreenChangeCallbackFunction = 0;
var screenKeydownCallbackFunction = 0;
var screenKeyupCallbackFunction = 0;
var userInactivityCallbackFunction = 0;
var fpsDropCallbackFunction = 0;
var performanceDropCallbackFunction = 0;
var defaultCameraControlsDisabled = false;
var modeSwitcher;
var isMouseDown = false;
var projectName = "psShowcase";
var author = "oguz";
var loadedScriptsCounter = 0;
var isMobile = /Mobi|Android/i.test(navigator.userAgent);
var WHITE_COLOR = new THREE.Color("white");
var LIME_COLOR = new THREE.Color("lime");
var ORANGE_COLOR = new THREE.Color("orange");
var NO_MOBILE = false;
var isPaused = false;
var defaultFont;
var fonts = new Object();
var MAX_TEXT_CHAR_COUNT = 64;
var DEFAULT_OFFSET_BETWEEN_CHARS = 20;
var DEFAULT_OFFSET_BETWEEN_LINES = 20;
var MARGIN_MODE_2D_TEXT_TOP_LEFT = 0;
var MARGIN_MODE_2D_TEXT_BOTTOM_RIGHT = 1;
var roygbivAttributeCounter = 1;
var roygbivBufferAttributeCounter = 1;
var roygbivSkippedArrayBufferUpdates = 0;
var roygbivSkippedElementArrayBufferUpdates = 0;
var selectionHandler;
var guiHandler;

// WORKER VARIABLES
var WORKERS_SUPPORTED = (typeof(Worker) !== "undefined");
var WORKERS_DEBUG_MODE_ENABLED = false;
var PHYSICS_WORKER_PATH = "/js/worker/physicsWorker.js";
var COLLISION_WORKER_PATH = "/js/worker/collisionWorker.js";
var PS_COLLISION_WORKER_PATH = "/js/worker/psCollisionWorker.js";
var PHYSICS_WORKER_ENABLED = true;
var COLLISION_WORKER_ENABLED = true;
var PS_COLLISION_WORKER_ENABLED = true;

// TEXT POOL
var Text = (!isDeployment)? new Text(): 0;

// SCRIPTING UTILITY FUNCTIONS
var ROYGBIV;

// DAT GUI
var datGui;
var datGuiObjectManipulation;
var datGuiTextManipulation;
var datGuiAreaConfigurations;
var datGuiSkybox;
var datGuiFog;
var omGUIlastObjectName = "";

var postprocessingParameters = {
  "Bloom_strength": bloomStrength,
  "Bloom_radius": bloomRadius,
  "Bloom_threshhold": bloomThreshold,
  "Bloom_resolution_scale": bloomResolutionScale,
  "Bloom": bloomOn
};

var omObjController;
var omRotationXController;
var omRotationYController;
var omRotationZController;
var omMassController;
var omSlipperyController;
var omChangeableController;
var omColorizableController;
var omHasMassController;
var omSideController;
var omHideHalfController;
var omBlendingController;
var omTextureOffsetXController;
var omTextureOffsetYController;
var omOpacityController;
var omAOIntensityController;
var omEmissiveIntensityController;
var omEmissiveColorController;
var omDisplacementScaleController;
var omDisplacementBiasController;
var objectManipulationParameters = {
  "Object": "objectName",
  "Rotate x": 0.0,
  "Rotate y": 0.0,
  "Rotate z": 0.0,
  "Mass": 0.0,
  "Slippery": false,
  "Changeable": false,
  "Colorizable": false,
  "Has mass": true,
  "Side": "Both",
  "Hide half": "None",
  "Blending": "None",
  "Texture offset x": 0.0,
  "Texture offset y": 0.0,
  "Opacity": 1.0,
  "AO intensity": 0.0,
  "Emissive int.": 0.0,
  "Emissive col.": "#ffffff",
  "Disp. scale": 0.0,
  "Disp. bias": 0.0
};

var skyboxNameController;
var skyboxColorController;
var skyboxParameters = {
  "Name": "skyboxName",
  "Color": "#ffffff"
};

var textManipulationController;
var textManipulationTextNameController;
var textManipulationContentController;
var textManipulationTextColorController;
var textManipulationAlphaController;
var textManipulationHasBackgroundController;
var textManipulationBackgroundColorController;
var textManipulationBackgroundAlphaController;
var textManipulationCharacterSizeController;
var textManipulationCharacterMarginController;
var textManipulationLineMarginController;
var textManipulationClickableController;
var textManipulationAffectedByFogController;
var textManipulationIs2DController;
var textManipulationMarginModeController;
var textManipulationMarginXController;
var textManipulationMarginYController;
var textManipulationMaxWidthPercentController;
var textManipulationMaxHeightPercentController;
var textManipulationParameters = {
  "Text": "textName",
  "Content": "",
  "Text color": "#ffffff",
  "Alpha": 0.0,
  "Has bg": false,
  "Bg color": "#ffffff",
  "Bg alpha": 0.0,
  "Char size": 0.0,
  "Char margin": 0.0,
  "Line margin": 0.0,
  "Clickable": false,
  "Aff. by fog": false,
  "is 2D": false,
  "Margin mode": "Top/Left",
  "Margin X": 50.0,
  "Margin Y": 50.0,
  "Max width%": 100,
  "Max height%": 100
}

var fogDensityController;
var fogColorController;
var fogBlendWithSkyboxController;
var fogParameters = {
  "Density": 0.0,
  "Color": "#ffffff",
  "Blend skybox": false
};

// KEYCODE TO STRING MAP
keyCodeToChar = {
  8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause/Break",20:"Caps Lock",
  27:"Esc",32:"Space",33:"Page Up",34:"Page Down",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",
  40:"Down",45:"Insert",46:"Delete",48:"0",49:"1",50:"2",51:"3",52:"4",53:"5",54:"6",55:"7",56:"8",
  57:"9",65:"A",66:"B",67:"C",68:"D",69:"E",70:"F",71:"G",72:"H",73:"I",74:"J",75:"K",76:"L",77:"M",
  78:"N",79:"O",80:"P",81:"Q",82:"R",83:"S",84:"T",85:"U",86:"V",87:"W",88:"X",89:"Y",90:"Z",91:"Windows",
  93:"Right Click",96:"Numpad 0",97:"Numpad 1",98:"Numpad 2",99:"Numpad 3",100:"Numpad 4",101:"Numpad 5",
  102:"Numpad 6",103:"Numpad 7",104:"Numpad 8",105:"Numpad 9",106:"Numpad *",107:"Numpad +",109:"Numpad -",
  110:"Numpad .",111:"Numpad /",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",
  120:"F9",121:"F10",122:"F11",123:"F12",144:"Num Lock",145:"Scroll Lock",182:"My Computer",
  183:"My Calculator",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",
  219:"[",220:"\\",221:"]",222:"'"
};

// SUPPORTED FONT ATLAS CHARACTERS
var supportedFontAtlasChars = [
  "!", "\"", "#", "$", "%", "&", "\'", "(", ")", "*", "+", ",", "-", ".", "/",
  "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ":", ";", "<", "=", ">", "?",
  "@", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O",
  "P", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "[", "\\", "]", "^", "_", "`",
  "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p",
  "r", "s", "t", "u", "v", "w", "x", "y", "z", "{", "|", "}", "~"
];
var supportedFontCharMap = new Object();
for (var i = 0; i<supportedFontAtlasChars.length; i++){
  supportedFontCharMap[supportedFontAtlasChars[i]] = true;
}

// BANNER
var BANNERL1 = " ____   _____   ______ ____ _____     __ ";
var BANNERL2 = "|  _ \\ / _ \\ \\ / / ___| __ )_ _\\ \\   / / ";
var BANNERL3 = "| |_) | | | \\ V / |  _|  _ \\| | \\ \\ / /  ";
var BANNERL4 = "|  _ <| |_| || || |_| | |_) | |  \\   /   ";
var BANNERL5 = "|_| \\_\\\\___/ |_| \\____|____/___|  \\_/    ";

/*
  CONSTRUCTOR PARAMETERS
    name -> name of this grid.
    parentName -> name of the GridSystem to which this Grid belongs
    startX -> upper left corner X coordinate
    startY -> upper left corner Y coordinate
    startZ -> upper left corner Z coordinate
    size -> size of this grid
    outlineColor -> X11 color name
    colNumber -> column number inside the grid system
    rowNumber -> row number inside the grid system
*/
var Grid = function(name, parentName, startX, startY, startZ, size,
                              outlineColor, colNumber, rowNumber, axis){
  this.name = name;
  this.parentName = parentName;
  this.startX = startX;
  this.startY = startY;
  this.startZ = startZ;
  this.size = size;
  this.outlineColor = outlineColor;
  this.selected = false;

  this.colNumber = colNumber;
  this.rowNumber = rowNumber;

  this.axis = axis;

  this.status = "ACTIVE";

  this.parentDestroyed = false;

  this.frustum = new THREE.Frustum();

  if (this.axis == "XZ"){

    this.centerX = startX + (size / 2);
    this.centerY = startY;
    this.centerZ = startZ - (size / 2);

  }else if (this.axis == "XY"){

    this.centerX = startX + (size / 2);
    this.centerY = startY - (size / 2);
    this.centerZ = startZ;

  }else if (this.axis == "YZ"){
    this.centerX = startX;
    this.centerY = startY - (size / 2);
    this.centerZ = startZ + (size / 2);
  }

  if (this.outlineColor != "red"){
    this.dotColor = "red";
  }else{
    this.dotColor = "white";
  }

}

Grid.prototype.makeMesh = function(size, startX, startY, startZ){
  this.material = new THREE.MeshBasicMaterial({color: this.outlineColor,
    side: THREE.DoubleSide,
    transparent: true,
    opacity:0.8
  });
  var geomKey = (
    "PlaneGeometry" + PIPE +
    size + PIPE + size + PIPE +
    "undefined" + PIPE + "undefined"
  );
  this.geometry = geometryCache[geomKey];
  if (!this.geometry){
    this.geometry = new THREE.PlaneGeometry(size, size);
    geometryCache[geomKey] = this.geometry;
  }
  this.mesh = new THREE.Mesh(this.geometry, this.material);
  this.mesh.renderOrder = 10;
  this.mesh.gridSystemName = this.parentName;
  if (this.axis == "XZ"){

    this.mesh.position.x = startX + (size / 2);
    this.mesh.position.y = startY;
    this.mesh.position.z = startZ - (size / 2);

  }else if (this.axis == "XY"){

    this.mesh.position.x = startX + (size / 2);
    this.mesh.position.y = startY - (size / 2);
    this.mesh.position.z = startZ;

  }else if (this.axis == "YZ"){

    this.mesh.position.x = startX;
    this.mesh.position.y = startY - (size / 2);
    this.mesh.position.z = startZ + (size / 2);

  }

  if (this.axis == "XZ"){
    this.mesh.rotation.x = Math.PI / 2;
  }else if (this.axis == "XY"){

  }else if (this.axis == "YZ"){
    this.mesh.rotation.y = Math.PI / 2;
  }

  this.centerDotGeometry = new THREE.Geometry();
  this.centerDotGeometry.vertices.push(new THREE.Vector3(this.centerX, this.centerY, this.centerZ));
  this.centerDotMaterial = new THREE.PointsMaterial( { color: this.dotColor, size: 4, sizeAttenuation: false } );
  this.dot = new THREE.Points( this.centerDotGeometry, this.centerDotMaterial);
  this.dot.renderOrder = 10;
  this.dot.gridSystemName = this.parentName;

  this.vertices = [];
  this.mesh.updateMatrixWorld();
  for (var i = 0; i<this.mesh.geometry.vertices.length; i++){
    var vertex = this.mesh.geometry.vertices[i].clone();
    vertex.applyMatrix4(this.mesh.matrixWorld);
    this.vertices.push(vertex);
  }
}

Grid.prototype.export = function(){
  var exportObject = new Object();
  exportObject.name = this.name;
  exportObject.parentName = this.parentName;
  exportObject.startX = this.startX;
  exportObject.startY = this.startY;
  exportObject.startZ = this.startZ;
  exportObject.size = this.size;
  exportObject.outlineColor = this.outlineColor;
  exportObject.colNumber = this.colNumber;
  exportObject.rowNumber = this.rowNumber;
  exportObject.axis = this.axis;
  exportObject.status = this.status;
  exportObject.selected = this.selected;
  if (this.sliced){
    exportObject.sliced = true;
    exportObject.slicedGridSystemName = this.slicedGridSystemName;
  }else{
    exportObject.sliced = false;
  }

  return exportObject;
}

Grid.prototype.getCoordInfo = function(){
  if (this.axis == "XZ"){
    return "X: "+this.centerX + " , " + "Z: "+this.centerZ;
  }
  if (this.axis == "XY"){
    return "X: "+this.centerX + " , " + "Y: "+this.centerY;
  }
  if (this.axis == "YZ"){
    return "Y: "+this.centerY + " , " + "Z: "+this.centerZ;
  }
}

Grid.prototype.toggleSelect = function(sliced, printInfo, fromStateLoader, allAtOnce){
  if (this.status == "DESTROYED"){
    return;
  }
  if (this.selected){
    scene.remove(this.mesh);
    scene.remove(this.dot);
    delete gridSelections[this.name];
  }else{
    if (!this.mesh){
      this.makeMesh(this.size, this.startX, this.startY, this.startZ);
    }
    scene.add(this.mesh);
    scene.add(this.dot);
    gridSelections[this.name] = this;
  }
  this.selected = ! this.selected;
  if (sliced){
    this.sliced = true;
  }
  if (printInfo){
    terminal.clear();
    var info;
    if (this.selected){
      info = this.name+" selected ("+this.getCoordInfo()+")";
    }else{
      info = this.name+" released ("+this.getCoordInfo()+")";
    }
    terminal.printInfo(info);
  }
}

Grid.prototype.renderCornerHelpers = function(){
  if (this.texts){
    return;
  }
  this.texts = [];
  for (var i = 0; i<this.vertices.length; i++){
    var vertex = this.vertices[i];
    var x = vertex.x, y = vertex.y, z = vertex.z;
    if (this.axis == "XZ"){
      y = 0;
    }else if (this.axis == "YZ"){
      x = 0;
    }else if (this.axis == "XY"){
      z = 0;
    }
    var text = "(@@1, @@2, @@3)".replace("@@1", x).replace("@@2", y).replace("@@3", z);
    var addedText = new AddedText(
      null, defaultFont, text, new THREE.Vector3().copy(vertex), ORANGE_COLOR, 1, 6
    );
    addedText.setMarginBetweenChars(2.5);
    addedText.refInnerHeight = 569;
    addedText.refCharSize = 6;
    addedText.handleResize();
    this.texts.push(addedText);
  }
}

Grid.prototype.removeCornerHelpers = function(){
  if (!this.texts){
    return;
  }
  for (var i = 0; i<this.texts.length; i++){
    this.texts[i].destroy();
  }
  this.texts = 0;
}

/*
  note from the future:
  this is the first engine obj class of the engine so I was motivated about
  writing comments and stuff like below.

  CONSTRUCTOR PARAMETERS
    name -> name of this grid system, must be unique.
    sizeX -> size along the x axis
    sizeZ -> size along the z axis
    centerX -> x coordinate of the center point
    centerY -> y coordinate of the center point
    centerZ -> z coordinate of the center point
    color -> color of this grid system (lowercase X11 color name)
    outlineColor -> color of the outline of each grid (lowercase X11 color name)
    cellSize -> size of each grid of this grid system
    axis -> axis (XZ / XY / YZ)

*/
var GridSystem = function(name, sizeX, sizeZ, centerX, centerY, centerZ,
                                              outlineColor, cellSize, axis){

  this.isGridSystem = true;

  // size negativity/zero check
  if (sizeX<=0 || sizeZ <=0){
    if (!isDeployment){
      terminal.printError(Text.GS_CREATION_ERROR_1);
    }
    return;
  }

  // size mismatch check
  if (sizeX%cellSize != 0){
    if (!isDeployment){
      terminal.printError(Text.GS_CREATION_ERROR_2);
    }
    return;
  }
  if (sizeZ%cellSize != 0){
    if (!isDeployment){
      terminal.printError(Text.GS_CREATION_ERROR_3);
    }
    return;
  }

  // check if name is unique
  if (gridSystems[name]){
    if (!isDeployment){
      terminal.printError(Text.GS_CREATION_ERROR_4);
    }
    return;
  }

  // LIMITATIONS
  if (cellSize < MIN_CELLSIZE_ALLOWED){
    if (!isDeployment){
      terminal.printError(Text.GS_CREATION_ERROR_5);
    }
    return;
  }
  var totalGridCount = (sizeX * sizeZ) / (cellSize * cellSize);
  if (gridCounter + totalGridCount > MAX_GRIDS_ALLOWED){
    if (!isDeployment){
      terminal.printError(Text.GS_CREATION_ERROR_6);
    }
    return;
  }

  this.totalGridCount = totalGridCount;
  this.name = name;
  this.sizeX = sizeX;
  this.sizeZ = sizeZ;
  this.centerX = centerX;
  this.centerY = centerY;
  this.centerZ = centerZ;
  this.outlineColor = outlineColor;
  this.cellSize = cellSize;
  this.cellCount = 0;
  this.axis = axis;

  this.grids = new Object();
  this.gridsByColRow = new Object();
  this.slicedGrids = new Object();

  if (this.axis == "XZ"){

    var initX = centerX - (sizeX / 2);
    var finalX = centerX + (sizeX / 2);
    var initZ = centerZ + (sizeZ / 2);
    var finalZ = centerZ - (sizeZ / 2);

    this.initX = initX;
    this.finalX = finalX;
    this.initZ = initZ;
    this.finalZ = finalZ;

    var gridNumber = 1;

    for (var x = initX; x < finalX; x+=cellSize){
      for (var z = initZ; z > finalZ; z-= cellSize){
        var grid = new Grid(name+"_grid_"+gridNumber, name, x,
                  centerY, z, cellSize, this.outlineColor,
                                  x/cellSize, z/cellSize, this.axis);
        grid.gridNumber = gridNumber;
        this.grids[gridNumber] = grid;
        this.gridsByColRow[grid.colNumber+"_"+grid.rowNumber] = grid;
        this.cellCount++;
        gridNumber ++;
      }
    }

  }else if (this.axis == "XY"){

    var initX = centerX - (sizeX / 2);
    var finalX = centerX + (sizeX / 2);
    var initY = centerY + (sizeZ / 2);
    var finalY = centerY - (sizeZ / 2);

    this.initX = initX;
    this.finalX = finalX;
    this.initY= initY;
    this.finalY = finalY;

    var gridNumber = 1;

    for (var x = initX; x<finalX; x+=cellSize){
      for (var y = initY; y>finalY; y-=cellSize){
        var grid = new Grid(name+"_grid_"+gridNumber, name, x, y,
                          centerZ, cellSize, this.outlineColor,
                                      x/cellSize, y/cellSize, this.axis);
        grid.gridNumber = gridNumber;
        this.grids[gridNumber] = grid;
        this.gridsByColRow[grid.colNumber+"_"+grid.rowNumber] = grid;
        this.cellCount++;
        gridNumber++;
      }
    }

  }else if (this.axis = "YZ"){

    var initY = centerY + (sizeX / 2);
    var finalY = centerY - (sizeX / 2);
    var initZ = centerZ - (sizeZ / 2);
    var finalZ = centerZ + (sizeZ / 2);

    this.initY = initY;
    this.finalY = finalY;
    this.initZ = initZ;
    this.finalZ = finalZ;

    var gridNumber = 1;

    for (var z = initZ; z<finalZ; z+= cellSize){
      for (var y = initY; y>finalY; y-= cellSize){
        var grid = new Grid(name+"_grid_"+gridNumber, name, centerX, y, z,
                                  cellSize, this.outlineColor,
                                      z/cellSize, y/cellSize, this.axis);
        grid.gridNumber = gridNumber;
        this.grids[gridNumber] = grid;
        this.gridsByColRow[grid.colNumber+"_"+grid.rowNumber] = grid;
        this.cellCount++;
        gridNumber++;
      }
    }

  }

  this.draw();

  this.boundingBox = new THREE.Box3().setFromObject(this.boundingPlane);
  if (!LIMIT_BOUNDING_BOX.containsBox(this.boundingBox)){
    this.destroy();
    if (!isDeployment){
      terminal.printError(Text.GRID_SYSTEM_IS_OUT_OF);
    }
    return;
  }

  gridSystems[name] = this;

  gridCounter = gridCounter + totalGridCount;

  if (!isDeployment){
    terminal.printInfo(Text.GS_CREATED);
  }
}

GridSystem.prototype.draw = function(){
  var geometry = new THREE.Geometry();
  var color = this.outlineColor;
  var material = new THREE.LineBasicMaterial({
    color: color,
    transparent: true,
    linewidth: 4,
    opacity: 0.5,
    depthWrite: false
  });

  for (var i = 0; i<= this.sizeX; i+= this.cellSize){
    geometry.vertices.push(
      new THREE.Vector3(i, 0, 0),
      new THREE.Vector3(i, 0, this.sizeZ)
    );
  }
  for (var i = 0; i<= this.sizeZ; i+= this.cellSize){
    geometry.vertices.push(
      new THREE.Vector3(0, 0, i),
      new THREE.Vector3(this.sizeX, 0, i)
    );
  }

  var boundingPlaneGeometry;
  if (this.axis == "XZ" || this.axis == "XY"){
    var geomKey = (
      "PlaneBufferGeometry" + PIPE +
      this.sizeX + PIPE + this.sizeZ + PIPE +
      "1" + PIPE + "1"
    );
    boundingPlaneGeometry = geometryCache[geomKey];
    if (!boundingPlaneGeometry){
      boundingPlaneGeometry = new THREE.PlaneBufferGeometry(
        this.sizeX, this.sizeZ
      );
      geometryCache[geomKey] = boundingPlaneGeometry;
    }
  }else if (this.axis == "YZ"){
    var geomKey = (
      "PlaneBufferGeometry" + PIPE +
      this.sizeZ + PIPE + this.sizeX + PIPE +
      "1" + PIPE + "1"
    );
    boundingPlaneGeometry = geometryCache[geomKey];
    if (!boundingPlaneGeometry){
      boundingPlaneGeometry = new THREE.PlaneBufferGeometry(
        this.sizeZ, this.sizeX
      );
      geometryCache[geomKey] = boundingPlaneGeometry;
    }
  }

  var boundingPlaneMaterial = new THREE.MeshBasicMaterial({
    color: 'black',
    transparent: true,
    opacity: 0.5,
    side: THREE.DoubleSide,
    polygonOffset: true,
    polygonOffsetFactor: 1.0,
    polygonOffsetUnits: 4.0
  });
  var boundingPlane = new THREE.Mesh(
    boundingPlaneGeometry, boundingPlaneMaterial
  );
  boundingPlane.renderOrder = 10;

  geometry.center();
  var gridSystemRepresentation = new THREE.LineSegments(
    geometry, material
  );
  gridSystemRepresentation.renderOrder = 10;

  gridSystemRepresentation.position.set(
    this.centerX,
    this.centerY,
    this.centerZ
  );

  boundingPlane.position.set(
    this.centerX,
    this.centerY,
    this.centerZ
  );

  if (this.axis == "XZ"){
    boundingPlane.rotateX(Math.PI/2);
  }
  if (this.axis == "XY"){
    gridSystemRepresentation.rotateX(Math.PI / 2);
  }
  if (this.axis == "YZ"){
    gridSystemRepresentation.rotateZ(Math.PI / 2);
    boundingPlane.rotateY(Math.PI/2);
  }

  this.gridSystemRepresentation = gridSystemRepresentation;
  this.boundingPlane = boundingPlane;
  this.boundingPlane.gridSystemName = this.name;
  this.gridSystemRepresentation.gridSystemName = this.name;

  this.boundingBox = new THREE.Box3().setFromObject(this.boundingPlane);
  this.trianglePlanes = [];
  this.triangles = [];
  var pseudoGeom = new THREE.Geometry().fromBufferGeometry(boundingPlaneGeometry);
  var transformedVertices = [];
  for (var i = 0; i<pseudoGeom.vertices.length; i++){
    var vertex = pseudoGeom.vertices[i].clone();
    vertex.applyMatrix4(this.boundingPlane.matrixWorld);
    transformedVertices.push(vertex);
  }
  for (var i = 0; i<pseudoGeom.faces.length; i++){
    var face = pseudoGeom.faces[i];
    var a = face.a;
    var b = face.b;
    var c = face.c;
    var triangle = new THREE.Triangle(
      transformedVertices[a], transformedVertices[b], transformedVertices[c]
    );
    this.triangles.push(triangle);
    var plane = new THREE.Plane();
    triangle.getPlane(plane);
    this.trianglePlanes.push(plane);
  }

  scene.add(this.gridSystemRepresentation);
  scene.add(this.boundingPlane);

}

GridSystem.prototype.intersectsLine = function(line){
  for (var i = 0; i< this.trianglePlanes.length; i+=2){
    var plane = this.trianglePlanes[i];
    if (plane.intersectLine(line, REUSABLE_VECTOR)){
      var triangle1 = this.triangles[i];
      var triangle2 = this.triangles[i+1];
      if (triangle1.containsPoint(REUSABLE_VECTOR)){
        INTERSECTION_NORMAL.set(plane.normal.x, plane.normal.y, plane.normal.z);
        return REUSABLE_VECTOR;
      }else if (triangle2.containsPoint(REUSABLE_VECTOR)){
        INTERSECTION_NORMAL.set(plane.normal.x, plane.normal.y, plane.normal.z);
        return REUSABLE_VECTOR;
      }
    }
  }
  return false;
}

GridSystem.prototype.getDistanceBetweenPointAndGrid = function(grid, point){
  var xDif = grid.centerX - point.x;
  var yDif = grid.centerY - point.y;
  var zDif = grid.centerZ - point.z;
  return Math.sqrt(
    (xDif * xDif) +
    (yDif * yDif) +
    (zDif * zDif)
  );
}

GridSystem.prototype.getGridFromPoint = function(point){
    if (this.axis == "XZ"){
      var xSegment, zSegment;
      var xStart = this.centerX  - (this.sizeX / 2);
      var xEnd = this.centerX + (this.sizeX / 2);
      var zStart = this.centerZ + (this.sizeZ / 2);
      var zEnd = this.centerZ - (this.sizeZ / 2);
      if (point.x >= xStart && point.x <= xEnd){
        var xDiff = point.x - xStart;
        var xSegment = Math.floor(xDiff / this.cellSize) + 1;
        if (point.z <= zStart && point.z >= zEnd){
          var zDiff = zStart - point.z;
          var zSegment = Math.floor(zDiff / this.cellSize) +1;
        }
      }
      if (xSegment && zSegment){
        var count = (xSegment - 1)*(this.sizeZ / this.cellSize);
        count += zSegment;
        return this.grids[count];
      }
    }else if (this.axis == "YZ"){
      var ySegment, zSegment;
      var yStart = this.centerY + (this.sizeX / 2);
      var yEnd = this.centerY - (this.sizeX / 2);
      var zStart = this.centerZ - (this.sizeZ / 2);
      var zEnd = this.centerZ + (this.sizeZ / 2);
      if (point.y <= yStart && point.y >= yEnd){
        var yDiff = yStart - point.y;
        var ySegment = Math.floor(yDiff / this.cellSize) + 1;
        if (point.z >= zStart && point.z <= zEnd){
          var zDiff = point.z - zStart;
          var zSegment = Math.floor(zDiff / this.cellSize) +1;
        }
      }
      if (ySegment && zSegment){
        var count = (zSegment - 1)*(this.sizeX / this.cellSize);
        count += ySegment;
        return this.grids[count];
      }
    }else if (this.axis == "XY"){
      var xSegment, ySegment;
      var xStart = this.centerX  - (this.sizeX / 2);
      var xEnd = this.centerX + (this.sizeX / 2);
      var yStart = this.centerY + (this.sizeZ / 2);
      var yEnd = this.centerY - (this.sizeZ / 2);
      if (point.x >= xStart && point.x <= xEnd){
        var xDiff = point.x - xStart;
        var xSegment = Math.floor(xDiff / this.cellSize) + 1;
        if (point.y <= yStart && point.y >= yEnd){
          var yDiff = yStart - point.y;
          var ySegment = Math.floor(yDiff / this.cellSize) +1;
        }
      }
      if (xSegment && ySegment){
        var count = (xSegment - 1)*(this.sizeZ / this.cellSize);
        count += ySegment;
        return this.grids[count];
      }
    }
}

GridSystem.prototype.export = function(){
  var exportObject = new Object();
  exportObject.name = this.name;
  exportObject.sizeX = this.sizeX;
  exportObject.sizeZ = this.sizeZ;
  exportObject.centerX = this.centerX;
  exportObject.centerY = this.centerY;
  exportObject.centerZ = this.centerZ;
  exportObject.outlineColor = this.outlineColor;
  exportObject.cellSize = this.cellSize;
  exportObject.axis = this.axis;
  exportObject.isSuperposed = this.isSuperposed;
  var selectedGridsExport = [];
  var slicedGridsExport = [];
  var slicedGridSystemNamesExport = [];
  for (var selectedGridName in gridSelections){
    var grid = gridSelections[selectedGridName];
    if (grid.parentName == this.name){
      selectedGridsExport.push(grid.gridNumber);
    }
  }
  for (var gridName in this.slicedGrids){
    var grid = this.slicedGrids[gridName];
    slicedGridsExport.push(grid.gridNumber);
    slicedGridSystemNamesExport.push(grid.slicedGridSystemName);
  }
  exportObject.selectedGridsExport = selectedGridsExport;
  exportObject.slicedGridsExport = slicedGridsExport;
  exportObject.slicedGridSystemNamesExport = slicedGridSystemNamesExport;
  if (this.markedPointNames){
    exportObject.markedPointNames = [];
    for (var i = 0; i<this.markedPointNames.length; i++){
      exportObject.markedPointNames.push(this.markedPointNames[i]);
    }
  }
  return exportObject;
}

GridSystem.prototype.getGridByColRow = function(col, row){
  return this.gridsByColRow[col+"_"+row];
}

GridSystem.prototype.printInfo = function(){
  terminal.printHeader(this.name);
  terminal.printInfo(
    Text.TREE_NAME.replace(Text.PARAM1, this.name),
    true
  );
  terminal.printInfo(
    Text.TREE_SIZEX.replace(Text.PARAM1, this.sizeX),
    true
  );
  terminal.printInfo(
    Text.TREE_SIZEZ.replace(Text.PARAM1, this.sizeZ),
    true
  );
  terminal.printInfo(
    Text.TREE_CENTERX.replace(Text.PARAM1, this.centerX),
    true
  );
  terminal.printInfo(
    Text.TREE_CENTERY.replace(Text.PARAM1, this.centerY),
    true
  );
  terminal.printInfo(
    Text.TREE_CENTERZ.replace(Text.PARAM1, this.centerZ),
    true
  );
  terminal.printInfo(
    Text.TREE_COLOR.replace(Text.PARAM1, this.outlineColor),
    true
  );
  terminal.printInfo(
    Text.TREE_CELL_SIZE.replace(Text.PARAM1, this.cellSize),
    true
  );
  terminal.printInfo(
    Text.TREE_CELL_COUNT.replace(Text.PARAM1, this.cellCount),
    true
  );
  terminal.printInfo(
    Text.TREE_AXIS.replace(Text.PARAM1, this.axis)
  );
}

GridSystem.prototype.destroy = function(){

  if (this.slicedGrid){
    this.slicedGrid.sliced = false;
    this.slicedGrid.slicedGridSystemName = 0;
  }

  scene.remove(this.gridSystemRepresentation);
  scene.remove(this.boundingPlane);

  this.gridSystemRepresentation.geometry.dispose();
  this.gridSystemRepresentation.material.dispose();
  this.boundingPlane.geometry.dispose();
  this.boundingPlane.material.dispose();

  for (var i in this.grids){
    this.grids[i].parentDestroyed = true;
    if (this.grids[i].selected){
      this.grids[i].toggleSelect();
    }
  }
  delete gridSystems[this.name];
  gridCounter = gridCounter - this.totalGridCount;

  if (this.markedPointNames){
    for (var i = 0; i<this.markedPointNames.length; i++){
      var markedPoint = markedPoints[this.markedPointNames[i]];
      if (markedPoint){
        markedPoint.gridDestroyed = true;
        scene.remove(markedPoint.line);
        delete markedPoint.line;
      }
    }
  }

  for (var objName in addedObjects){
    var obj = addedObjects[objName];
    if (obj.metaData.gridSystemName == this.name){
      obj.destroyedGrids = new Object();
    }
  }
  for (var objName in objectGroups){
    var obj = objectGroups[objName];
    for (var childName in obj.group){
      if (obj.group[childName].metaData.gridSystemName == this.name){
        obj.group[childName].destroyedGrids = new Object();
      }
    }
  }
  for (var textName in addedTexts){
    var obj = addedTexts[textName];
    if (obj.gsName == this.name){
      obj.destroyedGrids = new Object();
    }
  }

  rayCaster.refresh();

}

GridSystem.prototype.selectAllGrids = function(){
  for (var i in this.grids){
    if (!this.grids[i].selected){
      this.grids[i].toggleSelect();
    }
  }
}

GridSystem.prototype.crop = function(grid1, grid2){
  var centerX = (grid1.centerX + grid2.centerX)/2;
  var centerY = (grid1.centerY + grid2.centerY)/2;
  var centerZ = (grid1.centerZ + grid2.centerZ)/2;

  if (this.axis =="XZ"){

    var croppedSizeX = this.cellSize * (Math.abs(grid1.colNumber - grid2.colNumber) + 1);
    var croppedSizeZ = this.cellSize * (Math.abs(grid1.rowNumber - grid2.rowNumber) + 1);

    croppedGridSystemBuffer = new CroppedGridSystem(croppedSizeX, croppedSizeZ, centerX, centerY, centerZ, this.axis);

  } else if (this.axis == "XY"){

    var croppedSizeX = this.cellSize * (Math.abs(grid1.colNumber - grid2.colNumber) + 1);
    var croppedSizeZ = this.cellSize * (Math.abs(grid1.rowNumber - grid2.rowNumber) + 1);

    croppedGridSystemBuffer = new CroppedGridSystem(croppedSizeX, croppedSizeZ, centerX, centerY, centerZ, this.axis);

  }else if (this.axis == "YZ"){

    var croppedSizeX = this.cellSize * (Math.abs(grid1.colNumber - grid2.colNumber) + 1);
    var croppedSizeZ = this.cellSize * (Math.abs(grid1.rowNumber - grid2.rowNumber) + 1);

    croppedGridSystemBuffer = new CroppedGridSystem(croppedSizeZ, croppedSizeX, centerX, centerY, centerZ, this.axis);

  }

  if (!isDeployment){
    terminal.printInfo(Text.GS_CROPPED);
  }
}

GridSystem.prototype.newArea = function(name, height, selections){
  var boxCenterX, boxCenterY, boxCenterZ, boxSizeX, boxSizeY, boxSizeZ;
  if (selections.length == 1){
    var grid = selections[0];
    boxCenterX = grid.centerX;
    boxCenterZ = grid.centerZ;
    boxSizeX = this.cellSize;
    boxSizeZ = this.cellSize;
  }else{
    var grid1 = selections[0];
    var grid2 = selections[1];
    boxCenterX = (grid1.centerX + grid2.centerX) / 2;
    boxCenterZ = (grid1.centerZ + grid2.centerZ) / 2;
    boxSizeX = (Math.abs(grid1.colNumber - grid2.colNumber) + 1) * this.cellSize;
    boxSizeZ = (Math.abs(grid1.rowNumber - grid2.rowNumber) + 1) * this.cellSize;
  }

  boxCenterY = this.centerY + (height / 2);
  boxSizeY = Math.abs(height);

  if (this.axis == "XY"){
    var tmp = boxSizeY;
    boxSizeY = boxSizeZ;
    boxSizeZ = tmp;
    boxCenterZ = this.centerZ + (height / 2);
    if (selections.length == 1){
        var grid = selections[0];
        boxCenterY = grid.centerY;
    }else{
      var grid1 = selections[0];
      var grid2 = selections[1];
      boxCenterY = (grid1.centerY + grid2.centerY) / 2;
    }
  }else if (this.axis == "YZ"){
    var oldX = boxSizeX;
    var oldY = boxSizeY;
    var oldZ = boxSizeZ;
    boxSizeZ = oldX;
    boxSizeX = oldY;
    boxSizeY = oldZ;
    if (selections.length == 1){
      var grid = selections[0];
      boxCenterY = grid.centerY;
      boxCenterZ = grid.centerZ;
      boxCenterX = grid.centerX + (height / 2);
    }else{
      var grid1 = selections[0];
      var grid2 = selections[1];
      boxCenterY = (grid1.centerY + grid2.centerY) / 2;
      boxCenterZ = (grid1.centerZ + grid2.centerZ) / 2;
      boxCenterX = grid1.centerX + (height / 2);
    }
  }

  if (this.isSuperposed){
    boxCenterY = boxCenterY - superposeYOffset;
  }

  var boundingBox = new THREE.Box3().setFromCenterAndSize(
    new THREE.Vector3(boxCenterX, boxCenterY, boxCenterZ),
    new THREE.Vector3(boxSizeX, boxSizeY, boxSizeZ)
  );

  areas[name] = new Area(name, boundingBox, this.outlineColor, selections[0].size);
  if (areasVisible){
    areas[name].renderToScreen();
  }

  for (var i = 0; i<selections.length; i++){
    selections[i].toggleSelect(false, false, false, true);
  }

  areaBinHandler.insert(boundingBox, name);

}

GridSystem.prototype.newSurface = function(name, grid1, grid2, material){
  if (!grid2){
    grid2 = grid1;
  }
  var height = (Math.abs(grid1.rowNumber - grid2.rowNumber) + 1) * this.cellSize;
  var width = (Math.abs(grid1.colNumber - grid2.colNumber ) + 1) * this.cellSize;
  var geomKey = (
    "PlaneBufferGeometry" + PIPE +
    width + PIPE + height + PIPE +
    "1" + PIPE + "1"
  );
  var geometry;
  if (geometryCache[geomKey]){
    geometry = geometryCache[geomKey];
  }else{
    geometry = new THREE.PlaneBufferGeometry(width, height);
    geometryCache[geomKey] = geometry;
  }
  var surface = new MeshGenerator(geometry, material).generateMesh();
  if (this.axis == "XZ"){

    surface.position.x = (grid1.centerX + grid2.centerX) / 2;
    surface.position.y = this.centerY;
    surface.position.z = (grid1.centerZ + grid2.centerZ) / 2;
    surface.rotation.x = Math.PI / 2;

    if (this.isSuperposed){
      surface.position.y = surface.position.y - superposeYOffset;
    }

  } else if (this.axis == "XY"){

    surface.position.x = (grid1.centerX + grid2.centerX) / 2;
    surface.position.y = (grid1.centerY + grid2.centerY) / 2;
    surface.position.z = this.centerZ;

  }else if (this.axis == "YZ"){

    surface.position.x = this.centerX;
    surface.position.y = (grid1.centerY + grid2.centerY) / 2;
    surface.position.z = (grid1.centerZ + grid2.centerZ) / 2;
    surface.rotation.y = Math.PI / 2;

  }

  grid1.toggleSelect(false, false, false, true);
  if (grid1.name != grid2.name){
    grid2.toggleSelect(false, false, false, true);
  }

  delete gridSelections[grid1.name];
  delete gridSelections[grid2.name];

  var startRow, finalRow, startCol, finalCol;

  var destroyedGrids = new Object();

  startRow = grid1.rowNumber;
  if (grid2.rowNumber < grid1.rowNumber){
    startRow = grid2.rowNumber;
  }
  startCol = grid1.colNumber;
  if (grid2.colNumber < grid1.colNumber){
    startCol = grid2.colNumber;
  }
  finalRow = grid1.rowNumber;
  if (grid2.rowNumber > grid1.rowNumber){
    finalRow = grid2.rowNumber;
  }
  finalCol = grid1.colNumber;
  if (grid2.colNumber > grid1.colNumber){
    finalCol = grid2.colNumber;
  }
  for (var row = startRow; row <= finalRow; row++){
    for (var col = startCol; col <= finalCol; col++ ){
      var grid = this.getGridByColRow(col, row);
      if (grid){
        destroyedGrids[grid.name] = grid;
      }
    }
  }

  scene.add(surface);

  var surfacePhysicsShape;
  var physicsShapeParameters = new Object();

  if (this.axis == "XZ"){
    physicsShapeParameters["x"] = width/2;
    physicsShapeParameters["y"] = surfacePhysicalThickness;
    physicsShapeParameters["z"] = height/2;
  }else if (this.axis == "XY"){
    physicsShapeParameters["x"] = width/2;
    physicsShapeParameters["z"] = surfacePhysicalThickness;
    physicsShapeParameters["y"] = height/2;
  }else if (this.axis == "YZ"){
    physicsShapeParameters["z"] = width/2;
    physicsShapeParameters["x"] = surfacePhysicalThickness;
    physicsShapeParameters["y"] = height/2;
  }
  var physicsShapeKey = "BOX" + PIPE + physicsShapeParameters["x"] + PIPE +
                                       physicsShapeParameters["y"] + PIPE +
                                       physicsShapeParameters["z"];
  surfacePhysicsShape = physicsShapeCache[physicsShapeKey];
  if (!surfacePhysicsShape){
    surfacePhysicsShape = new CANNON.Box(new CANNON.Vec3(
      physicsShapeParameters["x"],
      physicsShapeParameters["y"],
      physicsShapeParameters["z"]
    ));
    physicsShapeCache[physicsShapeKey] = surfacePhysicsShape;
  }
  var physicsMaterial = new CANNON.Material();
  var surfacePhysicsBody = new CANNON.Body({
    mass: 0,
    shape: surfacePhysicsShape,
    material: physicsMaterial
  });
  surfacePhysicsBody.position.set(
    surface.position.x,
    surface.position.y,
    surface.position.z
  );
  physicsWorld.add(surfacePhysicsBody);

  var metaData = new Object();
  metaData["grid1Name"] = grid1.name;
  metaData["grid2Name"] = grid2.name;
  metaData["height"] = height;
  metaData["width"] = width;
  metaData["gridSystemName"] = this.name;
  metaData["gridSystemAxis"] = this.axis;
  metaData["positionX"] = surface.position.x;
  metaData["positionY"] = surface.position.y;
  metaData["positionZ"] = surface.position.z;
  metaData["quaternionX"] = surface.quaternion.x;
  metaData["quaternionY"] = surface.quaternion.y;
  metaData["quaternionZ"] = surface.quaternion.z;
  metaData["quaternionW"] = surface.quaternion.w;
  metaData["physicsShapeParameterX"] = physicsShapeParameters["x"];
  metaData["physicsShapeParameterY"] = physicsShapeParameters["y"];
  metaData["physicsShapeParameterZ"] = physicsShapeParameters["z"];

  var addedObjectInstance = new AddedObject(name, "surface", metaData, material,
                                    surface, surfacePhysicsBody, destroyedGrids);
  addedObjects[name] = addedObjectInstance;

  surface.addedObject = addedObjectInstance;
  addedObjectInstance.updateMVMatrix();
}

GridSystem.prototype.newRamp = function(anchorGrid, otherGrid, axis, height, material, name){

  var rampWidth, rampHeight;
  var centerX, centerY, centerZ;
  var colDif, rowDif;

  if (this.axis == "XZ"){
    centerX = (anchorGrid.centerX + otherGrid.centerX) / 2;
    centerZ = (anchorGrid.centerZ + otherGrid.centerZ) / 2;
    if (this.isSuperposed){
        anchorGrid.centerY = anchorGrid.centerY - superposeYOffset;
        otherGrid.centerY = otherGrid.centerY - superposeYOffset;
    }
    centerY = (anchorGrid.centerY + (otherGrid.centerY + height)) / 2;
  }else if (this.axis == "XY"){
    centerX = (anchorGrid.centerX + otherGrid.centerX) / 2;
    centerY = (anchorGrid.centerY + otherGrid.centerY) / 2;
    centerZ = (anchorGrid.centerZ + (otherGrid.centerZ + height)) / 2;
  }else if (this.axis == "YZ"){
    centerX = (anchorGrid.centerX + (otherGrid.centerX + height)) / 2;
    centerY = (anchorGrid.centerY + otherGrid.centerY) / 2;
    centerZ = (anchorGrid.centerZ + otherGrid.centerZ) / 2;
  }

  if (axis == "x"){
    rampHeight = (Math.abs(anchorGrid.rowNumber - otherGrid.rowNumber) + 1) * this.cellSize;
    colDif = (Math.abs(anchorGrid.colNumber - otherGrid.colNumber) + 1) * this.cellSize;
    rampWidth = Math.sqrt((colDif * colDif) + (height * height));
  }else if (axis == "z") {
    if (this.axis == "YZ"){
      rampHeight = (Math.abs(anchorGrid.rowNumber - otherGrid.rowNumber) + 1) * this.cellSize;
      colDif = (Math.abs(anchorGrid.colNumber - otherGrid.colNumber) + 1) * this.cellSize;
      rampWidth = Math.sqrt((colDif * colDif) + (height * height));
    }else{
      rampWidth = (Math.abs(anchorGrid.colNumber - otherGrid.colNumber) + 1) * this.cellSize;
      rowDif = (Math.abs(anchorGrid.rowNumber - otherGrid.rowNumber) + 1) * this.cellSize;
      rampHeight = Math.sqrt((rowDif * rowDif) + (height * height));
    }
  }else if (axis == "y"){
    rampWidth = (Math.abs(anchorGrid.colNumber - otherGrid.colNumber) + 1) * this.cellSize;
    rowDif = (Math.abs(anchorGrid.rowNumber - otherGrid.rowNumber) + 1) * this.cellSize;
    rampHeight = Math.sqrt((rowDif * rowDif) + (height * height));
  }
  var geometry;
  var geomKey = (
    "PlaneBufferGeometry" + PIPE +
    rampWidth + PIPE + rampHeight + PIPE +
    "1" + PIPE + "1"
  );
  geometry = geometryCache[geomKey];
  if (!geometry){
    geometry = new THREE.PlaneBufferGeometry(rampWidth, rampHeight);
    geometryCache[geomKey] = geometry;
  }
  var ramp = new MeshGenerator(geometry, material).generateMesh();

  ramp.position.x = centerX;
  ramp.position.y = centerY;
  ramp.position.z = centerZ;
  if (this.axis == "XZ"){
    ramp.rotation.x = Math.PI / 2;
  }
  if (this.axis == "YZ"){
    if (axis == "z"){
      ramp.rotation.y = Math.PI / 2;
    }else{
      ramp.rotation.y = Math.PI / 2;
    }
  }

  if (axis == "x"){
    var coef = 1;
    if (this.axis == "XY"){
      coef = -1;
    }
    var alpha = Math.acos(colDif / rampWidth);
    if (anchorGrid.centerX > otherGrid.centerX){
      if (height >= 0 ){
        ramp.rotateY(-1 * alpha * coef);
      }else {
        ramp.rotateY(alpha * coef);
      }
    }else{
      if (height >= 0){
        ramp.rotateY(alpha * coef);
      }else{
        ramp.rotateY(-1 * alpha * coef);
      }
    }
  }else if (axis == "z"){
    var alpha = Math.acos(rowDif / rampHeight);
    if (this.axis == "YZ"){
      alpha = Math.asin(height / rampWidth);
      if (anchorGrid.centerZ > otherGrid.centerZ){
        ramp.rotateY(-1 * alpha);
      }else{
        ramp.rotateY(alpha);
      }
    }else{
      if (anchorGrid.centerZ > otherGrid.centerZ){
        if (height >= 0){
          ramp.rotateX(alpha);
        }else{
          ramp.rotateX(-1 * alpha);
        }
      }else{
        if (height >= 0){
          ramp.rotateX(-1 * alpha);
        }else{
          ramp.rotateX(alpha);
        }
      }
    }
  }else if (axis == "y"){
    var alpha = Math.acos(rowDif / rampHeight);
    if (anchorGrid.centerY < otherGrid.centerY){
      if (height >= 0){
        ramp.rotateX(alpha);
      }else{
        ramp.rotateX(-1 * alpha);
      }
    }else{
      if (height >= 0){
        ramp.rotateX(-1 * alpha);
      }else{
        ramp.rotateX(alpha);
      }
    }
  }

  scene.add(ramp);

  var rampPhysicsShape;
  var physicsShapeKey = "BOX" + PIPE + (rampWidth/2) + PIPE +
                                       (surfacePhysicalThickness) + PIPE +
                                       (rampHeight/2);
  rampPhysicsShape = physicsShapeCache[physicsShapeKey];
  if (!rampPhysicsShape){
    rampPhysicsShape = new CANNON.Box(new CANNON.Vec3(
      rampWidth/2,
      surfacePhysicalThickness,
      rampHeight/2
    ));
    physicsShapeCache[physicsShapeKey] = rampPhysicsShape;
  }

  var physicsMaterial = new CANNON.Material();

  var rampPhysicsBody = new CANNON.Body({
    mass: 0,
    shape: rampPhysicsShape,
    material: physicsMaterial
  });
  rampPhysicsBody.position.set(
    ramp.position.x,
    ramp.position.y,
    ramp.position.z
  );

  var fromEuler = new Object();

  fromEuler["x"] = 0;
  fromEuler["y"] = 0;
  fromEuler["z"] = 0;

  if (axis == "x"){
    if (this.axis == "XZ"){
      fromEuler["x"] = 0;
      fromEuler["y"] = 0;
      fromEuler["z"] = ramp.rotation.y;
    }else if (this.axis == "XY"){
      fromEuler["x"] = Math.PI / 2;
      fromEuler["y"] = 0;
      fromEuler["z"] = -1 * ramp.rotation.y;
    }
  }else if (axis == "z"){
    if (this.axis == "YZ"){
      var coef = 1;
      if (otherGrid.centerZ > anchorGrid.centerZ){
        coef = -1;
      }

      if (height < 0){
          coef = coef * -1;
      }
      fromEuler["x"] = Math.PI / 2 ;
      fromEuler["y"] = 0;
      fromEuler["z"] = (-1 * ramp.rotation.y * coef);
    }else{
      fromEuler["x"] = ramp.rotation.x - (Math.PI / 2);
      fromEuler["y"] = 0;
      fromEuler["z"] = 0;
    }
  }else if (axis == "y"){
    if (this.axis == "YZ"){
      fromEuler["x"] = ramp.rotation.x;
      fromEuler["y"] = ramp.rotation.y + (Math.PI / 2);
      fromEuler["z"] = Math.PI / 2;
    }else{
      fromEuler["x"] = (Math.PI / 2) + ramp.rotation.x;
      fromEuler["y"] = 0;
      fromEuler["z"] = 0;
    }
  }

  rampPhysicsBody.quaternion.setFromEuler(
    fromEuler["x"],
    fromEuler["y"],
    fromEuler["z"]
  );
  physicsWorld.add(rampPhysicsBody);

  var metaData = new Object();
  metaData["anchorGridName"] = anchorGrid.name;
  metaData["otherGridName"] = otherGrid.name;
  metaData["rampHeight"] = rampHeight;
  metaData["rampWidth"] = rampWidth;
  metaData["gridSystemName"] = this.name;
  metaData["axis"] = axis;
  metaData["gridSystemAxis"] = this.axis;
  metaData["height"] = height;
  metaData["quaternionX"] = ramp.quaternion.x;
  metaData["quaternionY"] = ramp.quaternion.y;
  metaData["quaternionZ"] = ramp.quaternion.z;
  metaData["quaternionW"] = ramp.quaternion.w;
  metaData["centerX"] = ramp.position.x;
  metaData["centerY"] = ramp.position.y;
  metaData["centerZ"] = ramp.position.z;
  metaData["fromEulerX"] = fromEuler["x"];
  metaData["fromEulerY"] = fromEuler["y"];
  metaData["fromEulerZ"] = fromEuler["z"];

  var addedObjectInstance = new AddedObject(name, "ramp", metaData, material,
                                    ramp, rampPhysicsBody, new Object());
  addedObjects[name] = addedObjectInstance;

  ramp.addedObject = addedObjectInstance;
  addedObjectInstance.updateMVMatrix();
  anchorGrid.toggleSelect(false, false, false, true);
  if (otherGrid.selected){
    otherGrid.toggleSelect(false, false, false, true);
  }
  delete gridSelections[anchorGrid.name];
  delete gridSelections[otherGrid.name];

}

GridSystem.prototype.newBox = function(selections, height, material, name){
  var boxCenterX, boxCenterY, boxCenterZ;
  var boxSizeX, boxSizeY, boxSizeZ;

  if (selections.length == 1){
    var grid = selections[0];
    boxCenterX = grid.centerX;
    boxCenterZ = grid.centerZ;
    boxSizeX = this.cellSize;
    boxSizeZ = this.cellSize;
  }else{
    var grid1 = selections[0];
    var grid2 = selections[1];
    boxCenterX = (grid1.centerX + grid2.centerX) / 2;
    boxCenterZ = (grid1.centerZ + grid2.centerZ) / 2;
    boxSizeX = (Math.abs(grid1.colNumber - grid2.colNumber) + 1) * this.cellSize;
    boxSizeZ = (Math.abs(grid1.rowNumber - grid2.rowNumber) + 1) * this.cellSize;
  }

  boxCenterY = this.centerY + (height / 2);
  boxSizeY = Math.abs(height);

  if (this.axis == "XY"){
    var tmp = boxSizeY;
    boxSizeY = boxSizeZ;
    boxSizeZ = tmp;
    boxCenterZ = this.centerZ + (height / 2);
    if (selections.length == 1){
        var grid = selections[0];
        boxCenterY = grid.centerY;
    }else{
      var grid1 = selections[0];
      var grid2 = selections[1];
      boxCenterY = (grid1.centerY + grid2.centerY) / 2;
    }
  }else if (this.axis == "YZ"){
    var oldX = boxSizeX;
    var oldY = boxSizeY;
    var oldZ = boxSizeZ;
    boxSizeZ = oldX;
    boxSizeX = oldY;
    boxSizeY = oldZ;
    if (selections.length == 1){
      var grid = selections[0];
      boxCenterY = grid.centerY;
      boxCenterZ = grid.centerZ;
      boxCenterX = grid.centerX + (height / 2);
    }else{
      var grid1 = selections[0];
      var grid2 = selections[1];
      boxCenterY = (grid1.centerY + grid2.centerY) / 2;
      boxCenterZ = (grid1.centerZ + grid2.centerZ) / 2;
      boxCenterX = grid1.centerX + (height / 2);
    }
  }

  if (this.isSuperposed){
    boxCenterY = boxCenterY - superposeYOffset;
  }

  var geomKey = (
    "BoxBufferGeometry" + PIPE +
    boxSizeX + PIPE + boxSizeY + PIPE + boxSizeZ + PIPE +
    "1" + PIPE + "1" + PIPE + "1"
  );
  var boxGeometry = geometryCache[geomKey];
  if (!boxGeometry){
    boxGeometry = new THREE.BoxBufferGeometry(boxSizeX, boxSizeY, boxSizeZ);
    geometryCache[geomKey] = boxGeometry;
  }
  var boxMesh = new MeshGenerator(boxGeometry, material).generateMesh();

  boxMesh.position.x = boxCenterX;
  boxMesh.position.y = boxCenterY;
  boxMesh.position.z = boxCenterZ;

  scene.add(boxMesh);

  var boxPhysicsShape;
  var physicsShapeKey = "BOX" + PIPE + (boxSizeX / 2) + PIPE +
                                       (boxSizeY / 2) + PIPE +
                                       (boxSizeZ / 2);
  boxPhysicsShape = physicsShapeCache[physicsShapeKey];
  if (!boxPhysicsShape){
    boxPhysicsShape = new CANNON.Box(new CANNON.Vec3(
      boxSizeX / 2,
      boxSizeY / 2,
      boxSizeZ / 2
    ));
    physicsShapeCache[physicsShapeKey] = boxPhysicsShape;
  }

  var physicsMaterial = new CANNON.Material();

  var boxPhysicsBody = new CANNON.Body({
    mass: 0,
    shape: boxPhysicsShape,
    material: physicsMaterial
  });
  boxPhysicsBody.position.set(
    boxMesh.position.x,
    boxMesh.position.y,
    boxMesh.position.z
  );

  physicsWorld.add(boxPhysicsBody);

  for (var i = 0; i<selections.length; i++){
    selections[i].toggleSelect(false, false, false, true);
    delete gridSelections[selections[i].name];
  }

  var destroyedGrids = new Object();

  if(selections.length == 1){
    destroyedGrids[selections[0].name] = selections[0];
  }else{
    var grid1 = selections[0];
    var grid2 = selections[1];
    startRow = grid1.rowNumber;
    if (grid2.rowNumber < grid1.rowNumber){
      startRow = grid2.rowNumber;
    }
    startCol = grid1.colNumber;
    if (grid2.colNumber < grid1.colNumber){
      startCol = grid2.colNumber;
    }
    finalRow = grid1.rowNumber;
    if (grid2.rowNumber > grid1.rowNumber){
      finalRow = grid2.rowNumber;
    }
    finalCol = grid1.colNumber;
    if (grid2.colNumber > grid1.colNumber){
      finalCol = grid2.colNumber;
    }
    for (var row = startRow; row <= finalRow; row++){
      for (var col = startCol; col <= finalCol; col++ ){
        var grid = this.getGridByColRow(col, row);
        if (grid){
          destroyedGrids[grid.name] = grid;
        }
      }
    }
  }

  var metaData = new Object();
  metaData["height"] = height;
  metaData["gridCount"] = selections.length;
  metaData["grid1Name"] = selections[0].name;
  if (selections.length == 2){
    metaData["grid2Name"] = selections[1].name;
  }
  metaData["gridSystemName"] = this.name;
  metaData["boxSizeX"] = boxSizeX;
  metaData["boxSizeY"] = boxSizeY;
  metaData["boxSizeZ"] = boxSizeZ;
  metaData["centerX"] = boxCenterX;
  metaData["centerY"] = boxCenterY;
  metaData["centerZ"] = boxCenterZ;
  metaData["gridSystemAxis"] = this.axis;

  var addedObjectInstance = new AddedObject(name, "box", metaData, material,
                                    boxMesh, boxPhysicsBody, destroyedGrids);
  addedObjects[name] = addedObjectInstance;

  boxMesh.addedObject = addedObjectInstance;
  addedObjectInstance.updateMVMatrix();
}

GridSystem.prototype.newSphere = function(sphereName, material, radius, selections){

  var sphereCenterX, sphereCenterY, sphereCenterZ;

  if (this.axis == "XZ"){
    if (selections.length == 1){
      var grid = selections[0];
      sphereCenterX = grid.centerX;
      sphereCenterY = grid.centerY + radius;
      sphereCenterZ = grid.centerZ;
    }else if (selections.length == 2){
      var grid1 = selections[0];
      var grid2 = selections[1];
      sphereCenterX = (grid1.centerX + grid2.centerX) / 2;
      sphereCenterY = ((grid1.centerY + grid2.centerY) / 2) + radius;
      sphereCenterZ = (grid1.centerZ + grid2.centerZ) / 2;
    }
  }else if (this.axis == "XY"){
    if (selections.length == 1){
      var grid = selections[0];
      sphereCenterX = grid.centerX;
      sphereCenterY = grid.centerY;
      sphereCenterZ = grid.centerZ + radius;
    }else if (selections.length == 2){
      var grid1 = selections[0];
      var grid2 = selections[1];
      sphereCenterX = (grid1.centerX + grid2.centerX) / 2;
      sphereCenterY = (grid1.centerY + grid2.centerY) / 2;
      sphereCenterZ = ((grid1.centerZ + grid2.centerZ) / 2) + radius;
    }
  }else if (this.axis == "YZ"){
    if (selections.length == 1){
      var grid = selections[0];
      sphereCenterX = grid.centerX + radius;
      sphereCenterY = grid.centerY;
      sphereCenterZ = grid.centerZ;
    }else if (selections.length == 2){
      var grid1 = selections[0];
      var grid2 = selections[1];
      sphereCenterX = ((grid1.centerX + grid2.centerX) / 2) + radius;
      sphereCenterY = (grid1.centerY + grid2.centerY) / 2;
      sphereCenterZ = (grid1.centerZ + grid2.centerZ) / 2;
    }
  }

  if (this.isSuperposed){
    sphereCenterY = sphereCenterY - superposeYOffset;
  }
  var geomKey = (
    "SphereBufferGeometry" + PIPE +
    Math.abs(radius)+ PIPE +
    "8" + PIPE + "6"
  );
  var sphereGeometry = geometryCache[geomKey];
  if (!sphereGeometry){
    sphereGeometry = new THREE.SphereBufferGeometry(Math.abs(radius));
    geometryCache[geomKey] = sphereGeometry;
  }
  var sphereMesh = new MeshGenerator(sphereGeometry, material).generateMesh();
  sphereMesh.position.set(sphereCenterX, sphereCenterY, sphereCenterZ);
  scene.add(sphereMesh);

  var spherePhysicsShape;
  var physicsShapeKey = "SPHERE" + PIPE + radius;
  spherePhysicsShape = physicsShapeCache[physicsShapeKey];
  if (!spherePhysicsShape){
    spherePhysicsShape = new CANNON.Sphere(Math.abs(radius));
    physicsShapeCache[physicsShapeKey] = spherePhysicsShape;
  }
  var physicsMaterial = new CANNON.Material();

  var spherePhysicsBody = new CANNON.Body({
    mass: 0,
    shape: spherePhysicsShape,
    material: physicsMaterial
  });
  spherePhysicsBody.position.set(
    sphereMesh.position.x,
    sphereMesh.position.y,
    sphereMesh.position.z
  );

  physicsWorld.add(spherePhysicsBody);

  for (var i = 0; i<selections.length; i++){
    selections[i].toggleSelect(false, false, false, true);
    delete gridSelections[selections[i].name];
  }

  var destroyedGrids = new Object();

  if(selections.length == 1){
    destroyedGrids[selections[0].name] = selections[0];
  }else{
    var grid1 = selections[0];
    var grid2 = selections[1];
    startRow = grid1.rowNumber;
    if (grid2.rowNumber < grid1.rowNumber){
      startRow = grid2.rowNumber;
    }
    startCol = grid1.colNumber;
    if (grid2.colNumber < grid1.colNumber){
      startCol = grid2.colNumber;
    }
    finalRow = grid1.rowNumber;
    if (grid2.rowNumber > grid1.rowNumber){
      finalRow = grid2.rowNumber;
    }
    finalCol = grid1.colNumber;
    if (grid2.colNumber > grid1.colNumber){
      finalCol = grid2.colNumber;
    }
    for (var row = startRow; row <= finalRow; row++){
      for (var col = startCol; col <= finalCol; col++ ){
        var grid = this.getGridByColRow(col, row);
        if (grid){
          destroyedGrids[grid.name] = grid;
        }
      }
    }
  }

  var metaData = new Object();
  metaData["radius"] = radius;
  metaData["gridCount"] = selections.length;
  metaData["grid1Name"] = selections[0].name;
  if (selections.length == 2){
    metaData["grid2Name"] = selections[1].name;
  }
  metaData["gridSystemName"] = this.name;
  metaData["centerX"] = sphereMesh.position.x;
  metaData["centerY"] = sphereMesh.position.y;
  metaData["centerZ"] = sphereMesh.position.z;
  metaData["gridSystemAxis"] = this.axis;

  var addedObjectInstance = new AddedObject(sphereName, "sphere", metaData, material,
                                    sphereMesh, spherePhysicsBody, destroyedGrids);
  addedObjects[sphereName] = addedObjectInstance;

  sphereMesh.addedObject = addedObjectInstance;
  addedObjectInstance.updateMVMatrix();
}

GridSystem.prototype.newCylinder = function(cylinderName, material, topRadius, bottomRadius, height, isOpenEnded, selections){
  var cylinderCenterX, cylinderCenterY, cylinderCenterZ;
  if (this.axis == "XZ"){
    if (selections.length == 1){
      var grid = selections[0];
      cylinderCenterX = grid.centerX;
      cylinderCenterY = grid.centerY + (height/2);
      cylinderCenterZ = grid.centerZ;
    }else if (selections.length == 2){
      var grid1 = selections[0];
      var grid2 = selections[1];
      cylinderCenterX = (grid1.centerX + grid2.centerX) / 2;
      cylinderCenterY = ((grid1.centerY + grid2.centerY) / 2) + (height/2);
      cylinderCenterZ = (grid1.centerZ + grid2.centerZ) / 2;
    }
  }else if (this.axis == "XY"){
    if (selections.length == 1){
      var grid = selections[0];
      cylinderCenterX = grid.centerX;
      cylinderCenterY = grid.centerY;
      cylinderCenterZ = grid.centerZ + (height/2);
    }else if (selections.length == 2){
      var grid1 = selections[0];
      var grid2 = selections[1];
      cylinderCenterX = (grid1.centerX + grid2.centerX) / 2;
      cylinderCenterY = (grid1.centerY + grid2.centerY) / 2;
      cylinderCenterZ = ((grid1.centerZ + grid2.centerZ) / 2) + (height/2);
    }
  }else if (this.axis == "YZ"){
    if (selections.length == 1){
      var grid = selections[0];
      cylinderCenterX = grid.centerX + (height/2);
      cylinderCenterY = grid.centerY;
      cylinderCenterZ = grid.centerZ;
    }else if (selections.length == 2){
      var grid1 = selections[0];
      var grid2 = selections[1];
      cylinderCenterX = ((grid1.centerX + grid2.centerX) / 2) + (height/2);
      cylinderCenterY = (grid1.centerY + grid2.centerY) / 2;
      cylinderCenterZ = (grid1.centerZ + grid2.centerZ) / 2;
    }
  }
  if (this.isSuperposed){
    cylinderCenterY = cylinderCenterY - superposeYOffset;
  }
  var geomKey = "CylinderBufferGeometry" + PIPE + height + PIPE + topRadius + PIPE +
                                         bottomRadius + PIPE + 8 + PIPE + 1 + PIPE + isOpenEnded;
  var cylinderGeometry = geometryCache[geomKey];
  if (!cylinderGeometry){
    cylinderGeometry = new THREE.CylinderBufferGeometry(topRadius, bottomRadius, height, 8, 1, isOpenEnded);
    geometryCache[geomKey] = cylinderGeometry;
  }
  var cylinderMesh = new MeshGenerator(cylinderGeometry, material).generateMesh();
  cylinderMesh.position.set(cylinderCenterX, cylinderCenterY, cylinderCenterZ);
  scene.add(cylinderMesh);
  var cylinderPhysicsShape;
  var physicsShapeKey = "CYLINDER" + PIPE + topRadius + PIPE + bottomRadius + PIPE +
                                            Math.abs(height) + PIPE + 8 + PIPE +
                                            this.axis;
  cylinderPhysicsShape = physicsShapeCache[physicsShapeKey];
  var cached = false;
  if (!cylinderPhysicsShape){
      cylinderPhysicsShape = new CANNON.Cylinder(topRadius, bottomRadius, Math.abs(height), 8);
      physicsShapeCache[physicsShapeKey] = cylinderPhysicsShape;
  }else{
    cached = true;
  }
  cylinderPhysicsShape.topRadius = topRadius;
  cylinderPhysicsShape.bottomRadius = bottomRadius;
  cylinderPhysicsShape.height = Math.abs(height);
  if (this.axis == "XZ"){
    if (!cached){
      var quat = new CANNON.Quaternion();
      var coef = 1;
      if (height < 0){
        coef = -1;
      }
      quat.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI/2 * coef);
      var translation = new CANNON.Vec3(0, 0, 0);
      cylinderPhysicsShape.transformAllPoints(translation,quat);
    }
  }else if (this.axis == "XY"){
    cylinderMesh.rotateX(Math.PI/2);
    if (!cached){
      if (height < 0){
        var quat = new CANNON.Quaternion();
        quat.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), -Math.PI);
        var translation = new CANNON.Vec3(0, 0, 0);
        cylinderPhysicsShape.transformAllPoints(translation,quat);
      }
    }
  }else if (this.axis == "YZ"){
    cylinderMesh.rotateZ(-Math.PI/2);
    if (!cached){
      var quat = new CANNON.Quaternion();
      var coef = 1;
      if (height < 0){
        coef = -1;
      }
      quat.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), coef * Math.PI/2);
      var translation = new CANNON.Vec3(0, 0, 0);
      cylinderPhysicsShape.transformAllPoints(translation,quat);
    }
  }
  var physicsMaterial = new CANNON.Material();
  var cylinderPhysicsBody = new CANNON.Body({
    mass: 0,
    shape: cylinderPhysicsShape,
    material: physicsMaterial
  });
  cylinderPhysicsBody.position.set(
    cylinderMesh.position.x,
    cylinderMesh.position.y,
    cylinderMesh.position.z
  );
  physicsWorld.add(cylinderPhysicsBody);
  for (var i = 0; i<selections.length; i++){
    selections[i].toggleSelect(false, false, false, true);
    delete gridSelections[selections[i].name];
  }
  var destroyedGrids = new Object();
  if(selections.length == 1){
    destroyedGrids[selections[0].name] = selections[0];
  }else{
    var grid1 = selections[0];
    var grid2 = selections[1];
    startRow = grid1.rowNumber;
    if (grid2.rowNumber < grid1.rowNumber){
      startRow = grid2.rowNumber;
    }
    startCol = grid1.colNumber;
    if (grid2.colNumber < grid1.colNumber){
      startCol = grid2.colNumber;
    }
    finalRow = grid1.rowNumber;
    if (grid2.rowNumber > grid1.rowNumber){
      finalRow = grid2.rowNumber;
    }
    finalCol = grid1.colNumber;
    if (grid2.colNumber > grid1.colNumber){
      finalCol = grid2.colNumber;
    }
    for (var row = startRow; row <= finalRow; row++){
      for (var col = startCol; col <= finalCol; col++ ){
        var grid = this.getGridByColRow(col, row);
        if (grid){
          destroyedGrids[grid.name] = grid;
        }
      }
    }
  }
  var metaData = new Object();
  metaData["height"] = height;
  metaData["topRadius"] = topRadius;
  metaData["bottomRadius"] = bottomRadius;
  metaData["isOpenEnded"] = isOpenEnded;
  metaData["gridCount"] = selections.length;
  metaData["grid1Name"] = selections[0].name;
  if (selections.length == 2){
    metaData["grid2Name"] = selections[1].name;
  }
  metaData["gridSystemName"] = this.name;
  metaData["centerX"] = cylinderMesh.position.x;
  metaData["centerY"] = cylinderMesh.position.y;
  metaData["centerZ"] = cylinderMesh.position.z;
  metaData["gridSystemAxis"] = this.axis;

  var addedObjectInstance = new AddedObject(cylinderName, "cylinder", metaData, material,
                                    cylinderMesh, cylinderPhysicsBody, destroyedGrids);
  addedObjects[cylinderName] = addedObjectInstance;

  cylinderMesh.addedObject = addedObjectInstance;
  addedObjectInstance.updateMVMatrix();
}

var WallCollection = function(name, height, outlineColor,
                            grid1, grid2, isSuperposed, isLoaded, exportObj){

  this.name = name;
  this.height = height;
  this.outlineColor = outlineColor;

  this.isSuperposed = isSuperposed;

  if (isLoaded){
    this.createPreloadedWallCollection(exportObj);
    return;
  }

  if (!grid2){
    grid2 = grid1;
  }

  if (grid1.axis == "XZ"){
    this.sizeX = (Math.abs(grid1.colNumber - grid2.colNumber) + 1) * grid1.size;
    this.sizeZ = (Math.abs(grid1.rowNumber - grid2.rowNumber) + 1) * grid1.size;
  }else if (grid1.axis == "XY"){
    this.sizeX = (Math.abs(grid1.colNumber - grid2.colNumber) + 1) * grid1.size;
    this.sizeY = (Math.abs(grid1.rowNumber - grid2.rowNumber) + 1) * grid1.size;
  }else if (grid1.axis == "YZ"){
    this.sizeZ = (Math.abs(grid1.colNumber - grid2.colNumber) + 1) * grid1.size;
    this.sizeY = (Math.abs(grid1.rowNumber - grid2.rowNumber) + 1) * grid1.size;
  }

  var centerX, centerY, centerZ;
  if (grid1.axis == "XZ"){
    centerX = (grid1.centerX + grid2.centerX) / 2;
    centerY = grid1.centerY + (this.height / 2);
    centerZ = (grid1.centerZ + grid2.centerZ) / 2;
  }else if (grid1.axis == "XY"){
    centerX = (grid1.centerX + grid2.centerX) / 2;
    centerY = (grid1.centerY + grid2.centerY) / 2;
    centerZ = (grid1.centerZ) + (this.height / 2);
  }else if (grid1.axis == "YZ"){
    centerX = grid1.centerX + (this.height / 2);
    centerY = (grid1.centerY + grid2.centerY) / 2;
    centerZ = (grid1.centerZ + grid2.centerZ) / 2;
  }

  if (this.isSuperposed){
    centerY = centerY - superposeYOffset;
  }

  var gridSystem1Name, gridSystem2Name, gridSystem3Name, gridSystem4Name, gridSystemRoofName;

  if (grid1.axis == "XZ"){
    gridSystem1Name = this.name + "_"+"YZ_1";
    gridSystem2Name = this.name + "_"+"YZ_2";
    gridSystem3Name = this.name + "_"+"XY_1";
    gridSystem4Name = this.name + "_"+"XY_2";
    gridSystemRoofName = this.name + "_"+"XZ_ROOF";
  }else if (grid1.axis == "XY"){
    gridSystem1Name = this.name + "_"+"XZ_1",
    gridSystem2Name = this.name + "_"+"XZ_2",
    gridSystem3Name = this.name + "_"+"YZ_1",
    gridSystem4Name = this.name + "_"+"YZ_2",
    gridSystemRoofName = this.name + "_"+"XY_ROOF"
  }else if (grid1.axis == "YZ"){
    gridSystem1Name = this.name + "_"+"XZ_1",
    gridSystem2Name = this.name + "_"+"XZ_2",
    gridSystem3Name = this.name + "_"+"XY_1",
    gridSystem4Name = this.name + "_"+"XY_2",
    gridSystemRoofName = this.name+ "_"+"YZ_ROOF"
  }

  this.gridSystemNames = [
    gridSystem1Name,
    gridSystem2Name,
    gridSystem3Name,
    gridSystem4Name,
    gridSystemRoofName
  ]

  var gridSystem1CenterCoordinates, gridSystem2CenterCoordinates,
      gridSystem3CenterCoordinates, gridSystem4CenterCoordinates,
      gridSystemRoofCenterCoordinates;

  if (grid1.axis == "XZ"){
    gridSystem1CenterCoordinates = [
      centerX - (this.sizeX / 2),
      centerY,
      centerZ
    ];
    gridSystem2CenterCoordinates = [
      centerX + (this.sizeX / 2),
      centerY,
      centerZ
    ];
    gridSystem3CenterCoordinates = [
      centerX,
      centerY,
      centerZ - (this.sizeZ / 2)
    ];
    gridSystem4CenterCoordinates = [
      centerX,
      centerY,
      centerZ + (this.sizeZ / 2)
    ];
    gridSystemRoofCenterCoordinates = [
      centerX,
      centerY + (this.height / 2),
      centerZ
    ];
  } else if (grid1.axis == "XY"){
    gridSystem1CenterCoordinates = [
      centerX,
      centerY + (this.sizeY / 2),
      centerZ
    ];
    gridSystem2CenterCoordinates = [
      centerX,
      centerY - (this.sizeY / 2),
      centerZ
    ];
    gridSystem3CenterCoordinates = [
      centerX - (this.sizeX / 2),
      centerY,
      centerZ
    ];
    gridSystem4CenterCoordinates = [
      centerX + (this.sizeX / 2),
      centerY,
      centerZ
    ];
    gridSystemRoofCenterCoordinates = [
      centerX,
      centerY,
      centerZ + (this.height / 2)
    ];
  } else if (grid1.axis == "YZ"){
    gridSystem1CenterCoordinates = [
      centerX,
      centerY + (this.sizeY / 2),
      centerZ
    ];
    gridSystem2CenterCoordinates = [
      centerX,
      centerY - (this.sizeY / 2),
      centerZ
    ];
    gridSystem3CenterCoordinates = [
      centerX,
      centerY,
      centerZ + (this.sizeZ / 2)
    ];
    gridSystem4CenterCoordinates = [
      centerX,
      centerY,
      centerZ - (this.sizeZ / 2)
    ];
    gridSystemRoofCenterCoordinates = [
      centerX + (this.height / 2),
      centerY,
      centerZ
    ];
  }

  height = Math.abs(height);

  if (grid1.axis == "XZ"){
    new GridSystem(
      gridSystem1Name, height, this.sizeZ,
      gridSystem1CenterCoordinates[0], gridSystem1CenterCoordinates[1],
      gridSystem1CenterCoordinates[2], outlineColor, grid1.size, "YZ"
    );
    new GridSystem(
      gridSystem2Name, height, this.sizeZ,
      gridSystem2CenterCoordinates[0], gridSystem2CenterCoordinates[1],
      gridSystem2CenterCoordinates[2], outlineColor, grid1.size, "YZ"
    );
    new GridSystem(
      gridSystem3Name, this.sizeX, height,
      gridSystem3CenterCoordinates[0], gridSystem3CenterCoordinates[1],
      gridSystem3CenterCoordinates[2], outlineColor, grid1.size, "XY"
    );
    new GridSystem(
      gridSystem4Name, this.sizeX, height,
      gridSystem4CenterCoordinates[0], gridSystem4CenterCoordinates[1],
      gridSystem4CenterCoordinates[2], outlineColor, grid1.size, "XY"
    );
    new GridSystem(
      gridSystemRoofName, this.sizeX, this.sizeZ,
      gridSystemRoofCenterCoordinates[0], gridSystemRoofCenterCoordinates[1],
      gridSystemRoofCenterCoordinates[2], outlineColor, grid1.size, "XZ"
    );
  }else if (grid1.axis == "XY"){
    new GridSystem(
      gridSystem1Name, this.sizeX, height,
      gridSystem1CenterCoordinates[0], gridSystem1CenterCoordinates[1],
      gridSystem1CenterCoordinates[2], outlineColor, grid1.size, "XZ"
    );
    new GridSystem(
      gridSystem2Name, this.sizeX, height,
      gridSystem2CenterCoordinates[0], gridSystem2CenterCoordinates[1],
      gridSystem2CenterCoordinates[2], outlineColor, grid1.size, "XZ"
    );
    new GridSystem(
      gridSystem3Name, this.sizeY, height,
      gridSystem3CenterCoordinates[0], gridSystem3CenterCoordinates[1],
      gridSystem3CenterCoordinates[2], outlineColor, grid1.size, "YZ"
    );
    new GridSystem(
      gridSystem4Name, this.sizeY, height,
      gridSystem4CenterCoordinates[0], gridSystem4CenterCoordinates[1],
      gridSystem4CenterCoordinates[2], outlineColor, grid1.size, "YZ"
    );
    new GridSystem(
      gridSystemRoofName, this.sizeX, this.sizeY,
      gridSystemRoofCenterCoordinates[0], gridSystemRoofCenterCoordinates[1],
      gridSystemRoofCenterCoordinates[2], outlineColor, grid1.size, "XY"
    );
  } else if (grid1.axis == "YZ"){
    new GridSystem(
      gridSystem1Name, height, this.sizeZ,
      gridSystem1CenterCoordinates[0], gridSystem1CenterCoordinates[1],
      gridSystem1CenterCoordinates[2], outlineColor, grid1.size, "XZ"
    );
    new GridSystem(
      gridSystem2Name, height, this.sizeZ,
      gridSystem2CenterCoordinates[0], gridSystem2CenterCoordinates[1],
      gridSystem2CenterCoordinates[2], outlineColor, grid1.size, "XZ"
    );
    new GridSystem(
      gridSystem3Name, height, this.sizeY,
      gridSystem3CenterCoordinates[0], gridSystem3CenterCoordinates[1],
      gridSystem3CenterCoordinates[2], outlineColor, grid1.size, "XY"
    );
    new GridSystem(
      gridSystem4Name, height, this.sizeY,
      gridSystem4CenterCoordinates[0], gridSystem4CenterCoordinates[1],
      gridSystem4CenterCoordinates[2], outlineColor, grid1.size, "XY"
    );
    new GridSystem(
      gridSystemRoofName, this.sizeY, this.sizeZ,
      gridSystemRoofCenterCoordinates[0], gridSystemRoofCenterCoordinates[1],
      gridSystemRoofCenterCoordinates[2], outlineColor, grid1.size, "YZ"
    );
  }

  wallCollections[this.name] = this;

};

WallCollection.prototype.createPreloadedWallCollection = function(exportObj){
  this.sizeX = exportObj.sizeX;
  this.sizeZ = exportObj.sizeZ;
  this.gridSystemNames = exportObj.gridSystemNames;
  wallCollections[this.name] = this;
}

WallCollection.prototype.export = function(){
  var exportObject = new Object();
  exportObject["name"] = this.name;
  exportObject["height"] = this.height;
  exportObject["outlineColor"] = this.outlineColor;
  exportObject["isSuperposed"] = this.isSuperposed;
  exportObject["sizeX"] = this.sizeX;
  exportObject["sizeZ"] = this.sizeZ;
  exportObject["gridSystemNames"] = this.gridSystemNames;
  return exportObject;
}

WallCollection.prototype.destroy = function(){
  for (var i=0; i<this.gridSystemNames.length; i++){
    var gridSystemName = this.gridSystemNames[i];
    if (gridSystems[gridSystemName]){
      gridSystems[gridSystemName].destroy();
    }
  }
  delete wallCollections[this.name];
}

var CroppedGridSystem = function(sizeX, sizeZ, centerX, centerY, centerZ, axis){
  this.sizeX = sizeX;
  this.sizeZ = sizeZ;
  this.centerX = centerX;
  this.centerY = centerY;
  this.centerZ = centerZ;
  this.axis = axis;
}

CroppedGridSystem.prototype.export = function(){
  var exportObj = new Object();
  exportObj.sizeX = this.sizeX;
  exportObj.sizeZ = this.sizeZ;
  exportObj.centerX = this.centerX;
  exportObj.centerY = this.centerY;
  exportObj.centerZ = this.centerZ;
  exportObj.axis = this.axis;
  return exportObj;
}

CroppedGridSystem.prototype.clone = function(){
  return new CroppedGridSystem(this.sizeX, this.sizeZ, this.centerX, this.centerY, this.centerZ, this.axis);
}

var AddedObject = function(name, type, metaData, material, mesh, physicsBody, destroyedGrids){
  this.isAddedObject = true;
  this.name = name;
  this.type = type;
  this.metaData = metaData;
  this.material = material;
  this.mesh = mesh;
  this.physicsBody = physicsBody;
  this.destroyedGrids = destroyedGrids;

  this.physicsBody.addedObject = this;

  if (mesh instanceof BasicMaterial){
    this.hasBasicMaterial = true;
  }

  if (this.destroyedGrids){
    for (var gridName in this.destroyedGrids){
      this.destroyedGrids[gridName].destroyedAddedObject = this.name;
    }
  }

  var baseGridSystemName = this.metaData["gridSystemName"];
  var baseGridSystem = gridSystems[baseGridSystemName];
  if (baseGridSystem && !(this.metaData["baseGridSystemAxis"])){
    this.metaData["baseGridSystemAxis"] = baseGridSystem.axis.toUpperCase();
  }

  this.metaData["widthSegments"] = 1;
  this.metaData["heightSegments"] = 1;
  if (type == "box"){
    this.metaData["depthSegments"] = 1;
  }else if (type == "sphere"){
    this.metaData["widthSegments"] = 8;
    this.metaData["heightSegments"] = 6;
  }else if (type == "cylinder"){
    this.metaData["widthSegments"] = 8;
  }

  this.metaData["textureRepeatU"] = 1;
  this.metaData["textureRepeatV"] = 1;

  this.associatedTexturePack = 0;

  this.rotationX = 0;
  this.rotationY = 0;
  this.rotationZ = 0;

  this.initQuaternion = this.mesh.quaternion.clone();

  this.collisionCallbackFunction = function(collisionEvent){
    if (!collisionEvent.body.addedObject || (!this.isVisibleOnThePreviewScene() && !this.physicsKeptWhenHidden)){
      return;
    }
    if (isPhysicsWorkerEnabled()){
      // WE WILL HANDLE PHYSICS CALCULATIONS INSIDE THE WORKER
      return;
    }
    var targetObjectName = collisionEvent.body.addedObject.name;
    var contact = collisionEvent.contact;
    var collisionPosition = new Object();
    var collisionImpact = contact.getImpactVelocityAlongNormal();
    collisionPosition.x = contact.bi.position.x + contact.ri.x;
    collisionPosition.y = contact.bi.position.y + contact.ri.y;
    collisionPosition.z = contact.bi.position.z + contact.ri.z;
    var quatX = this.mesh.quaternion.x;
    var quatY = this.mesh.quaternion.y;
    var quatZ = this.mesh.quaternion.z;
    var quatW = this.mesh.quaternion.w;
    var collisionInfo = reusableCollisionInfo.set(
      targetObjectName,
      collisionPosition.x,
      collisionPosition.y,
      collisionPosition.z,
      collisionImpact,
      quatX,
      quatY,
      quatZ,
      quatW
    );
    var curCollisionCallbackRequest = collisionCallbackRequests[this.name];
    if (curCollisionCallbackRequest){
      curCollisionCallbackRequest(collisionInfo);
    }
  };

  this.physicsBody.addEventListener(
    "collide",
    this.collisionCallbackFunction.bind(this)
  );

  this.reusableVec3 = new THREE.Vector3();
  this.reusableVec3_2 = new THREE.Vector3();
  this.reusableVec3_3 = new THREE.Vector3();

}

AddedObject.prototype.export = function(){
  var exportObject = new Object();
  exportObject["type"] = this.type;
  exportObject["roygbivMaterialName"] = this.material.roygbivMaterialName;
  var exportDestroyedGrids = new Object();
  for (var gridName in this.destroyedGrids){
    exportDestroyedGrids[gridName] = this.destroyedGrids[gridName].export();
  }
  exportObject["destroyedGrids"] = exportDestroyedGrids;
  exportObject["metaData"] = Object.assign({}, this.metaData);
  exportObject["associatedTexturePack"] = this.associatedTexturePack;

  if (this.mass){
    exportObject["mass"] = this.mass;
  }
  if (this.isDynamicObject){
    exportObject["isDynamicObject"] = this.isDynamicObject;
  }

  exportObject["opacity"] = this.mesh.material.uniforms.alpha.value;
  if (this.hasAOMap()){
    exportObject["aoMapIntensity"] = this.mesh.material.uniforms.aoIntensity.value;
  }else{
    exportObject["aoMapIntensity"] = this.material.aoMapIntensity;
  }
  if (this.hasEmissiveMap()){
    exportObject["emissiveIntensity"] = this.mesh.material.uniforms.emissiveIntensity.value;
    exportObject["emissiveColor"] = "#"+this.mesh.material.uniforms.emissiveColor.value.getHexString();
  }else{
    exportObject["emissiveIntensity"] = this.material.emissiveIntensity;
    exportObject["emissiveColor"] = this.material.emissiveColor;
  }

  exportObject["textureOffsetX"] = this.getTextureOffsetX();
  exportObject["textureOffsetY"] = this.getTextureOffsetY();
  exportObject["textureRepeatU"] = this.getTextureRepeatX();
  exportObject["textureRepeatV"] = this.getTextureRepeatY();

  if (this.hasDiffuseMap()){
    var diffuseMap = this.mesh.material.uniforms.diffuseMap.value;
    exportObject["diffuseRoygbivTexturePackName"] = diffuseMap.roygbivTexturePackName;
    exportObject["diffuseRoygbivTextureName"] =  diffuseMap.roygbivTextureName;
  }
  if (this.hasAlphaMap()){
    var alphaMap = this.mesh.material.uniforms.alphaMap.value;
    exportObject["alphaRoygbivTexturePackName"] = alphaMap.roygbivTexturePackName;
    exportObject["alphaRoygbivTextureName"] = alphaMap.roygbivTextureName;
  }
  if (this.hasAOMap()){
    var aoMap = this.mesh.material.uniforms.aoMap.value;
    exportObject["aoRoygbivTexturePackName"] = aoMap.roygbivTexturePackName;
    exportObject["aoRoygbivTextureName"] = aoMap.roygbivTextureName;
  }
  if (this.hasEmissiveMap()){
    var emissiveMap = this.mesh.material.uniforms.emissiveMap.value;
    exportObject["emissiveRoygbivTexturePackName"] = emissiveMap.roygbivTexturePackName;
    exportObject["emissiveRoygbivTextureName"] = emissiveMap.roygbivTextureName;
  }
  if (this.hasDisplacementMap()){
    var displacementMap = this.mesh.material.uniforms.displacementMap.value;
    exportObject["displacementRoygbivTexturePackName"] = displacementMap.roygbivTexturePackName;
    exportObject["displacementRoygbivTextureName"] = displacementMap.roygbivTextureName;
    exportObject["displacementScale"] = this.mesh.material.uniforms.displacementInfo.value.x;
    exportObject["displacementBias"] = this.mesh.material.uniforms.displacementInfo.value.y;
  }

  exportObject.rotationX = this.rotationX;
  exportObject.rotationY = this.rotationY;
  exportObject.rotationZ = this.rotationZ;

  if (!this.parentObjectName){
    exportObject.quaternionX = this.mesh.quaternion.x;
    exportObject.quaternionY = this.mesh.quaternion.y;
    exportObject.quaternionZ = this.mesh.quaternion.z;
    exportObject.quaternionW = this.mesh.quaternion.w;
    exportObject.pQuaternionX = this.physicsBody.quaternion.x;
    exportObject.pQuaternionY = this.physicsBody.quaternion.y;
    exportObject.pQuaternionZ = this.physicsBody.quaternion.z;
    exportObject.pQuaternionW = this.physicsBody.quaternion.w;
  }else{
    exportObject.quaternionX = this.qxWhenAttached;
    exportObject.quaternionY = this.qyWhenAttached;
    exportObject.quaternionZ = this.qzWhenAttached;
    exportObject.quaternionW = this.qwWhenAttached;
    exportObject.pQuaternionX = this.pqxWhenAttached;
    exportObject.pQuaternionY = this.pqyWhenAttached;
    exportObject.pQuaternionZ = this.pqzWhenAttached;
    exportObject.pQuaternionW = this.pqwWhenAttached;
    exportObject.positionXWhenAttached = this.positionXWhenAttached;
    exportObject.positionYWhenAttached = this.positionYWhenAttached;
    exportObject.positionZWhenAttached = this.positionZWhenAttached;
  }

  var blendingModeInt = this.mesh.material.blending;
  if (blendingModeInt == NO_BLENDING){
    exportObject.blendingMode = "NO_BLENDING";
  }else if (blendingModeInt == NORMAL_BLENDING){
    exportObject.blendingMode = "NORMAL_BLENDING";
  }else if (blendingModeInt == ADDITIVE_BLENDING){
    exportObject.blendingMode = "ADDITIVE_BLENDING";
  }else if (blendingModeInt == SUBTRACTIVE_BLENDING){
    exportObject.blendingMode = "SUBTRACTIVE_BLENDING";
  }else if (blendingModeInt == MULTIPLY_BLENDING){
    exportObject.blendingMode = "MULTIPLY_BLENDING";
  }

  if (this.metaData.isSlippery){
    exportObject.isSlippery = true;
  }else{
    exportObject.isSlippery = false;
  }

  if (this.isChangeable){
    exportObject.isChangeable = true;
  }else{
    exportObject.isChangeable = false;
  }
  if (this.isColorizable){
    exportObject.isColorizable = true;
  }else{
    exportObject.isColorizable = false;
  }

  if (this.noMass){
    exportObject.noMass = true;
  }else{
    exportObject.noMass = false;
  }

  if (this.areaVisibilityConfigurations){
    exportObject.areaVisibilityConfigurations = this.areaVisibilityConfigurations;
  }
  if (this.areaSideConfigurations){
    exportObject.areaSideConfigurations = this.areaSideConfigurations;
  }

  if (this.pivotObject){
    exportObject.hasPivot = true;
    exportObject.pivotOffsetX = this.pivotOffsetX;
    exportObject.pivotOffsetY = this.pivotOffsetY;
    exportObject.pivotOffsetZ = this.pivotOffsetZ;
    exportObject.positionX = this.mesh.position.x;
    exportObject.positionY = this.mesh.position.y;
    exportObject.positionZ = this.mesh.position.z;
    exportObject.pivotQX = this.pivotObject.quaternion.x;
    exportObject.pivotQY = this.pivotObject.quaternion.y;
    exportObject.pivotQZ = this.pivotObject.quaternion.z;
    exportObject.pivotQW = this.pivotObject.quaternion.w;
    exportObject.insidePivotQX = this.pivotObject.children[0].quaternion.x;
    exportObject.insidePivotQY = this.pivotObject.children[0].quaternion.y;
    exportObject.insidePivotQZ = this.pivotObject.children[0].quaternion.z;
    exportObject.insidePivotQW = this.pivotObject.children[0].quaternion.w;
    if (this.parentObjectName){
      var objGroup = objectGroups[this.parentObjectName];
      if (objGroup){
        exportObject.positionX = this.physicsBody.position.x;
        exportObject.positionY = this.physicsBody.position.y;
        exportObject.positionZ = this.physicsBody.position.z;
      }
    }
  }else if (this.pivotRemoved){
    exportObject.pivotRemoved = true;
    exportObject.positionX = this.mesh.position.x;
    exportObject.positionY = this.mesh.position.y;
    exportObject.positionZ = this.mesh.position.z;
    if (this.parentObjectName){
      var objGroup = objectGroups[this.parentObjectName];
      if (objGroup){
        exportObject.positionX = this.physicsBody.position.x;
        exportObject.positionY = this.physicsBody.position.y;
        exportObject.positionZ = this.physicsBody.position.z;
      }
    }
  }

  if (this.softCopyParentName){
    exportObject.softCopyParentName = this.softCopyParentName;
  }

  if (this.hasTexture()){
    exportObject.txtMatrix = this.mesh.material.uniforms.textureMatrix.value.elements;
  }

  return exportObject;
}

AddedObject.prototype.forceColor = function(r, g, b, a){
  if (!this.isColorizable){
    return;
  }
  if (a < 0){
    a = 0;
  }
  if (a > 1){
    a = 1;
  }
  this.mesh.material.uniforms.forcedColor.value.set(a, r, g, b);
  this.mesh.material.needsUpdate = true;
}

AddedObject.prototype.resetColor = function(){
  if (!this.isColorizable){
    return;
  }
  this.mesh.material.uniforms.forcedColor.value.set(-50, 0, 0, 0);
}

AddedObject.prototype.applyAreaConfiguration = function(areaName){
  if (this.areaVisibilityConfigurations){
    var configurations = this.areaVisibilityConfigurations[areaName];
    if (!(typeof configurations == UNDEFINED)){
      this.mesh.visible = configurations;
    }else{
      this.mesh.visible = true;
    }
  }
  if (this.areaSideConfigurations){
    var configurations = this.areaSideConfigurations[areaName];
    if (!(typeof configurations == UNDEFINED)){
      if (configurations == SIDE_BOTH){
        this.mesh.material.side = THREE.DoubleSide;
      }else if (configurations == SIDE_FRONT){
        this.mesh.material.side = THREE.FrontSide;
      }else if (configurations == SIDE_BACK){
        this.mesh.material.side = THREE.BackSide;
      }
    }else{
      if (this.defaultSide){
        if (this.defaultSide == SIDE_BOTH){
          this.mesh.material.side = THREE.DoubleSide;
        }else if (this.defaultSide == SIDE_FRONT){
          this.mesh.material.side = THREE.FrontSide;
        }else if (this.defaultSide == SIDE_BACK){
          this.mesh.material.side = THREE.BackSide;
        }
      }else{
        this.mesh.material.side = THREE.DoubleSide;
      }
    }
  }
}

AddedObject.prototype.getSideInArea = function(areaName){
  if (this.areaSideConfigurations){
    if (!(typeof this.areaSideConfigurations[areaName] == UNDEFINED)){
      return this.areaSideConfigurations[areaName];
    }
  }
  if (this.defaultSide){
    return this.defaultSide;
  }
  return SIDE_BOTH;
}

AddedObject.prototype.setSideInArea = function(areaName, side){
  if (!this.areaSideConfigurations){
    this.areaSideConfigurations = new Object();
  }
  this.areaSideConfigurations[areaName] = side;
}

AddedObject.prototype.getVisibilityInArea = function(areaName){
  if (this.areaVisibilityConfigurations){
    if (!(typeof this.areaVisibilityConfigurations[areaName] == UNDEFINED)){
      return this.areaVisibilityConfigurations[areaName];
    }
  }
  return true;
}

AddedObject.prototype.setVisibilityInArea = function(areaName, isVisible){
  if (!this.areaVisibilityConfigurations){
    this.areaVisibilityConfigurations = new Object();
  }
  this.areaVisibilityConfigurations[areaName] = isVisible;
}

AddedObject.prototype.loadState = function(){
  this.physicsBody.position.set(
    this.state.physicsPX, this.state.physicsPY, this.state.physicsPZ
  );
  this.physicsBody.quaternion.set(
    this.state.physicsQX, this.state.physicsQY, this.state.physicsQZ, this.state.physicsQW
  );
  this.physicsBody.angularVelocity.set(
    this.state.physicsAVX, this.state.physicsAVY, this.state.physicsAVZ
  );
  this.physicsBody.velocity.set(
    this.state.physicsVX, this.state.physicsVY, this.state.physicsVZ
  );
  this.mesh.position.set(
    this.state.positionX, this.state.positionY, this.state.positionZ
  );
  this.mesh.quaternion.set(
    this.state.quaternionX, this.state.quaternionY, this.state.quaternionZ, this.state.quaternionW
  );
  if (this.pivotObject){
    delete this.pivotObject;
    delete this.pivotOffsetX;
    delete this.pivotOffsetY;
    delete this.pivotOffsetZ;
  }
  if (this.originalPivotObject){
    this.pivotObject = this.originalPivotObject;
    this.pivotOffsetX = this.originalPivotOffsetX;
    this.pivotOffsetY = this.originalPivotOffsetY;
    this.pivotOffsetZ = this.originalPivotOffsetZ;
  }
}

AddedObject.prototype.saveState = function(){
  this.state = new Object();
  this.state.physicsPX = this.physicsBody.position.x;
  this.state.physicsPY = this.physicsBody.position.y;
  this.state.physicsPZ = this.physicsBody.position.z;
  this.state.physicsQX = this.physicsBody.quaternion.x;
  this.state.physicsQY = this.physicsBody.quaternion.y;
  this.state.physicsQZ = this.physicsBody.quaternion.z;
  this.state.physicsQW = this.physicsBody.quaternion.w;
  this.state.physicsAVX = this.physicsBody.angularVelocity.x;
  this.state.physicsAVY = this.physicsBody.angularVelocity.y;
  this.state.physicsAVZ = this.physicsBody.angularVelocity.z;
  this.state.physicsVX = this.physicsBody.velocity.x;
  this.state.physicsVY = this.physicsBody.velocity.y;
  this.state.physicsVZ = this.physicsBody.velocity.z;
  this.state.positionX = this.mesh.position.x;
  this.state.positionY = this.mesh.position.y;
  this.state.positionZ = this.mesh.position.z;
  this.state.quaternionX = this.mesh.quaternion.x;
  this.state.quaternionY = this.mesh.quaternion.y;
  this.state.quaternionZ = this.mesh.quaternion.z;
  this.state.quaternionW = this.mesh.quaternion.w;
  if (this.pivotObject){
    this.originalPivotObject = this.pivotObject;
    this.originalPivotOffsetX = this.pivotOffsetX;
    this.originalPivotOffsetY = this.pivotOffsetY;
    this.originalPivotOffsetZ = this.pivotOffsetZ;
  }
}

AddedObject.prototype.handleRenderSide = function(val){
  this.metaData["renderSide"] = val;
  if (val == 0){
    this.mesh.material.side = THREE.DoubleSide;
    this.defaultSide = SIDE_BOTH;
  }else if (val == 1){
    this.mesh.material.side = THREE.FrontSide;
    this.defaultSide = SIDE_FRONT;
  }else if (val == 2){
    this.mesh.material.side = THREE.BackSide;
    this.defaultSide = SIDE_BACK;
  }
}

AddedObject.prototype.isSlicable = function(){
  if (this.type == "sphere"){
    return true;
  }
  if (this.type != "surface"){
    return false;
  }
  if (this.metaData.widthSegments == 1 && this.metaData.heightSegments == 1){
    return true;
  }
  return false;
}

AddedObject.prototype.sliceInHalf = function(type){
  if (!this.isSlicable()){
    return;
  }
  var newGeometry;
  if (this.type == "sphere"){
    if (type == 0 || type == 1 || type == 2 || type == 3){
      var geomKey = (
        "SphereBufferGeometry" + PIPE +
        Math.abs(this.metaData.radius) + PIPE +
        this.metaData.widthSegments + PIPE + this.metaData.heightSegments + PIPE +
        "SLICED" + PIPE + type
      );
      var cachedGeom = geometryCache[geomKey];
      this.metaData.slicedType = type;
      if (!cachedGeom){
        if (type == 0){
          newGeometry = new THREE.SphereBufferGeometry(
            this.metaData.radius, this.metaData.widthSegments,
            this.metaData.heightSegments, 0, 2 * Math.PI, 0, 0.5 * Math.PI);
        }else if (type == 1){
          newGeometry = new THREE.SphereBufferGeometry(
            this.metaData.radius, this.metaData.widthSegments,
            this.metaData.heightSegments, 0, Math.PI, 0, Math.PI);
        }else if (type == 2){
          newGeometry = new THREE.SphereBufferGeometry(
            this.metaData.radius, this.metaData.widthSegments,
            this.metaData.heightSegments, 0, 2 * Math.PI, Math.PI / 2, 0.5 * Math.PI);
        }else if (type == 3){
          newGeometry = new THREE.SphereBufferGeometry(
            this.metaData.radius, this.metaData.widthSegments,
            this.metaData.heightSegments, Math.PI, Math.PI, 0, Math.PI);
        }
        geometryCache[geomKey] = newGeometry;
      }else{
        newGeometry = cachedGeom;
      }
    }else{
      var originalGeomKey = (
        "SphereBufferGeometry" + PIPE +
        Math.abs(this.metaData.radius) + PIPE +
        this.metaData.widthSegments + PIPE + this.metaData.heightSegments
      );
      newGeometry = geometryCache[originalGeomKey];
      delete this.metaData.slicedType;
    }
  }else if (this.type == "surface"){
    var geomKey = (
      "PlaneBufferGeometry" + PIPE +
      this.metaData.width + PIPE + this.metaData.height + PIPE +
      this.metaData.widthSegments + PIPE + this.metaData.heightSegments
    );
    var originalGeometry = geometryCache[geomKey];
    var normals = [], positions = [], uvs = [0, 0, 1, 1, 0, 1];
    var subIndices;
    var indices = originalGeometry.index.array;
    if (type == 0){
      subIndices = [indices[0], indices[1], indices[2]];
    }else if (type == 1){
      subIndices = [indices[3], indices[4], indices[5]];
    }else if (type == 2){
      subIndices = [indices[1], indices[4], indices[0]];
    }else if (type == 3){
      subIndices = [indices[2], indices[4], indices[0]]
    }

    if (type == 0 || type == 1 || type == 2 || type == 3){
      this.metaData.slicedType = type;
      for (var i = 0; i<subIndices.length; i++){
        for (var i2 = 0; i2<3; i2++){
          positions.push(originalGeometry.attributes.position.array[
            (3 * subIndices[i]) + i2
          ]);
          normals.push(originalGeometry.attributes.normal.array[
            (3 * subIndices[i]) + i2
          ]);
        }
      }

      var newGeometryKey = (
        "SlicedPlaneBufferGeometry" + PIPE +
        this.metaData.width + PIPE + this.metaData.height + PIPE + type
      );
      newGeometry = geometryCache[newGeometryKey];
      if (!newGeometry){
        newGeometry = new THREE.BufferGeometry();
        newGeometry.addAttribute("position", new THREE.BufferAttribute(new Float32Array(positions), 3));
        newGeometry.addAttribute("normal", new THREE.BufferAttribute(new Float32Array(normals), 3));
        newGeometry.addAttribute("uv", new THREE.BufferAttribute(new Float32Array(uvs), 2));
        geometryCache[newGeometryKey] = newGeometry;
      }
    }else{
      delete this.metaData.slicedType;
      newGeometry = originalGeometry;
    }
  }

  scene.remove(this.mesh);
  var newMesh = new THREE.Mesh(newGeometry, this.mesh.material);
  newMesh.position.copy(this.mesh.position);
  newMesh.quaternion.copy(this.mesh.quaternion);
  newMesh.addedObject = this;
  this.mesh = newMesh;
  scene.add(this.mesh);
  this.generateBoundingBoxes();
}

AddedObject.prototype.syncProperties = function(refObject){
  // TEXTURE OFFSETS
  if (refObject.hasTexture() && this.hasTexture()){
    var m1 = this.mesh.material.uniforms.textureMatrix.value.elements;
    var m2 = refObject.mesh.material.uniforms.textureMatrix.value.elements;
    for (var i = 0; i<m2.length; i++){
      m1[i] = m2[i];
    }
  }
  // OPACITY
  var refOpacity = refObject.mesh.material.uniforms.alpha.value;
  this.updateOpacity(refOpacity);
  this.initOpacitySet = false;
  // AO INTENSITY
  if (refObject.hasAOMap() && this.hasAOMap()){
    var refAOIntensity = refObject.mesh.material.uniforms.aoIntensity.value;
    this.mesh.material.uniforms.aoIntensity.value = refAOIntensity
  }
  // EMISSIVE INTENSITY
  if (refObject.hasEmissiveMap() && this.hasEmissiveMap()){
    var refMaterial = refObject.mesh.material;
    var refEmissiveIntensity = refMaterial.uniforms.emissiveIntensity.value;
    this.mesh.material.uniforms.emissiveIntensity.value = refEmissiveIntensity;
    // EMISSIVE COLOR
    var refEmissiveColor = refMaterial.uniforms.emissiveColor.value;
    this.mesh.material.uniforms.emissiveColor.value.copy(refEmissiveColor);
  }
  // DISPLACEMENT
    if (refObject.hasDisplacementMap() && this.hasDisplacementMap()){
    var refDispX = refObject.mesh.material.uniforms.displacementInfo.value.x;
    var refDispY = refObject.mesh.material.uniforms.displacementInfo.value.y;
    this.mesh.material.uniforms.displacementInfo.value.x = refDispX;
    this.mesh.material.uniforms.displacementInfo.value.y = refDispY;
  }
}

AddedObject.prototype.setAttachedProperties = function(){
  this.qxWhenAttached = this.mesh.quaternion.x;
  this.qyWhenAttached = this.mesh.quaternion.y;
  this.qzWhenAttached = this.mesh.quaternion.z;
  this.qwWhenAttached = this.mesh.quaternion.w;
  this.pqxWhenAttached = this.physicsBody.quaternion.x;
  this.pqyWhenAttached = this.physicsBody.quaternion.y;
  this.pqzWhenAttached = this.physicsBody.quaternion.z;
  this.pqwWhenAttached = this.physicsBody.quaternion.w;
  this.positionXWhenAttached = this.mesh.position.x;
  this.positionYWhenAttached = this.mesh.position.y;
  this.positionZWhenAttached = this.mesh.position.z;
}

AddedObject.prototype.getTextureUniform = function(texture){
  if (textureUniformCache[texture.uuid]){
    return textureUniformCache[texture.uuid];
  }
  var uniform = new THREE.Uniform(texture);
  textureUniformCache[texture.uuid] = uniform;
  return uniform;
}

AddedObject.prototype.hasEmissiveMap = function(){
  return !(typeof this.mesh.material.uniforms.emissiveMap == UNDEFINED);
}

AddedObject.prototype.unMapEmissive = function(){
  if (this.hasEmissiveMap()){
    delete this.mesh.material.uniforms.emissiveMap;
    delete this.mesh.material.uniforms.emissiveIntensity;
    delete this.mesh.material.uniforms.emissiveColor;
    this.removeMacro("HAS_EMISSIVE", false, true);
    if (!this.hasTexture()){
      delete this.mesh.material.uniforms.textureMatrix;
      this.removeMacro("HAS_TEXTURE", true, true);
    }
  }
}

AddedObject.prototype.mapEmissive = function(emissiveMap){
  if (!this.hasTexture()){
    var tMatrix = new THREE.Matrix3();
    tMatrix.setUvTransform(0, 0, 1, 1, 0, 0, 0);
    this.mesh.material.uniforms.textureMatrix = new THREE.Uniform(tMatrix);
    this.injectMacro("HAS_TEXTURE", true, true);
    this.mesh.material.uniformsNeedUpdate = true;
  }
  if (this.hasEmissiveMap()){
    this.mesh.material.uniforms.emissiveMap.value = emissiveMap;
  }else{
    this.mesh.material.uniforms.emissiveMap = this.getTextureUniform(emissiveMap);
    this.mesh.material.uniforms.emissiveIntensity = new THREE.Uniform(this.material.emissiveIntensity);
    this.mesh.material.uniforms.emissiveColor = new THREE.Uniform(new THREE.Color(this.material.emissiveColor));
    this.injectMacro("HAS_EMISSIVE", false, true);
    this.mesh.material.uniformsNeedUpdate = true;
  }
  emissiveMap.updateMatrix();
}

AddedObject.prototype.hasDisplacementMap = function(){
  return !(typeof this.mesh.material.uniforms.displacementMap == UNDEFINED);
}

AddedObject.prototype.unMapDisplacement = function(){
  if (!VERTEX_SHADER_TEXTURE_FETCH_SUPPORTED){
    console.error("Displacement mapping is not supported for this device.");
    return;
  }
  if (this.hasDisplacementMap()){
    delete this.mesh.material.uniforms.displacementMap;
    delete this.mesh.material.uniforms.displacementInfo;
    this.removeMacro("HAS_DISPLACEMENT", true, false);
    if (!this.hasTexture()){
      delete this.mesh.material.uniforms.textureMatrix;
      this.removeMacro("HAS_TEXTURE", true, true);
    }
  }
}

AddedObject.prototype.mapDisplacement = function(displacementTexture){
  if (!VERTEX_SHADER_TEXTURE_FETCH_SUPPORTED){
    console.error("Displacement mapping is not supported for this device.");
    return;
  }
  if (!this.hasTexture()){
    var tMatrix = new THREE.Matrix3();
    tMatrix.setUvTransform(0, 0, 1, 1, 0, 0, 0);
    this.mesh.material.uniforms.textureMatrix = new THREE.Uniform(tMatrix);
    this.injectMacro("HAS_TEXTURE", true, true);
    this.mesh.material.uniformsNeedUpdate = true;
  }
  if (this.hasDisplacementMap()){
    this.mesh.material.uniforms.displacementMap.value = displacementTexture;
  }else{
    this.mesh.material.uniforms.displacementMap = this.getTextureUniform(displacementTexture);
    this.mesh.material.uniforms.displacementInfo = new THREE.Uniform(new THREE.Vector2());
    this.injectMacro("HAS_DISPLACEMENT", true, false);
    this.mesh.material.uniformsNeedUpdate = true;
  }
  displacementTexture.updateMatrix();
}

AddedObject.prototype.hasAOMap = function(){
  return !(typeof this.mesh.material.uniforms.aoMap == UNDEFINED);
}

AddedObject.prototype.unMapAO = function(){
  if (this.hasAOMap()){
    delete this.mesh.material.uniforms.aoMap;
    delete this.mesh.material.uniforms.aoIntensity;
    this.removeMacro("HAS_AO", false, true);
    if (!this.hasTexture()){
      delete this.mesh.material.uniforms.textureMatrix;
      this.removeMacro("HAS_TEXTURE", true, true);
    }
  }
}

AddedObject.prototype.mapAO = function(aoTexture){
  if (!this.hasTexture()){
    var tMatrix = new THREE.Matrix3();
    tMatrix.setUvTransform(0, 0, 1, 1, 0, 0, 0);
    this.mesh.material.uniforms.textureMatrix = new THREE.Uniform(tMatrix);
    this.injectMacro("HAS_TEXTURE", true, true);
    this.mesh.material.uniformsNeedUpdate = true;
  }
  if (this.hasAOMap()){
    this.mesh.material.uniforms.aoMap.value = aoTexture;
  }else{
    this.mesh.material.uniforms.aoMap = this.getTextureUniform(aoTexture);
    this.mesh.material.uniforms.aoIntensity = new THREE.Uniform(this.material.aoMapIntensity);
    this.injectMacro("HAS_AO", false, true);
    this.mesh.material.uniformsNeedUpdate = true;
  }
  aoTexture.updateMatrix();
}

AddedObject.prototype.hasAlphaMap = function(){
  return !(typeof this.mesh.material.uniforms.alphaMap == UNDEFINED);
}

AddedObject.prototype.unMapAlpha = function(){
  if (this.hasAlphaMap()){
    delete this.mesh.material.uniforms.alphaMap;
    this.removeMacro("HAS_ALPHA", false, true);
    if (!this.hasTexture()){
      delete this.mesh.material.uniforms.textureMatrix;
      this.removeMacro("HAS_TEXTURE", true, true);
    }
  }
}

AddedObject.prototype.mapAlpha = function(alphaTexture){
  if (!this.hasTexture()){
    var tMatrix = new THREE.Matrix3();
    tMatrix.setUvTransform(0, 0, 1, 1, 0, 0, 0);
    this.mesh.material.uniforms.textureMatrix = new THREE.Uniform(tMatrix);
    this.injectMacro("HAS_TEXTURE", true, true);
    this.mesh.material.uniformsNeedUpdate = true;
  }
  if (this.hasAlphaMap()){
    this.mesh.material.uniforms.alphaMap.value = alphaTexture;
  }else{
    this.mesh.material.uniforms.alphaMap = this.getTextureUniform(alphaTexture);
    this.injectMacro("HAS_ALPHA", false, true);
    this.mesh.material.uniformsNeedUpdate = true;
  }
  alphaTexture.updateMatrix();
}

AddedObject.prototype.hasDiffuseMap = function(){
  return !(typeof this.mesh.material.uniforms.diffuseMap == UNDEFINED);
}

AddedObject.prototype.unMapDiffuse = function(){
  if (this.hasDiffuseMap()){
    delete this.mesh.material.uniforms.diffuseMap;
    this.removeMacro("HAS_DIFFUSE", false, true);
    if (!this.hasTexture()){
      delete this.mesh.material.uniforms.textureMatrix;
      this.removeMacro("HAS_TEXTURE", true, true);
    }
  }
}

AddedObject.prototype.mapDiffuse = function(diffuseTexture){
  if (!this.hasTexture()){
    var tMatrix = new THREE.Matrix3();
    tMatrix.setUvTransform(0, 0, 1, 1, 0, 0, 0);
    this.mesh.material.uniforms.textureMatrix = new THREE.Uniform(tMatrix);
    this.injectMacro("HAS_TEXTURE", true, true);
    this.mesh.material.uniformsNeedUpdate = true;
  }
  if (this.hasDiffuseMap()){
    this.mesh.material.uniforms.diffuseMap.value = diffuseTexture
  }else{
    this.mesh.material.uniforms.diffuseMap = this.getTextureUniform(diffuseTexture);
    this.injectMacro("HAS_DIFFUSE", false, true);
    this.mesh.material.uniformsNeedUpdate = true;
  }
  diffuseTexture.updateMatrix();
}

AddedObject.prototype.incrementOpacity = function(val){
  this.mesh.material.uniforms.alpha.value += val;
}

AddedObject.prototype.updateOpacity = function(val){
  this.mesh.material.uniforms.alpha.value = val;
}

AddedObject.prototype.updateMVMatrix = function(){
  this.mesh.material.uniforms.modelViewMatrix.value = this.mesh.modelViewMatrix;
}

AddedObject.prototype.handleMirror = function(axis, property){
  var texturesStack = this.getTextureStack();
  if (axis == "T"){
    this.metaData["mirrorT"] = property.toUpperCase();
  }
  if (axis == "S"){
    this.metaData["mirrorS"] = property.toUpperCase();
  }
  if (axis == "ST"){
    this.metaData["mirrorT"] = property.toUpperCase();
    this.metaData["mirrorS"] = property.toUpperCase();
  }
  for (var i = 0; i < texturesStack.length; i++){
    var texture = texturesStack[i];
    if (property.toUpperCase() == "ON"){
      if (axis == "T"){
        texture.wrapT = THREE.MirroredRepeatWrapping;
      }else if (axis == "S"){
        texture.wrapS = THREE.MirroredRepeatWrapping;
      }else if (axis == "ST"){
        texture.wrapS = THREE.MirroredRepeatWrapping;
        texture.wrapT = THREE.MirroredRepeatWrapping;
      }
    }else if (property.toUpperCase() == "OFF"){
      if (axis == "T"){
        texture.wrapT = THREE.RepeatWrapping;
      }else if (axis == "S"){
        texture.wrapS = THREE.RepeatWrapping;
      }else if (axis == "ST"){
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
      }
    }
    texture.needsUpdate = true;
  }
}

AddedObject.prototype.getTextureStack = function(){
  var texturesStack = [];
  if (this.hasDiffuseMap()){
    texturesStack.push(this.mesh.material.uniforms.diffuseMap.value);
  }
  if (this.hasAlphaMap()){
    texturesStack.push(this.mesh.material.uniforms.alphaMap.value);
  }
  if (this.hasAOMap()){
    texturesStack.push(this.mesh.material.uniforms.aoMap.value);
  }
  if (this.hasEmissiveMap()){
    texturesStack.push(this.mesh.material.uniforms.emissiveMap.value);
  }
  if (this.hasDisplacementMap()){
    texturesStack.push(this.mesh.material.uniforms.displacementMap.value);
  }
  return texturesStack;
}

AddedObject.prototype.getPositionAtAxis = function(axis){
  if (axis.toLowerCase() == "x"){
    if (this.type == "box" || this.type == "ramp" || this.type == "sphere" || this.type == "cylinder"){
      return parseInt(this.metaData["centerX"]);
    }else if (this.type == "surface"){
      return parseInt(this.metaData["positionX"]);
    }
  }else if (axis.toLowerCase() == "y"){
    if (this.type == "box" || this.type == "ramp" || this.type == "sphere" || this.type == "cylinder"){
      return parseInt(this.metaData["centerY"]);
    }else if (this.type == "surface"){
      return parseInt(this.metaData["positionY"]);
    }
  }else if (axis.toLowerCase() == "z"){
    if (this.type == "box" || this.type == "ramp" || this.type == "sphere" || this.type == "cylinder"){
      return parseInt(this.metaData["centerZ"]);
    }else if (this.type == "surface"){
      return parseInt(this.metaData["positionZ"]);
    }
  }
}

AddedObject.prototype.resetPosition = function(){
  var mesh = this.mesh;
  var physicsBody = this.physicsBody;
  if (this.type == "box" || this.type == "ramp" || this.type == "sphere" || this.type == "cylinder"){
    mesh.position.x = this.metaData["centerX"];
    mesh.position.y = this.metaData["centerY"];
    mesh.position.z = this.metaData["centerZ"];
  }else if (this.type == "surface"){
    mesh.position.x = this.metaData["positionX"];
    mesh.position.y = this.metaData["positionY"];
    mesh.position.z = this.metaData["positionZ"];
  }

  physicsBody.position.copy(mesh.position);
}

AddedObject.prototype.translate = function(axis, amount, fromScript){
  var physicsBody = this.physicsBody;
  if (axis == "x"){
    this.mesh.translateX(amount);
  }else if (axis == "y"){
    this.mesh.translateY(amount);
  }else if (axis == "z"){
    this.mesh.translateZ(amount);
  }
  physicsBody.position.copy(this.mesh.position);
  if (this.mesh.visible){
    rayCaster.updateObject(this);
  }
}

AddedObject.prototype.rotate = function(axis, radians, fromScript){

  if (this.type == "surface"){
    this.rotateSurface(axis, radians, fromScript);
  }else if (this.type == "box"){
    this.rotateBox(axis, radians, fromScript);
  }else if (this.type == "ramp"){
    this.rotateRamp(axis, radians, fromScript);
  }else if (this.type == "sphere"){
    this.rotateSphere(axis, radians, fromScript);
  }else if (this.type == "cylinder"){
    this.rotateCylinder(axis, radians, fromScript);
  }

  if (!fromScript){
    if (axis == "x"){
      this.rotationX += radians;
    }else if (axis == "y"){
      this.rotationY += radians;
    }else if (axis == "z"){
      this.rotationZ += radians;
    }
    this.initQuaternion.copy(this.mesh.quaternion);
  }

  if (this.mesh.visible){
    rayCaster.updateObject(this);
  }

}

AddedObject.prototype.setPhysicsAfterRotationAroundPoint = function(axis, radians){
  if (this.type == "surface"){
    this.setSurfacePhysicsAfterRotationAroundPoint(axis, radians);
  }else if (this.type == "box"){
    this.setBoxPhysicsAfterRotationAroundPoint(axis, radians);
  }else if (this.type == "ramp"){
    this.setRampPhysicsAfterRotationAroundPoint(axis, radians);
  }else if (this.type == "sphere"){
    this.setSpherePhysicsAfterRotationAroundPoint(axis, radians);
  }else if (this.type == "cylinder"){
    this.setCylinderPhysicsAfterRotationAroundPoint(axis, radians);
  }
  this.physicsBody.position.copy(this.mesh.position);
}

AddedObject.prototype.setSurfacePhysicsAfterRotationAroundPoint = function(axis, radians){
  var physicsBody = this.physicsBody;
  var gridSystemAxis = this.metaData.gridSystemAxis;
  if (gridSystemAxis == "XY"){
    physicsBody.quaternion.copy(this.mesh.quaternion);
  }else if (gridSystemAxis == "XZ"){
    REUSABLE_QUATERNION.copy(this.mesh.quaternion);
    REUSABLE_QUATERNION2.setFromAxisAngle(THREE_AXIS_VECTOR_X, Math.PI / 2);
    REUSABLE_QUATERNION.multiply(REUSABLE_QUATERNION2);
    physicsBody.quaternion.copy(REUSABLE_QUATERNION);
  }else if (gridSystemAxis == "YZ"){
    REUSABLE_QUATERNION.copy(this.mesh.quaternion);
    REUSABLE_QUATERNION2.setFromAxisAngle(THREE_AXIS_VECTOR_Y, Math.PI / 2);
    REUSABLE_QUATERNION.multiply(REUSABLE_QUATERNION2);
    physicsBody.quaternion.copy(REUSABLE_QUATERNION);
  }
}

AddedObject.prototype.setCylinderPhysicsAfterRotationAroundPoint = function(axis, radians){
  var physicsBody = this.physicsBody;
  var gridSystemAxis = this.metaData.gridSystemAxis;
  if (gridSystemAxis == "XZ"){
    physicsBody.quaternion.copy(this.mesh.quaternion);
  }else if (gridSystemAxis == "XY"){
    REUSABLE_QUATERNION.copy(this.mesh.quaternion);
    REUSABLE_QUATERNION2.setFromAxisAngle(THREE_AXIS_VECTOR_X, -Math.PI/2);
    REUSABLE_QUATERNION.multiply(REUSABLE_QUATERNION2);
    physicsBody.quaternion.copy(REUSABLE_QUATERNION);
  }else if (gridSystemAxis == "YZ"){
    REUSABLE_QUATERNION.copy(this.mesh.quaternion);
    REUSABLE_QUATERNION2.setFromAxisAngle(THREE_AXIS_VECTOR_Z, Math.PI/2);
    REUSABLE_QUATERNION.multiply(REUSABLE_QUATERNION2);
    physicsBody.quaternion.copy(REUSABLE_QUATERNION);
  }
}

AddedObject.prototype.setSpherePhysicsAfterRotationAroundPoint = function(axis, radians){
  var physicsBody = this.physicsBody;
  physicsBody.quaternion.copy(this.mesh.quaternion);
}

AddedObject.prototype.setBoxPhysicsAfterRotationAroundPoint = function(axis, radians){
  var physicsBody = this.physicsBody;
  physicsBody.quaternion.copy(this.mesh.quaternion);
}

AddedObject.prototype.setRampPhysicsAfterRotationAroundPoint = function(axis, radians){
  var physicsBody = this.physicsBody;
  var gridSystemAxis = this.metaData.gridSystemAxis;
  if (gridSystemAxis == "XY"){
    REUSABLE_QUATERNION.copy(this.mesh.quaternion);
    REUSABLE_QUATERNION2.setFromAxisAngle(THREE_AXIS_VECTOR_X, Math.PI / 2);
    REUSABLE_QUATERNION.multiply(REUSABLE_QUATERNION2);
    physicsBody.quaternion.copy(REUSABLE_QUATERNION);
  }else if (gridSystemAxis == "XZ"){
    REUSABLE_QUATERNION.copy(this.mesh.quaternion);
    REUSABLE_QUATERNION2.setFromAxisAngle(THREE_AXIS_VECTOR_X, Math.PI / 2);
    REUSABLE_QUATERNION.multiply(REUSABLE_QUATERNION2);
    physicsBody.quaternion.copy(REUSABLE_QUATERNION);
  }else if (gridSystemAxis == "YZ"){
    REUSABLE_QUATERNION.copy(this.mesh.quaternion);
    REUSABLE_QUATERNION2.setFromAxisAngle(THREE_AXIS_VECTOR_X, Math.PI / 2);
    REUSABLE_QUATERNION.multiply(REUSABLE_QUATERNION2);
    physicsBody.quaternion.copy(REUSABLE_QUATERNION);
  }
}

AddedObject.prototype.rotateSphere = function(axis, radians, fromScript){
  var mesh = this.mesh;
  var physicsBody = this.physicsBody;
  if (axis == "x"){
    mesh.rotateOnWorldAxis(
      THREE_AXIS_VECTOR_X,
      radians
    );
  }else if (axis == "y"){
    mesh.rotateOnWorldAxis(
      THREE_AXIS_VECTOR_Y,
      radians
    );
  }else if (axis == "z"){
    mesh.rotateOnWorldAxis(
      THREE_AXIS_VECTOR_Z,
      radians
    );
  }
  physicsBody.quaternion.copy(mesh.quaternion);
  if (!fromScript){
    physicsBody.initQuaternion.copy(
      physicsBody.quaternion
    );
  }
}

AddedObject.prototype.rotateCylinder = function(axis, radians, fromScript){
  var mesh = this.mesh;
  var physicsBody = this.physicsBody;
  var gridSystemAxis = this.metaData.gridSystemAxis;
  if (axis == "x"){
    mesh.rotateOnWorldAxis(
      THREE_AXIS_VECTOR_X,
      radians
    );
  }else if (axis == "y"){
    mesh.rotateOnWorldAxis(
      THREE_AXIS_VECTOR_Y,
      radians
    );
  }else if (axis == "z"){
    mesh.rotateOnWorldAxis(
      THREE_AXIS_VECTOR_Z,
      radians
    );
  }
  this.rotatePhysicsBody(axis, radians);
  if (!fromScript){
    physicsBody.initQuaternion.copy(
      physicsBody.quaternion
    );
  }
}

AddedObject.prototype.rotateRamp = function(axis, radians, fromScript){
  var mesh = this.mesh;
  var physicsBody = this.physicsBody;
  var gridSystemAxis = this.metaData.gridSystemAxis;
  if (axis == "x"){
    mesh.rotateOnWorldAxis(
      THREE_AXIS_VECTOR_X,
      radians
    );
  }else if (axis == "y"){
    mesh.rotateOnWorldAxis(
      THREE_AXIS_VECTOR_Y,
      radians
    );
  }else if (axis == "z"){
    mesh.rotateOnWorldAxis(
      THREE_AXIS_VECTOR_Z,
      radians
    );
  }
  if (gridSystemAxis == "XY"){
    REUSABLE_QUATERNION.copy(mesh.quaternion);
    REUSABLE_QUATERNION2.setFromAxisAngle(THREE_AXIS_VECTOR_X, Math.PI / 2);
    REUSABLE_QUATERNION.multiply(REUSABLE_QUATERNION2);
    physicsBody.quaternion.copy(REUSABLE_QUATERNION);
  }else if (gridSystemAxis == "XZ"){
    REUSABLE_QUATERNION.copy(mesh.quaternion);
    REUSABLE_QUATERNION2.setFromAxisAngle(THREE_AXIS_VECTOR_X, Math.PI / 2);
    REUSABLE_QUATERNION.multiply(REUSABLE_QUATERNION2);
    physicsBody.quaternion.copy(REUSABLE_QUATERNION);
  }else if (gridSystemAxis == "YZ"){
    REUSABLE_QUATERNION.copy(mesh.quaternion);
    REUSABLE_QUATERNION2.setFromAxisAngle(THREE_AXIS_VECTOR_X, Math.PI / 2);
    REUSABLE_QUATERNION.multiply(REUSABLE_QUATERNION2);
    physicsBody.quaternion.copy(REUSABLE_QUATERNION);
  }
  if (!fromScript){
    physicsBody.initQuaternion.copy(
      physicsBody.quaternion
    );
    this.initQuaternion.copy(this.mesh.quaternion);
  }
}

AddedObject.prototype.rotateSurface = function(axis, radians, fromScript){
  var mesh = this.mesh;
  var physicsBody = this.physicsBody;
  var gridSystemAxis = this.metaData.gridSystemAxis;

  if (axis == "x"){
    mesh.rotateOnWorldAxis(
      THREE_AXIS_VECTOR_X,
      radians
    );
  }else if (axis == "y"){
    mesh.rotateOnWorldAxis(
      THREE_AXIS_VECTOR_Y,
      radians
    );
  }else if (axis == "z"){
    mesh.rotateOnWorldAxis(
      THREE_AXIS_VECTOR_Z,
      radians
    );
  }
  if (gridSystemAxis == "XY"){
    physicsBody.quaternion.copy(mesh.quaternion);
  }else if (gridSystemAxis == "XZ"){
    REUSABLE_QUATERNION.copy(mesh.quaternion);
    REUSABLE_QUATERNION2.setFromAxisAngle(THREE_AXIS_VECTOR_X, Math.PI / 2);
    REUSABLE_QUATERNION.multiply(REUSABLE_QUATERNION2);
    physicsBody.quaternion.copy(REUSABLE_QUATERNION);
  }else if (gridSystemAxis == "YZ"){
    REUSABLE_QUATERNION.copy(mesh.quaternion);
    REUSABLE_QUATERNION2.setFromAxisAngle(THREE_AXIS_VECTOR_Y, Math.PI / 2);
    REUSABLE_QUATERNION.multiply(REUSABLE_QUATERNION2);
    physicsBody.quaternion.copy(REUSABLE_QUATERNION);
  }
  if (!fromScript){
    physicsBody.initQuaternion.copy(
      physicsBody.quaternion
    );
    this.initQuaternion.copy(this.mesh.quaternion);
  }
}

AddedObject.prototype.rotateBox = function(axis, radians, fromScript){
  var mesh = this.mesh;
  var physicsBody = this.physicsBody;
  if (axis == "x"){
    mesh.rotateOnWorldAxis(
      THREE_AXIS_VECTOR_X,
      radians
    );
  }else if (axis == "y"){
    mesh.rotateOnWorldAxis(
      THREE_AXIS_VECTOR_Y,
      radians
    );
  }else if (axis == "z"){
    mesh.rotateOnWorldAxis(
      THREE_AXIS_VECTOR_Z,
      radians
    );
  }
  physicsBody.quaternion.copy(mesh.quaternion);
  if (!fromScript){
    physicsBody.initQuaternion.copy(
      physicsBody.quaternion
    );
  }
}

AddedObject.prototype.rotatePhysicsBody = function(axis, radians){
  if (axis.toLowerCase() == "x"){
    REUSABLE_CANNON_QUATERNION.setFromAxisAngle(CANNON_AXIS_VECTOR_X, radians);
  }else if (axis.toLowerCase() == "y"){
    REUSABLE_CANNON_QUATERNION.setFromAxisAngle(CANNON_AXIS_VECTOR_Y, radians);
  }else if (axis.toLowerCase() == "z"){
    REUSABLE_CANNON_QUATERNION.setFromAxisAngle(CANNON_AXIS_VECTOR_Z, radians);
  }
  REUSABLE_CANNON_QUATERNION.mult(this.physicsBody.quaternion, REUSABLE_CANNON_QUATERNION_2);
  this.physicsBody.quaternion.copy(REUSABLE_CANNON_QUATERNION_2);
}

AddedObject.prototype.setCannonQuaternionFromTHREE = function(){
  this.physicsBody.quaternion.copy(this.mesh.quaternion);
  if (this.type == "ramp" || this.type == "surface"){
    if (this.gridSystemAxis == "XZ" || this.gridSystemAxis == "XY" || this.gridSystemAxis == "YZ"){
      if (!(this.type == "surface" && (this.gridSystemAxis == "XY" || this.gridSystemAxis == "YZ"))){
        this.physicsBody.rotation.y += (Math.PI / 2);
      }else{
        if (this.type == "surface" && this.gridSystemAxis == "YZ"){
          this.mesh.rotation.y -= (Math.PI / 2);
        }
      }
    }
  }
}

AddedObject.prototype.setMass = function(mass){
  if (mass != 0){
    this.isDynamicObject = true;
    this.physicsBody.type = CANNON.Body.DYNAMIC;
  }else{
    this.isDynamicObject = false;
    this.physicsBody.type = CANNON.Body.STATIC;
  }
  this.physicsBody.mass = mass;
  this.physicsBody.updateMassProperties();
  this.physicsBody.aabbNeedsUpdate = true;
  this.mass = mass;
}

AddedObject.prototype.destroy = function(){
  scene.remove(this.mesh);
  physicsWorld.remove(this.physicsBody);
  if (this.destroyedGrids){
    for (var gridName in this.destroyedGrids){
      this.destroyedGrids[gridName].destroyedAddedObject = 0;
    }
  }

  this.dispose();

  rayCaster.refresh();
}

AddedObject.prototype.dispose = function(){

  if (this.hasDiffuseMap()){
    this.mesh.material.uniforms.diffuseMap.value.dispose();
  }
  if (this.hasAlphaMap()){
    this.mesh.material.uniforms.alphaMap.value.dispose();
  }
  if (this.hasAOMap()){
    this.mesh.material.uniforms.aoMap.value.dispose();
  }
  if (this.hasDisplacementMap()){
    this.mesh.material.uniforms.displacementMap.value.dispose();
  }
  if (this.hasEmissiveMap()){
    this.mesh.material.uniforms.emissiveMap.value.dispose();
  }
  this.mesh.material.dispose();
}

AddedObject.prototype.mapTexturePack = function(texturePack){
  this.resetMaps();
  if (texturePack.hasDiffuse){
    this.mapDiffuse(texturePack.diffuseTexture);
    this.mesh.material.uniforms.diffuseMap.value.roygbivTexturePackName = texturePack.name;
    this.mesh.material.uniforms.diffuseMap.value.roygbivTextureName = 0;
    this.mesh.material.uniforms.diffuseMap.value.needsUpdate = true;
  }
  if (texturePack.hasAlpha){
    this.mapAlpha(texturePack.alphaTexture);
    this.mesh.material.uniforms.alphaMap.value.roygbivTexturePackName = texturePack.name;
    this.mesh.material.uniforms.alphaMap.value.roygbivTextureName = 0;
    this.mesh.material.uniforms.alphaMap.value.needsUpdate = true;
  }
  if (texturePack.hasAO){
    this.mapAO(texturePack.aoTexture);
    this.mesh.material.uniforms.aoMap.value.roygbivTexturePackName = texturePack.name;
    this.mesh.material.uniforms.aoMap.value.roygbivTextureName = 0;
    this.mesh.material.uniforms.aoMap.value.needsUpdate = true;
  }
  if (texturePack.hasEmissive){
    this.mapEmissive(texturePack.emissiveTexture);
    this.mesh.material.uniforms.emissiveMap.value.roygbivTexturePackName = texturePack.name;
    this.mesh.material.uniforms.emissiveMap.value.roygbivTextureName = 0;
    this.mesh.material.uniforms.emissiveMap.value.needsUpdate = true;
  }
  if (texturePack.hasHeight && VERTEX_SHADER_TEXTURE_FETCH_SUPPORTED){
    this.mapDisplacement(texturePack.heightTexture);
    this.mesh.material.uniforms.displacementMap.value.roygbivTexturePackName = texturePack.name;
    this.mesh.material.uniforms.displacementMap.value.roygbivTextureName = 0;
    this.mesh.material.uniforms.displacementMap.value.needsUpdate = true;
  }
  this.associatedTexturePack = texturePack.name;
}

AddedObject.prototype.resetAssociatedTexturePack = function(){
  this.associatedTexturePack = 0;
}

AddedObject.prototype.segmentGeometry = function(isCustom, count, returnGeometry){
  var newGometry;
  if (this.type == "surface"){
    var width = this.metaData["width"];
    var height = this.metaData["height"];
    if (!isCustom){
      var geomKey = (
        "PlaneBufferGeometry" + PIPE +
        width + PIPE + height + PIPE +
        planeWidthSegments + PIPE + planeHeightSegments
      );
      newGeometry = geometryCache[geomKey];
      if (!newGeometry){
        newGeometry = new THREE.PlaneBufferGeometry(width, height, planeWidthSegments, planeHeightSegments);
        geometryCache[geomKey] = newGeometry;
      }
    }else{
      if (!isNaN(count)){
        if (returnGeometry){
          var geomKey = (
            "PlaneGeometry" + PIPE +
            width + PIPE + height + PIPE +
            count + PIPE + count
          );
          newGeometry = geometryCache[geomKey];
          if (!newGeometry){
            newGeometry = new THREE.PlaneGeometry(width, height, count, count);
            geometryCache[geomKey] = newGeometry;
          }
        }else{
          var geomKey = (
            "PlaneBufferGeometry" + PIPE +
            width + PIPE + height + PIPE +
            count + PIPE + count
          );
          newGeometry = geometryCache[geomKey];
          if (!newGeometry){
            newGeometry = new THREE.PlaneBufferGeometry(width, height, count, count);
            geometryCache[geomKey] = newGeometry;
          }
        }
      }else{
        if (returnGeometry){
          var geomKey = (
            "PlaneGeometry" + PIPE +
            width + PIPE + height + PIPE +
            count.width + PIPE + count.height
          );
          newGeometry = geometryCache[geomKey];
          if (!newGeometry){
            newGeometry = new THREE.PlaneGeometry(width, height, count.width, count.height);
            geometryCache[geomKey] = newGeometry;
          }
        }else{
          var geomKey = (
            "PlaneBufferGeometry" + PIPE +
            width + PIPE + height + PIPE +
            count.width + PIPE + count.height
          );
          newGeometry = geometryCache[geomKey];
          if (!newGeometry){
            newGeometry = new THREE.PlaneBufferGeometry(width, height, count.width, count.height);
            geometryCache[geomKey] = newGeometry;
          }
        }
      }
    }
  }else if (this.type == "ramp"){
    var rampWidth = this.metaData["rampWidth"];
    var rampHeight = this.metaData["rampHeight"];
    if (!isCustom){
      var geomKey = (
        "PlaneBufferGeometry" + PIPE +
        rampWidth + PIPE + rampHeight + PIPE +
        planeWidthSegments + PIPE + planeHeightSegments
      );
      newGeometry = geometryCache[geomKey];
      if (!newGeometry){
        newGeometry = new THREE.PlaneBufferGeometry(rampWidth, rampHeight, planeWidthSegments, planeHeightSegments);
        geometryCache[geomKey] = newGeometry;
      }
    }else{
      if (!isNaN(count)){
        if (returnGeometry){
          var geomKey = (
            "PlaneGeometry" + PIPE +
            rampWidth + PIPE + rampHeight + PIPE +
            count + PIPE + count
          );
          newGeometry = geometryCache[geomKey];
          if (!newGeometry){
            newGeometry = new THREE.PlaneGeometry(rampWidth, rampHeight, count, count);
            geometryCache[geomKey] = newGeometry;
          }
        }else{
          var geomKey = (
            "PlaneBufferGeometry" + PIPE +
            rampWidth + PIPE + rampHeight + PIPE +
            count + PIPE + count
          );
          newGeometry = geometryCache[geomKey];
          if (!newGeometry){
            newGeometry = new THREE.PlaneBufferGeometry(rampWidth, rampHeight, count, count);
            geometryCache[geomKey] = newGeometry;
          }
        }
      }else{
        if (returnGeometry){
          var geomKey = (
            "PlaneGeometry" + PIPE +
            rampWidth + PIPE + rampHeight + PIPE +
            count.width + PIPE + count.height
          );
          newGeometry = geometryCache[geomKey]
          if (!newGeometry){
            newGeometry = new THREE.PlaneGeometry(rampWidth, rampHeight, count.width, count.height);
            geometryCache[geomKey] = newGeometry;
          }
        }else{
          var geomKey = (
            "PlaneBufferGeometry" + PIPE +
            rampWidth + PIPE + rampHeight + PIPE +
            count.width + PIPE + count.height
          );
          newGeometry = geometryCache[geomKey];
          if (!newGeometry){
            newGeometry = new THREE.PlaneBufferGeometry(rampWidth, rampHeight, count.width, count.height);
            geometryCache[geomKey] = newGeometry;
          }
        }
      }
    }
  }else if (this.type == "box"){
    var boxSizeX = this.metaData["boxSizeX"];
    var boxSizeY = this.metaData["boxSizeY"];
    var boxSizeZ = this.metaData["boxSizeZ"];
    if (!isCustom){
      var geomKey = (
        "BoxBufferGeometry" + PIPE +
        boxSizeX + PIPE + boxSizeY + PIPE + boxSizeZ + PIPE +
        boxWidthSegments + PIPE + boxHeightSegments + PIPE +boxDepthSegments
      );
      newGeometry = geometryCache[geomKey];
      if (!newGeometry){
        newGeometry = new THREE.BoxBufferGeometry(boxSizeX, boxSizeY, boxSizeZ, boxWidthSegments, boxHeightSegments, boxDepthSegments);
        geometryCache[geomKey] = newGeometry;
      }
    }else{
      if (!isNaN(count)){
        if (returnGeometry){
          var geomKey = (
            "BoxGeometry" + PIPE +
            boxSizeX + PIPE + boxSizeY + PIPE + boxSizeZ + PIPE +
            count + PIPE + count + PIPE + count
          );
          newGeometry = geometryCache[geomKey];
          if (!newGeometry){
            newGeometry = new THREE.BoxGeometry(boxSizeX, boxSizeY, boxSizeZ, count, count, count);
            geometryCache[geomKey] = newGeometry;
          }
        }else{
          var geomKey = (
            "BoxBufferGeometry" + PIPE +
            boxSizeX + PIPE + boxSizeY + PIPE + boxSizeZ + PIPE +
            count + PIPE + count + PIPE + count
          );
          newGeometry = geometryCache[geomKey];
          if (!newGeometry){
            newGeometry = new THREE.BoxBufferGeometry(boxSizeX, boxSizeY, boxSizeZ, count, count, count);
            geometryCache[geomKey] = newGeometry;
          }
        }
      }else{
        if (returnGeometry){
          var geomKey = (
            "BoxGeometry" + PIPE +
            boxSizeX + PIPE + boxSizeY + PIPE + boxSizeZ + PIPE +
            count.width + PIPE + count.height + PIPE + count.depth
          );
          newGeometry = geometryCache[geomKey];
          if (!newGeometry){
            newGeometry = new THREE.BoxGeometry(boxSizeX, boxSizeY, boxSizeZ, count.width, count.height, count.depth);
            geometryCache[geomKey] = newGeometry;
          }
        }else{
          var geomKey = (
            "BoxBufferGeometry" + PIPE +
            boxSizeX + PIPE + boxSizeY + PIPE + boxSizeZ + PIPE +
            count.width + PIPE + count.height + PIPE + count.depth
          );
          newGeometry = geometryCache[geomKey];
          if (!newGeometry){
            newGeometry = new THREE.BoxBufferGeometry(boxSizeX, boxSizeY, boxSizeZ, count.width, count.height, count.depth);
            geometryCache[geomKey] = newGeometry;
          }
        }
      }
    }
  }else if (this.type == "sphere"){
    var radius = this.metaData["radius"];
    if (!isCustom){
      var geomKey = (
        "SphereBufferGeometry" + PIPE +
        Math.abs(radius) + PIPE +
        sphereWidthSegments + PIPE + sphereHeightSegments
      );
      newGeometry = geometryCache[geomKey];
      if (!newGeometry){
        newGeometry = new THREE.SphereBufferGeometry(Math.abs(radius), sphereWidthSegments, sphereHeightSegments);
        geometryCache[geomKey] = newGeometry;
      }
    }else{
      if (!isNaN(count)){
        if (count < 8){
          count = 8;
        }
        if (returnGeometry){
          var geomKey = (
            "SphereGeometry" + PIPE +
            Math.abs(radius) + PIPE +
            count + PIPE + count
          );
          newGeometry = geometryCache[geomKey];
          if (!newGeometry){
            newGeometry = new THREE.SphereGeometry(Math.abs(radius), count, count);
            geometryCache[geomKey] = newGeometry;
          }
        }else{
          var geomKey = (
            "SphereBufferGeometry" + PIPE +
            Math.abs(radius) + PIPE +
            count + PIPE + count
          );
          newGeometry = geometryCache[geomKey];
          if (!newGeometry){
            newGeometry = new THREE.SphereBufferGeometry(Math.abs(radius), count, count);
            geometryCache[geomKey] = newGeometry;
          }
        }
      }else{
        if (count.width < 8){
          count.width = 8;
        }
        if (count.height < 6){
          count.height = 6;
        }
        if (returnGeometry){
          var geomKey = (
            "SphereGeometry" + PIPE +
            Math.abs(radius) + PIPE +
            count.width + PIPE + count.height
          );
          newGeometry = geometryCache[geomKey];
          if (!newGeometry){
            newGeometry = new THREE.SphereGeometry(Math.abs(radius), count.width, count.height);
            geometryCache[geomKey] = newGeometry;
          }
        }else{
          var geomKey = (
            "SphereBufferGeometry" + PIPE +
            Math.abs(radius) + PIPE +
            count.width + PIPE + count.height
          );
          newGeometry = geometryCache[geomKey];
          if (!newGeometry){
            newGeometry = new THREE.SphereBufferGeometry(Math.abs(radius), count.width, count.height);
            geometryCache[geomKey] = newGeometry;
          }
        }
      }
    }
  }else if (this.type == "cylinder"){
    var height = this.metaData["height"];
    var topRadius = this.metaData["topRadius"];
    var bottomRadius = this.metaData["bottomRadius"];
    var isOpenEnded = this.metaData["isOpenEnded"];
    if (!isCustom){
      var geomKey = (
        "CylinderBufferGeometry" + PIPE + height + PIPE + topRadius + PIPE + bottomRadius + PIPE +
        cylinderWidthSegments + PIPE + cylinderHeightSegments + PIPE + isOpenEnded
      );
      newGeometry = geometryCache[geomKey];
      if (!newGeometry){
        newGeometry = new THREE.CylinderBufferGeometry(
          topRadius, bottomRadius, height, cylinderWidthSegments, cylinderHeightSegments, isOpenEnded
        );
        geometryCache[geomKey] = newGeometry;
      }
      this.modifyCylinderPhysicsAfterSegmentChange(cylinderWidthSegments);
    }else{
      if (!isNaN(count)){
        if (count < 8){
          count = 8;
        }
        if (returnGeometry){
          var geomKey = (
            "CylinderGeometry" + PIPE + height + PIPE + topRadius + PIPE + bottomRadius + PIPE +
            count + PIPE + count + PIPE + isOpenEnded
          );
          newGeometry = geometryCache[geomKey];
          if (!newGeometry){
            newGeometry = new THREE.CylinderGeometry(
              topRadius, bottomRadius, height, count, count, isOpenEnded
            );
            geometryCache[geomKey] = newGeometry;
          }
        }else{
          var geomKey = (
            "CylinderBufferGeometry" + PIPE + height + PIPE + topRadius + PIPE + bottomRadius + PIPE +
            count + PIPE + count + PIPE + isOpenEnded
          );
          newGeometry = geometryCache[geomKey];
          if (!newGeometry){
            newGeometry = new THREE.CylinderBufferGeometry(
              topRadius, bottomRadius, height, count, count, isOpenEnded
            );
            geometryCache[geomKey] = newGeometry;
          }
          this.modifyCylinderPhysicsAfterSegmentChange(count);
        }
      }else{
        if (count.width < 8){
          count.width = 8;
        }
        if (count.height < 1){
          count.height = 1;
        }
        if (returnGeometry){
          var geomKey = (
            "CylinderGeometry" + PIPE + height + PIPE + topRadius + PIPE + bottomRadius + PIPE +
            count.width + PIPE + count.height + PIPE + isOpenEnded
          );
          newGeometry = geometryCache[geomKey];
          if (!newGeometry){
            newGeometry = new THREE.CylinderGeometry(
              topRadius, bottomRadius, height, count.width, count.height, isOpenEnded
            );
            geometryCache[geomKey] = newGeometry;
          }
        }else{
          var geomKey = (
            "CylinderBufferGeometry" + PIPE + height + PIPE + topRadius + PIPE + bottomRadius + PIPE +
            count.width + PIPE + count.height + PIPE + isOpenEnded
          );
          newGeometry = geometryCache[geomKey];
          if (!newGeometry){
            newGeometry = new THREE.CylinderBufferGeometry(
              topRadius, bottomRadius, height, count.width, count.height, isOpenEnded
            );
            geometryCache[geomKey] = newGeometry;
          }
          this.modifyCylinderPhysicsAfterSegmentChange(count.width);
        }
      }
    }
  }

  if (returnGeometry){
    return newGeometry;
  }

  var newMesh = new THREE.Mesh(newGeometry, this.mesh.material);
  newMesh.position.x = this.mesh.position.x;
  newMesh.position.y = this.mesh.position.y;
  newMesh.position.z = this.mesh.position.z;
  newMesh.rotation.x = this.mesh.rotation.x;
  newMesh.rotation.y = this.mesh.rotation.y;
  newMesh.rotation.z = this.mesh.rotation.z;

  scene.remove(this.mesh);
  this.mesh = newMesh;
  this.mesh.addedObject = this;
  scene.add(this.mesh);

  if (this.type == "surface" || this.type == "ramp"){
    if (!isCustom){
      this.metaData["widthSegments"] = planeWidthSegments;
      this.metaData["heightSegments"] = planeHeightSegments;
    }else{
      if (isNaN(count)){
        this.metaData["widthSegments"] = count.width;
        this.metaData["heightSegments"] = count.height;
      }else{
        this.metaData["widthSegments"] = count;
        this.metaData["heightSegments"] = count;
      }
    }
  }else if(this.type == "box"){
    if (!isCustom){
      this.metaData["widthSegments"] = boxWidthSegments;
      this.metaData["heightSegments"] = boxHeightSegments;
      this.metaData["depthSegments"] = boxDepthSegments;
    }else{
      if (isNaN(count)){
        this.metaData["widthSegments"] = count.width;
        this.metaData["heightSegments"] = count.height;
        this.metaData["depthSegments"] = count.depth;
      }else{
        this.metaData["widthSegments"] = count;
        this.metaData["heightSegments"] = count;
        this.metaData["depthSegments"] = count;
      }
    }
  }else if (this.type == "sphere"){
    if (!isCustom){
      this.metaData["widthSegments"] = sphereWidthSegments;
      this.metaData["heightSegments"] = sphereHeightSegments;
    }else{
      if (isNaN(count)){
        this.metaData["widthSegments"] = count.width;
        this.metaData["heightSegments"] = count.height;
      }else{
        this.metaData["widthSegments"] = count;
        this.metaData["heightSegments"] = count;
      }
    }
  }else if (this.type == "cylinder"){
    if (!isCustom){
      this.metaData["widthSegments"] = cylinderWidthSegments;
      this.metaData["heightSegments"] = cylinderHeightSegments;
    }else{
      if (isNaN(count)){
        this.metaData["widthSegments"] = count.width;
        this.metaData["heightSegments"] = count.height;
      }else{
        this.metaData["widthSegments"] = count;
        this.metaData["heightSegments"] = count;
      }
    }
  }
}

AddedObject.prototype.modifyCylinderPhysicsAfterSegmentChange = function(radialSegments){
  var topRadius = this.metaData.topRadius;
  var bottomRadius = this.metaData.bottomRadius;
  var height = this.metaData.height;
  var oldPosition = this.physicsBody.position.clone();
  var oldQuaternion = this.physicsBody.quaternion.clone();
  if (!this.noMass){
    physicsWorld.remove(this.physicsBody);
  }
  var physicsShapeKey = "CYLINDER" + PIPE + topRadius + PIPE + bottomRadius + PIPE +
                                            Math.abs(height) + PIPE + radialSegments + PIPE +
                                            this.metaData.gridSystemAxis;
  var newPhysicsShape = physicsShapeCache[physicsShapeKey];
  var cached = false;
  if (!newPhysicsShape){
    newPhysicsShape = new CANNON.Cylinder(
      this.metaData.topRadius, this.metaData.bottomRadius, Math.abs(this.metaData.height), parseInt(radialSegments)
    );
    physicsShapeCache[physicsShapeKey] = newPhysicsShape;
  }else{
    cached = true;
  }
  if (!cached){
    if (this.metaData.gridSystemAxis == "XZ"){
      var quat = new CANNON.Quaternion();
      var coef = 1;
      if (height < 0){
        coef = -1;
      }
      quat.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI/2 * coef);
      var translation = new CANNON.Vec3(0, 0, 0);
      newPhysicsShape.transformAllPoints(translation,quat);
    }else if (this.metaData.gridSystemAxis == "XY"){
      if (height < 0){
        var quat = new CANNON.Quaternion();
        quat.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), -Math.PI);
        var translation = new CANNON.Vec3(0, 0, 0);
        newPhysicsShape.transformAllPoints(translation,quat);
      }
    }else if (this.metaData.gridSystemAxis == "YZ"){
      var quat = new CANNON.Quaternion();
      var coef = 1;
      if (height < 0){
        coef = -1;
      }
      quat.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), coef * Math.PI/2);
      var translation = new CANNON.Vec3(0, 0, 0);
      newPhysicsShape.transformAllPoints(translation,quat);
    }
  }
  var physicsMaterial = this.physicsBody.material;
  var mass = this.physicsBody.mass;
  this.physicsBody = new CANNON.Body({
    mass: mass,
    shape: newPhysicsShape,
    material: physicsMaterial
  });
  this.physicsBody.position.copy(oldPosition);
  this.physicsBody.quaternion.copy(oldQuaternion);
  if (!this.noMass){
    physicsWorld.add(this.physicsBody);
  }
}

AddedObject.prototype.resetMaps = function(resetAssociatedTexturePack){
  this.unMapDiffuse();
  this.unMapAlpha();
  this.unMapAO();
  this.unMapDisplacement();
  this.unMapEmissive();
  if (resetAssociatedTexturePack){
    this.associatedTexturePack = 0;
  }
}

AddedObject.prototype.refreshTextueMatrix = function(){
  if (this.hasDiffuseMap()){
    this.mesh.material.uniforms.diffuseMap.value.updateMatrix();
  }
  if (this.hasAlphaMap()){
    this.mesh.material.uniforms.alphaMap.value.updateMatrix();
  }
  if (this.hasAOMap()){
    this.mesh.material.uniforms.aoMap.value.updateMatrix();
  }
  if (this.hasEmissiveMap()){
    this.mesh.material.uniforms.emissiveMap.value.updateMatrix();
  }
  if (this.hasDisplacementMap()){
    this.mesh.material.uniforms.displacementMap.value.updateMatrix();
  }
}

AddedObject.prototype.adjustTextureRepeat = function(repeatU, repeatV){
  if (repeatU){
    this.metaData["textureRepeatU"] = repeatU;
  }else{
    repeatU = this.metaData["textureRepeatU"];
  }
  if (repeatV){
    this.metaData["textureRepeatV"] = repeatV;
  }else{
    repeatV = this.metaData["textureRepeatV"];
  }
  if (this.hasTexture()){
    this.mesh.material.uniforms.textureMatrix.value.elements[0] = repeatU;
    this.mesh.material.uniforms.textureMatrix.value.elements[4] = repeatV;
  }
}

AddedObject.prototype.isVisibleOnThePreviewScene = function(parentName){
  if (typeof parentName == "undefined"){
    return !(this.isHidden);
  }else{
    return objectGroups[parentName].isVisibleOnThePreviewScene();
  }
}

AddedObject.prototype.isTextureUsed = function(textureName){
  var textureStack = this.getTextureStack();
  for (var i = 0; i<textureStack.length; i++){
    if (!(textureStack[i].roygbivTextureName == "undefined")){
      if (textureStack[i].roygbivTextureName == textureName){
        return true;
      }
    }
  }
}

AddedObject.prototype.isTexturePackUsed = function(texturePackName){
  var textureStack = this.getTextureStack();
  for (var i = 0; i<textureStack.length; i++){
    if (!(textureStack[i].roygbivTexturePackName == "undefined")){
      if (textureStack[i].roygbivTexturePackName == texturePackName){
        return true;
      }
    }
  }
}

AddedObject.prototype.setBlending = function(blendingModeInt){
  this.mesh.material.blending = blendingModeInt;
  if (blendingModeInt == NO_BLENDING){
    this.blendingMode = "NO_BLENDING";
  }else if (blendingModeInt == NORMAL_BLENDING){
    this.blendingMode = "NORMAL_BLENDING";
  }else if (blendingModeInt == ADDITIVE_BLENDING){
    this.blendingMode = "ADDITIVE_BLENDING";
  }else if (blendingModeInt == SUBTRACTIVE_BLENDING){
    this.blendingMode = "SUBTRACTIVE_BLENDING";
  }else if (blendingModeInt == MULTIPLY_BLENDING){
    this.blendingMode = "MULTIPLY_BLENDING";
  }
}

AddedObject.prototype.getBlendingText = function(){
  var blendingModeInt = this.mesh.material.blending;
  if (blendingModeInt == NO_BLENDING){
    return "None";
  }else if (blendingModeInt == NORMAL_BLENDING){
    return "Normal";
  }else if (blendingModeInt == ADDITIVE_BLENDING){
    return "Additive";
  }else if (blendingModeInt == SUBTRACTIVE_BLENDING){
    return "Subtractive";
  }else if (blendingModeInt == MULTIPLY_BLENDING){
    return "Multiply";
  }
}

AddedObject.prototype.intersectsBox = function(box){
  for (var i = 0; i< this.trianglePlanes.length; i+=2){
    var plane = this.trianglePlanes[i];
    if (plane.intersectLine(line, REUSABLE_VECTOR)){
      var triangle1 = this.triangles[i];
      var triangle2 = this.triangles[i+1];
      if (triangle1.containsPoint(REUSABLE_VECTOR)){
        INTERSECTION_NORMAL.set(plane.normal.x, plane.normal.y, plane.normal.z);
        return REUSABLE_VECTOR;
      }else if (triangle2.containsPoint(REUSABLE_VECTOR)){
        INTERSECTION_NORMAL.set(plane.normal.x, plane.normal.y, plane.normal.z);
        return REUSABLE_VECTOR;
      }
    }
  }
  return false;
}

AddedObject.prototype.intersectsLine = function(line){
  for (var i = 0; i< this.trianglePlanes.length; i+=2){
    var plane = this.trianglePlanes[i];
    if (plane.intersectLine(line, REUSABLE_VECTOR)){
      var triangle1 = this.triangles[i];
      var triangle2 = this.triangles[i+1];
      if (triangle1 && triangle1.containsPoint(REUSABLE_VECTOR)){
        INTERSECTION_NORMAL.set(plane.normal.x, plane.normal.y, plane.normal.z);
        return REUSABLE_VECTOR;
      }else if (triangle2 && triangle2.containsPoint(REUSABLE_VECTOR)){
        INTERSECTION_NORMAL.set(plane.normal.x, plane.normal.y, plane.normal.z);
        return REUSABLE_VECTOR;
      }
    }
  }
  return false;
}

AddedObject.prototype.correctBoundingBox = function(bb){
  if (bb.min.x >= bb.max.x){
    bb.max.x += 0.5;
    bb.min.x -= 0.5;
  }
  if (bb.min.y >= bb.max.y){
    bb.max.y += 0.5;
    bb.min.y -= 0.5;
  }
  if (bb.min.z >= bb.max.z){
    bb.max.z += 0.5;
    bb.min.z -= 0.5;
  }
}

AddedObject.prototype.updateBoundingBoxes = function(parentAry){
  var startTime = performance.now();
  var bb = this.boundingBoxes[0];
  bb.makeEmpty();
  for (var i = 0; i<this.vertices.length; i++){
    var vertex = this.vertices[i];
    this.reusableVec3.set(vertex.x, vertex.y, vertex.z);
    this.reusableVec3.applyMatrix4(this.mesh.matrixWorld);
    bb.expandByPoint(this.reusableVec3);
    this.transformedVertices[i].set(
      this.reusableVec3.x, this.reusableVec3.y, this.reusableVec3.z
    );
  }
  for (var i = 0; i<this.pseudoFaces.length; i++){
    var face = this.pseudoFaces[i];
    var a = face.a;
    var b = face.b;
    var c = face.c;
    var triangle = this.triangles[i];
    triangle.set(
      this.transformedVertices[a], this.transformedVertices[b], this.transformedVertices[c]
    );
    var plane = this.trianglePlanes[i];
    triangle.getPlane(plane);
  }
  if (parentAry){
    parentAry[this.parentBoundingBoxIndex] = bb;
  }
  this.boundingBoxUpdatePerformance = performance.now() - startTime;
}

AddedObject.prototype.generateBoundingBoxes = function(parentAry){
  var pseudoGeometry;
  if (typeof this.metaData.slicedType == UNDEFINED){
    pseudoGeometry = this.segmentGeometry(true, 1, true);
  }else{
    pseudoGeometry = new THREE.Geometry().fromBufferGeometry(this.mesh.geometry);
  }
  this.vertices = pseudoGeometry.vertices;
  var bb = new THREE.Box3();
  bb.roygbivObjectName = this.name;
  this.boundingBoxes = [bb];
  if (parentAry){
    parentAry.push(bb);
    this.parentBoundingBoxIndex = (parentAry.length - 1);
  }
  this.mesh.updateMatrixWorld();
  this.transformedVertices = [];
  for (var i = 0; i<this.vertices.length; i++){
    var vertex = this.vertices[i].clone();
    vertex.applyMatrix4(this.mesh.matrixWorld);
    bb.expandByPoint(vertex);
    this.transformedVertices.push(vertex);
  }
  this.triangles = [];
  this.trianglePlanes = [];
  for (var i = 0; i<pseudoGeometry.faces.length; i++){
    var face = pseudoGeometry.faces[i];
    var a = face.a;
    var b = face.b;
    var c = face.c;
    var triangle = new THREE.Triangle(
      this.transformedVertices[a], this.transformedVertices[b], this.transformedVertices[c]
    );
    this.triangles.push(triangle);
    var plane = new THREE.Plane();
    triangle.getPlane(plane);
    this.trianglePlanes.push(plane);
  }
  this.pseudoFaces = pseudoGeometry.faces;
}

AddedObject.prototype.visualiseBoundingBoxes = function(){
  if (this.bbHelpers){
    for (var i = 0; i<this.bbHelpers.length; i++){
      scene.remove(this.bbHelpers[i]);
    }
  }
  this.bbHelpers = [];
  for (var i = 0; i<this.boundingBoxes.length; i++){
    this.correctBoundingBox(this.boundingBoxes[i]);
    var bbHelper = new THREE.Box3Helper(this.boundingBoxes[i], LIME_COLOR);
    scene.add(bbHelper);
    this.bbHelpers.push(bbHelper);
  }
}

AddedObject.prototype.removeBoundingBoxesFromScene = function(){
  if (this.bbHelpers){
    for (var i = 0; i<this.bbHelpers.length; i++){
      scene.remove(this.bbHelpers[i]);
    }
  }
  this.bbHelpers = [];
}

AddedObject.prototype.getNormalGeometry = function(){
  if (!(typeof this.metaData.slicedType == UNDEFINED)){
    var geomKey = "SLICED_NORMAL_GEOMETRY_"+this.type+"_"+this.metaData.slicedType;
    if (geometryCache[geomKey]){
      return geometryCache[geomKey];
    }
    var geom = new THREE.Geometry().fromBufferGeometry(this.mesh.geometry);
    geometryCache[geomKey] = geom;
    return geom;
  }
  var count = new Object();
  if (this.type == "surface" || this.type == "ramp" || this.type == "sphere" || this.type == "cylinder"){
    count.width = this.metaData["widthSegments"];
    count.height = this.metaData["heightSegments"];
  }else if (this.type == "box"){
    count.width = this.metaData["widthSegments"];
    count.height = this.metaData["heightSegments"];
    count.depth = this.metaData["depthSegments"];
  }
  return this.segmentGeometry(true, count, true);
}

AddedObject.prototype.setSlippery = function(isSlippery){
  if (isSlippery){
    if (!isPhysicsWorkerEnabled()){
      this.setFriction(0);
    }
    this.metaData["isSlippery"] = true;
  }else{
    if (!isPhysicsWorkerEnabled()){
      this.setFriction(friction);
    }
    this.metaData["isSlippery"] = false;
  }
}

AddedObject.prototype.setFriction = function(val){
  var physicsMaterial = this.physicsBody.material;
  for (var objName in addedObjects){
    if (objName == this.name){
      continue;
    }
    var otherMaterial = addedObjects[objName].physicsBody.material;
    var contact = physicsWorld.getContactMaterial(physicsMaterial, otherMaterial);
    if (contact){
      contact.friction = val;
    }else{
      contact = new CANNON.ContactMaterial(physicsMaterial,otherMaterial, {
        friction: val,
        restitution: 0.3,
        contactEquationStiffness: 1e8,
        contactEquationRelaxation: 3
      });
      physicsWorld.addContactMaterial(contact);
    }
  }
  for (var objName in objectGroups){
    var otherMaterial = objectGroups[objName].physicsBody.material;
    var contact = physicsWorld.getContactMaterial(physicsMaterial, otherMaterial);
    if (contact){
      contact.friction = val;
    }else{
      contact = new CANNON.ContactMaterial(physicsMaterial, otherMaterial, {
        friction: val,
        restitution: 0.3,
        contactEquationStiffness: 1e8,
        contactEquationRelaxation: 3
      });
      physicsWorld.addContactMaterial(contact);
    }
  }
}

AddedObject.prototype.makePivot = function(offsetX, offsetY, offsetZ){
  var obj = this;
  var pseudoMesh = new THREE.Mesh(obj.mesh.geometry, obj.mesh.material);
  pseudoMesh.position.copy(obj.mesh.position);
  pseudoMesh.quaternion.copy(obj.mesh.quaternion);
  var pivot = new THREE.Object3D();
  pivot.add(pseudoMesh);
  pivot.position.set(
    pseudoMesh.position.x + offsetX,
    pseudoMesh.position.y + offsetY,
    pseudoMesh.position.z + offsetZ
  );
  pseudoMesh.position.x = -offsetX;
  pseudoMesh.position.y = -offsetY;
  pseudoMesh.position.z = -offsetZ;
  pivot.pseudoMesh = pseudoMesh;
  pivot.offsetX = offsetX;
  pivot.offsetY = offsetY;
  pivot.offsetZ = offsetZ;
  pivot.rotation.order = 'YXZ';
  pivot.sourceObject = this;
  return pivot;
}

AddedObject.prototype.rotateAroundPivotObject = function(axis, radians){
  if (!this.pivotObject){
    return;
  }
  this.updatePivot();
  this.pivotObject.updateMatrix();
  this.pivotObject.updateMatrixWorld();
  if (axis == "x"){
    this.pivotObject.rotation.x += radians;
  }else if (axis == "y"){
    this.pivotObject.rotation.y += radians;
  }else if (axis == "z"){
    this.pivotObject.rotation.z += radians;
  }
  this.pivotObject.updateMatrix();
  this.pivotObject.updateMatrixWorld();
  this.pivotObject.pseudoMesh.updateMatrix();
  this.pivotObject.pseudoMesh.updateMatrixWorld();
  this.pivotObject.pseudoMesh.matrixWorld.decompose(REUSABLE_VECTOR, REUSABLE_QUATERNION, REUSABLE_VECTOR_2);
  this.mesh.position.copy(REUSABLE_VECTOR);
  this.mesh.quaternion.copy(REUSABLE_QUATERNION);
  this.setPhysicsAfterRotationAroundPoint(axis, radians);
  if (this.mesh.visible){
    rayCaster.updateObject(this);
  }
}

AddedObject.prototype.updatePivot = function(){
  if (!this.pivotObject){
    return;
  }
  this.pivotObject.position.copy(this.mesh.position);
  this.pivotObject.translateX(this.pivotOffsetX);
  this.pivotObject.translateY(this.pivotOffsetY);
  this.pivotObject.translateZ(this.pivotOffsetZ);
}

AddedObject.prototype.getEndPoint = function(axis){
  var translationAmount = 0;
  if (axis == "+x"){
    REUSABLE_VECTOR_6.set(1, 0, 0);
    if (this.type == "surface"){
      translationAmount = this.metaData.width / 2;
    }else if (this.type == "ramp"){
      translationAmount = this.metaData.rampWidth / 2;
    }else if (this.type == "box"){
      translationAmount = this.metaData.boxSizeX / 2;
    }else if (this.type == "sphere"){
      translationAmount = this.metaData.radius;
    }else if (this.type == "cylinder"){
      translationAmount = (this.metaData.topRadius + this.metaData.bottomRadius) / 2;
    }
  }else if (axis == "-x"){
    REUSABLE_VECTOR_6.set(-1, 0, 0);
    if (this.type == "surface"){
      translationAmount = this.metaData.width / 2;
    }else if (this.type == "ramp"){
      translationAmount = this.metaData.rampWidth / 2;
    }else if (this.type == "box"){
      translationAmount = this.metaData.boxSizeX / 2;
    }else if (this.type == "sphere"){
      translationAmount = this.metaData.radius;
    }else if (this.type == "cylinder"){
      translationAmount = (this.metaData.topRadius + this.metaData.bottomRadius) / 2;
    }
  }else if (axis == "+y"){
    REUSABLE_VECTOR_6.set(0, 1, 0);
    if (this.type == "surface"){
      translationAmount = this.metaData.height / 2;
    }else if (this.type == "ramp"){
      translationAmount = this.metaData.rampHeight / 2;
    }else if (this.type == "box"){
      translationAmount = this.metaData.boxSizeY / 2;
    }else if (this.type == "sphere"){
      translationAmount = this.metaData.radius;
    }else if (this.type == "cylinder"){
      translationAmount = this.metaData.height / 2;
    }
  }else if (axis == "-y"){
    REUSABLE_VECTOR_6.set(0, -1, 0);
    if (this.type == "surface"){
      translationAmount = this.metaData.height / 2;
    }else if (this.type == "ramp"){
      translationAmount = this.metaData.rampHeight / 2;
    }else if (this.type == "box"){
      translationAmount = this.metaData.boxSizeY / 2;
    }else if (this.type == "sphere"){
      translationAmount = this.metaData.radius;
    }else if (this.type == "cylinder"){
      translationAmount = this.metaData.height / 2;
    }
  }else if (axis == "+z"){
    REUSABLE_VECTOR_6.set(0, 0, 1);
    if (this.type == "surface"){
      translationAmount = 0;
    }else if (this.type == "ramp"){
      translationAmount = 0;
    }else if (this.type == "box"){
      translationAmount = this.metaData.boxSizeZ / 2;
    }else if (this.type == "sphere"){
      translationAmount = this.metaData.radius;
    }else if (this.type == "cylinder"){
      translationAmount = (this.metaData.topRadius + this.metaData.bottomRadius) / 2;
    }
  }else if (axis == "-z"){
    REUSABLE_VECTOR_6.set(0, 0, -1);
    if (this.type == "surface"){
      translationAmount = 0;
    }else if (this.type == "ramp"){
      translationAmount = 0;
    }else if (this.type == "box"){
      translationAmount = this.metaData.boxSizeZ / 2;
    }else if (this.type == "sphere"){
      translationAmount = this.metaData.radius;
    }else if (this.type == "cylinder"){
      translationAmount = (this.metaData.topRadius + this.metaData.bottomRadius) / 2;
    }
  }
  var quaternion, position;
  if (this.parentObjectName){
    var parentObject = objectGroups[this.parentObjectName];
    parentObject.graphicsGroup.position.copy(parentObject.mesh.position);
    parentObject.graphicsGroup.quaternion.copy(parentObject.mesh.quaternion);
    parentObject.graphicsGroup.updateMatrix();
    parentObject.graphicsGroup.updateMatrixWorld();
    var child = parentObject.graphicsGroup.children[this.indexInParent];
    child.getWorldPosition(REUSABLE_VECTOR_7);
    child.getWorldQuaternion(REUSABLE_QUATERNION);
    position = REUSABLE_VECTOR_7;
    quaternion = REUSABLE_QUATERNION;
  }else{
    quaternion = this.mesh.quaternion;
    position = REUSABLE_VECTOR_7.copy(this.mesh.position);
  }
  REUSABLE_VECTOR_6.applyQuaternion(quaternion);
  position.add(REUSABLE_VECTOR_6.multiplyScalar(translationAmount));
  return position;
}

AddedObject.prototype.copy = function(name, isHardCopy, copyPosition, gridSystem, fromScript){
  var copyMesh;
  if (isHardCopy){
    copyMesh = new MeshGenerator(this.mesh.geometry, this.material).generateMesh();
  }else{
    copyMesh = new THREE.Mesh(this.mesh.geometry, this.mesh.material);
  }
  var copyPhysicsbody = new CANNON.Body({
    mass: 0,
    shape: this.physicsBody.shapes[0],
    material: new CANNON.Material()
  });
  copyMesh.position.copy(copyPosition);
  copyPhysicsbody.position.copy(copyPosition);
  copyMesh.quaternion.copy(this.mesh.quaternion);
  copyPhysicsbody.quaternion.copy(this.physicsBody.quaternion);
  var copyMetaData = Object.assign({}, this.metaData);

  var destroyedGrids = new Object();
  if (!fromScript && !jobHandlerWorking){
    var startRow, finalRow, startCol, finalCol;
    var grid1 = 0, grid2 = 0;
    for (var gridName in gridSelections){
      if (!grid1){
        grid1 = gridSelections[gridName];
      }else{
        grid2 = gridSelections[gridName];
      }
    }
    if (!grid2){
      grid2 = grid1;
    }
    if (!this.skipToggleGrid){
      grid1.toggleSelect(false, false, false, true);
      if (grid1.name != grid2.name){
        grid2.toggleSelect(false, false, false, true);
      }
      delete gridSelections[grid1.name];
      delete gridSelections[grid2.name];
    }
    startRow = grid1.rowNumber;
    if (grid2.rowNumber < grid1.rowNumber){
      startRow = grid2.rowNumber;
    }
    startCol = grid1.colNumber;
    if (grid2.colNumber < grid1.colNumber){
      startCol = grid2.colNumber;
    }
    finalRow = grid1.rowNumber;
    if (grid2.rowNumber > grid1.rowNumber){
      finalRow = grid2.rowNumber;
    }
    finalCol = grid1.colNumber;
    if (grid2.colNumber > grid1.colNumber){
      finalCol = grid2.colNumber;
    }
    for (var row = startRow; row <= finalRow; row++){
      for (var col = startCol; col <= finalCol; col++ ){
        var grid = gridSystem.getGridByColRow(col, row);
        if (grid){
          destroyedGrids[grid.name] = grid;
        }
      }
    }
  }
  if (jobHandlerWorking){
    destroyedGrids[jobHandlerSelectedGrid.name] = jobHandlerSelectedGrid;
  }
  var copyInstance = new AddedObject(
    name, this.type, copyMetaData, this.material, copyMesh, copyPhysicsbody, destroyedGrids
  );
  copyMesh.addedObject = copyInstance;
  copyInstance.updateMVMatrix();
  copyInstance.isCopied = true;
  copyInstance.copiedWithScript = fromScript;
  if (!fromScript && !jobHandlerWorking){
    copyInstance.metaData["grid1Name"] = grid1.name;
    copyInstance.metaData["grid2Name"] = grid2.name;
  }
  if (jobHandlerWorking){
    copyInstance.metaData["grid1Name"] = jobHandlerSelectedGrid.name;
    copyInstance.metaData["grid2Name"] = jobHandlerSelectedGrid.name;
  }
  copyInstance.metaData["positionX"] = copyMesh.position.x;
  copyInstance.metaData["positionY"] = copyMesh.position.y;
  copyInstance.metaData["positionZ"] = copyMesh.position.z;
  copyInstance.metaData["centerX"] = copyMesh.position.x;
  copyInstance.metaData["centerY"] = copyMesh.position.y;
  copyInstance.metaData["centerZ"] = copyMesh.position.z;
  copyInstance.metaData["quaternionX"] = copyMesh.quaternion.x;
  copyInstance.metaData["quaternionY"] = copyMesh.quaternion.y;
  copyInstance.metaData["quaternionZ"] = copyMesh.quaternion.z;
  copyInstance.metaData["quaternionW"] = copyMesh.quaternion.w;
  copyInstance.metaData["widthSegments"] = this.metaData["widthSegments"];
  copyInstance.metaData["heightSegments"] = this.metaData["heightSegments"];
  copyInstance.metaData["depthSegments"] = this.metaData["depthSegments"];

  copyInstance.rotationX = this.rotationX;
  copyInstance.rotationY = this.rotationY;
  copyInstance.rotationZ = this.rotationZ;
  if (this.physicsBody.mass != 0){
    copyInstance.setMass(this.physicsBody.mass);
  }
  copyInstance.noMass = this.noMass;
  copyInstance.isChangeable = this.isChangeable;
  copyInstance.isColorizable = this.isColorizable;
  if (this.metaData["isSlippery"]){
    copyInstance.setSlippery(true);
  }
  if (!(typeof this.metaData["renderSide"] == UNDEFINED)){
    copyInstance.handleRenderSide(this.metaData["renderSide"]);
  }
  if (!(typeof this.metaData.slicedType == UNDEFINED)){
    copyInstance.sliceInHalf(this.metaData.slicedType);
  }

  if (isHardCopy){
    if (this.material instanceof BasicMaterial){
      if (this.hasDiffuseMap()){
        copyInstance.mapDiffuse(this.mesh.material.uniforms.diffuseMap.value);
      }
      if (this.hasAlphaMap()){
        copyInstance.mapAlpha(this.mesh.material.uniforms.alphaMap.value);
      }
      if (this.hasAOMap()){
        copyInstance.mapAO(this.mesh.material.uniforms.aoMap.value);
        copyInstance.mesh.material.uniforms.aoIntensity.value = this.mesh.material.uniforms.aoIntensity.value;
      }
      if (this.hasDisplacementMap()){
        copyInstance.mapDisplacement(this.mesh.material.uniforms.displacementMap.value);
        copyInstance.mesh.material.uniforms.displacementInfo.value.x = this.mesh.material.uniforms.displacementInfo.value.x;
        copyInstance.mesh.material.uniforms.displacementInfo.value.y = this.mesh.material.uniforms.displacementInfo.value.y;
      }
      if (this.hasEmissiveMap()){
        copyInstance.mapEmissive(this.mesh.material.uniforms.emissiveMap.value);
        copyInstance.mesh.material.uniforms.emissiveIntensity.value = this.mesh.material.uniforms.emissiveIntensity.value;
        copyInstance.mesh.material.uniforms.emissiveColor.value = new THREE.Color().copy(this.mesh.material.uniforms.emissiveColor.value);
      }
    }
    copyInstance.updateOpacity(this.mesh.material.uniforms.alpha.value);
    if (this.hasTexture()){
      for (var ix = 0; ix<this.mesh.material.uniforms.textureMatrix.value.elements.length; ix++){
        copyInstance.mesh.material.uniforms.textureMatrix.value.elements[ix] = this.mesh.material.uniforms.textureMatrix.value.elements[ix];
      }
    }
  }

  if (this.pivotObject){
    var pivot = copyInstance.makePivot(this.pivotOffsetX, this.pivotOffsetY, this.pivotOffsetZ);
    copyInstance.pivotObject = pivot;
    copyInstance.pivotOffsetX = this.pivotOffsetX;
    copyInstance.pivotOffsetY = this.pivotOffsetY;
    copyInstance.pivotOffsetZ = this.pivotOffsetZ;
    copyInstance.pivotRemoved = false;
  }

  copyInstance.setBlending(this.mesh.material.blending);

  if (!isHardCopy){
    copyInstance.softCopyParentName = this.name;
  }

  copyInstance.createdWithScript = fromScript;

  return copyInstance;
}

AddedObject.prototype.hasTexture = function(){
  return (
    this.hasDiffuseMap() || this.hasAOMap() || this.hasAlphaMap() || this.hasEmissiveMap() || this.hasDisplacementMap()
  );
}

AddedObject.prototype.injectMacro = function(macro, insertVertexShader, insertFragmentShader){
  if (insertVertexShader){
    this.mesh.material.vertexShader = this.mesh.material.vertexShader.replace(
      "#define INSERTION", "#define INSERTION\n#define "+macro
    )
  };
  if (insertFragmentShader){
    this.mesh.material.fragmentShader = this.mesh.material.fragmentShader.replace(
      "#define INSERTION", "#define INSERTION\n#define "+macro
    )
  };
  this.mesh.material.needsUpdate = true;
}

AddedObject.prototype.removeMacro = function(macro, removeVertexShader, removeFragmentShader){
  if (removeVertexShader){
    this.mesh.material.vertexShader = this.mesh.material.vertexShader.replace("\n#define "+macro, "");
  }
  if (removeFragmentShader){
    this.mesh.material.fragmentShader = this.mesh.material.fragmentShader.replace("\n#define "+macro, "");
  }
  this.mesh.material.needsUpdate = true;
}

AddedObject.prototype.getTextureOffsetX = function(){
  if (this.hasTexture()){
    return this.mesh.material.uniforms.textureMatrix.value.elements[6];
  }
  return 0;
}

AddedObject.prototype.getTextureOffsetY = function(){
  if (this.hasTexture()){
    return this.mesh.material.uniforms.textureMatrix.value.elements[7];
  }
  return 0;
}

AddedObject.prototype.setTextureOffsetX = function(val){
  if (this.hasTexture()){
    this.mesh.material.uniforms.textureMatrix.value.elements[6] = val;
  }
}

AddedObject.prototype.setTextureOffsetY = function(val){
  if (this.hasTexture()){
    this.mesh.material.uniforms.textureMatrix.value.elements[7] = val;
  }
}

AddedObject.prototype.getTextureRepeatX = function(){
  if (this.hasTexture()){
    return this.mesh.material.uniforms.textureMatrix.value.elements[0];
  }
  return 1;
}

AddedObject.prototype.getTextureRepeatY = function(){
  if (this.hasTexture()){
    return this.mesh.material.uniforms.textureMatrix.value.elements[4];
  }
  return 1;
}

AddedObject.prototype.setFog = function(){
  if (!this.mesh.material.uniforms.fogInfo){
    this.injectMacro("HAS_FOG", false, true);
    this.mesh.material.uniforms.fogInfo = GLOBAL_FOG_UNIFORM;
  }
  if (fogBlendWithSkybox){
    if (!this.mesh.material.uniforms.cubeTexture){
      this.injectMacro("HAS_SKYBOX_FOG", true, true);
      this.mesh.material.uniforms.worldMatrix = new THREE.Uniform(this.mesh.matrixWorld);
      this.mesh.material.uniforms.cubeTexture = GLOBAL_CUBE_TEXTURE_UNIFORM;
      this.mesh.material.uniforms.cameraPosition = GLOBAL_CAMERA_POSITION_UNIFORM;
    }
  }
  this.mesh.material.needsUpdate = true;
}

AddedObject.prototype.removeFog = function(){
  this.removeMacro("HAS_FOG", false, true);
  this.removeMacro("HAS_SKYBOX_FOG", true, true);
  delete this.mesh.material.uniforms.fogInfo;
  delete this.mesh.material.uniforms.cubeTexture;
  delete this.mesh.material.uniforms.worldMatrix;
  delete this.mesh.material.uniforms.cameraPosition;
  this.mesh.material.needsUpdate = true;
}

function render(){
  stats.begin();
  if (!(mode == 1 && isPaused)){
    requestID = requestAnimationFrame(render);
  }else{
    return;
  }

  GLOBAL_CAMERA_POSITION_UNIFORM.value.copy(camera.position);
  GLOBAL_CAMERA_QUATERNION_UNIFORM.value.copy(camera.quaternion);
  GLOBAL_ADDEDTEXT_VIEWPORT_UNIFORM.value.set(0, 0, window.innerWidth * screenResolution, window.innerHeight * screenResolution);

  if (!(mode == 1 && defaultCameraControlsDisabled)){
    processKeyboardBuffer();
  }
  handleSkybox();
  if (!stopAreaConfigurationsHandler){
    areaConfigurationsHandler.handle();
  }

  if (physicsDebugMode){
    debugRenderer.update();
  }

  if (mode == 1){
    if (!isPhysicsWorkerEnabled()){
      physicsWorld.step(physicsStepAmount);
      updateDynamicObjects();
      updateTrackingObjects();
    }
    processCameraRotationBuffer();
    runScripts();
    updateRaycaster();
    updateParticleSystems();
    updateObjectTrails();
    updateCrosshair();
  }else{
    cameraOperationsDone = false;
  }

  renderScene();
  updateAddedTexts();
  if (mode == 1){
    previewSceneRendered = true;
  }
  stats.end();
}


function renderScene(){
  if (mode == 0){
    renderer.render(scene, camera);
  }else{
    if (bloomOn){
      composer.render(0.1);
    }else{
      renderer.render(scene, camera);
    }
  }
}

function updateAddedTexts(){
  if (mode == 0){
    for (var addedTextName in addedTexts){
      var addedText = addedTexts[addedTextName];
      if (addedText.needsUpdate() && !addedText.is2D){
        addedText.handleBoundingBox();
        rayCaster.updateObject(addedText);
      }
    }
  }else{
    for (var addedTextName in clickableAddedTexts){
      var addedText = addedTexts[addedTextName];
      if (addedText.needsUpdate() && !addedText.is2D){
        addedText.handleBoundingBox();
        rayCaster.updateObject(addedText);
      }
    }
  }
}

function updateCrosshair(){
  if (selectedCrosshair && (selectedCrosshair.angularSpeed != 0 || selectedCrosshair.expand || selectedCrosshair.shrink)){
    selectedCrosshair.update();
  }
}

function updateRaycaster(){
  rayCaster.binHandler.update();
}

function updateParticleSystems(){
  for (var particleSystemName in particleSystems){
    var particleSystem = particleSystems[particleSystemName];
    if (particleSystem && !particleSystem.destroyed){
      particleSystem.update();
    }
  }
  for (var mergedParticleSystemName in mergedParticleSystems){
    mergedParticleSystems[mergedParticleSystemName].update();
  }
}

function updateObjectTrails(){
  for (var objectName in activeObjectTrails){
    var objectTrail = activeObjectTrails[objectName];
    if (objectTrail && !objectTrail.destroyed){
      objectTrail.update();
    }
  }
}

function runScripts(){
  for (var scriptName in scriptsToRun){
    scripts[scriptName].execute();
  }
}

function updateTrackingObjects(){
  for (var objName in trackingObjects){
    var obj = addedObjects[objName];
    var isObjectGroup = false;
    if (!obj){
      obj = objectGroups[objName];
      isObjectGroup = true;
    }
    obj.mesh.position.set(
      obj.mesh.position.x + obj.trackedObject.dx,
      obj.mesh.position.y + obj.trackedObject.dy,
      obj.mesh.position.z + obj.trackedObject.dz
    );
    obj.physicsBody.position.copy(obj.mesh.position);
    if (isObjectGroup){
      obj.graphicsGroup.position.copy(obj.mesh.position);
      obj.graphicsGroup.quaternion.copy(obj.mesh.quaternion);
    }
    if (obj.mesh.visible){
      rayCaster.updateObject(obj);
    }
  }
}

function updateDynamicObjects(){
  for (var objectName in dynamicObjects){
    var object = addedObjects[objectName];
    var physicsBody = object.physicsBody;
    var axis = object.metaData.axis;
    var gridSystemAxis = object.metaData.gridSystemAxis;
    var type = object.type;
    if (object.isTracked){
      object.dx = physicsBody.position.x - object.oldPX;
      object.dy = physicsBody.position.y - object.oldPY;
      object.dz = physicsBody.position.z - object.oldPZ;
      object.oldPX = physicsBody.position.x;
      object.oldPY = physicsBody.position.y;
      object.oldPZ = physicsBody.position.z;
    }
    object.mesh.position.copy(physicsBody.position);
    setTHREEQuaternionFromCANNON(object.mesh, physicsBody, axis, type, gridSystemAxis);
  }
  for (var grouppedObjectName in dynamicObjectGroups){
    var grouppedObject = objectGroups[grouppedObjectName];
    var physicsBody = grouppedObject.physicsBody;
    if (grouppedObject.isTracked){
      grouppedObject.dx = physicsBody.position.x - grouppedObject.oldPX;
      grouppedObject.dy = physicsBody.position.y - grouppedObject.oldPY;
      grouppedObject.dz = physicsBody.position.z - grouppedObject.oldPZ;
      grouppedObject.oldPX = physicsBody.position.x;
      grouppedObject.oldPY = physicsBody.position.y;
      grouppedObject.oldPZ = physicsBody.position.z;
    }
    grouppedObject.mesh.position.copy(physicsBody.position);
    grouppedObject.mesh.quaternion.copy(physicsBody.quaternion);
  }
}

function setTHREEQuaternionFromCANNON(mesh, physicsBody, axis, type, gridSystemAxis){
  mesh.quaternion.copy(physicsBody.quaternion);
  if (type == "ramp" || type == "surface"){
    if (gridSystemAxis == "XZ" || gridSystemAxis == "XY" || gridSystemAxis == "YZ"){
      if (!(type == "surface" && (gridSystemAxis == "XY" || gridSystemAxis == "YZ"))){
        mesh.rotateX(Math.PI / 2);
      }else{
        if (type == "surface" && gridSystemAxis == "YZ"){
          mesh.rotateY(Math.PI / 2);
        }
      }
    }
  }else if (type == "cylinder"){
    if (gridSystemAxis == "YZ"){
      mesh.rotateZ(Math.PI / 2);
    }else if (gridSystemAxis == "XY"){
      mesh.rotateX(Math.PI / 2);
    }
  }
}

function handleSkybox(){
  if (skyboxMesh){
    skyboxMesh.position.copy(camera.position);
  }
}

var TexturePack = function(name, directoryName, fileExtension, mapCallback, isPreLoaded, refTexturePack, scaleFactor, refTexturePackName){
  this.directoryName = directoryName;
  this.name = name;


  if (!DDS_SUPPORTED){
    if (fileExtension.toUpperCase() == "DDS"){
      fileExtension = compressedTextureFallbackFormat.replace(".", "");
    }
  }

  this.fileExtension = fileExtension;

  this.scaleFactor = scaleFactor;
  this.refTexturePackName = refTexturePackName;

  this.maxAttemptCount = 5;
  this.totalLoadedCount = 0;

  this.hasDiffuse = false;
  this.hasAlpha = false;
  this.hasAO = false;
  this.hasEmissive = false;
  this.hasHeight = false;

  if (isPreLoaded){
    this.isPreLoaded = isPreLoaded;
  }

  this.diffuseFilePath = texturePackRootDirectory+directoryName+"/"+"diffuse."+fileExtension.toLowerCase();
  this.alphaFilePath = texturePackRootDirectory+directoryName+"/"+"alpha."+fileExtension.toLowerCase();
  this.aoFilePath = texturePackRootDirectory+directoryName+"/"+"ao."+fileExtension.toLowerCase();
  this.emissiveFilePath = texturePackRootDirectory+directoryName+"/"+"emissive."+fileExtension.toLowerCase();
  this.heightFilePath = texturePackRootDirectory+directoryName+"/"+"height."+fileExtension.toLowerCase();

  if (fileExtension.toUpperCase() == "DDS"){
    this.loader = ddsLoader;
  }else if (fileExtension.toUpperCase() == "TGA"){
    this.loader = tgaLoader;
  }else{
    this.loader = textureLoader;
  }

  this.diffuseCanMapFlag = false;
  this.alphaCanMapFlag = false;
  this.aoCanMapFlag = false;
  this.emissiveCanMapFlag = false;
  this.heightCanMapFlag = false;

  if (mapCallback){
    this.mapCallback = mapCallback;
  }

  if (!refTexturePack){
    this.loadTextures();
  }else{
    if (refTexturePack.hasDiffuse){
      this.diffuseTexture = refTexturePack.diffuseTexture.clone();
      this.hasDiffuse = true;
    }
    if (refTexturePack.hasAlpha){
      this.alphaTexture = refTexturePack.alphaTexture.clone();
      this.hasAlpha = true;
    }
    if (refTexturePack.hasAO){
      this.aoTexture = refTexturePack.aoTexture.clone();
      this.hasAO = true;
    }
    if (refTexturePack.hasEmissive){
      this.emissiveTexture = refTexturePack.emissiveTexture.clone();
      this.hasEmissive = true;
    }
    if (refTexturePack.hasHeight){
      this.heightTexture = refTexturePack.heightTexture.clone();
      this.hasHeight = true;
    }
  }

}

TexturePack.prototype.export = function(){
  var exportObject = new Object();
  exportObject.directoryName = this.directoryName;
  exportObject.name = this.name;
  exportObject.fileExtension = this.fileExtension;
  exportObject.hasDiffuse = this.hasDiffuse;
  exportObject.hasAlpha = this.hasAlpha;
  exportObject.hasAO = this.hasAO;
  exportObject.hasEmissive = this.hasEmissive;
  exportObject.hasHeight = this.hasHeight;
  exportObject.diffuseFilePath = this.diffuseFilePath;
  exportObject.alphaFilePath = this.alphaFilePath;
  exportObject.aoFilePath = this.aoFilePath;
  exportObject.emissiveFilePath = this.emissiveFilePath;
  exportObject.heightFilePath = this.heightFilePath;
  if (this.scaleFactor){
    exportObject.scaleFactor = this.scaleFactor;
  }
  if (this.refTexturePackName){
    exportObject.refTexturePackName = this.refTexturePackName;
  }
  return exportObject;
}

TexturePack.prototype.destroy = function(){
  for (var addedObjectName in addedObjects){
    var addedObject = addedObjects[addedObjectName];
    if (addedObject.associatedTexturePack == name){
      addedObject.resetAssociatedTexturePack();
    }
  }
  if (this.hasDiffuse){
    this.diffuseTexture.dispose();
  }
  if (this.hasAlpha){
    this.alphaTexture.dispose();
  }
  if (this.hasAO){
    this.aoTexture.dispose();
  }
  if (this.hasEmissive){
    this.emissiveTexture.dispose();
  }
  if (this.hasHeight){
    this.heightTexture.dispose();
  }
  delete texturePacks[this.name];
}

TexturePack.prototype.readyCallback = function(){
  this.totalLoadedCount ++;
  if (this.maxAttemptCount == this.totalLoadedCount && this.mapCallback){
    this.mapCallback();
  }
}

TexturePack.prototype.mapDiffuse = function (that, textureData){
  that.diffuseTexture = textureData;
  diffuseTextureCache[that.name] = textureData;
  that.diffuseTexture.wrapS = THREE.RepeatWrapping;
  that.diffuseTexture.wrapT = THREE.RepeatWrapping;
  that.hasDiffuse = true;
  that.diffuseCanMapFlag = true;
  that.refreshMap();
}

TexturePack.prototype.mapHeight = function (that, textureData){
  that.heightTexture = textureData;
  heightTextureCache[that.name] = textureData;
  that.heightTexture.wrapS = THREE.RepeatWrapping;
  that.heightTexture.wrapT = THREE.RepeatWrapping;
  that.hasHeight = true;
  that.heightCanMapFlag = true;
  that.refreshMap();
}

TexturePack.prototype.mapAmbientOcculsion = function(that, textureData){
  that.aoTexture = textureData;
  that.aoTexture.wrapS = THREE.RepeatWrapping;
  that.aoTexture.wrapT = THREE.RepeatWrapping;
  that.hasAO = true;
  that.aoCanMapFlag = true;
  that.refreshMap();
}

TexturePack.prototype.mapAlpha = function(that, textureData){
  that.alphaTexture = textureData;
  that.alphaTexture.wrapS = THREE.RepeatWrapping;
  that.alphaTexture.wrapT = THREE.RepeatWrapping;
  that.hasAlpha = true;
  that.alphaCanMapFlag = true;
  that.refreshMap();
}

TexturePack.prototype.mapEmissive = function(that, textureData){
  that.emissiveTexture = textureData;
  that.emissiveTexture.wrapS = THREE.RepeatWrapping;
  that.emissiveTexture.wrapT = THREE.RepeatWrapping;
  that.hasEmissive = true;
  that.emissiveCanMapFlag = true;
  that.refreshMap();
}

TexturePack.prototype.loadTextures = function(){

  var that = this;

  //DIFFUSE
  var diffuseTextureCached = diffuseTextureCache[this.name];
  if (!diffuseTextureCached || (diffuseTextureCached && diffuseTextureCached == CACHE_NOT_PRESENT)){
    this.loader.load(this.diffuseFilePath,
      function(textureData){
        if (that.scaleFactor){
          textureData.image = that.rescaleTextureImage(textureData, that.scaleFactor);
        }
        that.mapDiffuse(that, textureData);
      },
      function(xhr){

      },
      function(xhr){
        diffuseTextureCache[that.name] = CACHE_NOT_PRESENT;
        that.hasDiffuse = false;
        that.diffuseCanMapFlag = true;
        that.refreshMap();
      }
    );
  }else{
    if (diffuseTextureCached != CACHE_NOT_PRESENT){
      texturePacks[this.name] = this;
      this.mapDiffuse(this, diffuseTextureCached);
    }
  }
  //ALPHA
  var alphaTextureCached = alphaTextureCache[this.name];
  if (!alphaTextureCached || (alphaTextureCached && alphaTextureCached == CACHE_NOT_PRESENT)){
    this.loader.load(this.alphaFilePath,
      function(textureData){
        if (that.scaleFactor){
          textureData.image = that.rescaleTextureImage(textureData, that.scaleFactor);
        }
        that.mapAlpha(that, textureData);
      },
      function(xhr){

      },
      function(xhr){
        alphaTextureCache[that.name] = CACHE_NOT_PRESENT;
        that.hasAlpha = false;
        that.alphaCanMapFlag = true;
        that.refreshMap();
      }
    );
  }else{
    if (alphaTextureCached != CACHE_NOT_PRESENT){
      this.mapAlpha(this, alphaTextureCached);
      texturePacks[this.name] = this;
    }
  }
  //AO
  var ambientOcculsionTextureCached = ambientOcculsionTextureCache[this.name];
  if (!ambientOcculsionTextureCached || (ambientOcculsionTextureCached && ambientOcculsionTextureCached == CACHE_NOT_PRESENT)){
    this.loader.load(this.aoFilePath,
      function(textureData){
        if (that.scaleFactor){
          textureData.image = that.rescaleTextureImage(textureData, that.scaleFactor);
        }
        that.mapAmbientOcculsion(that, textureData);
      },
      function(xhr){

      },
      function(xhr){
        ambientOcculsionTextureCache[that.name] = CACHE_NOT_PRESENT;
        that.hasAo = false;
        that.aoCanMapFlag = true;
        that.refreshMap();
      }
    );
  }else{
    if (ambientOcculsionTextureCached != CACHE_NOT_PRESENT){
      this.mapAmbientOcculsion(this, ambientOcculsionTextureCached);
      texturePacks[this.name] = this;
    }
  }
  //EMISSIVE
  var emissiveTextureCached = emissiveTextureCache[this.name];
  if (!emissiveTextureCached || (emissiveTextureCached && emissiveTextureCached == CACHE_NOT_PRESENT)){
    this.loader.load(this.emissiveFilePath,
      function(textureData){
        if (that.scaleFactor){
          textureData.image = that.rescaleTextureImage(textureData, that.scaleFactor);
        }
        that.mapEmissive(that, textureData);
      },
      function(xhr){

      },
      function(xhr){
        emissiveTextureCache[that.name] = CACHE_NOT_PRESENT;
        that.hasEmissive = false;
        that.emissiveCanMapFlag = true;
        that.refreshMap();
      }
    );
  }else{
    if (emissiveTextureCached != CACHE_NOT_PRESENT){
      this.mapEmissive(this, emissiveTextureCached);
      texturePacks[this.name] = this;
    }
  }
  //HEIGHT
  var heightTextureCached = heightTextureCache[this.name];
  if (!heightTextureCached || (heightTextureCached && heightTextureCached == CACHE_NOT_PRESENT)){
    this.loader.load(this.heightFilePath,
      function(textureData){
        if (that.scaleFactor){
          textureData.image = that.rescaleTextureImage(textureData, that.scaleFactor);
        }
        that.mapHeight(that, textureData);
      },
      function(xhr){

      },
      function(xhr){
        heightTextureCache[that.name] = CACHE_NOT_PRESENT;
        that.hasHeight = false;
        that.heightCanMapFlag = true;
        that.refreshMap();
      }
    );
  }else{
      if (heightTextureCached != CACHE_NOT_PRESENT){
        this.mapHeight(this, heightTextureCached);
        texturePacks[this.name] = this;
      }
  }

}

TexturePack.prototype.printInfo = function(){
  var diffuseSizeText = "";
  var alphaSizeText = "";
  var ambientOcculsionSizeText = "";
  var emissiveSizeText = "";
  var heightSizeText = "";
  if (this.hasDiffuse){
    var img = this.diffuseTexture.image;
    diffuseSizeText = " ["+img.width+"x"+img.height+"]";
  }
  if (this.hasAlpha){
    var img = this.alphaTexture.image;
    alphaSizeText = " ["+img.width+"x"+img.height+"]";  }
  if (this.hasAO){
    var img = this.aoTexture.image;
    ambientOcculsionSizeText = " ["+img.width+"x"+img.height+"]";
  }
  if (this.hasEmissive){
    var img = this.emissiveTexture.image;
    emissiveSizeText = " ["+img.width+"x"+img.height+"]";
  }
  if (this.hasHeight){
    var img = this.heightTexture.image;
    heightSizeText = " ["+img.width+"x"+img.height+"]";
  }
  terminal.printHeader(Text.TEXTUREPACK_INFO_HEADER, true);
  terminal.printInfo(Text.TEXTUREPACK_NAME.replace(
    Text.PARAM1, this.name
  ), true);
  terminal.printInfo(Text.TEXTUREPACK_DIRNAME.replace(
    Text.PARAM1, this.directoryName
  ), true);
  terminal.printInfo(Text.TEXTUREPACK_FILEEXTENSION.replace(
    Text.PARAM1, this.fileExtension
  ), true);
  terminal.printInfo(Text.TEXTUREPACK_FILEPATHS, true);
  terminal.printInfo(Text.TEXTUREPACK_INFO_TREE_DIFFUSE.replace(
    Text.PARAM1, this.diffuseFilePath
  ), true);
  terminal.printInfo(Text.TEXTUREPACK_INFO_TREE_ALPHA.replace(
    Text.PARAM1, this.alphaFilePath
  ), true);
  terminal.printInfo(Text.TEXTUREPACK_INFO_TREE_AO.replace(
    Text.PARAM1, this.aoFilePath
  ), true);
  terminal.printInfo(Text.TEXTUREPACK_INFO_TREE_EMISSIVE.replace(
    Text.PARAM1, this.emissiveFilePath
  ), true);
  terminal.printInfo(Text.TEXTUREPACK_INFO_TREE_HEIGHT.replace(
    Text.PARAM1, this.heightFilePath
  ), true);
  terminal.printInfo(Text.TEXTUREPACK_TEXTURES, true);
  terminal.printInfo(Text.TEXTUREPACK_INFO_TREE_DIFFUSE.replace(
    Text.PARAM1, this.hasDiffuse + diffuseSizeText
  ), true);
  terminal.printInfo(Text.TEXTUREPACK_INFO_TREE_ALPHA.replace(
    Text.PARAM1, this.hasAlpha + alphaSizeText
  ), true);
  terminal.printInfo(Text.TEXTUREPACK_INFO_TREE_AO.replace(
    Text.PARAM1, this.hasAO + ambientOcculsionSizeText
  ), true);
  terminal.printInfo(Text.TEXTUREPACK_INFO_TREE_EMISSIVE.replace(
    Text.PARAM1, this.hasEmissive + emissiveSizeText
  ), true);
  terminal.printInfo(Text.TEXTUREPACK_INFO_TREE_HEIGHT.replace(
    Text.PARAM1, this.hasHeight + heightSizeText
  ), false);
}

TexturePack.prototype.isUsable = function(){
  return (
    this.hasDiffuse ||
    this.hasAlpha ||
    this.hasAO ||
    this.hasEmissive ||
    this.hasHeight
  );
}

TexturePack.prototype.refresh = function(){
  delete diffuseTextureCache[this.name];
  delete heightTextureCache[this.name];
  delete ambientOcculsionTextureCache[this.name];
  delete alphaTextureCache[this.name];
  delete emissiveTextureCache[this.name];
  this.loadTextures();
}

TexturePack.prototype.refreshMap = function(){
  if (!this.isPreLoaded){
    for (var addedObjectName in addedObjects){
      var addedObject = addedObjects[addedObjectName];
      if (addedObject.associatedTexturePack == this.name){
        addedObject.mapTexturePack(this);
      }
    }
  }
  this.readyCallback();
}

TexturePack.prototype.rescaleTextureImage = function(texture, scale){
  var tmpCanvas = document.createElement("canvas");
  tmpCanvas.width = texture.image.width * scale;
  tmpCanvas.height = texture.image.height * scale;
  tmpCanvas.getContext("2d").drawImage(texture.image, 0, 0, texture.image.width, texture.image.height, 0, 0, tmpCanvas.width, tmpCanvas.height);
  return tmpCanvas;
}

TexturePack.prototype.rescale = function(scale){
  if (this.hasDiffuse){
    this.diffuseTexture.image = this.rescaleTextureImage(this.diffuseTexture, scale);
    this.diffuseTexture.needsUpdate = true;
  }
  if (this.hasAlpha){
    this.alphaTexture.image = this.rescaleTextureImage(this.alphaTexture, scale);
    this.alphaTexture.needsUpdate = true;
  }
  if (this.hasAO){
    this.aoTexture.image = this.rescaleTextureImage(this.aoTexture, scale);
    this.aoTexture.needsUpdate = true;
  }
  if (this.hasEmissive){
    this.emissiveTexture.image = this.rescaleTextureImage(this.emissiveTexture, scale);
    this.emissiveTexture.needsUpdate = true;
  }
  if (this.hasHeight){
    this.heightTexture.image = this.rescaleTextureImage(this.heightTexture, scale);
    this.heightTexture.needsUpdate = true;
  }
  this.scaleFactor = scale;
}

var SkyBox = function(name, directoryName, fileExtension, alpha, color, callback){

  this.name = name;
  this.directoryName = directoryName;

  if (!DDS_SUPPORTED){
    if (fileExtension.toUpperCase() == "DDS"){
      fileExtension = compressedTextureFallbackFormat.replace(".", "");
    }
  }

  this.fileExtension = fileExtension;

  this.color = color;
  this.alpha = alpha;

  this.hasBack = false;
  this.hasDown = false;
  this.hasFront = false;
  this.hasLeft = false;
  this.hasRight = false;
  this.hasUp = false;

  if (callback){
    this.callback = callback;
  }

  this.backFilePath = skyBoxRootDirectory+directoryName+"/"+"back."+fileExtension;
  this.downFilePath = skyBoxRootDirectory+directoryName+"/"+"down."+fileExtension;
  this.frontFilePath = skyBoxRootDirectory+directoryName+"/"+"front."+fileExtension;
  this.leftFilePath = skyBoxRootDirectory+directoryName+"/"+"left."+fileExtension;
  this.rightFilePath = skyBoxRootDirectory+directoryName+"/"+"right."+fileExtension;
  this.upFilePath = skyBoxRootDirectory+directoryName+"/"+"up."+fileExtension;

  if (this.fileExtension.toUpperCase() == "DDS"){
    this.loader = ddsLoader;
  }else if (this.fileExtension.toUpperCase() == "TGA"){
    this.loader = tgaLoader;
  }else{
    this.loader = textureLoader;
  }

  this.loadTextures();
}

SkyBox.prototype.export = function(){
  var exportObject = new Object();
  exportObject.name = this.name;
  exportObject.directoryName = this.directoryName;
  exportObject.fileExtension = this.fileExtension;
  exportObject.hasBack = this.hasBack;
  exportObject.hasDown = this.hasDown;
  exportObject.hasFront = this.hasFront;
  exportObject.hasLeft = this.hasLeft;
  exportObject.hasRight = this.hasRight;
  exportObject.hasUp = this.hasUp;
  exportObject.backFilePath = this.backFilePath;
  exportObject.downFilePath = this.downFilePath;
  exportObject.frontFilePath = this.frontFilePath;
  exportObject.leftFilePath = this.leftFilePath;
  exportObject.rightFilePath =this.rightFilePath;
  exportObject.upFilePath = this.upFilePath;
  exportObject.alpha = this.alpha;
  exportObject.color = this.color;
  return exportObject;
}

SkyBox.prototype.loadTextures = function(){

  var that = this;

  //BACK
  this.loader.load(this.backFilePath,
    function(textureData){
      that.backTexture = textureData;
      that.hasBack = true;
      that.callbackCheck();
      //that.backTexture.flipY = false;
    },
    function(xhr){

    },
    function(xhr){
      that.hasBack = false;
      that.callbackCheck();
    }
  );
  //DOWN
  this.loader.load(this.downFilePath,
    function(textureData){
      that.downTexture = textureData;
      that.hasDown = true;
      that.callbackCheck();
      //that.downTexture.flipY = false;
    },
    function(xhr){

    },
    function(xhr){
      that.hasDown = false;
      that.callbackCheck();
    }
  );
  //FRONT
  this.loader.load(this.frontFilePath,
    function(textureData){
      that.frontTexture = textureData;
      that.hasFront = true;
      that.callbackCheck();
      //that.frontTexture.flipY = false;
    },
    function(xhr){

    },
    function(xhr){
      that.hasFront = false;
      that.callbackCheck();
    }
  );
  //LEFT
  this.loader.load(this.leftFilePath,
    function(textureData){
      that.leftTexture = textureData;
      that.hasLeft = true;
      that.callbackCheck();
      //that.leftTexture.flipY = false;
    },
    function(xhr){

    },
    function(xhr){
      that.hasLeft = false;
      that.callbackCheck();
    }
  );
  //RIGHT
  this.loader.load(this.rightFilePath,
    function(textureData){
      that.rightTexture = textureData;
      that.hasRight = true;
      that.callbackCheck();
      //that.rightTexture.flipY = false;
    },
    function(xhr){

    },
    function(xhr){
      that.hasRight = false;
      that.callbackCheck();
    }
  );
  //UP
  this.loader.load(this.upFilePath,
    function(textureData){
      that.upTexture = textureData;
      that.hasUp = true;
      that.callbackCheck();
      //that.upTexture.flipY = false;
    },
    function(xhr){

    },
    function(xhr){
      that.hasUp = false;
      that.callbackCheck();
    }
  );
}

SkyBox.prototype.isUsable = function(){
  return (
    this.hasBack &&
    this.hasDown &&
    this.hasFront &&
    this.hasLeft &&
    this.hasRight &&
    this.hasUp
  );
}

SkyBox.prototype.callbackCheck = function(){
  if (this.isUsable()){
    this.cubeTexture = new THREE.CubeTexture([
      this.rightTexture.image, this.leftTexture.image,
      this.upTexture.image, this.downTexture.image,
      this.frontTexture.image, this.backTexture.image
    ]);
    this.cubeTexture.needsUpdate = true;
    if (this.callback){
      this.callback();
    }
  }
}

SkyBox.prototype.printInfo = function(){
  terminal.printHeader(Text.SKYBOXINFO_HEADER);
  terminal.printInfo(Text.SKYBOXINFO_NAME.replace(
    Text.PARAM1, this.name
  ), true);
  terminal.printInfo(Text.SKYBOXINFO_DIRNAME.replace(
    Text.PARAM1, this.directoryName
  ), true);
  terminal.printInfo(Text.SKYBOXINFO_FILEEXTENSION.replace(
    Text.PARAM1, this.fileExtension
  ), true);
  terminal.printInfo(Text.SKYBOXINFO_FILEPATHS, true);
  terminal.printInfo(Text.SKYBOXINFO_TREE_BACK.replace(
    Text.PARAM1, this.backFilePath
  ), true);
  terminal.printInfo(Text.SKYBOXINFO_TREE_DOWN.replace(
    Text.PARAM1, this.downFilePath
  ), true);
  terminal.printInfo(Text.SKYBOXINFO_TREE_FRONT.replace(
    Text.PARAM1, this.frontFilePath
  ), true);
  terminal.printInfo(Text.SKYBOXINFO_TREE_LEFT.replace(
    Text.PARAM1, this.leftFilePath
  ), true);
  terminal.printInfo(Text.SKYBOXINFO_TREE_RIGHT.replace(
    Text.PARAM1, this.rightFilePath
  ), true);
  terminal.printInfo(Text.SKYBOXINFO_TREE_UP.replace(
    Text.PARAM1, this.upFilePath
  ), true);
  terminal.printInfo(Text.SKYBOXINFO_TEXTURES, true);
  terminal.printInfo(Text.SKYBOXINFO_TREE_BACK.replace(
    Text.PARAM1, this.hasBack
  ), true);
  terminal.printInfo(Text.SKYBOXINFO_TREE_DOWN.replace(
    Text.PARAM1, this.hasDown
  ), true);
  terminal.printInfo(Text.SKYBOXINFO_TREE_FRONT.replace(
    Text.PARAM1, this.hasFront
  ), true);
  terminal.printInfo(Text.SKYBOXINFO_TREE_LEFT.replace(
    Text.PARAM1, this.hasLeft
  ), true);
  terminal.printInfo(Text.SKYBOXINFO_TREE_RIGHT.replace(
    Text.PARAM1, this.hasRight
  ), true);
  terminal.printInfo(Text.SKYBOXINFO_TREE_UP.replace(
    Text.PARAM1, this.hasUp
  ), false);
}

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.EffectComposer = function ( renderer, renderTarget ) {

	this.renderer = renderer;

	if ( renderTarget === undefined ) {

		var parameters = {
			minFilter: THREE.LinearFilter,
			magFilter: THREE.LinearFilter,
			format: THREE.RGBAFormat,
			stencilBuffer: false
		};
		var size = renderer.getSize();
		renderTarget = new THREE.WebGLRenderTarget( size.width, size.height, parameters );

	}

	this.renderTarget1 = renderTarget;
	this.renderTarget2 = renderTarget.clone();

	this.writeBuffer = this.renderTarget1;
	this.readBuffer = this.renderTarget2;

	this.passes = [];

	if ( THREE.CopyShader === undefined )
		console.error( "THREE.EffectComposer relies on THREE.CopyShader" );

	this.copyPass = new THREE.ShaderPass( THREE.CopyShader );

};

THREE.EffectComposer.prototype = {

	swapBuffers: function() {

		var tmp = this.readBuffer;
		this.readBuffer = this.writeBuffer;
		this.writeBuffer = tmp;

	},

	addPass: function ( pass ) {

		this.passes.push( pass );

	},

	insertPass: function ( pass, index ) {

		this.passes.splice( index, 0, pass );

	},

	render: function ( delta ) {

		this.writeBuffer = this.renderTarget1;
		this.readBuffer = this.renderTarget2;

		var maskActive = false;

		var pass, i, il = this.passes.length;

		for ( i = 0; i < il; i ++ ) {

			pass = this.passes[ i ];

			if ( ! pass.enabled ) continue;

			pass.render( this.renderer, this.writeBuffer, this.readBuffer, delta, maskActive );

			if ( pass.needsSwap ) {

				if ( maskActive ) {

					var context = this.renderer.context;

					context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );

					this.copyPass.render( this.renderer, this.writeBuffer, this.readBuffer, delta );

					context.stencilFunc( context.EQUAL, 1, 0xffffffff );

				}

				this.swapBuffers();

			}

			if ( pass instanceof THREE.MaskPass ) {

				maskActive = true;

			} else if ( pass instanceof THREE.ClearMaskPass ) {

				maskActive = false;

			}

		}

	},

	reset: function ( renderTarget ) {

		if ( renderTarget === undefined ) {

			var size = this.renderer.getSize();

			renderTarget = this.renderTarget1.clone();
			renderTarget.setSize( size.width, size.height );

		}

		this.renderTarget1.dispose();
		this.renderTarget2.dispose();
		this.renderTarget1 = renderTarget;
		this.renderTarget2 = renderTarget.clone();

		this.writeBuffer = this.renderTarget1;
		this.readBuffer = this.renderTarget2;

	},

	setSize: function ( width, height ) {

		this.renderTarget1.setSize( width, height );
		this.renderTarget2.setSize( width, height );

	}

};

THREE.Pass = function () {

	// if set to true, the pass is processed by the composer
	this.enabled = true;

	// if set to true, the pass indicates to swap read and write buffer after rendering
	this.needsSwap = true;

	// if set to true, the pass clears its buffer before rendering
	this.clear = false;

	// if set to true, the result of the pass is rendered to screen
	this.renderToScreen = false;

};

Object.assign( THREE.Pass.prototype, {

	setSize: function( width, height ) {},

	render: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {

		console.error( 'THREE.Pass: .render() must be implemented in derived pass.' );

	}

} );

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.RenderPass = function ( scene, camera, overrideMaterial, clearColor, clearAlpha ) {

	this.scene = scene;
	this.camera = camera;

	this.overrideMaterial = overrideMaterial;

	this.clearColor = clearColor;
	this.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 1;

	this.oldClearColor = new THREE.Color();
	this.oldClearAlpha = 1;

	this.enabled = true;
	this.clear = true;
	this.needsSwap = false;

};

THREE.RenderPass.prototype = {

	render: function ( renderer, writeBuffer, readBuffer, delta ) {

		this.scene.overrideMaterial = this.overrideMaterial;

		if ( this.clearColor ) {

			this.oldClearColor.copy( renderer.getClearColor() );
			this.oldClearAlpha = renderer.getClearAlpha();

			renderer.setClearColor( this.clearColor, this.clearAlpha );

		}

		renderer.render( this.scene, this.camera, readBuffer, this.clear );

		if ( this.clearColor ) {

			renderer.setClearColor( this.oldClearColor, this.oldClearAlpha );

		}

		this.scene.overrideMaterial = null;

	}

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.ShaderPass = function( shader, textureID ) {

	this.textureID = ( textureID !== undefined ) ? textureID : "tDiffuse";

	if ( shader instanceof THREE.ShaderMaterial ) {

		this.uniforms = shader.uniforms;

		this.material = shader;

	}
	else if ( shader ) {

		this.uniforms = THREE.UniformsUtils.clone( shader.uniforms );

		this.material = new THREE.ShaderMaterial( {

			defines: shader.defines || {},
			uniforms: this.uniforms,
			vertexShader: shader.vertexShader,
			fragmentShader: shader.fragmentShader

		} );

	}

	this.renderToScreen = false;

	this.enabled = true;
	this.needsSwap = true;
	this.clear = false;


	this.camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
	this.scene = new THREE.Scene();

	this.quad = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), null );
	this.scene.add( this.quad );

};

THREE.ShaderPass.prototype = {

	render: function( renderer, writeBuffer, readBuffer, delta ) {

		if ( this.uniforms[ this.textureID ] ) {

			this.uniforms[ this.textureID ].value = readBuffer.texture;

		}

		this.quad.material = this.material;

		if ( this.renderToScreen ) {

			renderer.render( this.scene, this.camera );

		} else {

			renderer.render( this.scene, this.camera, writeBuffer, this.clear );

		}

	}

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.MaskPass = function ( scene, camera ) {

	this.scene = scene;
	this.camera = camera;

	this.enabled = true;
	this.clear = true;
	this.needsSwap = false;

	this.inverse = false;

};

THREE.MaskPass.prototype = {

	render: function ( renderer, writeBuffer, readBuffer, delta ) {

		var context = renderer.context;

		// don't update color or depth

		context.colorMask( false, false, false, false );
		context.depthMask( false );

		// set up stencil

		var writeValue, clearValue;

		if ( this.inverse ) {

			writeValue = 0;
			clearValue = 1;

		} else {

			writeValue = 1;
			clearValue = 0;

		}

		context.enable( context.STENCIL_TEST );
		context.stencilOp( context.REPLACE, context.REPLACE, context.REPLACE );
		context.stencilFunc( context.ALWAYS, writeValue, 0xffffffff );
		context.clearStencil( clearValue );

		// draw into the stencil buffer

		renderer.render( this.scene, this.camera, readBuffer, this.clear );
		renderer.render( this.scene, this.camera, writeBuffer, this.clear );

		// re-enable update of color and depth

		context.colorMask( true, true, true, true );
		context.depthMask( true );

		// only render where stencil is set to 1

		context.stencilFunc( context.EQUAL, 1, 0xffffffff );  // draw if == 1
		context.stencilOp( context.KEEP, context.KEEP, context.KEEP );

	}

};


THREE.ClearMaskPass = function () {

	this.enabled = true;

};

THREE.ClearMaskPass.prototype = {

	render: function ( renderer, writeBuffer, readBuffer, delta ) {

		var context = renderer.context;

		context.disable( context.STENCIL_TEST );

	}

};

(function(root, factory) {
    if (typeof define === 'function' && define.amd) {
        define('three.UnrealBloomPass', ['three'], factory);
    }
    else if ('undefined' !== typeof exports && 'undefined' !== typeof module) {
        module.exports = factory(require('three'));
    }
    else {
        factory(root.THREE);
    }
}(this, function(THREE) {

/**
 * @author spidersharma / http://eduperiment.com/
 *
 * Inspired from Unreal Engine
 * https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/
 */
THREE.UnrealBloomPass = function ( resolution, strength, radius, threshold ) {

	THREE.Pass.call( this );

	this.strength = ( strength !== undefined ) ? strength : 1;
	this.radius = radius;
	this.threshold = threshold;
	this.resolution = ( resolution !== undefined ) ? new THREE.Vector2( resolution.x, resolution.y ) : new THREE.Vector2( 256, 256 );

  this.reusableColor = new THREE.Color( 0, 0, 0 );

	// render targets
	var pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat };
	this.renderTargetsHorizontal = [];
	this.renderTargetsVertical = [];
	this.nMips = 5;
	var resx = Math.round( this.resolution.x / 2 );
	var resy = Math.round( this.resolution.y / 2 );

	this.renderTargetBright = new THREE.WebGLRenderTarget( resx, resy, pars );
	this.renderTargetBright.texture.name = "UnrealBloomPass.bright";
	this.renderTargetBright.texture.generateMipmaps = false;

	for ( var i = 0; i < this.nMips; i ++ ) {

		var renderTarget = new THREE.WebGLRenderTarget( resx, resy, pars );

		renderTarget.texture.name = "UnrealBloomPass.h" + i;
		renderTarget.texture.generateMipmaps = false;

		this.renderTargetsHorizontal.push( renderTarget );

		var renderTarget = new THREE.WebGLRenderTarget( resx, resy, pars );

		renderTarget.texture.name = "UnrealBloomPass.v" + i;
		renderTarget.texture.generateMipmaps = false;

		this.renderTargetsVertical.push( renderTarget );

		resx = Math.round( resx / 2 );

		resy = Math.round( resy / 2 );

	}

	// luminosity high pass material

	if ( THREE.LuminosityHighPassShader === undefined )
		console.error( "THREE.UnrealBloomPass relies on THREE.LuminosityHighPassShader" );

	var highPassShader = THREE.LuminosityHighPassShader;
	this.highPassUniforms = THREE.UniformsUtils.clone( highPassShader.uniforms );

	this.highPassUniforms[ "luminosityThreshold" ].value = threshold;
	this.highPassUniforms[ "smoothWidth" ].value = 0.01;

	this.materialHighPassFilter = new THREE.ShaderMaterial( {
		uniforms: this.highPassUniforms,
		vertexShader: highPassShader.vertexShader,
		fragmentShader: highPassShader.fragmentShader,
		defines: {}
	} );

	// Gaussian Blur Materials
	this.separableBlurMaterials = [];
	var kernelSizeArray = [ 3, 5, 7, 9, 11 ];
	var resx = Math.round( this.resolution.x / 2 );
	var resy = Math.round( this.resolution.y / 2 );

	for ( var i = 0; i < this.nMips; i ++ ) {

		this.separableBlurMaterials.push( this.getSeperableBlurMaterial( kernelSizeArray[ i ] ) );

		this.separableBlurMaterials[ i ].uniforms[ "texSize" ].value = new THREE.Vector2( resx, resy );

		resx = Math.round( resx / 2 );

		resy = Math.round( resy / 2 );

	}

	// Composite material
	this.compositeMaterial = this.getCompositeMaterial( this.nMips );
	this.compositeMaterial.uniforms[ "blurTexture1" ].value = this.renderTargetsVertical[ 0 ].texture;
	this.compositeMaterial.uniforms[ "blurTexture2" ].value = this.renderTargetsVertical[ 1 ].texture;
	this.compositeMaterial.uniforms[ "blurTexture3" ].value = this.renderTargetsVertical[ 2 ].texture;
	this.compositeMaterial.uniforms[ "blurTexture4" ].value = this.renderTargetsVertical[ 3 ].texture;
	this.compositeMaterial.uniforms[ "blurTexture5" ].value = this.renderTargetsVertical[ 4 ].texture;
	this.compositeMaterial.uniforms[ "bloomStrength" ].value = strength;
	this.compositeMaterial.uniforms[ "bloomRadius" ].value = 0.1;
	this.compositeMaterial.needsUpdate = true;

	var bloomFactors = [ 1.0, 0.8, 0.6, 0.4, 0.2 ];
	this.compositeMaterial.uniforms[ "bloomFactors" ].value = bloomFactors;
	this.bloomTintColors = [ new THREE.Vector3( 1, 1, 1 ), new THREE.Vector3( 1, 1, 1 ), new THREE.Vector3( 1, 1, 1 ),
							 new THREE.Vector3( 1, 1, 1 ), new THREE.Vector3( 1, 1, 1 ) ];
	this.compositeMaterial.uniforms[ "bloomTintColors" ].value = this.bloomTintColors;

	// copy material
	if ( THREE.CopyShader === undefined ) {

		console.error( "THREE.BloomPass relies on THREE.CopyShader" );

	}

	var copyShader = THREE.CopyShader;

	this.copyUniforms = THREE.UniformsUtils.clone( copyShader.uniforms );
	this.copyUniforms[ "opacity" ].value = 1.0;

	this.materialCopy = new THREE.ShaderMaterial( {
		uniforms: this.copyUniforms,
		vertexShader: copyShader.vertexShader,
		fragmentShader: copyShader.fragmentShader,
		blending: THREE.AdditiveBlending,
		depthTest: false,
		depthWrite: false,
		transparent: true
	} );

	this.enabled = true;
	this.needsSwap = false;

	this.oldClearColor = new THREE.Color();
	this.oldClearAlpha = 1;

	this.camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
	this.scene = new THREE.Scene();

	this.basic = new THREE.MeshBasicMaterial();

	this.quad = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), null );
	this.quad.frustumCulled = false; // Avoid getting clipped
	this.scene.add( this.quad );

};

THREE.UnrealBloomPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {

	constructor: THREE.UnrealBloomPass,

	dispose: function () {

		for ( var i = 0; i < this.renderTargetsHorizontal.length; i ++ ) {

			this.renderTargetsHorizontal[ i ].dispose();

		}

		for ( var i = 0; i < this.renderTargetsVertical.length; i ++ ) {

			this.renderTargetsVertical[ i ].dispose();

		}

		this.renderTargetBright.dispose();

	},

	setSize: function ( width, height ) {

		var resx = Math.round( width / 2 );
		var resy = Math.round( height / 2 );

		this.renderTargetBright.setSize( resx, resy );

		for ( var i = 0; i < this.nMips; i ++ ) {

			this.renderTargetsHorizontal[ i ].setSize( resx, resy );
			this.renderTargetsVertical[ i ].setSize( resx, resy );

			this.separableBlurMaterials[ i ].uniforms[ "texSize" ].value = new THREE.Vector2( resx, resy );

			resx = Math.round( resx / 2 );
			resy = Math.round( resy / 2 );

		}

	},

	render: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {

		this.oldClearColor.copy( renderer.getClearColor() );
		this.oldClearAlpha = renderer.getClearAlpha();
		var oldAutoClear = renderer.autoClear;
		renderer.autoClear = false;

		renderer.setClearColor( this.reusableColor , 0 );

		if ( maskActive ) renderer.context.disable( renderer.context.STENCIL_TEST );

		// Render input to screen

		if ( this.renderToScreen ) {

			this.quad.material = this.basic;
			this.basic.map = readBuffer.texture;

			renderer.render( this.scene, this.camera, undefined, true );

		}

		// 1. Extract Bright Areas

		this.highPassUniforms[ "tDiffuse" ].value = readBuffer.texture;
		this.highPassUniforms[ "luminosityThreshold" ].value = this.threshold;
		this.quad.material = this.materialHighPassFilter;

		renderer.render( this.scene, this.camera, this.renderTargetBright, true );

		// 2. Blur All the mips progressively

		var inputRenderTarget = this.renderTargetBright;

		for ( var i = 0; i < this.nMips; i ++ ) {

			this.quad.material = this.separableBlurMaterials[ i ];

			this.separableBlurMaterials[ i ].uniforms[ "colorTexture" ].value = inputRenderTarget.texture;
			this.separableBlurMaterials[ i ].uniforms[ "direction" ].value = THREE.UnrealBloomPass.BlurDirectionX;
			renderer.render( this.scene, this.camera, this.renderTargetsHorizontal[ i ], true );

			this.separableBlurMaterials[ i ].uniforms[ "colorTexture" ].value = this.renderTargetsHorizontal[ i ].texture;
			this.separableBlurMaterials[ i ].uniforms[ "direction" ].value = THREE.UnrealBloomPass.BlurDirectionY;
			renderer.render( this.scene, this.camera, this.renderTargetsVertical[ i ], true );

			inputRenderTarget = this.renderTargetsVertical[ i ];

		}

		// Composite All the mips

		this.quad.material = this.compositeMaterial;
		this.compositeMaterial.uniforms[ "bloomStrength" ].value = this.strength;
		this.compositeMaterial.uniforms[ "bloomRadius" ].value = this.radius;
		this.compositeMaterial.uniforms[ "bloomTintColors" ].value = this.bloomTintColors;

		renderer.render( this.scene, this.camera, this.renderTargetsHorizontal[ 0 ], true );

		// Blend it additively over the input texture

		this.quad.material = this.materialCopy;
		this.copyUniforms[ "tDiffuse" ].value = this.renderTargetsHorizontal[ 0 ].texture;

		if ( maskActive ) renderer.context.enable( renderer.context.STENCIL_TEST );


		if ( this.renderToScreen ) {

			renderer.render( this.scene, this.camera, undefined, false );

		} else {

			renderer.render( this.scene, this.camera, readBuffer, false );

		}

		// Restore renderer settings

		renderer.setClearColor( this.oldClearColor, this.oldClearAlpha );
		renderer.autoClear = oldAutoClear;

	},

	getSeperableBlurMaterial: function ( kernelRadius ) {

		return new THREE.ShaderMaterial( {

			defines: {
				"KERNEL_RADIUS": kernelRadius,
				"SIGMA": kernelRadius
			},

			uniforms: {
				"colorTexture": { value: null },
				"texSize": { value: new THREE.Vector2( 0.5, 0.5 ) },
				"direction": { value: new THREE.Vector2( 0.5, 0.5 ) }
			},

			vertexShader:
				"varying vec2 vUv;\n\
				void main() {\n\
					vUv = uv;\n\
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
				}",

			fragmentShader:
				"#include <common>\
				varying vec2 vUv;\n\
				uniform sampler2D colorTexture;\n\
				uniform vec2 texSize;\
				uniform vec2 direction;\
				\
				float gaussianPdf(in float x, in float sigma) {\
					return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\
				}\
				void main() {\n\
					vec2 invSize = 1.0 / texSize;\
					float fSigma = float(SIGMA);\
					float weightSum = gaussianPdf(0.0, fSigma);\
					vec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\
					for( int i = 1; i < KERNEL_RADIUS; i ++ ) {\
						float x = float(i);\
						float w = gaussianPdf(x, fSigma);\
						vec2 uvOffset = direction * invSize * x;\
						vec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\
						vec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\
						diffuseSum += (sample1 + sample2) * w;\
						weightSum += 2.0 * w;\
					}\
					gl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n\
				}"
		} );

	},

	getCompositeMaterial: function ( nMips ) {

		return new THREE.ShaderMaterial( {

			defines: {
				"NUM_MIPS": nMips
			},

			uniforms: {
				"blurTexture1": { value: null },
				"blurTexture2": { value: null },
				"blurTexture3": { value: null },
				"blurTexture4": { value: null },
				"blurTexture5": { value: null },
				"dirtTexture": { value: null },
				"bloomStrength": { value: 1.0 },
				"bloomFactors": { value: null },
				"bloomTintColors": { value: null },
				"bloomRadius": { value: 0.0 }
			},

			vertexShader:
				"varying vec2 vUv;\n\
				void main() {\n\
					vUv = uv;\n\
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
				}",

			fragmentShader:
				"varying vec2 vUv;\
				uniform sampler2D blurTexture1;\
				uniform sampler2D blurTexture2;\
				uniform sampler2D blurTexture3;\
				uniform sampler2D blurTexture4;\
				uniform sampler2D blurTexture5;\
				uniform sampler2D dirtTexture;\
				uniform float bloomStrength;\
				uniform float bloomRadius;\
				uniform float bloomFactors[NUM_MIPS];\
				uniform vec3 bloomTintColors[NUM_MIPS];\
				\
				float lerpBloomFactor(const in float factor) { \
					float mirrorFactor = 1.2 - factor;\
					return mix(factor, mirrorFactor, bloomRadius);\
				}\
				\
				void main() {\
					gl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) + \
													 lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) + \
													 lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) + \
													 lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) + \
													 lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\
				}"
		} );

	}

} );

THREE.UnrealBloomPass.BlurDirectionX = new THREE.Vector2( 1.0, 0.0 );
THREE.UnrealBloomPass.BlurDirectionY = new THREE.Vector2( 0.0, 1.0 );
}));

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Full-screen textured quad shader
 */

THREE.CopyShader = {

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"opacity":  { type: "f", value: 1.0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join( "\n" ),

	fragmentShader: [

		"uniform float opacity;",

		"uniform sampler2D tDiffuse;",

		"varying vec2 vUv;",

		"void main() {",

			"vec4 texel = texture2D( tDiffuse, vUv );",
			"gl_FragColor = opacity * texel;",

		"}"

	].join( "\n" )

};

/**
 * @author bhouston / http://clara.io/
 *
 * Luminosity
 * http://en.wikipedia.org/wiki/Luminosity
 */

THREE.LuminosityHighPassShader = {

  shaderID: "luminosityHighPass",

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"luminosityThreshold": { type: "f", value: 1.0 },
		"smoothWidth": { type: "f", value: 1.0 },
		"defaultColor": { type: "c", value: new THREE.Color( 0x000000 ) },
		"defaultOpacity":  { type: "f", value: 0.0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",

			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"uniform vec3 defaultColor;",
		"uniform float defaultOpacity;",
		"uniform float luminosityThreshold;",
		"uniform float smoothWidth;",

		"varying vec2 vUv;",

		"void main() {",

			"vec4 texel = texture2D( tDiffuse, vUv );",

			"vec3 luma = vec3( 0.299, 0.587, 0.114 );",

			"float v = dot( texel.xyz, luma );",

			"vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );",

			"float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );",

			"gl_FragColor = mix( outputColor, texel, alpha );",

		"}"

	].join("\n")

};

window.onload = function() {
  // STATS
  fpsHandler = new FPSHandler();
  stats = new Stats();
  stats.showPanel(0);
  document.body.appendChild(stats.dom);
  // DRAGABLE CLI
  var cliDiv = document.getElementById("cliDiv");
  cliDivheader = document.getElementById("cliDivheader");
  var terminalDiv = document.getElementById("terminalDiv");
  scriptCreatorDiv = document.getElementById("scriptCreatorDiv");
  scriptCreatorCancelButton = document.getElementById("scriptCreatorCancelButton");
  scriptCreatorSaveButton = document.getElementById("scriptCreatorSaveButton");
  scriptCreatorTextArea = document.getElementById("scriptCreatorTextArea");
  if (!isDeployment){
    scriptCreatorTextArea.onkeydown = function(e){
      if(e.keyCode==9 || e.which==9){
        e.preventDefault();
        var s = this.selectionStart;
        this.value = this.value.substring(0,this.selectionStart) + "\t" + this.value.substring(this.selectionEnd);
        this.selectionEnd = s+1;
      }
    }
    cliDiv.addEventListener("click", function(){
      cliFocused = true;
      omGUIFocused = false;
      tmGUIFocused = false;
      inactiveCounter = 0;
      if (keyboardBuffer["Shift"] && mode == 0){
        keyboardBuffer["Shift"] = false;
        for (var objName in addedObjects){
          addedObjects[objName].mesh.visible = true;
        }
        for (var objName in objectGroups){
          objectGroups[objName].mesh.visible = true;
        }
        for (var textName in addedTexts){
          addedTexts[textName].show();
        }
      }
    });
    cliDiv.addEventListener("mousemove", function(event){
      inactiveCounter = 0;
    });

    terminalDiv.addEventListener("mousewheel", function(e){
      e.preventDefault();
      e.stopPropagation();
    });
    if (typeof InstallTrigger !== 'undefined') {
      // M O Z I L L A
      terminalDiv.addEventListener("wheel", function(e){
        e.preventDefault();
        e.stopPropagation();
      });
    }
    dragElement(cliDiv);
  }

  // SELECTION HANDLER
  if (!isDeployment){
    selectionHandler = new SelectionHandler();
  }

  // SCRIPTING UTILITY FUNCTIONS
  ROYGBIV = new Roygbiv();
  if (!isDeployment){
    var roygbivScriptingAPIMethodCount = (Object.keys(Roygbiv.prototype).length);
    if (roygbivScriptingAPIMethodCount != ROYGBIV.functionNames.length){
      console.error("[*] Scripting API error: Some methods are missing in functionNames list.");
    }
    for (var i = 0; i<ROYGBIV.functionNames.length; i++){
      if (!Text[Text.ROYGBIV_SCRIPTING_API_PREFIX+ROYGBIV.functionNames[i].toUpperCase()]){
        console.error("[*] Scripting API error: "+ROYGBIV.functionNames[i]+" explanation is not present.");
      }
    }
  }

  pointerLockSupported = 'pointerLockElement' in document ||
                         'mozPointerLockElement' in document ||
                         'webkitPointerLockElement' in document;

  // DEFAULT FONT
  document.fonts.forEach(function(font){
    if (font.family == "hack"){
      defaultFont = new Font(null, null, null, null, font);
    }
  });


  // COMMAND DESCRIPTOR
  if (!isDeployment){
    commandDescriptor = new CommandDescriptor();
    commandDescriptor.test();
  }

  // COLOR NAMES
  ColorNames = new ColorNames();

  // AREA BIN HANDLER
  areaBinHandler = new WorldBinHandler(true);
  areaBinHandler.isAreaBinHandler = true;

  // AREA CONFIGURATIONS HANDLER
  areaConfigurationsHandler = new AreaConfigurationsHandler();

  // RAYCASTER
  rayCaster = new RayCaster();

  // OBJECT PICKER 2D
  objectPicker2D = new ObjectPicker2D();

  // MODE SWITCHER
  modeSwitcher = new ModeSwitcher();

  if (!isDeployment){
    // GUI HANDLER
    guiHandler = new GUIHandler();
    guiHandler.init();
  }

  // IMAGE UPLOADER
  imageUploaderInput = $("#imageUploaderInput");
  // LOAD
  loadInput = $("#loadInput");
  // 3D CANVAS
  canvas = document.getElementById("rendererCanvas");
  canvas.requestPointerLock = canvas.requestPointerLock ||
                              canvas.mozRequestPointerLock ||
                              canvas.webkitRequestPointerLock;
  var pointerLockChangeFunction = 0;
  if ("onpointerlockchange" in document){
    pointerLockChangeFunction = "pointerlockchange";
  }else if ("onmozpointerlockchange" in document){
    pointerLockChangeFunction = "mozpointerlockchange";
  }else if ("onwebkitpointerlockchange" in document){
    pointerLockChangeFunction = "webkitpointerlockchange";
  }
  if (pointerLockChangeFunction){
    document.addEventListener(pointerLockChangeFunction, function(event){
      if (mode == 1 && screenPointerLockChangedCallbackFunction){
        if (document.pointerLockElement == canvas ||
              document.mozPointerLockElement == canvas ||
                document.webkitPointerLockElement == canvas){
          screenPointerLockChangedCallbackFunction(true);
        }else{
          screenPointerLockChangedCallbackFunction(false);
        }
      }
    });
  }
  canvas.onfullscreenchange = function(event){
    if (document.fullscreenElement == canvas){
      onFullScreen = true;
      if (mode == 1 && screenFullScreenChangeCallbackFunction){
        screenFullScreenChangeCallbackFunction(true);
      }
    }else{
      onFullScreen = false;
      if (mode == 1 && screenFullScreenChangeCallbackFunction){
        screenFullScreenChangeCallbackFunction(false);
      }
    }
  }
  var hiddenText, visibilityChange;
  if (!(typeof document.hidden == UNDEFINED)){
    hiddenText = "hidden";
    visibilityChange = "visibilitychange";
  }else if (!(typeof document.mozHidden == UNDEFINED)){
    hiddenText = "mozHidden";
    visibilityChange = "mozvisibilitychange";
  }else if (!(typeof document.msHidden == UNDEFINED)){
    hiddenText = "msHidden";
    visibilityChange = "msvisibilitychange";
  }else if (!(typeof document.webkitHidden == UNDEFINED)){
    hiddenText = "webkitHidden";
    visibilityChange = "webkitvisibilitychange";
  }
  document.addEventListener(visibilityChange, function(){
    isScreenVisible = !(document[hiddenText]);
  }, false);
  canvas.addEventListener("click", function(event){
    inactiveCounter = 0;
    cliFocused = false;
    omGUIFocused = false;
    tmGUIFocused = false;
    if (windowLoaded){
      var rect = renderer.getCurrentViewport();
      var rectX = rect.x, rectY = rect.y, rectZ = rect.z, rectW = rect.w;
      if (screenResolution != 1){
        rectX = rectX / screenResolution;
        rectY = rectY / screenResolution;
        rectZ = rectZ / screenResolution;
        rectW = rectW / screenResolution;
      }
      var coordX = ((event.clientX - rectX) / rectZ) * 2 - 1;
      var coordY = - ((event.clientY - rectY) / rectW) * 2 + 1;
      if (mode == 1 && screenClickCallbackFunction){
        screenClickCallbackFunction(coordX, coordY);
      }
      if (mode == 1 && pointerLockSupported && pointerLockRequested){
        canvas.requestPointerLock();
        pointerLockRequested = false;
      }
      if (mode == 1 && fullScreenRequested){
        if (canvas.requestFullscreen){
          canvas.requestFullscreen();
        } else if (canvas.mozRequestFullScreen){
          canvas.mozRequestFullScreen();
        } else if (canvas.webkitRequestFullscreen){
          canvas.webkitRequestFullscreen();
        } else if (canvas.msRequestFullscreen){
          canvas.msRequestFullscreen();
        }
        fullScreenRequested = false;
      }
      if (mode == 1 && isPaused){
        return;
      }
      if (event.clientX < rectX || event.clientX > rectX + rectZ || event.clientY < rectY || event.clientY > rectY + rectW){
        return;
      }
      // TRY TO PICK 2D OBJECTS FIRST
      objectPicker2D.find(event.clientX, event.clientY);
      if (!intersectionPoint){
        REUSABLE_VECTOR.setFromMatrixPosition(camera.matrixWorld);
        REUSABLE_VECTOR_2.set(coordX, coordY, 0.5).unproject(camera).sub(REUSABLE_VECTOR).normalize();
        rayCaster.findIntersections(REUSABLE_VECTOR, REUSABLE_VECTOR_2, (mode == 0));
      }
      if (intersectionPoint){
         var object = addedObjects[intersectionObject];
         if (!object){
           object = objectGroups[intersectionObject];
         }
         if (!object){
           object = gridSystems[intersectionObject];
         }
         if (!object){
           object = addedTexts[intersectionObject];
         }
         if (object.isAddedObject || object.isObjectGroup){
           if (!defaultCameraControlsDisabled && !isDeployment){
             terminal.clear();
           }
           var point = intersectionPoint;
           var coordStr = " ("+point.x.toFixed(2)+", "+point.y.toFixed(2)+", "+point.z.toFixed(2)+")";
           if (object.isAddedObject){
             if (!defaultCameraControlsDisabled && !isDeployment){
               terminal.printInfo(Text.CLICKED_ON.replace(
                 Text.PARAM1, object.name + coordStr
               ));
             }
             if (mode == 0){
               selectionHandler.resetCurrentSelection();
             }
             if (!isDeployment){
               selectionHandler.select(object);
               guiHandler.afterObjectSelection();
             }
             if (object.clickCallbackFunction){
               object.clickCallbackFunction(point.x, point.y, point.z);
             }
           }else if (object.isObjectGroup){
             if (!defaultCameraControlsDisabled && !isDeployment){
               terminal.printInfo(Text.CLICKED_ON.replace(
                 Text.PARAM1, object.name+coordStr
               ));
             }
             if (mode == 0){
               selectionHandler.resetCurrentSelection();
             }
             if (!isDeployment){
               selectionHandler.select(object);
               guiHandler.afterObjectSelection();
             }
             if (object.clickCallbackFunction){
               object.clickCallbackFunction(point.x, point.y, point.z);
             }
           }
         }else if (object.isGridSystem){
           var gridSystem = object;
           var point = intersectionPoint;
           var selectedGrid = gridSystem.getGridFromPoint(point);
           if (selectedGrid.sliced && !selectedGrid.slicedGridSystemName){
             selectedGrid.sliced = false;
           }
           if (selectedGrid){
             if (!selectedGrid.sliced){
               if (selectedGrid.destroyedAddedObject && !(keyboardBuffer["Shift"])){
                 var addedObject = addedObjects[selectedGrid.destroyedAddedObject];
                 terminal.clear();
                 var point = intersectionPoint;
                 var coordStr = " ("+point.x.toFixed(2)+", "+point.y.toFixed(2)+", "+point.z.toFixed(2)+")";
                 terminal.printInfo(Text.CLICKED_ON.replace(
                   Text.PARAM1, addedObject.name+coordStr
                 ));
                 if (mode == 0){
                   selectionHandler.resetCurrentSelection();
                 }
                 if (!isDeployment){
                   selectionHandler.select(addedObject);
                   guiHandler.afterObjectSelection();
                 }
                 if (addedObject.clickCallbackFunction){
                   addedObject.clickCallbackFunction(point.x, point.y, point.z);
                 }
               }else if (selectedGrid.destroyedObjectGroup && !(keyboardBuffer["Shift"])){
                 var objectGroup = objectGroups[selectedGrid.destroyedObjectGroup];
                 terminal.clear();
                 var point = intersectionPoint;
                 var coordStr = " ("+point.x.toFixed(2)+", "+point.y.toFixed(2)+", "+point.z.toFixed(2)+")";
                 terminal.printInfo(Text.CLICKED_ON.replace(
                   Text.PARAM1, objectGroup.name+coordStr
                 ));
                 if (mode == 0){
                   selectionHandler.resetCurrentSelection();
                 }
                 if (!isDeployment){
                   selectionHandler.select(objectGroup);
                   guiHandler.afterObjectSelection();
                 }
                 if (objectGroup.clickCallbackFunction){
                   objectGroup.clickCallbackFunction(point.x, point.y, point.z);
                 }
               }else if (selectedGrid.createdAddedTextName && !(keyboardBuffer["Shift"])){
                  var addedText = addedTexts[selectedGrid.createdAddedTextName];
                  if (!defaultCameraControlsDisabled && !isDeployment){
                    terminal.clear();
                    terminal.printInfo(Text.SELECTED.replace(Text.PARAM1, addedText.name));
                  }
                  if (mode == 0){
                    selectionHandler.resetCurrentSelection();
                  }
                  if (!isDeployment){
                    selectionHandler.select(addedText);
                  }
                  if (mode != 0 && addedText.clickCallbackFunction){
                    addedText.clickCallbackFunction(addedText.name);
                  }
                  if (!isDeployment){
                    guiHandler.afterObjectSelection();
                  }
               }else{
                 selectedGrid.toggleSelect(false, true);
              }
            }
           }
         }else if (object.isAddedText){
           if (mode == 0){
             selectionHandler.resetCurrentSelection();
           }
           if (!defaultCameraControlsDisabled && !isDeployment){
             terminal.clear();
             terminal.printInfo(Text.SELECTED.replace(Text.PARAM1, object.name));
           }
           if (!isDeployment){
             selectionHandler.select(object);
           }
           if (mode != 0 && object.clickCallbackFunction){
             object.clickCallbackFunction(object.name);
           }
           if (!isDeployment){
             guiHandler.afterObjectSelection();
           }
         }
      }else{
        if (!isDeployment){
          selectionHandler.resetCurrentSelection();
          guiHandler.afterObjectSelection();
        }
      }
    }
  });

  canvas.addEventListener("mousedown", function(event){
    inactiveCounter = 0;
    if (mode == 1 && screenMouseDownCallbackFunction){
      var rect = boundingClientRect;
      var coordX = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      var coordY = - ((event.clientY - rect.top) / rect.height) * 2 + 1;
      screenMouseDownCallbackFunction(coordX, coordY);
    }
    isMouseDown = true;
  });
  canvas.addEventListener("mouseup", function(event){
    inactiveCounter = 0;
    if (mode == 1 && screenMouseUpCallbackFunction){
      var rect = boundingClientRect;
      var coordX = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      var coordY = - ((event.clientY - rect.top) / rect.height) * 2 + 1;
      screenMouseUpCallbackFunction(coordX, coordY);
    }
    isMouseDown = false;
  });
  canvas.addEventListener("mousemove", function(event){
    inactiveCounter = 0;
    if (mode == 1 && screenMouseMoveCallbackFunction){
      var rect = boundingClientRect;
      var coordX = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      var coordY = - ((event.clientY - rect.top) / rect.height) * 2 + 1;
      var movementX = event.movementX || event.mozMovementX ||
                      event.webkitMovementX || 0;
      var movementY = event.movementY || event.mozMovementY ||
                      event.webkitMovementY || 0;
      screenMouseMoveCallbackFunction(coordX, coordY, movementX, movementY);
    }
  });

  // INITIALIZE THREE.JS SCENE AND RENDERER
  scene = new THREE.Scene();
  debugRenderer = new THREE.CannonDebugRenderer(scene, physicsWorld);
  scene.background = new THREE.Color(sceneBackgroundColor);
  camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );
  camera.position.set(initialCameraX, initialCameraY, initialCameraZ);
  camera.rotation.order = 'YXZ';
  camera.aspect = (window.innerWidth / window.innerHeight);
  GLOBAL_PROJECTION_UNIFORM.value = camera.projectionMatrix;
  GLOBAL_VIEW_UNIFORM.value = camera.matrixWorldInverse;
  renderer = new THREE.WebGLRenderer({canvas: canvas});
  if (window.devicePixelRatio > 1){
    screenResolution = 1;
    renderer.setPixelRatio(1);
  }else{
    renderer.setPixelRatio(window.devicePixelRatio);
    screenResolution = window.devicePixelRatio;
  }
  renderer.setSize(window.innerWidth, window.innerHeight);
  boundingClientRect = renderer.domElement.getBoundingClientRect();
  initPhysics();
  initBadTV();
  render();
  windowLoaded = true;
  MAX_VERTEX_UNIFORM_VECTORS = renderer.context.getParameter(renderer.context.MAX_VERTEX_UNIFORM_VECTORS);
  VERTEX_SHADER_TEXTURE_FETCH_SUPPORTED = (renderer.context.getParameter(renderer.context.MAX_VERTEX_TEXTURE_IMAGE_UNITS) > 0);
  DDS_SUPPORTED = (!(renderer.context.getExtension("WEBGL_compressed_texture_s3tc") == null));
  INSTANCING_SUPPORTED = (!(renderer.context.getExtension("ANGLE_instanced_arrays") == null));

  var tmpCanvas = document.createElement("canvas");
  tmpCanvas.width = 1;
  tmpCanvas.height = 1;
  var tmpCtx = tmpCanvas.getContext("2d");
  tmpCtx.fillStyle = "rgba("+255+","+255+","+255+","+(0)+")";
  tmpCtx.fillRect(0, 0, 1, 1);
  nullTexture = new THREE.CanvasTexture(tmpCanvas);
  nullTexture.wrapS = THREE.ClampToEdgeWrapping;
  nullTexture.wrapT = THREE.ClampToEdgeWrapping;
  nullTexture.minFilter = THREE.NearestFilter;
  nullTexture.magFilter = THREE.NearestFilter;
  nullTexture.needsUpdate = true;
  nullCubeTexture = new THREE.CubeTexture([
    nullTexture.image, nullTexture.image, nullTexture.image,
    nullTexture.image, nullTexture.image, nullTexture.image
  ]);
  GLOBAL_CUBE_TEXTURE_UNIFORM = new THREE.Uniform(nullCubeTexture);
  GLOBAL_CUBE_TEXTURE_UNIFORM.value.wrapS = THREE.ClampToEdgeWrapping;
  GLOBAL_CUBE_TEXTURE_UNIFORM.value.wrapT = THREE.ClampToEdgeWrapping;
  GLOBAL_CUBE_TEXTURE_UNIFORM.value.minFilter = THREE.NearestFilter;
  GLOBAL_CUBE_TEXTURE_UNIFORM.value.magFilter = THREE.NearestFilter;
  GLOBAL_CUBE_TEXTURE_UNIFORM.value.needsUpdate = true;
  nullTexture.isNullTexture = true;

  if (!isDeployment){
    terminal.init();
  }
  ShaderContent = new ShaderContent();
  if (isDeployment){
    cliDiv.value = "";
    appendtoDeploymentConsole("Loading shaders.");
    console.log(
      "%c "+BANNERL1+"\n"+BANNERL2+"\n"+BANNERL3+"\n"+
      BANNERL4+"\n"+BANNERL5 +"\n"+"by Ouz Erolu - github.com/oguzeroglu",
      "background: black; color: lime"
    );
  }
};

window.addEventListener('mousewheel', mouseWheelEvent, false);
if (typeof InstallTrigger !== 'undefined') {
  // M O Z I L L A
  window.addEventListener('wheel', mouseWheelEvent, false);
}
window.addEventListener('resize', resizeFunction);
if (isMobile){
  window.addEventListener('orientationchange', resizeFunction);
}
window.addEventListener('keydown', function(event){
  inactiveCounter = 0;

  if (!windowLoaded){
    return;
  }

  if (cliFocused || omGUIFocused || tmGUIFocused){
    return;
  }

  if (keyCodeToChar[event.keyCode]){
    if (keyboardBuffer[keyCodeToChar[event.keyCode]]){
      return;
    }
    keyboardBuffer[keyCodeToChar[event.keyCode]] = true;
    if (mode == 1 && screenKeydownCallbackFunction && !isPaused){
      screenKeydownCallbackFunction(keyCodeToChar[event.keyCode]);
    }
  }

  if (mode == 0 && keyboardBuffer["."]){
    for (var gridName in gridSelections){
      gridSelections[gridName].renderCornerHelpers();
    }
  }

  if (mode == 1 && !isDeployment && keyboardBuffer["E"] && keyboardBuffer["T"] && (terminalDiv.style.display == "none" || terminal.isDisabled)){
    terminal.enable();
    terminalDiv.style.display = "";
    if (!isDeployment){
      cliDivheader.style.display = "";
    }
  }
  if (mode == 1 && isPaused){
    return;
  }
  switch(event.keyCode){
    case 16: //SHIFT
      if (mode == 0 && !isDeployment){
        selectionHandler.resetCurrentSelection();
        for (var objName in addedObjects){
          addedObjects[objName].mesh.visible = false;
        }
        for (var objName in objectGroups){
          objectGroups[objName].mesh.visible = false;
        }
        for (var textName in addedTexts){
          addedTexts[textName].hide();
        }
      }
    break;
    case 8: //BACKSPACE
      //FIREFOX GO BACK FIX
      if (selectionHandler.getSelectedObject() && !cliFocused){
        event.preventDefault();
      }
      if (mode == 1 || isDeployment){
        return;
      }
      var currentSelection = selectionHandler.getSelectedObject();
      if (currentSelection.isAddedObject){
        delete addedObjects[currentSelection.name];
        currentSelection.destroy();
        terminal.clear();
        terminal.printInfo(Text.OBJECT_DESTROYED);
        selectionHandler.resetCurrentSelection();
        if (areaConfigurationsVisible){
          guiHandler.hide(datGuiAreaConfigurations);
          areaConfigurationsVisible = false;
        }
      }else if (currentSelection.isObjectGroup){
        delete objectGroups[currentSelection.name];
        currentSelection.destroy();
        selectionHandler.resetCurrentSelection();
        terminal.clear();
        terminal.printInfo(Text.OBJECT_DESTROYED);
        if (areaConfigurationsVisible){
          guiHandler.hide(datGuiAreaConfigurations);
          areaConfigurationsVisible = false;
        }
      }else if (currentSelection.isAddedText){
        terminal.clear();
        parseCommand("destroyText "+currentSelection.name);
      }
      guiHandler.afterObjectSelection();
    break;
  }

});
window.addEventListener('keyup', function(event){
  inactiveCounter = 0;

  if (!windowLoaded){
    return;
  }
  if (cliFocused || omGUIFocused || tmGUIFocused){
    return;
  }
  if (keyCodeToChar[event.keyCode]){
    keyboardBuffer[keyCodeToChar[event.keyCode]] = false;
    if (mode == 0 && keyCodeToChar[event.keyCode] == "."){
      for (var gridName in gridSelections){
        gridSelections[gridName].removeCornerHelpers();
      }
    }
    if (mode == 1 && !isPaused && screenKeyupCallbackFunction){
      screenKeyupCallbackFunction(keyCodeToChar[event.keyCode]);
    }
  }
  if (mode == 1 && isPaused){
    return;
  }
  switch(event.keyCode){
    case 190: //PERIOD
      for (var gridName in gridSelections){
        var grid = gridSelections[gridName];
        if (grid.divs){
          for (var i = 0; i<grid.divs.length; i++){
            grid.divs[i].style.visibility = "hidden";
          }
        }
      }
    break;
    case 16: //SHIFT
      if (mode == 0){
        for (var objName in addedObjects){
          addedObjects[objName].mesh.visible = true;
        }
        for (var objName in objectGroups){
          objectGroups[objName].mesh.visible = true;
        }
        for (var textName in addedTexts){
          addedTexts[textName].show();
        }
      }
    break;
  }

});

 function initBadTV(){
   renderPass = new THREE.RenderPass(scene, camera);
   if (mode == 1){
    bloomPass = new THREE.UnrealBloomPass(
      new THREE.Vector2(
        window.innerWidth * bloomResolutionScale,
        window.innerHeight * bloomResolutionScale
      ),
      bloomStrength,
      bloomRadius,
      bloomThreshold
    );
   }
   copyPass = new THREE.ShaderPass( THREE.CopyShader );
   setPostProcessingParams();
   composer = new THREE.EffectComposer(renderer);
   composer.setSize(renderer.getCurrentViewport().z / screenResolution, renderer.getCurrentViewport().w / screenResolution);
   composer.addPass( renderPass );
   if (mode == 1){
    if (bloomOn){
      composer.addPass( bloomPass );
      bloomPass.renderToScreen = true;
    }
   }
   if (!(mode == 1 && bloomOn)){
	    composer.addPass( copyPass );
	    copyPass.renderToScreen = true;
   }
   setPostProcessingParams();
 }

 function setPostProcessingParams(){
   if (mode == 1){
    if (bloomOn){
      bloomPass.strength = bloomStrength;
      bloomPass.radius = bloomRadius;
      bloomPass.threshold = bloomThreshold;
      bloomPass.resolution = new THREE.Vector2(
        window.innerWidth * bloomResolutionScale,
        window.innerHeight * bloomResolutionScale
      );
    }
   }
 }

 function initPhysics(){
   physicsWorld.quatNormalizeSkip = quatNormalizeSkip;
   physicsWorld.quatNormalizeFast = quatNormalizeFast;
   physicsWorld.defaultContactMaterial.contactEquationStiffness = contactEquationStiffness;
   physicsWorld.defaultContactMaterial.contactEquationRelaxation = contactEquationRelaxation;
   physicsWorld.defaultContactMaterial.friction = friction;
   physicsSolver.iterations = physicsIterations;
   physicsSolver.tolerance = physicsTolerance;
   physicsWorld.solver = physicsSolver;
   physicsWorld.gravity.set(0, gravityY, 0);
   physicsWorld.broadphase = new CANNON.SAPBroadphase(physicsWorld);
 }

 function adjustPostProcessing(variableIndex, val){
   switch(variableIndex){
     case 1: //bloomStrength
      bloomStrength = val;
     break;
     case 2: //Bloom_radius
      bloomRadius = val;
     break;
     case 3: //Bloom_threshhold
      bloomThreshold = val;
     break;
     case 4: //Bloom_resolution_scale
      bloomResolutionScale = val;
      bloomPass = new THREE.UnrealBloomPass(
        new THREE.Vector2(
          window.innerWidth * bloomResolutionScale,
          window.innerHeight * bloomResolutionScale
        ),
        bloomStrength,
        bloomRadius,
        bloomThreshold
      );
     break;
     case 5: //Bloom
      bloomOn = val;
     break;
     case -1: //from script
      if(!isDeployment){
        postprocessingParameters["Bloom_strength"] = bloomStrength;
        postprocessingParameters["Bloom_radius"] = bloomRadius;
        postprocessingParameters["Bloom_threshhold"] = bloomThreshold;
        postprocessingParameters["Bloom_resolution_scale"] = bloomResolutionScale;
        postprocessingParameters["Bloom"] = bloomOn;
      }
     break;
   }
   composer = new THREE.EffectComposer(renderer);
   composer.setSize(renderer.getCurrentViewport().z / screenResolution, renderer.getCurrentViewport().w / screenResolution);
   composer.addPass(renderPass);
   if (bloomOn){
     composer.addPass(bloomPass);
     bloomPass.renderToScreen = true;
   }
   if (!(mode == 1 && bloomOn)){
	    composer.addPass(copyPass);
	    copyPass.renderToScreen = true;
   }
   setPostProcessingParams();
 }

function isPhysicsWorkerEnabled(){
  return false;
  //return (WORKERS_SUPPORTED && PHYSICS_WORKER_ENABLED);
}

function isCollisionWorkerEnabled(){
  return false;
  //return (WORKERS_SUPPORTED && COLLISION_WORKER_ENABLED);
}

function isPSCollisionWorkerEnabled(){
  return false;
  //return (WORKERS_SUPPORTED && PS_COLLISION_WORKER_ENABLED);
}

function resizeFunction(){
  if (renderer && composer){
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
    camera.oldAspect = camera.aspect;
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    boundingClientRect = renderer.domElement.getBoundingClientRect();
    if (isDeployment){
      canvas.oldWidth = (canvas.width / screenResolution) + 'px';
      if (!isDeployment && terminal.isMadeVisible){
        ROYGBIV.terminal(false);
        ROYGBIV.terminal(true);
        if (!terminal.terminalPromptEnabled){
          ROYGBIV.terminalPrompt(false);
        }
      }
    }
    if (mode == 1){
      handleViewport();
    }
    if (mode == 0){
      for (var areaName in areas){
        if (areas[areaName].text){
          areas[areaName].text.handleResize();
        }
      }
      for (var pointName in markedPoints){
        if (markedPoints[pointName].text){
          markedPoints[pointName].text.handleResize();
        }
      }
      for (var gridName in gridSelections){
        if (gridSelections[gridName].texts){
          for (var i = 0; i<gridSelections[gridName].texts.length; i++){
            gridSelections[gridName].texts[i].handleResize();
          }
        }
      }
    }
    for (var textName in addedTexts){
      addedTexts[textName].handleResize();
    }
  }
}

function processKeyboardBuffer(){
  if (keyboardBuffer["Left"]){
    camera.rotation.y += rotationYDelta;
  }
  if (keyboardBuffer["Right"]){
    camera.rotation.y -= rotationYDelta;
  }
  if (keyboardBuffer["Up"]){
    camera.rotation.x += rotationXDelta;
  }
  if (keyboardBuffer["Down"]){
    camera.rotation.x -= rotationXDelta;
  }
  if (keyboardBuffer["W"]){
    camera.translateZ(-1 * translateZAmount * defaultAspect / camera.aspect);
  }
  if (keyboardBuffer["S"]){
    camera.translateZ(translateZAmount * defaultAspect / camera.aspect);
  }
  if (keyboardBuffer["D"]){
    camera.translateX(translateXAmount * defaultAspect / camera.aspect);
  }
  if (keyboardBuffer["A"]){
    camera.translateX(-1 * translateXAmount * defaultAspect / camera.aspect);
  }
  if (keyboardBuffer["E"]){
    camera.translateY(-1 * translateYAmount * defaultAspect / camera.aspect);
  }
  if (keyboardBuffer["Q"]){
    camera.translateY(translateYAmount * defaultAspect / camera.aspect);
  }
  if (keyboardBuffer["Z"]){
    camera.rotation.z += rotationZDelta;
  }
  if (keyboardBuffer["C"]){
    camera.rotation.z -= rotationZDelta;
  }
}

function processCameraRotationBuffer(){
  camera.rotation.x += cameraRotationBuffer.x;
  camera.rotation.y += cameraRotationBuffer.y;
  camera.rotation.z += cameraRotationBuffer.z;
  cameraRotationBuffer.x = 0;
  cameraRotationBuffer.y = 0;
  cameraRotationBuffer.z = 0;
}

function mouseWheelEvent(e) {
  if (mode == 1 && isPaused){
    return;
  }
  e.preventDefault();
  if (mode == 1 && defaultCameraControlsDisabled){
    return;
  }
  if (!windowLoaded){
    return;
  }
  var deltaX = e.deltaX;
  var deltaY = e.deltaY;
  if((typeof deltaX == "undefined") || (typeof deltaY == "undefined")){
    return;
  }
  if (Math.abs(deltaX) < Math.abs(deltaY)){
    camera.translateZ(deltaY * defaultAspect / camera.aspect);
  }else{
    camera.translateX(deltaX * defaultAspect / camera.aspect);
  }
}

function rescale(canvas, scale){
  var resizedCanvas = document.createElement("canvas");
  resizedCanvas.width = canvas.width * scale;
  resizedCanvas.height = canvas.height * scale;
  var resizedContext = resizedCanvas.getContext("2d");
  resizedContext.drawImage(canvas, 0, 0, canvas.width, canvas.height, 0, 0, resizedCanvas.width, resizedCanvas.height);
  return resizedCanvas;
}

function handleViewport(){
  var curViewport = renderer.getCurrentViewport();
  var cvx = curViewport.x;
  var cvy = curViewport.y;
  var cvz = curViewport.z;
  var cvw = curViewport.w;
  if (screenResolution != 1){
    cvz = cvz / screenResolution;
    cvw = cvw / screenResolution;
  }
  if (mode == 1 && fixedAspect > 0){
    var result = getMaxWidthHeightGivenAspect(canvas.width / screenResolution, canvas.height / screenResolution, fixedAspect);
    var newViewportX = ((canvas.width / screenResolution) - result.width) / 2;
    var newViewportY = ((canvas.height / screenResolution) - result.height) / 2;
    var newViewportZ = result.width;
    var newViewportW = result.height;
    renderer.setViewport(newViewportX, newViewportY, newViewportZ, newViewportW);
    composer.setSize(newViewportZ, newViewportW);
    currentViewport.startX = newViewportX;
    currentViewport.startY = newViewportY;
    currentViewport.width = newViewportZ;
    currentViewport.height = newViewportW;
    camera.oldAspect = camera.aspect;
    camera.aspect = fixedAspect;
    camera.updateProjectionMatrix();
    return;
  }
  var newViewportX = 0;
  var newViewportY = 0;
  var newViewportZ = canvas.width / screenResolution;
  var newViewportW = canvas.height / screenResolution;
  if (viewportMaxWidth > 0){
    if (cvz > viewportMaxWidth){
      var diff = cvz - viewportMaxWidth;
      newViewportX = diff/2;
      newViewportZ = viewportMaxWidth;
    }
  }
  if (viewportMaxHeight > 0){
    if (cvw > viewportMaxHeight){
      var diff = cvw - viewportMaxHeight;
      newViewportY = diff/2;
      newViewportW = viewportMaxHeight;
    }
  }
  renderer.setViewport(newViewportX, newViewportY, newViewportZ, newViewportW);
  composer.setSize(newViewportZ, newViewportW);
  currentViewport.startX = newViewportX;
  currentViewport.startY = newViewportY;
  currentViewport.width = newViewportZ;
  currentViewport.height = newViewportW;

  camera.oldAspect = camera.aspect;
  camera.aspect = currentViewport.width / currentViewport.height;
  camera.updateProjectionMatrix();

}

function getMaxWidthHeightGivenAspect(currentWidth, currentHeight, givenAspect){
  if ((currentWidth/givenAspect) <= currentHeight){
    return {width: currentWidth, height: currentWidth/givenAspect}
  }
  var step = 0.1;
  for (var width = currentWidth; width>0; width-=0.1){
     if (width/givenAspect <= currentHeight){
       return {width: width, height: width/givenAspect};
     }
  }
  return {width: currentWidth, height: currentHeight};
}

function build(projectName, author){
  terminal.clear();
  terminal.printInfo(Text.BUILDING_PROJECT);
  canvas.style.visibility = "hidden";
  terminal.disable();
  var xhr = new XMLHttpRequest();
  xhr.open("POST", "/build", true);
  xhr.setRequestHeader("Content-type", "application/json");
  xhr.onreadystatechange = function () {
    if (xhr.readyState == 4 && xhr.status == 200){
      terminal.clear();
      var json = JSON.parse(xhr.responseText);
      if (json.error){
        terminal.printError(json.error);
      }else{
        terminal.printInfo(Text.PROJECT_BUILDED.replace(Text.PARAM1, json.path));
        window.open("http://localhost:8085/deploy/"+projectName+"/application.html", '_blank');
      }
      canvas.style.visibility = "";
      terminal.enable();
    }
  }
  var data = JSON.stringify(new State(projectName, author));
  xhr.send(data);
}

function generateUniqueObjectName(){
  var generatedName = (Date.now().toString(36) + Math.random().toString(36).substr(2, 5)).toUpperCase();
  var nameFound = true;
  while (nameFound){
    var nameInAddedObjects = !(typeof addedObjects[generatedName] == UNDEFINED);
    var nameInGluedObjects = !(typeof objectGroups[generatedName] == UNDEFINED);
    var nameInChildObjects = false;
    for (var gluedObjectName in objectGroups){
      var group = objectGroups[gluedObjectName].group;
      if (!(typeof group[generatedName] == "undefined")){
        nameInChildObjects = true;
      }
    }
    var nameInAddedTexts = !(typeof addedTexts[generatedName] == UNDEFINED);
    var nameInGridSystems = !(typeof gridSystems[generatedName] == UNDEFINED);
    nameFound = (nameInAddedObjects || nameInGluedObjects || nameInChildObjects || nameInAddedTexts || nameInGridSystems);
    if (nameFound){
      console.error("[*] Object name generation collision happened: "+generatedName);
      generatedName = (Date.now().toString(36) + Math.random().toString(36).substr(2, 5)).toUpperCase();
    }
  }
  return generatedName;
}

function isNameUsedAsSoftCopyParentName(name){
  for (var objName in addedObjects){
    if (addedObjects[objName].softCopyParentName && addedObjects[objName].softCopyParentName == name){
      return true;
    }
  }
  for (var objName in objectGroups){
    if (objectGroups[objName].softCopyParentName && objectGroups[objName].softCopyParentName == name){
      return true;
    }
  }
  return false;
}

function processNewGridSystemCommand(name, sizeX, sizeZ, centerX, centerY, centerZ, outlineColor, cellSize, axis, isSuperposed, slicedGrid){
  if (addedObjects[name] || objectGroups[name]){
    terminal.printError(Text.NAME_MUST_BE_UNIQUE);
    return true;
  }
  for (var objName in objectGroups){
    for (var childName in objectGroups[objName].group){
      if (childName == name){
        terminal.printError(Text.NAME_MUST_BE_UNIQUE);
      }
    }
  }
  sizeX = parseInt(sizeX);
  if (isNaN(sizeX)){
    terminal.printError(Text.SIZEX_MUST_BE_A_NUMBER);
    return true;
  }
  sizeZ = parseInt(sizeZ);
  if (isNaN(sizeZ)){
    terminal.printError(Text.SIZEZ_MUST_BE_A_NUMBER);
    return true;
  }
  centerX = parseInt(centerX);
  if (isNaN(centerX)){
    terminal.printError(Text.CENTERX_MUST_BE_A_NUMBER);
    return true;
  }
  centerY = parseInt(centerY);
  if (isNaN(centerY)){
    terminal.printError(Text.CENTERY_MUST_BE_A_NUMBER);
    return true;
  }
  centerZ = parseInt(centerZ);
  if (isNaN(centerZ)){
    terminal.printError(Text.CENTERZ_MUST_BE_A_NUMBER);
    return true;
  }
  cellSize = parseInt(cellSize);
  if (isNaN(cellSize)){
    terminal.printError(Text.CELLSIZE_MUST_BE_A_NUMBER);
    return true;
  }
  if (!axis){
    terminal.printError(Text.AXIS_MUST_BE_ONE_OF_XY_YZ_XZ);
    return true;
  }
  if (axis.toUpperCase() != "XZ" && axis.toUpperCase() != "XY" && axis.toUpperCase() != "YZ"){
    terminal.printError(Text.AXIS_MUST_BE_ONE_OF_XY_YZ_XZ);
    return true;
  }
  var gsObject = new GridSystem(name, parseInt(sizeX), parseInt(sizeZ),
          parseInt(centerX), parseInt(centerY), parseInt(centerZ),
                            outlineColor, parseInt(cellSize), axis.toUpperCase());

  gsObject.isSuperposed = isSuperposed;

  if (slicedGrid){
    gsObject.slicedGrid = slicedGrid;
    slicedGrid.toggleSelect(true, false, false, true);
    slicedGrid.slicedGridSystemName = name;
  }

  rayCaster.refresh();

  return true;
}

// DEPLOYMENT
function startDeployment(){
  appendtoDeploymentConsole("Project name: "+projectName);
  appendtoDeploymentConsole("Author: "+author);
  appendtoDeploymentConsole("");
  appendtoDeploymentConsole("Powered by");
  appendtoDeploymentConsole(BANNERL1);
  appendtoDeploymentConsole(BANNERL2);
  appendtoDeploymentConsole(BANNERL3);
  appendtoDeploymentConsole(BANNERL4);
  appendtoDeploymentConsole(BANNERL5);
  appendtoDeploymentConsole("");
  appendtoDeploymentConsole("by Ouz Erolu - github.com/oguzeroglu");
  appendtoDeploymentConsole("");
  appendtoDeploymentConsole("");
  if (NO_MOBILE && isMobile){
    appendtoDeploymentConsole("[!] This application does not support mobile devices. Please run this with a non mobile device.");
    return;
  }
  $.getJSON("js/application.json").done(function(data){
    appendtoDeploymentConsole("Initializing.");
    var stateLoader = new StateLoader(data);
    var result = stateLoader.load();
    if (result){
      if (stateLoader.hasTextures || stateLoader.hasTexturePacks || stateLoader.hasSkyboxes || stateLoader.hasFonts){
        appendtoDeploymentConsole("Loading assets.");
      }else{
        removeCLIDom();
      }
    }else{
      appendtoDeploymentConsole("[!] Project failed to load: "+stateLoader.reason);
    }
  }).fail(function(jqxhr, textStatus, error){
    appendtoDeploymentConsole("[!] Application cannot be loaded.");
  });
  appendtoDeploymentConsole("Loading application.");
}

function appendtoDeploymentConsole(val){
  cliDiv.value += val + "\n";
}

function removeCLIDom(){
  if (!(typeof cliDiv == UNDEFINED)){
    document.body.removeChild(cliDiv);
  }
}

//******************************************************************
// WARNING: FOR TEST PURPOSES
function generateRandomBoxes(gridSystemName){
  var gridSystem = gridSystems[gridSystemName];
  for (var gridNumber in gridSystem.grids){
    var grid = gridSystem.grids[gridNumber];
    grid.toggleSelect(false, false, false, false);
    var height = Math.random() * 100;
    var name = "randomGeneratedBox_"+gridSystemName+"_"+gridNumber;
    var color = ColorNames.generateRandomColor();
    var material = new BasicMaterial({
      color: color,
      name: "null"
    });
    gridSystem.newBox([grid], height, material, name);
  }
}

// WARNING: FOR TEST PURPOSES
function mergeAllAddedObjects(){
  var objNames = "";
  for (var addedObjectName in addedObjects){
    objNames += addedObjectName + ",";
  }
  objNames = objNames.substring(0, objNames.length - 1);
  parseCommand("glue glue_test_1 "+objNames);
}

// WARNING: FOR TEST PURPOSES
function printParticleSystemPerformances(){
  for (var particleSystemName in particleSystems){
    var particleSystem = particleSystems[particleSystemName];
    var particles = particleSystem.particles;
    var lastParticle = particles[particles.length-1];
    console.log(particleSystemName+": "+lastParticle.performance/1000+" secs.");
  }
}

// WARNING: FOR TEST PURPOSES - WORKS ONLY FOR CANVAS TEXTURES
function debugTexture(textureName){
  var texture = textures[textureName];
  if (!texture){
    texture = textureName;
  }
  var context = texture.image.getContext("2d");
  var newTab = window.open();
  var img = new Image(texture.image.width, texture.image.height);
  img.src = texture.image.toDataURL();
  newTab.document.body.appendChild(img);
}

// WARNING: FOR TEST PURPOSES
function debugCanvas(dbgCanvas){
  var context = dbgCanvas.getContext("2d");
  var newTab = window.open();
  var img = new Image(dbgCanvas.width, dbgCanvas.height);
  img.src = dbgCanvas.toDataURL();
  newTab.document.body.appendChild(img);
}

// WARNING: FOR TEST PURPOSES
function clearChildrenMesh(objectGroup){
  for (var childName in objectGroup.group){
    var child = objectGroup.group[childName];
    child.mesh.geometry.dispose();
    delete child.mesh.geometry;
  }
}

// WARNING: FOR TEST PURPOSES
function drawGridToScreen(widthParts, heightParts){
  var totalParts = (widthParts+1) * (heightParts+1);
  var gridGeom = new THREE.BufferGeometry();
  var positions = [];
  var gridIndices = new Float32Array(totalParts);
  var curX = 1;
  var curY = -1;
  var curIndex = 0;
  for (var i = 0; i<=widthParts; i++){
    for (var i2 = 0; i2<=heightParts; i2++){
      gridIndices[curIndex] = curIndex;
      curIndex ++;
      positions.push(new THREE.Vector2(curX, curY));
      curY += (2 / heightParts);
    }
    curX -= (2 / widthParts);
    curY = -1;
  }
  var indicesBufferAttribute = new THREE.BufferAttribute(gridIndices, 1);
  indicesBufferAttribute.setDynamic(false);
  gridGeom.addAttribute('rectangleIndex', indicesBufferAttribute);
  gridGeom.setDrawRange(0, totalParts);
  var gridMaterial = new THREE.RawShaderMaterial({
    vertexShader: ShaderContent.rectangleVertexShader.replace(
      "uniform vec2 positions[24];", "uniform vec2 positions["+totalParts+"];"
    ).replace(
      "gl_Position = vec4(curPosition.x, curPosition.y, 0.0, 1.0);",
      "gl_Position = vec4(curPosition.x, curPosition.y, 0.0, 1.0); gl_PointSize = 5.0;"
    ),
    fragmentShader: ShaderContent.rectangleFragmentShader,
    transparent: true,
    side: THREE.DoubleSide,
    uniforms: {
      color: new THREE.Uniform(new THREE.Color("lime")),
      alpha: new THREE.Uniform(1.0),
      positions: new THREE.Uniform(positions)
    }
  });
  var gridMesh = new THREE.Points(gridGeom, gridMaterial);
  gridMesh.frustumCulled = false;
  scene.add(gridMesh);
}

var State = function(projectName, author){
  // PROJECT INFOS *************************************************
  if (!(typeof projectName == UNDEFINED)){
    this.projectName = projectName;
  }
  if (!(typeof author == UNDEFINED)){
    this.author = author;
  }
  this.noMobile = NO_MOBILE;
  // DATE **********************************************************
  this.date = new Date();
  // VIEWPORT ******************************************************
  this.viewportMaxWidth = viewportMaxWidth;
  this.viewportMaxHeight = viewportMaxHeight;
  this.fixedAspect = fixedAspect;
  // GRID SYSTEMS **************************************************
  var gridSystemsExport = new Object();
  for (var gridSystemName in gridSystems){
    gridSystemsExport[gridSystemName] = gridSystems[gridSystemName].export();
  }
  this.gridSystems = gridSystemsExport;
  // CROPPED GRID SYSTEM BUFFER ************************************
  if (croppedGridSystemBuffer){
    this.croppedGridSystemBuffer = croppedGridSystemBuffer.export();
  }
  // MATERIALS *****************************************************
  var materialsExport = new Object();
  for (var materialName in materials){
    var curMaterialExport = new Object();
    var curMaterial = materials[materialName];
    var colorHexString = curMaterial.color.toArray();
    var opacity = curMaterial.opacity;
    var aoMapIntensity = curMaterial.aoMapIntensity;
    curMaterialExport["colorHexString"] = colorHexString;
    curMaterialExport["opacity"] = opacity;
    curMaterialExport["aoMapIntensity"] = aoMapIntensity;
    curMaterialExport["textColor"] = curMaterial.textColor;
    if (curMaterial instanceof BasicMaterial){
      curMaterialExport["materialType"] = "BASIC";
    }
    curMaterialExport.roygbivMaterialName = curMaterial.roygbivMaterialName;
    materialsExport[materialName] = curMaterialExport;
  }
  this.materials = materialsExport;
  // DEFAULT MATERIAL **********************************************
  this.defaultMaterialType = defaultMaterialType;
  // ADDED OBJECTS *************************************************
  var addedbObjectsExport = new Object();
  for (var objectName in addedObjects){
    addedbObjectsExport[objectName] = addedObjects[objectName].export();
  }
  this.addedObjects = addedbObjectsExport;
  // UPLOADED IMAGE SIZES ******************************************
  var uploadedImageSizes = new Object();
  for (var uploadedImageName in uploadedImages){
    var img = uploadedImages[uploadedImageName];
    var size = new Object();
    size.width = img.width;
    size.height = img.height;
    uploadedImageSizes[uploadedImageName] = size;
  }
  this.uploadedImageSizes = uploadedImageSizes;
  // TEXTURE SIZES AND PADDING *************************************
  var textureSizes = new Object();
  var texturePaddings = new Object();
  this.totalTextureCount = 0;
  for (var textureName in textures){
    this.totalTextureCount ++;
    if (textures[textureName].image){
      textureSizes[textureName] = new Object();
      textureSizes[textureName].width = textures[textureName].image.width;
      textureSizes[textureName].height = textures[textureName].image.height;
      if (textures[textureName].hasPadding){
        texturePaddings[textureName] = textures[textureName].paddingInfo;
      }
    }
  }
  this.textureSizes = textureSizes;
  this.texturePaddings = texturePaddings;
  // TEXTURES ******************************************************
  this.textures = JSON.parse(JSON.stringify(textures));
  // TEXTURE URLS **************************************************
  this.textureURLs = Object.assign({}, textureURLs);
  // WALL COLLECTIONS **********************************************
  var wallCollectionsExport = new Object();
  for (var wallCollectionName in wallCollections){
    wallCollectionsExport[wallCollectionName] = wallCollections[wallCollectionName].export();
  }
  this.wallCollections = wallCollectionsExport;
  // UPLOADED IMAGES ***********************************************
  var uploadedImagesExport = new Object();
  for (var imageName in uploadedImages){
    uploadedImagesExport[imageName] = uploadedImages[imageName].src;
  }
  this.uploadedImages = uploadedImagesExport;
  // MODIFIED TEXTURES *********************************************
  var modifiedTexturesExport = new Object();
  for (var textureName in modifiedTextures){
    modifiedTexturesExport[textureName] = modifiedTextures[textureName];
  }
  this.modifiedTextures = modifiedTexturesExport;
  // TEXTURE PACKS *************************************************
  var texturePacksExport = new Object();
  this.totalTexturePackCount = 0;
  for (var texturePackName in texturePacks){
    this.totalTexturePackCount ++;
    texturePacksExport[texturePackName] = texturePacks[texturePackName].export();
  }
  this.texturePacks = texturePacksExport;
  // SKYBOXES ******************************************************
  this.mappedSkyboxName = mappedSkyboxName;
  this.skyboxVisible = skyboxVisible;
  var skyBoxExport = new Object();
  this.totalSkyboxCount = 0;
  for (var skyBoxName in skyBoxes){
    this.totalSkyboxCount ++;
    skyBoxExport[skyBoxName] = skyBoxes[skyBoxName].export();
  }
  this.skyBoxes = skyBoxExport;
  if (skyboxMesh){
    this.skyBoxScale = skyboxMesh.scale.x;
  }
  // ANCHOR GRID ***************************************************
  if (anchorGrid){
    this.anchorGrid = anchorGrid.export();
  }else{
    this.anchorGrid = 0;
  }
  // SCRIPTS *******************************************************
  var scriptsExport = new Object();
  for (var scriptName in scripts){
    scriptsExport[scriptName] = scripts[scriptName].export();
  }
  this.scripts = scriptsExport;
  // OBJECT GROUPS *************************************************
  var objectGroupsExport = new Object();
  for (var objectName in objectGroups){
    objectGroupsExport[objectName] = objectGroups[objectName].export();
  }
  this.objectGroups = objectGroupsExport;
  // MARKED POINTS *************************************************
  var markedPointsExport = new Object();
  for (var markedPointName in markedPoints){
    markedPointsExport[markedPointName] = markedPoints[markedPointName].export();
  }
  this.markedPointsExport = markedPointsExport;
  // POST PROCESSING ***********************************************
  this.bloomStrength = bloomStrength;
  this.bloomRadius = bloomRadius;
  this.bloomThreshold = bloomThreshold;
  this.bloomResolutionScale = bloomResolutionScale;
  this.bloomOn = bloomOn;
  // PHYSICS WORKER MODE *******************************************
  this.physicsWorkerMode = PHYSICS_WORKER_ENABLED;
  // PARTICLE COLLISION WORKER MODE ********************************
  this.particleCollisionWorkerMode = COLLISION_WORKER_ENABLED;
  // PARTICLE SYSTME COLLISION WORKER MODE *************************
  this.particleSystemCollisionWorkerMode = PS_COLLISION_WORKER_ENABLED;
  // OCTREE LIMITS *************************************************
  var octreeMinX = LIMIT_BOUNDING_BOX.min.x;
  var octreeMinY = LIMIT_BOUNDING_BOX.min.y;
  var octreeMinZ = LIMIT_BOUNDING_BOX.min.z;
  var octreeMaxX = LIMIT_BOUNDING_BOX.max.x;
  var octreeMaxY = LIMIT_BOUNDING_BOX.max.y;
  var octreeMaxZ = LIMIT_BOUNDING_BOX.max.z;
  this.octreeLimit = octreeMinX+","+octreeMinY+","+octreeMinZ+","+
                     octreeMaxX+","+octreeMaxY+","+octreeMaxZ;
  // BIN SIZE ******************************************************
  this.binSize = BIN_SIZE;
  // FOG ***********************************************************
  this.fogObj = {
    fogActive: fogActive,
    fogColor: fogColor,
    fogDensity: fogDensity,
    blendWithSkybox: fogBlendWithSkybox
  };
  if (fogActive){
    this.fogObj.r = fogColorRGB.r;
    this.fogObj.g = fogColorRGB.g;
    this.fogObj.b = fogColorRGB.b;
  }
  // AREAS *********************************************************
  this.areasVisible = areasVisible;
  this.areas = new Object();
  for (var areaName in areas){
    this.areas[areaName] = areas[areaName].export();
  }
  // RESOLUTION ****************************************************
  this.screenResolution = screenResolution;
  // FONTS *********************************************************
  this.fonts = new Object();
  this.totalFontCount = 0;
  for (var fontName in fonts){
    this.totalFontCount ++;
    this.fonts[fontName] = fonts[fontName].export();
  }
  // TEXTS *********************************************************
  this.texts = new Object();
  for (var textName in addedTexts){
    this.texts[textName] = addedTexts[textName].export();
  }
}

var StateLoader = function(stateObj){
  this.stateObj = stateObj;
  this.reason = "";
  this.totalLoadedTextureCount = 0;
  this.totalLoadedTexturePackCount = 0;
  this.totalLoadedSkyboxCount = 0;
  this.totalLoadedFontCount = 0;
}

StateLoader.prototype.load = function(){
  try{
    projectLoaded = false;
    this.resetProject();
    var obj = this.stateObj;
    // NO MOBILE ***************************************************
    NO_MOBILE = obj.noMobile;
    // VIEWPORT ****************************************************
    if (!(typeof obj.viewportMaxWidth == UNDEFINED)){
      viewportMaxWidth = obj.viewportMaxWidth;
    }
    if (!(typeof obj.viewportMaxHeight == UNDEFINED)){
      viewportMaxHeight = obj.viewportMaxHeight;
    }
    if (!(typeof obj.fixedAspect == UNDEFINED)){
      fixedAspect = obj.fixedAspect;
    }
    // GRID SYSTEMS ************************************************
    var gridSystemsExport = obj.gridSystems;
    for (var gridSystemName in gridSystemsExport){
      var exportObject = gridSystemsExport[gridSystemName];
      var name = exportObject.name;
      var sizeX = exportObject.sizeX;
      var sizeZ = exportObject.sizeZ;
      var centerX = exportObject.centerX;
      var centerY = exportObject.centerY;
      var centerZ = exportObject.centerZ;
      var outlineColor = exportObject.outlineColor;
      var cellSize = exportObject.cellSize;
      var axis = exportObject.axis;
      var isSuperposed = exportObject.isSuperposed;
      var gs = new GridSystem(name, sizeX, sizeZ, centerX, centerY, centerZ,
                                              outlineColor, cellSize, axis);
      var selectedGridsExport = exportObject.selectedGridsExport;
      var slicedGridsExport = exportObject.slicedGridsExport;
      var slicedGridSystemNamesExport = exportObject.slicedGridSystemNamesExport;
      for (var i = 0; i<selectedGridsExport.length; i++){
        var gridNumber = selectedGridsExport[i];
        gs.grids[gridNumber].toggleSelect(false, false, true, false);
      }
      for (var i = 0; i<slicedGridsExport.length; i++){
        var gridNumber = slicedGridsExport[i];
        gs.grids[gridNumber].sliced = true;
        gs.grids[gridNumber].slicedGridSystemName = slicedGridSystemNamesExport[i];
      }
      gs.isSuperposed = isSuperposed;
      gs.markedPointNames = exportObject.markedPointNames;
    }
    for (var gridSystemName in gridSystems){
      var grids = gridSystems[gridSystemName].grids;
      for (var gridNumber in grids){
        var grid = grids[gridNumber];
        if (grid.sliced){
          var slicedGridSystemName = grid.slicedGridSystemName;
          var gridSystem = gridSystems[slicedGridSystemName];
          if (gridSystem){
            gridSystem.slicedGrid = grid;
          }
        }
      }
    }
    // WALL COLLECTIONS ********************************************
    var wallCollectionsExport = obj.wallCollections;
    for (var wallCollectionName in wallCollectionsExport){
      var curWallCollectionExport = wallCollectionsExport[wallCollectionName];
      var name = curWallCollectionExport.name;
      var height = curWallCollectionExport.height;
      var outlineColor = curWallCollectionExport.outlineColor;
      var isSuperposed = curWallCollectionExport.isSuperposed;
      new WallCollection(
        name, height, outlineColor, 0, 0, isSuperposed, true,
        curWallCollectionExport
      );
    }
    // MATERIALS ***************************************************
    var materialsExport = obj.materials;
    for (var materialName in materialsExport){
      var material;
      var curMaterialExport = materialsExport[materialName];
      var color = curMaterialExport.textColor;
      var opacity = curMaterialExport.opacity;
      var aoMapIntensity = curMaterialExport.aoMapIntensity;
      if (curMaterialExport.materialType == "BASIC"){
        material = new BasicMaterial(
          {
            name: curMaterialExport.roygbivMaterialName,
            color: color,
            alpha: opacity,
            aoMapIntensity: aoMapIntensity
          }
        );
      }
      material.roygbivMaterialName = curMaterialExport.roygbivMaterialName;
      material.textColor = color;
      materials[materialName] = material;
    }
    // DEFAULT MATERIAL ********************************************
    defaultMaterialType = obj.defaultMaterialType;
    // ADDED OBJECTS ***********************************************
    var addedObjectsExport = obj.addedObjects;
    for (var grouppedObjectName in obj.objectGroups){
      var curObjectGroupExport = obj.objectGroups[grouppedObjectName];
      var curGroup = curObjectGroupExport.group;
      for (var objectName in curGroup){
        addedObjectsExport[objectName] = curGroup[objectName];
        addedObjectsExport[objectName].fromObjectGroup = true;
      }
    }
    for (var addedObjectName in addedObjectsExport){
      var curAddedObjectExport = addedObjectsExport[addedObjectName];
      var type = curAddedObjectExport.type;
      var roygbivMaterialName = curAddedObjectExport.roygbivMaterialName;
      var destroyedGrids = new Object();
      var destroyedGridsExport = curAddedObjectExport.destroyedGrids;
      var metaData = curAddedObjectExport.metaData;
      var mass = 0;
      if (curAddedObjectExport.mass){
        mass = curAddedObjectExport.mass;
      }
      var isDynamicObject = false;
      if (curAddedObjectExport.isDynamicObject){
        isDynamicObject = curAddedObjectExport.isDynamicObject;
      }
      var gridSystemName = metaData["gridSystemName"];
      var gridSystem = gridSystems[gridSystemName];
      if (gridSystem){
        for (var gridName in destroyedGridsExport){
          var gridExport = destroyedGridsExport[gridName];
          var grid = gridSystem.getGridByColRow(
            gridExport.colNumber,
            gridExport.rowNumber
          );
          if (grid){
            destroyedGrids[gridName] = grid;
          }
        }
      }
      var material = materials[roygbivMaterialName];
      if (!material){
        if (roygbivMaterialName == "NULL_BASIC"){
          material = new BasicMaterial({
            name: roygbivMaterialName,
            color: "white",
            alpha: curAddedObjectExport.opacity,
            aoMapIntensity: curAddedObjectExport.aoMapIntensity,
            emissiveIntensity: curAddedObjectExport.emissiveIntensity,
            emissiveColor: curAddedObjectExport.emissiveColor
          });
        }
      }

      var widthSegments = metaData["widthSegments"];
      var heightSegments = metaData["heightSegments"];
      var depthSegments = metaData["depthSegments"];
      if (!widthSegments){
        widthSegments = 1;
        if (type == "cylinder"){
          widthSegments = 8;
        }else if (type == "sphere"){
          widthSegments = 8;
        }
      }
      if (!heightSegments){
        heightSegments = 1;
        if (type == "sphere"){
          widthSegments = 6;
        }
      }
      if (!depthSegments){
        depthSegments = 1;
      }
      var addedObjectInstance;
      if (type == "box"){
        var boxSizeX = metaData["boxSizeX"];
        var boxSizeY = metaData["boxSizeY"];
        var boxSizeZ = metaData["boxSizeZ"];
        var centerX = metaData["centerX"];
        var centerY = metaData["centerY"];
        var centerZ = metaData["centerZ"];
        var boxPhysicsShape;
        var physicsShapeKey = "BOX" + PIPE + (boxSizeX / 2) + PIPE +
                                             (boxSizeY / 2) + PIPE +
                                             (boxSizeZ / 2);
        boxPhysicsShape = physicsShapeCache[physicsShapeKey];
        if (!boxPhysicsShape){
          boxPhysicsShape = new CANNON.Box(new CANNON.Vec3(
            boxSizeX / 2,
            boxSizeY / 2,
            boxSizeZ / 2
          ));
          physicsShapeCache[physicsShapeKey] = boxPhysicsShape;
        }
        var physicsMaterial = new CANNON.Material();
        var boxPhysicsBody = new CANNON.Body({
          mass: mass,
          shape: boxPhysicsShape,
          material: physicsMaterial
        });
        var boxMesh;
        var boxClone;
        var axis = metaData["gridSystemAxis"];
        var geomKey = (
          "BoxBufferGeometry" + PIPE +
          boxSizeX + PIPE + boxSizeY + PIPE + boxSizeZ + PIPE +
          widthSegments + PIPE + heightSegments + PIPE + depthSegments
        );
        var geom = geometryCache[geomKey];
        if (!geom){
          geom = new THREE.BoxBufferGeometry(
            boxSizeX, boxSizeY, boxSizeZ,
            widthSegments, heightSegments, depthSegments
          );
          geometryCache[geomKey] = geom;
        }
        boxMesh = new MeshGenerator(geom, material).generateMesh();
        boxMesh.position.x = centerX;
        boxMesh.position.y = centerY;
        boxMesh.position.z = centerZ;
        scene.add(boxMesh);
        boxPhysicsBody.position.set(
          boxMesh.position.x,
          boxMesh.position.y,
          boxMesh.position.z
        );
        physicsWorld.add(boxPhysicsBody);
        addedObjectInstance = new AddedObject(
          addedObjectName, "box", metaData, material,
          boxMesh, boxPhysicsBody, destroyedGrids
        );
        boxMesh.addedObject = addedObjectInstance;
      }else if (type == "surface"){
        var width = metaData["width"];
        var height = metaData["height"];
        var positionX = metaData["positionX"];
        var positionY = metaData["positionY"];
        var positionZ = metaData["positionZ"];
        var quaternionX = metaData["quaternionX"];
        var quaternionY = metaData["quaternionY"];
        var quaternionZ = metaData["quaternionZ"];
        var quaternionW = metaData["quaternionW"];
        var physicsShapeParameterX = metaData["physicsShapeParameterX"];
        var physicsShapeParameterY = metaData["physicsShapeParameterY"];
        var physicsShapeParameterZ = metaData["physicsShapeParameterZ"];

        var geomKey = (
          "PlaneBufferGeometry" + PIPE +
          width + PIPE + height + PIPE +
          widthSegments + PIPE + heightSegments
        );
        var geom = geometryCache[geomKey];
        if (!geom){
          geom = new THREE.PlaneBufferGeometry(width, height, widthSegments, heightSegments);
          geometryCache[geomKey] = geom;
        }
        var surface = new MeshGenerator(geom, material).generateMesh();

        surface.position.x = positionX;
        surface.position.y = positionY;
        surface.position.z = positionZ;
        surface.quaternion.x = quaternionX;
        surface.quaternion.y = quaternionY;
        surface.quaternion.z = quaternionZ;
        surface.quaternion.w = quaternionW;

        scene.add(surface);

        var surfacePhysicsShape;
        var physicsShapeKey = "BOX" + PIPE + physicsShapeParameterX + PIPE +
                                             physicsShapeParameterY+ PIPE +
                                             physicsShapeParameterZ;
        surfacePhysicsShape = physicsShapeCache[physicsShapeKey];
        if (!surfacePhysicsShape){
          surfacePhysicsShape = new CANNON.Box(new CANNON.Vec3(
              physicsShapeParameterX,
              physicsShapeParameterY,
              physicsShapeParameterZ
          ));
          physicsShapeCache[physicsShapeKey] = surfacePhysicsShape;
        }

        var physicsMaterial = new CANNON.Material();
        var surfacePhysicsBody = new CANNON.Body({
          mass: mass,
          shape: surfacePhysicsShape,
          material: physicsMaterial
        });
        surfacePhysicsBody.position.set(
          positionX,
          positionY,
          positionZ
        );
        physicsWorld.add(surfacePhysicsBody);
        addedObjectInstance = new AddedObject(addedObjectName, "surface", metaData, material,
                                    surface, surfacePhysicsBody, destroyedGrids);
        surface.addedObject = addedObjectInstance;
      }else if (type == "ramp"){
        var rampHeight = metaData["rampHeight"];
        var rampWidth = metaData["rampWidth"];
        var quaternionX = metaData["quaternionX"];
        var quaternionY = metaData["quaternionY"];
        var quaternionZ = metaData["quaternionZ"];
        var quaternionW = metaData["quaternionW"];
        var centerX = metaData["centerX"];
        var centerY = metaData["centerY"];
        var centerZ = metaData["centerZ"];
        var fromEulerX = metaData["fromEulerX"];
        var fromEulerY = metaData["fromEulerY"];
        var fromEulerZ = metaData["fromEulerZ"];

        var geomKey = (
          "PlaneBufferGeometry" + PIPE +
          rampWidth + PIPE + rampHeight + PIPE +
          widthSegments + PIPE + heightSegments
        );
        var geom = geometryCache[geomKey];
        if (!geom){
          geom = new THREE.PlaneBufferGeometry(rampWidth, rampHeight, widthSegments, heightSegments);
          geometryCache[geomKey] = geom;
        }
        var ramp = new MeshGenerator(geom, material).generateMesh();
        ramp.position.x = centerX;
        ramp.position.y = centerY;
        ramp.position.z = centerZ;
        ramp.quaternion.x = quaternionX;
        ramp.quaternion.y = quaternionY;
        ramp.quaternion.z = quaternionZ;
        ramp.quaternion.w = quaternionW;

        var rampPhysicsShape;
        var physicsShapeKey = "BOX" + PIPE + (rampWidth / 2) + PIPE +
                                             (surfacePhysicalThickness) + PIPE +
                                             (rampHeight / 2);
        rampPhysicsShape = physicsShapeCache[physicsShapeKey];
        if (!rampPhysicsShape){
          rampPhysicsShape = new CANNON.Box(new CANNON.Vec3(
            rampWidth/2,
            surfacePhysicalThickness,
            rampHeight/2
          ));
          physicsShapeCache[physicsShapeKey] = rampPhysicsShape;
        }

        var physicsMaterial = new CANNON.Material();
        var rampPhysicsBody = new CANNON.Body({
          mass: mass,
          shape: rampPhysicsShape,
          material: physicsMaterial
        });
        rampPhysicsBody.position.set(
          ramp.position.x,
          ramp.position.y,
          ramp.position.z
        );
        if (!isNaN(fromEulerX) && !isNaN(fromEulerY) && !isNaN(fromEulerZ)){
          rampPhysicsBody.quaternion.setFromEuler(
            fromEulerX,
            fromEulerY,
            fromEulerZ
          );
        }
        scene.add(ramp);
        physicsWorld.add(rampPhysicsBody);
        addedObjectInstance = new AddedObject(
          addedObjectName, "ramp", metaData, material, ramp,
          rampPhysicsBody, new Object()
        );
        ramp.addedObject = addedObjectInstance;
      }else if (type == "sphere"){
        var radius = metaData["radius"];
        var centerX = metaData["centerX"];
        var centerY = metaData["centerY"];
        var centerZ = metaData["centerZ"];
        var spherePhysicsShape;
        var physicsShapeKey = "SPHERE" + PIPE + radius;
        spherePhysicsShape = physicsShapeCache[physicsShapeKey];
        if (!spherePhysicsShape){
          spherePhysicsShape = new CANNON.Sphere(Math.abs(radius));
          physicsShapeCache[physicsShapeKey] = spherePhysicsShape;
        }
        var physicsMaterial = new CANNON.Material();
        var spherePhysicsBody = new CANNON.Body({
          mass: mass,
          shape: spherePhysicsShape,
          material: physicsMaterial
        });
        var sphereMesh;
        var sphereClone;
        var axis = metaData["gridSystemAxis"];
        var geomKey = (
          "SphereBufferGeometry" + PIPE +
          Math.abs(radius) + PIPE +
          widthSegments + PIPE + heightSegments
        );
        var geom = geometryCache[geomKey];
        if (!geom){
          geom = new THREE.SphereBufferGeometry(Math.abs(radius), widthSegments, heightSegments);
          geometryCache[geomKey] = geom;
        }
        sphereMesh = new MeshGenerator(geom, material).generateMesh();
        sphereMesh.position.x = centerX;
        sphereMesh.position.y = centerY;
        sphereMesh.position.z = centerZ;
        scene.add(sphereMesh);
        spherePhysicsBody.position.set(
          sphereMesh.position.x,
          sphereMesh.position.y,
          sphereMesh.position.z
        );
        physicsWorld.add(spherePhysicsBody);
        addedObjectInstance = new AddedObject(
          addedObjectName, "sphere", metaData, material,
          sphereMesh, spherePhysicsBody, destroyedGrids
        );
        sphereMesh.addedObject = addedObjectInstance;
      }else if (type == "cylinder"){
        var cylinderHeight = metaData["height"];
        var topRadius = metaData["topRadius"];
        var bottomRadius = metaData["bottomRadius"];
        var isOpenEnded = metaData["isOpenEnded"];
        var geomKey = "CylinderBufferGeometry" + PIPE + cylinderHeight + PIPE + topRadius + PIPE +
                      bottomRadius + PIPE + widthSegments + PIPE + heightSegments + PIPE + isOpenEnded;
        var cylinderGeometry = geometryCache[geomKey];
        if (!cylinderGeometry){
          cylinderGeometry = new THREE.CylinderBufferGeometry(
            topRadius, bottomRadius, cylinderHeight, widthSegments, heightSegments, isOpenEnded
          );
          geometryCache[geomKey] = cylinderGeometry;
        }
        var cylinderMesh = new MeshGenerator(cylinderGeometry, material).generateMesh();
        var centerX = metaData["centerX"];
        var centerY = metaData["centerY"];
        var centerZ = metaData["centerZ"];
        cylinderMesh.position.set(centerX, centerY, centerZ);
        scene.add(cylinderMesh);
        var physicsMaterial = new CANNON.Material();
        var cylinderPhysicsShape;
        var physicsShapeKey = "CYLINDER" + PIPE + topRadius + PIPE + bottomRadius + PIPE +
                                                  Math.abs(cylinderHeight) + PIPE + widthSegments + PIPE +
                                                  metaData.gridSystemAxis;
        var cached = false;
        cylinderPhysicsShape = physicsShapeCache[physicsShapeKey];
        if (!cylinderPhysicsShape){
          cylinderPhysicsShape = new CANNON.Cylinder(topRadius, bottomRadius, Math.abs(cylinderHeight), widthSegments);
          physicsShapeCache[physicsShapeKey] = cylinderPhysicsShape;
        }else{
          cached = true;
        }
        if (metaData.gridSystemAxis == "XZ"){
          if (!cached){
            var quat = new CANNON.Quaternion();
            var coef = 1;
            if (height < 0){
              coef = -1;
            }
            quat.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI/2 * coef);
            var translation = new CANNON.Vec3(0, 0, 0);
            cylinderPhysicsShape.transformAllPoints(translation,quat);
          }
        }else if (metaData.gridSystemAxis == "XY"){
          cylinderMesh.rotateX(Math.PI/2);
          if (!cached){
            if (height < 0){
              var quat = new CANNON.Quaternion();
              quat.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), -Math.PI);
              var translation = new CANNON.Vec3(0, 0, 0);
              cylinderPhysicsShape.transformAllPoints(translation,quat);
            }
          }
        }else if (metaData.gridSystemAxis == "YZ"){
          cylinderMesh.rotateZ(-Math.PI/2);
          if (!cached){
            var quat = new CANNON.Quaternion();
            var coef = 1;
            if (height < 0){
              coef = -1;
            }
            quat.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), coef * Math.PI/2);
            var translation = new CANNON.Vec3(0, 0, 0);
            cylinderPhysicsShape.transformAllPoints(translation,quat);
          }
        }
        var cylinderPhysicsBody = new CANNON.Body({
          mass: mass,
          shape: cylinderPhysicsShape,
          material: physicsMaterial
        });
        cylinderPhysicsBody.position.set(centerX, centerY, centerZ);
        physicsWorld.add(cylinderPhysicsBody);
        addedObjectInstance = new AddedObject(
          addedObjectName, "cylinder", metaData, material,
          cylinderMesh, cylinderPhysicsBody, destroyedGrids
        );
        cylinderMesh.addedObject = addedObjectInstance;
      }
      addedObjectInstance.associatedTexturePack = curAddedObjectExport.associatedTexturePack;
      addedObjectInstance.metaData["widthSegments"] = widthSegments;
      addedObjectInstance.metaData["heightSegments"] = heightSegments;
      addedObjectInstance.metaData["depthSegments"] = depthSegments;
      addedObjectInstance.isDynamicObject = isDynamicObject;
      addedObjectInstance.mass = mass;

      addedObjectInstance.metaData["textureRepeatU"] = curAddedObjectExport.textureRepeatU;
      addedObjectInstance.metaData["textureRepeatV"] = curAddedObjectExport.textureRepeatV;

      if (!curAddedObjectExport.fromObjectGroup){

        var rotationX = curAddedObjectExport.rotationX;
        var rotationY = curAddedObjectExport.rotationY;
        var rotationZ = curAddedObjectExport.rotationZ;
        addedObjectInstance.rotationX = rotationX;
        addedObjectInstance.rotationY = rotationY;
        addedObjectInstance.rotationZ = rotationZ;
        addedObjectInstance.mesh.quaternion.set(
          curAddedObjectExport.quaternionX,
          curAddedObjectExport.quaternionY,
          curAddedObjectExport.quaternionZ,
          curAddedObjectExport.quaternionW
        );
        addedObjectInstance.physicsBody.quaternion.set(
          curAddedObjectExport.pQuaternionX,
          curAddedObjectExport.pQuaternionY,
          curAddedObjectExport.pQuaternionZ,
          curAddedObjectExport.pQuaternionW
        );
        addedObjectInstance.initQuaternion.copy(addedObjectInstance.mesh.quaternion);
        addedObjectInstance.physicsBody.initQuaternion.copy(addedObjectInstance.physicsBody.quaternion);
      }else{
        addedObjectInstance.mesh.quaternion.set(
          curAddedObjectExport.quaternionX,
          curAddedObjectExport.quaternionY,
          curAddedObjectExport.quaternionZ,
          curAddedObjectExport.quaternionW
        );
        addedObjectInstance.physicsBody.quaternion.set(
          curAddedObjectExport.pQuaternionX,
          curAddedObjectExport.pQuaternionY,
          curAddedObjectExport.pQuaternionZ,
          curAddedObjectExport.pQuaternionW
        );
      }

      if (curAddedObjectExport.blendingMode == "NO_BLENDING"){
        addedObjectInstance.setBlending(NO_BLENDING);
      }else if (curAddedObjectExport.blendingMode == "ADDITIVE_BLENDING"){
        addedObjectInstance.setBlending(ADDITIVE_BLENDING);
      }else if (curAddedObjectExport.blendingMode == "SUBTRACTIVE_BLENDING"){
        addedObjectInstance.setBlending(SUBTRACTIVE_BLENDING);
      }else if (curAddedObjectExport.blendingMode == "MULTIPLY_BLENDING"){
        addedObjectInstance.setBlending(MULTIPLY_BLENDING);
      }else if (curAddedObjectExport.blending == "NORMAL_BLENDING"){
        addedObjectInstance.setBlending(NORMAL_BLENDING);
      }

      if (curAddedObjectExport.isSlippery){
        addedObjectInstance.setSlippery(true);
      }

      addedObjectInstance.isChangeable = curAddedObjectExport.isChangeable;
      addedObjectInstance.isColorizable = curAddedObjectExport.isColorizable;
      if (addedObjectInstance.isColorizable){
        addedObjectInstance.injectMacro("HAS_FORCED_COLOR", false, true);
        addedObjectInstance.mesh.material.uniforms.forcedColor = new THREE.Uniform(new THREE.Vector4(-50, 0, 0, 0));
      }

      if (curAddedObjectExport.noMass){
        addedObjectInstance.noMass = true;
        physicsWorld.remove(addedObjectInstance.physicsBody);
      }

      if (curAddedObjectExport.softCopyParentName){
        addedObjectInstance.softCopyParentName = curAddedObjectExport.softCopyParentName;
      }

      addedObjectInstance.mesh.material.setEmissiveIntensity = curAddedObjectExport.emissiveIntensity;
      addedObjectInstance.mesh.material.setEmissiveColor = curAddedObjectExport.emissiveColor;
      addedObjectInstance.mesh.material.uniforms.setAOIntensity = curAddedObjectExport.aoMapIntensity;

      addedObjects[addedObjectName] = addedObjectInstance;

      addedObjectInstance.rotationX = curAddedObjectExport.rotationX;
      addedObjectInstance.rotationY = curAddedObjectExport.rotationY;
      addedObjectInstance.rotationZ = curAddedObjectExport.rotationZ;

       if (!(typeof addedObjectInstance.metaData.slicedType == UNDEFINED)){
         addedObjectInstance.sliceInHalf(addedObjectInstance.metaData.slicedType);
       }
       if (addedObjectInstance.metaData.renderSide){
         addedObjectInstance.handleRenderSide(addedObjectInstance.metaData.renderSide);
       }

       addedObjectInstance.areaVisibilityConfigurations = curAddedObjectExport.areaVisibilityConfigurations;
       addedObjectInstance.areaSideConfigurations = curAddedObjectExport.areaSideConfigurations;

       if (curAddedObjectExport.hasPivot){
         var pivot = addedObjectInstance.makePivot(
           curAddedObjectExport.pivotOffsetX,
           curAddedObjectExport.pivotOffsetY,
           curAddedObjectExport.pivotOffsetZ
         );
         pivot.quaternion.set(
           curAddedObjectExport.pivotQX, curAddedObjectExport.pivotQY,
           curAddedObjectExport.pivotQZ, curAddedObjectExport.pivotQW
         );
         pivot.children[0].quaternion.set(
           curAddedObjectExport.insidePivotQX, curAddedObjectExport.insidePivotQY,
           curAddedObjectExport.insidePivotQZ, curAddedObjectExport.insidePivotQW
         );
         addedObjectInstance.pivotObject = pivot;
         addedObjectInstance.pivotOffsetX = curAddedObjectExport.pivotOffsetX;
         addedObjectInstance.pivotOffsetY = curAddedObjectExport.pivotOffsetY;
         addedObjectInstance.pivotOffsetZ = curAddedObjectExport.pivotOffsetZ;
         addedObjectInstance.mesh.position.set(
           curAddedObjectExport.positionX, curAddedObjectExport.positionY, curAddedObjectExport.positionZ
         );
         addedObjectInstance.physicsBody.position.copy(addedObjectInstance.mesh.position);
       }else if (curAddedObjectExport.pivotRemoved){
         addedObjectInstance.mesh.position.set(
           curAddedObjectExport.positionX, curAddedObjectExport.positionY, curAddedObjectExport.positionZ
         );
         addedObjectInstance.physicsBody.position.copy(addedObjectInstance.mesh.position);
         addedObjectInstance.pivotRemoved = true;
       }

       if (curAddedObjectExport.txtMatrix){
         addedObjectInstance.setTxtMatrix = curAddedObjectExport.txtMatrix;
       }

    }
    for (var objName in addedObjects){
      if (addedObjects[objName].softCopyParentName){
        var softCopyParent = addedObjects[addedObjects[objName].softCopyParentName];
        if (softCopyParent){
          addedObjects[objName].mesh.material = softCopyParent.mesh.material;
        }else{
          for (var objName2 in addedObjects){
            if (objName2 != objName){
              if (addedObjects[objName2].softCopyParentName &&
                addedObjects[objName2].softCopyParentName == addedObjects[objName].softCopyParentName){
                addedObjects[objName].mesh.material = addedObjects[objName2].mesh.material;
              }
            }
          }
        }
      }
    }
    // TEXTURE URLS ************************************************
    textureURLs = Object.assign({}, obj.textureURLs);
    // UPLOADED IMAGES *********************************************
    var uploadedImagesExport = obj.uploadedImages;
    for (var imgName in uploadedImagesExport){
      var src = uploadedImagesExport[imgName];
      var imageDom = document.createElement("img");
      imageDom.src = src;
      if (obj.uploadedImageSizes && obj.uploadedImageSizes[imgName]){
        imageDom.width = obj.uploadedImageSizes[imgName].width;
        imageDom.height = obj.uploadedImageSizes[imgName].height;
      }
      uploadedImages[imgName] = imageDom;
    }
    // TEXTURES ****************************************************
    this.loaders = new Object();
    var uploadedTextures = obj.textures;
    for (var textureName in uploadedTextures){
      var curTexture = uploadedTextures[textureName];
      if (curTexture == 1 || curTexture == 2 || curTexture == 3){
        textures[textureName] = curTexture;
        this.totalLoadedTextureCount ++;
        this.finalize();
        continue;
      }
      var offsetX = curTexture.offset[0];
      var offsetY = curTexture.offset[1];
      var repeatU = curTexture.repeat[0];
      var repeatV = curTexture.repeat[1];
      var textureURL = textureURLs[textureName];
      if (obj.modifiedTextures[textureName]){
        var img = new Image();
        img.src = obj.modifiedTextures[textureName];
        var texture = new THREE.Texture(img);
        texture.needsUpdate = true;
        texture.repeat.set(repeatU, repeatV);
        texture.offset.x = offsetX;
        texture.offset.y = offsetY;
        texture.isLoaded = true;
        modifiedTextures[textureName] = obj.modifiedTextures[textureName];
        var that = this;
        texture.image.onload = function(){
          textures[this.textureNameX] = this.textureX;
          that.totalLoadedTextureCount ++;
          this.textureX.needsUpdate = true;
          that.mapLoadedTexture(this.textureX, this.textureNameX);
          that.finalize();
        }.bind({textureX: texture, textureNameX: textureName});
      }else if (uploadedImages[textureURL]){
        var texture = new THREE.Texture(uploadedImages[textureURL]);
        texture.repeat.set(repeatU, repeatV);
        texture.offset.x = offsetX;
        texture.offset.y = offsetY;
        texture.isLoaded = true;
        texture.fromUploadedImage = true;
        var skip = false;
        if (texture.image.width && texture.image.height){
          if (obj.textureSizes && obj.textureSizes[textureName]){
            var imgW = texture.image.width;
            var imgH = texture.image.height;
            var newW = obj.textureSizes[textureName].width;
            var newH = obj.textureSizes[textureName].height;
            if (imgW != newW || imgH != newH){
              var that = this;
              texture.image.onload = function(){
                var imgW = this.textureX.image.width;
                var imgH = this.textureX.image.height;
                var newW = obj.textureSizes[this.textureNameX].width;
                var newH = obj.textureSizes[this.textureNameX].height;
                var tmpCanvas = document.createElement("canvas");
                tmpCanvas.width = newW;
                tmpCanvas.height = newH;
                tmpCanvas.getContext("2d").drawImage(this.textureX.image, 0, 0, imgW, imgH, 0, 0, newW, newH);
                this.textureX.image = tmpCanvas;
                this.textureX.needsUpdate = true;
                textures[this.textureNameX] = this.textureX;
                that.totalLoadedTextureCount ++;
                that.mapLoadedTexture(this.textureX, this.textureNameX);
                that.finalize();
              }.bind({textureX: texture, textureNameX: textureName})
              skip = true;
            }
          }
        }
        if (!skip){
          textures[textureName] = texture;
          that.totalLoadedTextureCount ++;
          texture.needsUpdate = true;
          this.mapLoadedTexture(texture, textureName);
          this.finalize();
        }
      }else{
        if (textureURL.toUpperCase().endsWith("DDS")){
          if (!DDS_SUPPORTED){
            textureURL = textureURL.replace(
              ".dds", compressedTextureFallbackFormat
            ).replace(
              ".DDS", compressedTextureFallbackFormat
            );
            this.loaders[textureName] = textureLoader;
          }else{
            this.loaders[textureName] = ddsLoader;
          }
        }else if (textureURL.toUpperCase().endsWith("TGA")){
          this.loaders[textureName] = tgaLoader;
        }else{
          this.loaders[textureName] = textureLoader;
        }
        textures[textureName] = 1;
        var that = this;
        this.loaders[textureName].load(textureURL,
          function(textureData){
            var textureNameX = this.textureNameX;
            textures[textureNameX] = textureData;
            that.totalLoadedTextureCount ++;
            var hasPadding = (obj.texturePaddings[textureNameX] !== undefined);
            if (obj.textureSizes && obj.textureSizes[textureNameX]){
              var size = obj.textureSizes[textureNameX];
              if (!this.isCompressed){
                if (size.width != textureData.image.width || size.height != textureData.image.height){
                  var tmpCanvas = document.createElement("canvas");
                  tmpCanvas.width = size.width;
                  tmpCanvas.height = size.height;
                  tmpCanvas.getContext("2d").drawImage(textureData.image, 0, 0, textureData.image.width, textureData.image.height, 0, 0, size.width, size.height);
                  textureData.image = tmpCanvas;
                  textureData.needsUpdate = true;
                }
              }
            }
            textures[textureNameX].needsUpdate = true;
            textures[textureNameX].isLoaded = true;
            textures[textureNameX].repeat.set(this.repeatUU, this.repeatVV);
            textures[textureNameX].offset.x = this.offsetXX;
            textures[textureNameX].offset.y = this.offsetYY;
            that.mapLoadedTexture(textures[textureNameX], textureNameX);
            that.finalize();
          }.bind({textureNameX: textureName, offsetXX: offsetX, offsetYY: offsetY, repeatUU: repeatU, repeatVV: repeatV, isCompressed: (
            this.loaders[textureName] instanceof THREE.DDSLoader
          )}), function(xhr){
            textures[this.textureNameX] = 2;
          }.bind({textureNameX: textureName}), function(xhr){
            textures[this.textureNameX] = 3;
            that.totalLoadedTextureCount ++;
            that.finalize();
          }.bind({textureNameX: textureName})
        );
      }
      this.hasTextures = true;
    }
    // TEXTURE PACKS ***********************************************
    var texturePacksExport = obj.texturePacks;
    for (var texturePackName in texturePacksExport){
      var curTexturePackExport = texturePacksExport[texturePackName];
      var scaleFactor = curTexturePackExport.scaleFactor;
      var refTexturePackName = curTexturePackExport.refTexturePackName;
      var texturePack = new TexturePack(
        texturePackName,
        curTexturePackExport.directoryName,
        curTexturePackExport.fileExtension,
        function(){
          this.that.totalLoadedTexturePackCount ++;
          this.that.mapLoadedTexturePack(this.texturePackName, this.objj);
          this.that.finalize();
        }.bind({texturePackName: texturePackName, that: this, objj: obj, scaleFactorX: scaleFactor}),
        true,
        null,
        scaleFactor,
        refTexturePackName
      );
      texturePacks[texturePackName] = texturePack;
      this.hasTexturePacks = true;
    }
    // SKYBOXES ****************************************************
    var skyBoxScale = obj.skyBoxScale;
    var skyboxExports = obj.skyBoxes;
    skyboxVisible = obj.skyboxVisible;
    mappedSkyboxName = obj.mappedSkyboxName;
    var that = this;
    for (var skyboxName in skyboxExports){
      this.hasSkyboxes = true;
      var skyboxExport = skyboxExports[skyboxName];
      var skybox;
      if (!mappedSkyboxName){
        skybox = new SkyBox(
          skyboxExport.name,
          skyboxExport.directoryName,
          skyboxExport.fileExtension,
          skyboxExport.alpha,
          skyboxExport.color,
          function(){
            that.totalLoadedSkyboxCount ++;
            that.finalize();
          }
        );
      }else{
        skybox = new SkyBox(
          skyboxExport.name,
          skyboxExport.directoryName,
          skyboxExport.fileExtension,
          skyboxExport.alpha,
          skyboxExport.color,
          function(){
            that.totalLoadedSkyboxCount ++;
            if (this.skyboxName == mappedSkyboxName){
              var skybox = skyBoxes[this.skyboxName];
              if (skyboxMesh){
                scene.remove(skyboxMesh);
              }else{
                var geomKey = (
                  "BoxBufferGeometry" + PIPE +
                  skyboxDistance + PIPE + skyboxDistance + PIPE + skyboxDistance + PIPE +
                  "1" + PIPE + "1" + PIPE + "1"
                );
                var skyboxBufferGeometry = geometryCache[geomKey];
                if (!skyboxBufferGeometry){
                  skyboxBufferGeometry = new THREE.BoxBufferGeometry(skyboxDistance, skyboxDistance, skyboxDistance);
                  geometryCache[geomKey] = skyboxBufferGeometry;
                }
                skyboxMesh = new MeshGenerator(skyboxBufferGeometry, null).generateSkybox(skybox);
                skyboxMesh.renderOrder = -1;
              }
              if (skyboxVisible){
                scene.add(skyboxMesh);
              }
              if (this.skyBoxScale){
                skyboxMesh.scale.x = this.skyBoxScale;
                skyboxMesh.scale.y = this.skyBoxScale;
                skyboxMesh.scale.z = this.skyBoxScale;
              }
            }
            that.finalize();
          }.bind({skyboxName: skyboxName, skyBoxScale: skyBoxScale})
        );
      }
      skyBoxes[skyboxName] = skybox;
    }
    // ANCHOR GRID *************************************************
    anchorGrid = 0;
    var anchorGridExport = obj.anchorGrid;
    if (anchorGridExport){
      var parentName = anchorGridExport.parentName;
      var gridSystem = gridSystems[parentName];
      if (gridSystem){
        for (var gridNumber in gridSystem.grids){
          var grid = gridSystem.grids[gridNumber];
          if (grid.startX == anchorGridExport.startX && grid.startY == anchorGridExport.startY && grid.startZ == anchorGridExport.startZ){
            anchorGrid = grid;
            break;
          }
        }
      }
    }
    // CROPPED GRID SYSTEM BUFFER **********************************
    if (obj.croppedGridSystemBuffer){
      croppedGridSystemBuffer = new CroppedGridSystem(
        obj.croppedGridSystemBuffer.sizeX,
        obj.croppedGridSystemBuffer.sizeZ,
        obj.croppedGridSystemBuffer.centerX,
        obj.croppedGridSystemBuffer.centerY,
        obj.croppedGridSystemBuffer.centerZ,
        obj.croppedGridSystemBuffer.axis
      )
    }
    // SCRIPTS *****************************************************
    for (var scriptName in obj.scripts){
      var curScriptExport = obj.scripts[scriptName];
      scripts[scriptName] = new Script(
        curScriptExport.name, curScriptExport.script
      );
      if (curScriptExport.runAutomatically){
        scripts[scriptName].runAutomatically = true;
      }else{
        scripts[scriptName].runAutomatically = false;
      }
      if (curScriptExport.localFilePath && !isDeployment){
        modeSwitcher.totalScriptsToLoad ++;
        scripts[scriptName].localFilePath = curScriptExport.localFilePath;
      }
    }

    // OBJECT GROUPS ***********************************************
    // NOT HERE -> SEE: finalize

    // MARKED PONTS ************************************************
    markedPointsVisible = false;
    for (var markedPointName in obj.markedPointsExport){
      var curMarkedPointExport = obj.markedPointsExport[markedPointName];
      var markedPoint = new MarkedPoint(
        markedPointName,
        curMarkedPointExport["x"],
        curMarkedPointExport["y"],
        curMarkedPointExport["z"],
        curMarkedPointExport["fromX"],
        curMarkedPointExport["fromY"],
        curMarkedPointExport["fromZ"],
        curMarkedPointExport["gridDestroyed"]
      );
      if (!curMarkedPointExport.isHidden && mode == 0){
        markedPointsVisible = true;
      }else{
        markedPoint.hide();
      }
      markedPoint.showAgainOnTheNextModeSwitch = curMarkedPointExport.showAgainOnTheNextModeSwitch;
      if (mode == 0){
        markedPoint.showAgainOnTheNextModeSwitch = false;
      }
      markedPoints[markedPointName] = markedPoint;
    }
    // PHYSICS WORKER MODE *****************************************
    PHYSICS_WORKER_ENABLED = obj.physicsWorkerMode;
    // PARTICLE COLLISION WORKER MODE ******************************
    COLLISION_WORKER_ENABLED = obj.particleCollisionWorkerMode;
    // PARTICLE SYSTEM COLLISION WORKER MODE ***********************
    PS_COLLISION_WORKER_ENABLED = obj.particleSystemCollisionWorkerMode;
    // OCTREE LIMIT ************************************************
    var octreeLimitInfo = obj.octreeLimit
    var octreeLimitInfoSplitted = octreeLimitInfo.split(",");
    for (var i = 0; i<octreeLimitInfoSplitted.length; i++){
      octreeLimitInfoSplitted[i] = parseInt(octreeLimitInfoSplitted[i]);
    }
    var lowerBound = new THREE.Vector3(
      octreeLimitInfoSplitted[0], octreeLimitInfoSplitted[1], octreeLimitInfoSplitted[2]
    );
    var upperBound = new THREE.Vector3(
      octreeLimitInfoSplitted[3], octreeLimitInfoSplitted[4], octreeLimitInfoSplitted[5]
    );
    LIMIT_BOUNDING_BOX = new THREE.Box3(lowerBound, upperBound);
    // BIN SIZE ****************************************************
    BIN_SIZE = parseInt(obj.binSize);
    // FOG *********************************************************
    var fogObj = obj.fogObj;
    fogActive = fogObj.fogActive;
    fogColor = fogObj.fogColor;
    fogDensity = fogObj.fogDensity;
    fogColorRGB = new THREE.Color(fogColor);
    fogBlendWithSkybox = fogObj.blendWithSkybox;
    if (fogActive){
      fogColorRGB.setRGB(fogObj.r, fogObj.g, fogObj.b);
    }
    // AREAS *******************************************************
    areasVisible = obj.areasVisible;
    for (var areaName in obj.areas){
      var curAreaExport = obj.areas[areaName];
      areas[areaName] = new Area(
        areaName,
        new THREE.Box3(
          new THREE.Vector3(curAreaExport.bbMinX, curAreaExport.bbMinY, curAreaExport.bbMinZ),
          new THREE.Vector3(curAreaExport.bbMaxX, curAreaExport.bbMaxY, curAreaExport.bbMaxZ)
        ),
        curAreaExport.color,
        curAreaExport.gridSize
      );
      areaBinHandler.insert(areas[areaName].boundingBox, areaName);
      if (areasVisible){
        areas[areaName].renderToScreen();
      }
    }
    // RESOLUTION **************************************************
    screenResolution = obj.screenResolution;
    renderer.setPixelRatio(screenResolution);
    // FONTS *******************************************************
    this.hasFonts = false;
    var that = this;
    for (var fontName in obj.fonts){
      this.hasFonts = true;
      var curFontExport = obj.fonts[fontName];
      var font = new Font(curFontExport.name, curFontExport.path, function(fontInstance){
        fonts[fontInstance.name] = fontInstance;
        that.totalLoadedFontCount ++;
        that.finalize();
      }, function(fontName){
        console.error("Error loading font: "+fontName);
        terminal.printError("Error loading font: "+fontName);
      });
      font.load();
    }
    // TEXTS *******************************************************
    // NOT HERE -> SEE: finalize

    // POST PROCESSING *********************************************
    bloomStrength = obj.bloomStrength;
    bloomRadius = obj.bloomRadius;
    bloomThreshold = obj.bloomThreshold;
    bloomResolutionScale = obj.bloomResolutionScale;
    bloomOn = obj.bloomOn;
    if (!isDeployment){
      postprocessingParameters["Bloom_strength"] = bloomStrength;
      postprocessingParameters["Bloom_radius"] = bloomRadius;
      postprocessingParameters["Bloom_threshhold"] = bloomThreshold;
      postprocessingParameters["Bloom_resolution_scale"] = bloomResolutionScale;
      postprocessingParameters["Bloom"] = bloomOn;
    }

    if (this.oldPhysicsDebugMode){
      if (this.oldPhysicsDebugMode != "NONE"){
        debugRenderer = new THREE.CannonDebugRenderer(scene, physicsWorld);
        physicsDebugMode = this.oldPhysicsDebugMode;
      }
    }

    if (!this.hasTextures && !this.hasTexturePacks && !this.hasSkyboxes && !this.hasFonts){
      this.finalize();
    }

    return true;
  }catch (err){
    projectLoaded = true;
    throw err;
    this.reason = err;
    return false;
  }
}

StateLoader.prototype.finalize = function(){
  var obj = this.stateObj;
  if (parseInt(this.totalLoadedTextureCount) < parseInt(obj.totalTextureCount) ||
           parseInt(this.totalLoadedTexturePackCount) < parseInt(obj.totalTexturePackCount) ||
                parseInt(this.totalLoadedSkyboxCount) < parseInt(obj.totalSkyboxCount) ||
                      parseInt(this.totalLoadedFontCount) < parseInt(obj.totalFontCount)){
      return;
  }

  // ADDED TEXTS ***************************************************
  for (var textName in obj.texts){
    var curTextExport = obj.texts[textName];
    var addedTextInstance = new AddedText(
      textName, fonts[curTextExport.fontName], curTextExport.text,
      new THREE.Vector3(curTextExport.positionX, curTextExport.positionY, curTextExport.positionZ),
      new THREE.Color(curTextExport.colorR, curTextExport.colorG, curTextExport.colorB),
      curTextExport.alpha, curTextExport.charSize, curTextExport.strlen
    );
    addedTextInstance.isClickable = curTextExport.isClickable;
    addedTextInstance.setAffectedByFog(curTextExport.isAffectedByFog);
    if (curTextExport.hasBackground){
      addedTextInstance.setBackground(
        "#" + new THREE.Color(curTextExport.backgroundColorR, curTextExport.backgroundColorG, curTextExport.backgroundColorB).getHexString(),
        curTextExport.backgroundAlpha
      );
    }
    addedTextInstance.setMarginBetweenChars(curTextExport.offsetBetweenChars);
    addedTextInstance.setMarginBetweenLines(curTextExport.offsetBetweenLines);
    addedTextInstance.refCharSize = curTextExport.refCharSize;
    addedTextInstance.refInnerHeight = curTextExport.refInnerHeight;
    if (!(typeof curTextExport.refCharOffset == UNDEFINED)){
      addedTextInstance.refCharOffset = curTextExport.refCharOffset;
    }
    if (!(typeof curTextExport.refLineOffset == UNDEFINED)){
      addedTextInstance.refLineOffset = curTextExport.refLineOffset;
    }
    addedTextInstance.handleBoundingBox();
    addedTextInstance.gsName = curTextExport.gsName;
    addedTextInstance.is2D = curTextExport.is2D;
    if (addedTextInstance.is2D){
      addedTextInstance.injectMacro("IS_TWO_DIMENSIONAL", true, false);
    }
    if (!(typeof curTextExport.marginMode == UNDEFINED)){
      addedTextInstance.marginMode = curTextExport.marginMode;
      addedTextInstance.marginPercentWidth = curTextExport.marginPercentWidth;
      addedTextInstance.marginPercentHeight = curTextExport.marginPercentHeight;
      if (addedTextInstance.is2D){
          addedTextInstance.set2DCoordinates(addedTextInstance.marginPercentWidth,addedTextInstance.marginPercentHeight);
      }
    }
    addedTextInstance.maxWidthPercent = curTextExport.maxWidthPercent;
    addedTextInstance.maxHeightPercent = curTextExport.maxHeightPercent;
    var gridSystem = gridSystems[addedTextInstance.gsName];
    if (gridSystem){
      for (var gridName in curTextExport.destroyedGrids){
        var gridExport = curTextExport.destroyedGrids[gridName];
        var grid = gridSystem.getGridByColRow(
          gridExport.colNumber,
          gridExport.rowNumber
        );
        if (grid){
          addedTextInstance.destroyedGrids[gridName] = grid;
          grid.createdAddedTextName = addedTextInstance.name;
        }
      }
    }
    addedTexts[textName] = addedTextInstance;
    addedTextInstance.handleResize();
    if (addedTextInstance.is2D){
      addedTexts2D[addedTextInstance.name] = addedTextInstance;
    }
  }

  // ADDED OBJECTS EMISSIVE INTENSITY, EMISSIVE COLOR, AO INTENSITY, TEXTURE PROPERTIES
  for (var objName in addedObjects){
    var addedObject = addedObjects[objName];
    if (addedObject.setTxtMatrix){
      for (var ix = 0; ix<addedObject.setTxtMatrix.length; ix++){
        addedObject.mesh.material.uniforms.textureMatrix.value.elements[ix] = addedObject.setTxtMatrix[ix];
      }
      delete addedObject.setTxtMatrix;
    }
    if (addedObject.hasEmissiveMap()){
      if (!(typeof addedObject.setEmissiveIntensity == UNDEFINED)){
        addedObject.mesh.material.uniforms.emissiveIntensity.value = addedObject.setEmissiveIntensity;
        delete addedObject.setEmissiveIntensity;
      }
      if (!(typeof addedObject.setEmissiveColor == UNDEFINED)){
        addedObject.mesh.material.uniforms.emissiveColor.value.set(addedObject.setEmissiveColor);
        delete addedObject.setEmissiveColor;
      }
    }
    if (addedObject.hasAOMap()){
      if (!(typeof addedObject.setAOIntensity == UNDEFINED)){
        addedObject.mesh.material.uniforms.aoIntensity.value = addedObject.setAOIntensity;
        delete addedObject.setAOIntensity;
      }
    }
  }

  // OBJECT GROUPS *************************************************
  for (var objectName in obj.objectGroups){
    var curObjectGroupExport = obj.objectGroups[objectName];
    var group = new Object();
    for (var name in curObjectGroupExport.group){
      group[name] = addedObjects[name];
    }
    var objectGroupInstance = new ObjectGroup(objectName, group);
    objectGroups[objectName] = objectGroupInstance;
    objectGroupInstance.glue();
    if (curObjectGroupExport.mass){
      objectGroupInstance.setMass(curObjectGroupExport.mass);
    }
    objectGroupInstance.initQuaternion = new THREE.Quaternion(
      curObjectGroupExport.quaternionX, curObjectGroupExport.quaternionY,
      curObjectGroupExport.quaternionZ, curObjectGroupExport.quaternionW
    );
    objectGroupInstance.mesh.quaternion.copy(objectGroupInstance.initQuaternion.clone());
    objectGroupInstance.graphicsGroup.quaternion.copy(objectGroupInstance.initQuaternion.clone());
    objectGroupInstance.physicsBody.quaternion.copy(objectGroupInstance.graphicsGroup.quaternion);
    objectGroupInstance.physicsBody.initQuaternion = new CANNON.Quaternion().copy(
      objectGroupInstance.graphicsGroup.quaternion
    );

    var isDynamicObject = false;
    if (curObjectGroupExport.isDynamicObject){
      isDynamicObject = curObjectGroupExport.isDynamicObject;
    }
    if (curObjectGroupExport.isSlippery){
      objectGroupInstance.setSlippery(true);
    }

    objectGroupInstance.isChangeable = curObjectGroupExport.isChangeable;
    objectGroupInstance.isColorizable = curObjectGroupExport.isColorizable;
    if (objectGroupInstance.isColorizable){
      objectGroupInstance.injectMacro("HAS_FORCED_COLOR", false, true);
      objectGroupInstance.mesh.material.uniforms.forcedColor = new THREE.Uniform(new THREE.Vector4(-50, 0, 0, 0));
    }

    if (curObjectGroupExport.noMass){
      objectGroupInstance.noMass = true;
      physicsWorld.remove(objectGroupInstance.physicsBody);
    }

    objectGroupInstance.isDynamicObject = isDynamicObject;
    objectGroupInstance.isBasicMaterial = curObjectGroupExport.isBasicMaterial;

    if (curObjectGroupExport.blendingMode == "NO_BLENDING"){
      objectGroupInstance.setBlending(NO_BLENDING);
    }else if (curObjectGroupExport.blendingMode == "ADDITIVE_BLENDING"){
      objectGroupInstance.setBlending(ADDITIVE_BLENDING);
    }else if (curObjectGroupExport.blendingMode == "SUBTRACTIVE_BLENDING"){
      objectGroupInstance.setBlending(SUBTRACTIVE_BLENDING);
    }else if (curObjectGroupExport.blendingMode == "MULTIPLY_BLENDING"){
      objectGroupInstance.setBlending(MULTIPLY_BLENDING);
    }else if (curObjectGroupExport.blending == "NORMAL_BLENDING"){
      objectGroupInstance.setBlending(NORMAL_BLENDING);
    }

    objectGroupInstance.areaVisibilityConfigurations = curObjectGroupExport.areaVisibilityConfigurations;
    objectGroupInstance.areaSideConfigurations = curObjectGroupExport.areaSideConfigurations;

    if (curObjectGroupExport.renderSide){
      objectGroupInstance.handleRenderSide(curObjectGroupExport.renderSide);
    }

    if (curObjectGroupExport.hasPivot){
      var pivot = objectGroupInstance.makePivot(
        curObjectGroupExport.pivotOffsetX,
        curObjectGroupExport.pivotOffsetY,
        curObjectGroupExport.pivotOffsetZ
      );
      pivot.quaternion.set(
        curObjectGroupExport.pivotQX, curObjectGroupExport.pivotQY,
        curObjectGroupExport.pivotQZ, curObjectGroupExport.pivotQW
      );
      pivot.children[0].quaternion.set(
        curObjectGroupExport.insidePivotQX, curObjectGroupExport.insidePivotQY,
        curObjectGroupExport.insidePivotQZ, curObjectGroupExport.insidePivotQW
      );
      objectGroupInstance.pivotObject = pivot;
      objectGroupInstance.pivotOffsetX = curObjectGroupExport.pivotOffsetX;
      objectGroupInstance.pivotOffsetY = curObjectGroupExport.pivotOffsetY;
      objectGroupInstance.pivotOffsetZ = curObjectGroupExport.pivotOffsetZ;
      objectGroupInstance.mesh.position.set(
        curObjectGroupExport.positionX, curObjectGroupExport.positionY, curObjectGroupExport.positionZ
      );
      objectGroupInstance.physicsBody.position.copy(objectGroupInstance.mesh.position);
    }else if (curObjectGroupExport.pivotRemoved){
      objectGroupInstance.mesh.position.set(
        curObjectGroupExport.positionX, curObjectGroupExport.positionY, curObjectGroupExport.positionZ
      );
      objectGroupInstance.physicsBody.position.copy(objectGroupInstance.mesh.position);
    }

    if (curObjectGroupExport.softCopyParentName){
      objectGroupInstance.softCopyParentName = curObjectGroupExport.softCopyParentName;
    }

    objectGroupInstance.updateOpacity(curObjectGroupExport.totalAlpha);
    if (objectGroupInstance.mesh.material.uniforms.totalAOIntensity){
      objectGroupInstance.mesh.material.uniforms.totalAOIntensity.value = curObjectGroupExport.totalAOIntensity;
    }
    if (objectGroupInstance.mesh.material.uniforms.totalEmissiveIntensity){
      objectGroupInstance.mesh.material.uniforms.totalEmissiveIntensity.value = curObjectGroupExport.totalEmissiveIntensity;
    }
    if (objectGroupInstance.mesh.material.uniforms.totalEmissiveColor){
      objectGroupInstance.mesh.material.uniforms.totalEmissiveColor.value.set(curObjectGroupExport.totalEmissiveColor);
    }
  }

  for (var objName in objectGroups){
    if (objectGroups[objName].softCopyParentName){
      var softCopyParent = objectGroups[objectGroups[objName].softCopyParentName];
      if (softCopyParent){
        objectGroups[objName].mesh.material = softCopyParent.mesh.material;
      }else{
        for (var objName2 in objectGroups){
          if (objName2 != objName){
            if (objectGroups[objName2].softCopyParentName &&
              objectGroups[objName2].softCopyParentName == objectGroups[objName].softCopyParentName){
              objectGroups[objName].mesh.material = objectGroups[objName2].mesh.material;
            }
          }
        }
      }
    }
  }
  projectLoaded = true;
  rayCaster.refresh();
  canvas.style.visibility = "";
  if (!isDeployment){
    terminal.enable();
    terminal.clear();
    terminal.printInfo("Project loaded.");
  }else{
    removeCLIDom();
    modeSwitcher.switchMode();
    if (screenResolution != 1){
      canvas.style.oldPosition = canvas.style.position;
      canvas.style.position = "absolute";
    }
  }
}

StateLoader.prototype.mapTextureToSingleObject = function(diff, exported){
  for (var textureName in textures){
    var addedObjectName;
    if (!exported){
      addedObjectName = diff.path[1];
    }else{
      addedObjectName = diff.name;
    }
    var texture = textures[textureName];
    var curAddedObjectExport;
    if (!exported){
      curAddedObjectExport = diff.rhs;
    }else{
      curAddedObjectExport = diff.export();
    }
    if (!curAddedObjectExport){
      break;
    }
    var objInstance = addedObjects[addedObjectName];
    var material = addedObjects[addedObjectName].material;
    var metaData = addedObjects[addedObjectName].metaData;

    var diffuseRoygbivTextureName;
    var alphaRoygbivTextureName;
    var aoRoygbivTextureName;
    var emissiveRoygbivTextureName;
    var displacementRoygbivTextureName;
    var displacementScale;
    var displacementBias;

    if (!exported){
      diffuseRoygbivTextureName = curAddedObjectExport.diffuseRoygbivTextureName;
      alphaRoygbivTextureName = curAddedObjectExport.alphaRoygbivTextureName;
      aoRoygbivTextureName = curAddedObjectExport.aoRoygbivTextureName;
      emissiveRoygbivTextureName = curAddedObjectExport.emissiveRoygbivTextureName;
      displacementRoygbivTextureName = curAddedObjectExport.displacementRoygbivTextureName;
      displacementScale = curAddedObjectExport.displacementScale;
      displacementBias = curAddedObjectExport.displacementBias;
    }else{
      diffuseRoygbivTextureName = diff.diffuseRoygbivTextureName;
      alphaRoygbivTextureName = diff.alphaRoygbivTextureName;
      aoRoygbivTextureName = diff.aoRoygbivTextureName;
      emissiveRoygbivTextureName = diff.emissiveRoygbivTextureName;
      displacementRoygbivTextureName = diff.displacementRoygbivTextureName;
      displacementScale = diff.displacementScale;
      displacementBias = diff.displacementBias;
    }


    if (diffuseRoygbivTextureName){
      if (textureName == diffuseRoygbivTextureName){
        var repeatU = curAddedObjectExport["textureRepeatU"];
        var repeatV = curAddedObjectExport["textureRepeatV"];
        var cloneTexture = texture;
        cloneTexture.fromUploadedImage = texture.fromUploadedImage;
        cloneTexture.roygbivTextureName = textureName;
        cloneTexture.roygbivTexturePackName = 0;

        cloneTexture.wrapS = THREE.RepeatWrapping;
        cloneTexture.wrapT = THREE.RepeatWrapping;

        if (!(typeof repeatU == UNDEFINED)){
          cloneTexture.repeat.x = repeatU;
        }
        if (!(typeof repeatV == UNDEFINED)){
          cloneTexture.repeat.y = repeatV;
        }

        var mirrorT = metaData["mirrorT"];
        var mirrorS = metaData["mirrorS"];
        if (!(typeof mirrorT == UNDEFINED)){
          if (mirrorT == "ON"){
            cloneTexture.wrapT = THREE.MirroredRepeatWrapping;
          }
        }
        if (!(typeof mirrorS == UNDEFINED)){
          if (mirrorS == "ON"){
            cloneTexture.wrapS = THREE.MirroredRepeatWrapping;
          }
        }

        var textureOffsetX = curAddedObjectExport["textureOffsetX"];
        var textureOffsetY = curAddedObjectExport["textureOffsetY"];
        if (!(typeof textureOffsetX == UNDEFINED)){
          cloneTexture.offset.x = textureOffsetX;
        }
        if (!(typeof textureOffsetY == UNDEFINED)){
          cloneTexture.offset.y = textureOffsetY;
        }

        objInstance.mapDiffuse(cloneTexture);
        cloneTexture.needsUpdate = true;
      }
    }
    if (alphaRoygbivTextureName){
      if (textureName == alphaRoygbivTextureName){
        var repeatU = curAddedObjectExport["textureRepeatU"];
        var repeatV = curAddedObjectExport["textureRepeatV"];

        var cloneTexture = texture;
        cloneTexture.fromUploadedImage = texture.fromUploadedImage;
        cloneTexture.roygbivTextureName = textureName;
        cloneTexture.roygbivTexturePackName = 0;

        cloneTexture.wrapS = THREE.RepeatWrapping;
        cloneTexture.wrapT = THREE.RepeatWrapping;
        if (!(typeof repeatU == UNDEFINED)){
          cloneTexture.repeat.x = repeatU;
        }
        if (!(typeof repeatV == UNDEFINED)){
          cloneTexture.repeat.y = repeatV;
        }

        var mirrorT = metaData["mirrorT"];
        var mirrorS = metaData["mirrorS"];
        if (!(typeof mirrorT == UNDEFINED)){
          if (mirrorT == "ON"){
            cloneTexture.wrapT = THREE.MirroredRepeatWrapping;
          }
        }
        if (!(typeof mirrorS == UNDEFINED)){
          if (mirrorS == "ON"){
            cloneTexture.wrapS = THREE.MirroredRepeatWrapping;
          }
        }

        objInstance.mapAlpha(cloneTexture);
        cloneTexture.needsUpdate = true;
      }
    }
    if (aoRoygbivTextureName){
      if (textureName == aoRoygbivTextureName){
        var repeatU = curAddedObjectExport["textureRepeatU"];
        var repeatV = curAddedObjectExport["textureRepeatV"];

        var cloneTexture = texture;
        cloneTexture.fromUploadedImage = texture.fromUploadedImage;
        cloneTexture.roygbivTextureName = textureName;
        cloneTexture.roygbivTexturePackName = 0;

        cloneTexture.wrapS = THREE.RepeatWrapping;
        cloneTexture.wrapT = THREE.RepeatWrapping;
        if (!(typeof repeatU == UNDEFINED)){
          cloneTexture.repeat.x = repeatU;
        }
        if (!(typeof repeatV == UNDEFINED)){
          cloneTexture.repeat.y = repeatV;
        }

        var mirrorT = metaData["mirrorT"];
        var mirrorS = metaData["mirrorS"];
        if (!(typeof mirrorT == UNDEFINED)){
          if (mirrorT == "ON"){
            cloneTexture.wrapT = THREE.MirroredRepeatWrapping;
          }
        }
        if (!(typeof mirrorS == UNDEFINED)){
          if (mirrorS == "ON"){
            cloneTexture.wrapS = THREE.MirroredRepeatWrapping;
          }
        }

        objInstance.mapAO(cloneTexture);
        cloneTexture.needsUpdate = true;
      }
    }
    if (emissiveRoygbivTextureName){
      if (textureName == emissiveRoygbivTextureName){
        var repeatU = curAddedObjectExport["textureRepeatU"];
        var repeatV = curAddedObjectExport["textureRepeatV"];

        var cloneTexture = texture;
        cloneTexture.fromUploadedImage = texture.fromUploadedImage;
        cloneTexture.roygbivTextureName = textureName;
        cloneTexture.roygbivTexturePackName = 0;


        cloneTexture.wrapS = THREE.RepeatWrapping;
        cloneTexture.wrapT = THREE.RepeatWrapping;
        if (!(typeof repeatU == UNDEFINED)){
          cloneTexture.repeat.x = repeatU;
        }
        if (!(typeof repeatV == UNDEFINED)){
          cloneTexture.repeat.y = repeatV;
        }

        var mirrorT = metaData["mirrorT"];
        var mirrorS = metaData["mirrorS"];
        if (!(typeof mirrorT == UNDEFINED)){
          if (mirrorT == "ON"){
            cloneTexture.wrapT = THREE.MirroredRepeatWrapping;
          }
        }
        if (!(typeof mirrorS == UNDEFINED)){
          if (mirrorS == "ON"){
            cloneTexture.wrapS = THREE.MirroredRepeatWrapping;
          }
        }

        objInstance.mapEmissive(cloneTexture);
        cloneTexture.needsUpdate = true;
      }
    }
    if (displacementRoygbivTextureName){
      if (textureName == displacementRoygbivTextureName){
        var repeatU = curAddedObjectExport["textureRepeatU"];
        var repeatV = curAddedObjectExport["textureRepeatV"];

        var cloneTexture = texture;
        cloneTexture.fromUploadedImage = texture.fromUploadedImage;
        cloneTexture.roygbivTextureName = textureName;
        cloneTexture.roygbivTexturePackName = 0;

        if (!(typeof displacementScale == UNDEFINED)){
          material.displacementScale = displacementScale;
        }
        if (!(typeof displacementBias == UNDEFINED)){
          material.displacementBias = displacementBias;
        }

        cloneTexture.wrapS = THREE.RepeatWrapping;
        cloneTexture.wrapT = THREE.RepeatWrapping;
        if (!(typeof repeatU == UNDEFINED)){
          cloneTexture.repeat.x = repeatU;
        }
        if (!(typeof repeatV == UNDEFINED)){
          cloneTexture.repeat.y = repeatV;
        }

        var mirrorT = metaData["mirrorT"];
        var mirrorS = metaData["mirrorS"];
        if (!(typeof mirrorT == UNDEFINED)){
          if (mirrorT == "ON"){
            cloneTexture.wrapT = THREE.MirroredRepeatWrapping;
          }
        }
        if (!(typeof mirrorS == UNDEFINED)){
          if (mirrorS == "ON"){
            cloneTexture.wrapS = THREE.MirroredRepeatWrapping;
          }
        }

        objInstance.mapDisplacement(cloneTexture);
        cloneTexture.needsUpdate = true;
      }
    }
  }
}

StateLoader.prototype.mapTexturePackToSingleObject = function(diff){
  for (var texturePackName in texturePacks){
    var texturePack = texturePacks[texturePackName];
    var addedObject = addedObjects[diff.path[1]];
    var material = addedObject.mesh.material;

    var addedObjectExport = diff.rhs;
    if (!addedObjectExport){
      return;
    }
    var diffuseRoygbivTexturePackName;
    var alphaRoygbivTexturePackName;
    var aoRoygbivTexturePackName;
    var emissiveRoygbivTexturePackName;
    var displacementRoygbivTexturePackName;

    diffuseRoygbivTexturePackName = addedObjectExport["diffuseRoygbivTexturePackName"];
    alphaRoygbivTexturePackName = addedObjectExport["alphaRoygbivTexturePackName"];
    aoRoygbivTexturePackName = addedObjectExport["aoRoygbivTexturePackName"];
    emissiveRoygbivTexturePackName = addedObjectExport["emissiveRoygbivTexturePackName"];
    displacementRoygbivTexturePackName = addedObjectExport["displacementRoygbivTexturePackName"];

    var textureRepeatU, textureRepeatV;
    if (!(typeof addedObjectExport["textureRepeatU"] == UNDEFINED)){
      textureRepeatU = addedObjectExport["textureRepeatU"];
      addedObject.metaData["textureRepeatU"] = textureRepeatU;
    }
    if (!(typeof addedObjectExport["textureRepeatV"] == UNDEFINED)){
      textureRepeatV = addedObjectExport["textureRepeatV"];
      addedObject.metaData["textureRepeatV"] = textureRepeatV;
    }

    var textureOffsetX, textureOffsetY;
    if (!(typeof addedObjectExport.textureOffsetX == UNDEFINED)){
      textureOffsetX = addedObjectExport.textureOffsetX;
    }
    if (!(typeof addedObjectExport.textureOffsetY == UNDEFINED)){
      textureOffsetY = addedObjectExport.textureOffsetY;
    }

    var displacementScale, displacementBias;
    if (!(typeof addedObjectExport.displacementScale == UNDEFINED)){
      displacementScale = addedObjectExport.displacementScale;
    }
    if (!(typeof addedObjectExport.displacementBias == UNDEFINED)){
      displacementBias = addedObjectExport.displacementBias;
    }
    if (diffuseRoygbivTexturePackName){
      if (diffuseRoygbivTexturePackName == texturePackName){
        if (texturePack.hasDiffuse){
          addedObject.mapDiffuse(texturePack.diffuseTexture);
          material.uniforms.diffuseMap.value.roygbivTexturePackName = texturePackName;
          material.uniforms.diffuseMap.value.roygbivTextureName = 0;
          if (!(typeof textureOffsetX == UNDEFINED)){
            material.uniforms.diffuseMap.value.offset.x = textureOffsetX;
          }
          if (!(typeof textureOffsetY == UNDEFINED)){
            material.uniforms.diffuseMap.value.offset.y = textureOffsetY;
          }
          if (!(typeof textureRepeatU == UNDEFINED)){
            material.uniforms.diffuseMap.value.repeat.x = textureRepeatU;
          }
          if (!(typeof textureRepeatV == UNDEFINED)){
            material.uniforms.diffuseMap.value.repeat.y = textureRepeatV;
          }
          material.uniforms.diffuseMap.value.needsUpdate = true;
        }
      }
    }
    if (alphaRoygbivTexturePackName){
      if (alphaRoygbivTexturePackName == texturePackName){
        if (texturePack.hasAlpha){
          addedObject.mapAlpha(texturePack.alphaTexture);
          material.uniforms.alphaMap.value.roygbivTexturePackName = texturePackName;
          material.uniforms.alphaMap.value.roygbivTextureName = 0;
          if (!(typeof textureRepeatU == UNDEFINED)){
            material.uniforms.alphaMap.value.repeat.x = textureRepeatU;
          }
          if (!(typeof textureRepeatV == UNDEFINED)){
            material.uniforms.alphaMap.value.repeat.y = textureRepeatV;
          }
          material.uniforms.alphaMap.value.needsUpdate = true;
        }
      }
    }
    if (aoRoygbivTexturePackName){
      if (aoRoygbivTexturePackName == texturePackName){
        if (texturePack.hasAO){
          addedObject.mapAO(texturePack.aoTexture);
          material.uniforms.aoMap.value.roygbivTexturePackName = texturePackName;
          material.uniforms.aoMap.value.roygbivTextureName = 0;
          if (!(typeof textureRepeatU == UNDEFINED)){
            material.uniforms.aoMap.value.repeat.x = textureRepeatU;
          }
          if (!(typeof textureRepeatV == UNDEFINED)){
            material.uniforms.aoMap.value.repeat.y = textureRepeatV;
          }
          material.uniforms.aoMap.value.needsUpdate = true;
        }
      }
    }
    if (emissiveRoygbivTexturePackName){
      if (emissiveRoygbivTexturePackName == texturePackName){
        if (texturePack.hasEmissive){
          addedObject.mapEmissive(texturePack.emissiveTexture);
          material.uniforms.emissiveMap.value.roygbivTexturePackName = texturePackName;
          material.uniforms.emissiveMap.value.roygbivTextureName = 0;
          if (!(typeof textureRepeatU == UNDEFINED)){
            material.uniforms.emissiveMap.value.repeat.x = textureRepeatU;
          }
          if (!(typeof textureRepeatV == UNDEFINED)){
            material.uniforms.emissiveMap.value.repeat.y = textureRepeatV;
          }
          material.uniforms.emissiveMap.value.needsUpdate = true;
        }
      }
    }
    if (displacementRoygbivTexturePackName){
      if (displacementRoygbivTexturePackName == texturePackName){
        if (texturePack.hasHeight){
          addedObject.mapDisplacement(texturePack.heightTexture);
          material.uniforms.displacementMap.value.roygbivTexturePackName = texturePackName;
          material.uniforms.displacementMap.value.roygbivTextureName = 0;
          if (!(typeof textureRepeatU == UNDEFINED)){
            material.uniforms.displacementMap.value.repeat.x = textureRepeatU;
          }
          if (!(typeof textureRepeatV == UNDEFINED)){
            material.uniforms.displacementMap.value.repeat.y = textureRepeatV;
          }
          if (!(typeof displacementScale == UNDEFINED)){
            material.uniforms.displacementInfo.value.x = displacementScale;
          }
          if (!(typeof displacementBias == UNDEFINED)){
            material.uniforms.displacementInfo.value.y = displacementBias;
          }
          material.uniforms.displacementMap.value.needsUpdate = true;
        }
      }
    }
  }
}

StateLoader.prototype.mapLoadedTexturePack = function(texturePackName, exportObj){
  var texturePack = texturePacks[texturePackName];
  for (var objectGroupName in objectGroups){
    var group = objectGroups[objectGroupName].group;
    for (var objectName in group){
      addedObjects[objectName] = group[objectName];
    }
  }
  for (var addedObjectName in addedObjects){
    var addedObject = addedObjects[addedObjectName];
    var material = addedObject.mesh.material;

    var addedObjectExport = exportObj.addedObjects[addedObjectName];
    if (!addedObjectExport){
      return;
    }
    var diffuseRoygbivTexturePackName;
    var alphaRoygbivTexturePackName;
    var aoRoygbivTexturePackName;
    var emissiveRoygbivTexturePackName;
    var displacementRoygbivTexturePackName;

    diffuseRoygbivTexturePackName = addedObjectExport["diffuseRoygbivTexturePackName"];
    alphaRoygbivTexturePackName = addedObjectExport["alphaRoygbivTexturePackName"];
    aoRoygbivTexturePackName = addedObjectExport["aoRoygbivTexturePackName"];
    emissiveRoygbivTexturePackName = addedObjectExport["emissiveRoygbivTexturePackName"];
    displacementRoygbivTexturePackName = addedObjectExport["displacementRoygbivTexturePackName"];

    var textureRepeatU, textureRepeatV;
    if (!(typeof addedObjectExport["textureRepeatU"] == UNDEFINED)){
      textureRepeatU = addedObjectExport["textureRepeatU"];
      addedObject.metaData["textureRepeatU"] = textureRepeatU;
    }
    if (!(typeof addedObjectExport["textureRepeatV"] == UNDEFINED)){
      textureRepeatV = addedObjectExport["textureRepeatV"];
      addedObject.metaData["textureRepeatV"] = textureRepeatV;
    }

    var mirrorS = false;
    var mirrorT = false;
    if (!(typeof addedObjectExport.metaData.mirrorS == UNDEFINED)){
      if (addedObjectExport.metaData.mirrorS == "ON"){
        mirrorS = true;
      }
    }
    if (!(typeof addedObjectExport.metaData.mirrorT == UNDEFINED)){
      if (addedObjectExport.metaData.mirrorT == "ON"){
        mirrorT = true;
      }
    }

    var textureOffsetX, textureOffsetY;
    if (!(typeof addedObjectExport.textureOffsetX == UNDEFINED)){
      textureOffsetX = addedObjectExport.textureOffsetX;
    }else{
      textureOffsetX = 0;
    }
    if (!(typeof addedObjectExport.textureOffsetY == UNDEFINED)){
      textureOffsetY = addedObjectExport.textureOffsetY;
    }else{
      textureOffsetY = 0;
    }

    var displacementScale, displacementBias;
    if (!(typeof addedObjectExport.displacementScale == UNDEFINED)){
      displacementScale = addedObjectExport.displacementScale;
    }
    if (!(typeof addedObjectExport.displacementBias == UNDEFINED)){
      displacementBias = addedObjectExport.displacementBias;
    }
    if (diffuseRoygbivTexturePackName){
      if (diffuseRoygbivTexturePackName == texturePackName){
        if (texturePack.hasDiffuse){
          addedObject.mapDiffuse(texturePack.diffuseTexture);
          material.uniforms.diffuseMap.value.roygbivTexturePackName = texturePackName;
          material.uniforms.diffuseMap.value.roygbivTextureName = 0;
          if (!(typeof textureOffsetX == UNDEFINED)){
            material.uniforms.diffuseMap.value.offset.x = textureOffsetX;
          }
          if (!(typeof textureOffsetY == UNDEFINED)){
            material.uniforms.diffuseMap.value.offset.y = textureOffsetY;
          }
          if (!(typeof textureRepeatU == UNDEFINED)){
            material.uniforms.diffuseMap.value.repeat.x = textureRepeatU;
          }
          if (!(typeof textureRepeatV == UNDEFINED)){
            material.uniforms.diffuseMap.value.repeat.y = textureRepeatV;
          }
          material.uniforms.diffuseMap.value.needsUpdate = true;
          material.uniforms.diffuseMap.value.updateMatrix();
        }
      }
    }
    if (alphaRoygbivTexturePackName){
      if (alphaRoygbivTexturePackName == texturePackName){
        if (texturePack.hasAlpha){
          addedObject.mapAlpha(texturePack.alphaTexture);
          material.uniforms.alphaMap.value.roygbivTexturePackName = texturePackName;
          material.uniforms.alphaMap.value.roygbivTextureName = 0;
          if (!(typeof textureRepeatU == UNDEFINED)){
            material.uniforms.alphaMap.value.repeat.x = textureRepeatU;
          }
          if (!(typeof textureRepeatV == UNDEFINED)){
            material.uniforms.alphaMap.value.repeat.y = textureRepeatV;
          }
          material.uniforms.alphaMap.value.needsUpdate = true;
          material.uniforms.alphaMap.value.updateMatrix();
        }
      }
    }
    if (aoRoygbivTexturePackName){
      if (aoRoygbivTexturePackName == texturePackName){
        if (texturePack.hasAO){
          addedObject.mapAO(texturePack.aoTexture);
          material.uniforms.aoMap.value.roygbivTexturePackName = texturePackName;
          material.uniforms.aoMap.value.roygbivTextureName = 0;
          if (!(typeof textureRepeatU == UNDEFINED)){
            material.uniforms.aoMap.value.repeat.x = textureRepeatU;
          }
          if (!(typeof textureRepeatV == UNDEFINED)){
            material.uniforms.aoMap.value.repeat.y = textureRepeatV;
          }
          material.uniforms.aoMap.value.needsUpdate = true;
          material.uniforms.aoMap.value.updateMatrix();
        }
      }
    }
    if (emissiveRoygbivTexturePackName){
      if (emissiveRoygbivTexturePackName == texturePackName){
        if (texturePack.hasEmissive){
          addedObject.mapEmissive(texturePack.emissiveTexture);
          material.uniforms.emissiveMap.value.roygbivTexturePackName = texturePackName;
          material.uniforms.emissiveMap.value.roygbivTextureName = 0;
          if (!(typeof textureRepeatU == UNDEFINED)){
            material.uniforms.emissiveMap.value.repeat.x = textureRepeatU;
          }
          if (!(typeof textureRepeatV == UNDEFINED)){
            material.uniforms.emissiveMap.value.repeat.y = textureRepeatV;
          }
          material.uniforms.emissiveMap.value.needsUpdate = true;
          material.uniforms.emissiveMap.value.updateMatrix();
        }
      }
    }
    if (displacementRoygbivTexturePackName){
      if (displacementRoygbivTexturePackName == texturePackName){
        if (texturePack.hasHeight){
          addedObject.mapDisplacement(texturePack.heightTexture);
          material.uniforms.displacementMap.value.roygbivTexturePackName = texturePackName;
          material.uniforms.displacementMap.value.roygbivTextureName = 0;
          if (!(typeof textureRepeatU == UNDEFINED)){
            material.uniforms.displacementMap.value.repeat.x = textureRepeatU;
          }
          if (!(typeof textureRepeatV == UNDEFINED)){
            material.uniforms.displacementMap.value.repeat.y = textureRepeatV;
          }
          if (!(typeof displacementScale == UNDEFINED)){
            material.uniforms.displacementInfo.value.x = displacementScale;
          }
          if (!(typeof displacementBias == UNDEFINED)){
            material.uniforms.displacementInfo.value.y = displacementBias;
          }
          material.uniforms.displacementMap.value.needsUpdate = true;
          material.uniforms.displacementMap.value.updateMatrix();
        }
      }
    }
    if (mirrorS || mirrorT){
      if (mirrorS && ! mirrorT){
        addedObject.handleMirror("S", "ON");
      }else if (mirrorT && !mirrorS){
        addedObject.handleMirror("T", "ON");
      }else{
        addedObject.handleMirror("ST", "ON");
      }
    }
  }
  for (var objectGroupName in objectGroups){
    var group = objectGroups[objectGroupName].group;
    for (var objectName in group){
      delete addedObjects[objectName];
    }
  }
}

StateLoader.prototype.mapLoadedTexture = function(texture, textureName){
  var addedObjectsExport = this.stateObj.addedObjects;
  for (var objectGroupName in objectGroups){
    var group = objectGroups[objectGroupName].group;
    for (var objectName in group){
      addedObjects[objectName] = group[objectName];
    }
  }
  for (var addedObjectName in addedObjectsExport){

    var curAddedObjectExport = addedObjectsExport[addedObjectName];
    if (!curAddedObjectExport){
      break;
    }
    var objInstance = addedObjects[addedObjectName];
    var material = addedObjects[addedObjectName].material;
    var metaData = addedObjects[addedObjectName].metaData;

    var diffuseRoygbivTextureName = curAddedObjectExport.diffuseRoygbivTextureName;
    var alphaRoygbivTextureName = curAddedObjectExport.alphaRoygbivTextureName;
    var aoRoygbivTextureName = curAddedObjectExport.aoRoygbivTextureName;
    var emissiveRoygbivTextureName = curAddedObjectExport.emissiveRoygbivTextureName;
    var displacementRoygbivTextureName = curAddedObjectExport.displacementRoygbivTextureName;
    var displacementScale = curAddedObjectExport.displacementScale;
    var displacementBias = curAddedObjectExport.displacementBias;


    if (diffuseRoygbivTextureName){
      if (textureName == diffuseRoygbivTextureName){
        var repeatU = curAddedObjectExport["textureRepeatU"];
        var repeatV = curAddedObjectExport["textureRepeatV"];
        var cloneTexture = texture;
        cloneTexture.fromUploadedImage = texture.fromUploadedImage;
        cloneTexture.roygbivTextureName = textureName;
        cloneTexture.roygbivTexturePackName = 0;

        cloneTexture.wrapS = THREE.RepeatWrapping;
        cloneTexture.wrapT = THREE.RepeatWrapping;

        if (!(typeof repeatU == UNDEFINED)){
          cloneTexture.repeat.x = repeatU;
        }
        if (!(typeof repeatV == UNDEFINED)){
          cloneTexture.repeat.y = repeatV;
        }

        var mirrorT = metaData["mirrorT"];
        var mirrorS = metaData["mirrorS"];
        if (!(typeof mirrorT == UNDEFINED)){
          if (mirrorT == "ON"){
            cloneTexture.wrapT = THREE.MirroredRepeatWrapping;
          }
        }
        if (!(typeof mirrorS == UNDEFINED)){
          if (mirrorS == "ON"){
            cloneTexture.wrapS = THREE.MirroredRepeatWrapping;
          }
        }

        var textureOffsetX = curAddedObjectExport["textureOffsetX"];
        var textureOffsetY = curAddedObjectExport["textureOffsetY"];
        if (!(typeof textureOffsetX == UNDEFINED)){
          cloneTexture.offset.x = textureOffsetX;
        }
        if (!(typeof textureOffsetY == UNDEFINED)){
          cloneTexture.offset.y = textureOffsetY;
        }

        objInstance.mapDiffuse(cloneTexture);
        cloneTexture.needsUpdate = true;
      }
    }
    if (alphaRoygbivTextureName){
      if (textureName == alphaRoygbivTextureName){
        var repeatU = curAddedObjectExport["textureRepeatU"];
        var repeatV = curAddedObjectExport["textureRepeatV"];

        var cloneTexture = texture;
        cloneTexture.fromUploadedImage = texture.fromUploadedImage;
        cloneTexture.roygbivTextureName = textureName;
        cloneTexture.roygbivTexturePackName = 0;

        cloneTexture.wrapS = THREE.RepeatWrapping;
        cloneTexture.wrapT = THREE.RepeatWrapping;
        if (!(typeof repeatU == UNDEFINED)){
          cloneTexture.repeat.x = repeatU;
        }
        if (!(typeof repeatV == UNDEFINED)){
          cloneTexture.repeat.y = repeatV;
        }

        var mirrorT = metaData["mirrorT"];
        var mirrorS = metaData["mirrorS"];
        if (!(typeof mirrorT == UNDEFINED)){
          if (mirrorT == "ON"){
            cloneTexture.wrapT = THREE.MirroredRepeatWrapping;
          }
        }
        if (!(typeof mirrorS == UNDEFINED)){
          if (mirrorS == "ON"){
            cloneTexture.wrapS = THREE.MirroredRepeatWrapping;
          }
        }

        objInstance.mapAlpha(cloneTexture);
        cloneTexture.needsUpdate = true;
      }
    }
    if (aoRoygbivTextureName){
      if (textureName == aoRoygbivTextureName){
        var repeatU = curAddedObjectExport["textureRepeatU"];
        var repeatV = curAddedObjectExport["textureRepeatV"];

        var cloneTexture = texture;
        cloneTexture.fromUploadedImage = texture.fromUploadedImage;
        cloneTexture.roygbivTextureName = textureName;
        cloneTexture.roygbivTexturePackName = 0;

        cloneTexture.wrapS = THREE.RepeatWrapping;
        cloneTexture.wrapT = THREE.RepeatWrapping;
        if (!(typeof repeatU == UNDEFINED)){
          cloneTexture.repeat.x = repeatU;
        }
        if (!(typeof repeatV == UNDEFINED)){
          cloneTexture.repeat.y = repeatV;
        }

        var mirrorT = metaData["mirrorT"];
        var mirrorS = metaData["mirrorS"];
        if (!(typeof mirrorT == UNDEFINED)){
          if (mirrorT == "ON"){
            cloneTexture.wrapT = THREE.MirroredRepeatWrapping;
          }
        }
        if (!(typeof mirrorS == UNDEFINED)){
          if (mirrorS == "ON"){
            cloneTexture.wrapS = THREE.MirroredRepeatWrapping;
          }
        }

        objInstance.mapAO(cloneTexture);
        cloneTexture.needsUpdate = true;
      }
    }
    if (emissiveRoygbivTextureName){
      if (textureName == emissiveRoygbivTextureName){
        var repeatU = curAddedObjectExport["textureRepeatU"];
        var repeatV = curAddedObjectExport["textureRepeatV"];

        var cloneTexture = texture;
        cloneTexture.fromUploadedImage = texture.fromUploadedImage;
        cloneTexture.roygbivTextureName = textureName;
        cloneTexture.roygbivTexturePackName = 0;

        cloneTexture.wrapS = THREE.RepeatWrapping;
        cloneTexture.wrapT = THREE.RepeatWrapping;
        if (!(typeof repeatU == UNDEFINED)){
          cloneTexture.repeat.x = repeatU;
        }
        if (!(typeof repeatV == UNDEFINED)){
          cloneTexture.repeat.y = repeatV;
        }

        var mirrorT = metaData["mirrorT"];
        var mirrorS = metaData["mirrorS"];
        if (!(typeof mirrorT == UNDEFINED)){
          if (mirrorT == "ON"){
            cloneTexture.wrapT = THREE.MirroredRepeatWrapping;
          }
        }
        if (!(typeof mirrorS == UNDEFINED)){
          if (mirrorS == "ON"){
            cloneTexture.wrapS = THREE.MirroredRepeatWrapping;
          }
        }

        objInstance.mapEmissive(cloneTexture);
        cloneTexture.needsUpdate = true;
      }
    }
    if (displacementRoygbivTextureName){
      if (textureName == displacementRoygbivTextureName){
        var repeatU = curAddedObjectExport["textureRepeatU"];
        var repeatV = curAddedObjectExport["textureRepeatV"];

        var cloneTexture = texture;
        cloneTexture.fromUploadedImage = texture.fromUploadedImage;
        cloneTexture.roygbivTextureName = textureName;
        cloneTexture.roygbivTexturePackName = 0;

        if (!(typeof displacementScale == UNDEFINED)){
          objInstance.mesh.material.uniforms.displacementInfo.value.x = displacementScale;
        }
        if (!(typeof displacementBias == UNDEFINED)){
          objInstance.mesh.material.uniforms.displacementInfo.value.y = displacementBias;
        }

        cloneTexture.wrapS = THREE.RepeatWrapping;
        cloneTexture.wrapT = THREE.RepeatWrapping;
        if (!(typeof repeatU == UNDEFINED)){
          cloneTexture.repeat.x = repeatU;
        }
        if (!(typeof repeatV == UNDEFINED)){
          cloneTexture.repeat.y = repeatV;
        }

        var mirrorT = metaData["mirrorT"];
        var mirrorS = metaData["mirrorS"];
        if (!(typeof mirrorT == UNDEFINED)){
          if (mirrorT == "ON"){
            cloneTexture.wrapT = THREE.MirroredRepeatWrapping;
          }
        }
        if (!(typeof mirrorS == UNDEFINED)){
          if (mirrorS == "ON"){
            cloneTexture.wrapS = THREE.MirroredRepeatWrapping;
          }
        }

        objInstance.mapDisplacement(cloneTexture);
        cloneTexture.needsUpdate = true;
      }
    }
  }
  for (var objectGroupName in objectGroups){
    var group = objectGroups[objectGroupName].group;
    for (var objectName in group){
      delete addedObjects[objectName];
    }
  }
}

StateLoader.prototype.resetProject = function(){

  for (var gridSystemName in gridSystems){
    gridSystems[gridSystemName].destroy();
  }
  for (var addedObjectName in addedObjects){
    addedObjects[addedObjectName].destroy();
  }

  for (var grouppedObjectName in objectGroups){
    objectGroups[grouppedObjectName].destroy();
  }

  for (var textName in addedTexts){
    addedTexts[textName].destroy();
  }

  if (skyboxMesh){
    scene.remove(skyboxMesh);
  }

  collisionCallbackRequests = new Object();
  particleCollisionCallbackRequests = new Object();
  for (var particleSystemName in particleSystems){
    particleSystems[particleSystemName].destroy();
  }
  particleSystems = new Object();
  particleSystemPool = new Object();
  particleSystemPools = new Object();

  for (var markedPointName in markedPoints){
    markedPoints[markedPointName].destroy();
  }
  for (var areaName in areas){
    areas[areaName].destroy();
  }

  isPaused = false;
  maxInactiveTime = 0;
  inactiveCounter = 0;
  isScreenVisible = true;
  viewportMaxWidth = 0;
  viewportMaxHeight = 0;
  currentViewport = new Object();
  keyboardBuffer = new Object();
  gridSystems = new Object();
  gridSelections = new Object();
  materials = new Object();
  addedObjects = new Object();
  addedTexts = new Object();
  addedTexts2D = new Object();
  clickableAddedTexts = new Object();
  clickableAddedTexts2D = new Object();
  textures = new Object();
  textureURLs = new Object();
  physicsTests = new Object();
  wallCollections = new Object();
  uploadedImages = new Object();
  modifiedTextures = new Object();
  texturePacks = new Object();
  skyBoxes = new Object();
  scripts = new Object();
  objectGroups = new Object();
  disabledObjectNames = new Object();
  markedPoints = new Object();
  areas = new Object();
  areaBinHandler = new WorldBinHandler(true);
  rayCaster = new RayCaster();
  areaBinHandler.isAreaBinHandler = true;
  anchorGrid = 0;
  areasVisible = true;
  areaConfigurationsVisible = false;
  areaConfigurationsHandler = new AreaConfigurationsHandler();
  textureUniformCache = new Object();
  dynamicObjects = new Object();
  dynamicObjectGroups = new Object();
  trackingObjects = new Object();
  screenResolution = 1;
  skyboxConfigurationsVisible = false;
  fogConfigurationsVisible = false;
  stopAreaConfigurationsHandler = false;
  screenClickCallbackFunction = 0;
  screenMouseDownCallbackFunction = 0;
  screenMouseUpCallbackFunction = 0;
  screenMouseMoveCallbackFunction = 0;
  screenPointerLockChangedCallbackFunction = 0;
  screenFullScreenChangeCallbackFunction = 0;
  screenKeydownCallbackFunction = 0;
  screenKeyupCallbackFunction = 0;
  fpsDropCallbackFunction = 0;
  performanceDropCallbackFunction = 0;
  userInactivityCallbackFunction = 0;
  fpsHandler.reset();
  originalBloomConfigurations = new Object();
  fonts = new Object();
  NO_MOBILE = false;
  fixedAspect = 0;
  roygbivAttributeCounter = 1;
  roygbivBufferAttributeCounter = 1;
  roygbivSkippedArrayBufferUpdates = 0;
  roygbivSkippedElementArrayBufferUpdates = 0;

  boundingClientRect = renderer.domElement.getBoundingClientRect();
  pointerLockRequested = false;
  fullScreenRequested = false;
  defaultCameraControlsDisabled = false;
  isMouseDown = false;
  modeSwitcher = new ModeSwitcher();

  // FOG
  fogActive = false;
  fogColor = "black";
  fogDensity = 0;
  fogColorRGB = new THREE.Color(fogColor);
  fogBlendWithSkybox = false;
  GLOBAL_FOG_UNIFORM.value.set(-100.0, 0, 0, 0);

  mode = 0; // 0 -> DESIGN, 1-> PREVIEW
  this.oldPhysicsDebugMode = "NONE";

  physicsDebugMode = false;
  if (!isDeployment){
    selectionHandler.resetCurrentSelection();
  }
  skyboxVisible = false;
  croppedGridSystemBuffer = 0;

  scriptEditorShowing = false;

  physicsWorld = new CANNON.World();
  physicsSolver = new CANNON.GSSolver();
  initPhysics();

  // PHYSICS DEBUG MODE
  var objectsToRemove = [];
  var children = scene.children;
  for (var i = 0; i<children.length; i++){
    var child = children[i];
    if (child.forDebugPurposes){
      objectsToRemove.push(child);
    }
  }
  for (var i = 0; i<objectsToRemove.length; i++){
    scene.remove(objectsToRemove[i]);
  }

  diffuseTextureCache = new Object();
  heightTextureCache = new Object();
  ambientOcculsionTextureCache = new Object();
  alphaTextureCache = new Object();
  emissiveTextureCache = new Object();

  initBadTV();
  if (!isDeployment){
    guiHandler.hideAll();
    $("#cliDivheader").text("ROYGBIV Scene Creator - CLI (Design mode)");
  }

  LIMIT_BOUNDING_BOX = new THREE.Box3(new THREE.Vector3(-4000, -4000, -4000), new THREE.Vector3(4000, 4000, 4000));
  BIN_SIZE = 50;

  geometryCache = new Object();
  physicsShapeCache = new Object();

  previewSceneRendered = false;

}

var Script = function(name, script){
  this.name = name;
  this.script = script;
  this.status = SCRIPT_STATUS_STOPPED;
  try{
    this.func = new Function(this.script);
  }catch(err){
    this.status = SCRIPT_STATUS_ERROR;
  }
  this.counter1 = 0;
  this.counter2 = 0;
  this.lastExecutionPerformance = 0;
}

Script.prototype.execute = function(){
  if (this.status != SCRIPT_STATUS_STARTED){
    return ;
  }
  if (!this.func){
    terminal.clear();
    terminal.printError(Text.SCRIPT_IS_NOT_VALID);
    return;
  }
  this.counter1 = performance.now();
  try{
    this.func();
  }catch (err){
    console.error("Error at "+this.name+": "+err);
    this.status = SCRIPT_STATUS_ERROR;
  }
  this.counter2 = performance.now();
  this.lastExecutionPerformance = this.counter2 - this.counter1;
}

Script.prototype.reload = function(onSuccess, onLoadError, onCompilationError){
  if (this.localFilePath){
    var that = this;
    $.ajax({
      url: this.localFilePath,
      converters:{
        'text script': function(text){
          return text;
        }
      },
      success: function(data){
        that.script = data;
        try{
          that.func = new Function(that.script);
        }catch (err){
          onCompilationError(that.name, err.message);
          return;
        }
        onSuccess(that.name);
      }
    }).fail(function(){
      onLoadError(that.name, that.localFilePath);
    });
    return;
  }
}

Script.prototype.export = function(){
  var exportObject = new Object();
  exportObject["name"] = this.name;
  exportObject["script"] = this.script;
  exportObject["status"] = this.status;
  if (this.localFilePath){
    exportObject["localFilePath"] = this.localFilePath;
  }
  if (this.runAutomatically){
    exportObject["runAutomatically"] = true;
  }else{
    exportObject["runAutomatically"] = false;
  }
  return exportObject;
}

Script.prototype.stop = function(){
  this.status = SCRIPT_STATUS_STOPPED;
  delete scriptsToRun[this.name];
}

Script.prototype.start = function(){
  this.status = SCRIPT_STATUS_STARTED;
  scriptsToRun[this.name] = this;
}

Script.prototype.isRunning = function(){
  return (this.status == SCRIPT_STATUS_STARTED);
}

var ObjectGroup = function(name, group){
  this.isObjectGroup = true;
  this.name = name;
  this.group = group;

  this.rotationX = 0;
  this.rotationY = 0;
  this.rotationZ = 0;

  this.gridSystemNames = [];

  this.childObjectsByName = new Object();

  this.totalVertexCount = 0;
  this.skippedVertexCount = 0;

  this.isTransparent = false;
  for (var objName in this.group){
    var obj = this.group[objName];
    var isObjTransparent = (obj.mesh.material.uniforms.alpha.value < 1);
    if (isObjTransparent){
      this.isTransparent = true;
      break;
    }
  }

}

ObjectGroup.prototype.forceColor = function(r, g, b, a){
  if (!this.isColorizable){
    return;
  }
  if (a < 0){
    a = 0;
  }
  if (a > 1){
    a = 1;
  }
  this.mesh.material.uniforms.forcedColor.value.set(a, r, g, b);
  if (a < 1){
    this.mesh.material.transparent = true;
  }
}

ObjectGroup.prototype.resetColor = function(){
  if (!this.isColorizable){
    return;
  }
  this.mesh.material.uniforms.forcedColor.value.set(-50, 0, 0, 0);
  this.mesh.material.transparent = this.isTransparent;
}

ObjectGroup.prototype.applyAreaConfiguration = function(areaName){
  if (this.areaVisibilityConfigurations){
    var configurations = this.areaVisibilityConfigurations[areaName];
    if (!(typeof configurations == UNDEFINED)){
      this.mesh.visible = configurations;
    }else{
      this.mesh.visible = true;
    }
  }
  if (this.areaSideConfigurations){
    var configurations = this.areaSideConfigurations[areaName];
    if (!(typeof configurations == UNDEFINED)){
      if (configurations == SIDE_BOTH){
        this.mesh.material.side = THREE.DoubleSide;
      }else if (configurations == SIDE_FRONT){
        this.mesh.material.side = THREE.FrontSide;
      }else if (configurations == SIDE_BACK){
        this.mesh.material.side = THREE.BackSide;
      }
    }else{
      if (this.defaultSide){
        if (this.defaultSide == SIDE_BOTH){
          this.mesh.material.side = THREE.DoubleSide;
        }else if (this.defaultSide == SIDE_FRONT){
          this.mesh.material.side = THREE.FrontSide;
        }else if (this.defaultSide == SIDE_BACK){
          this.mesh.material.side = THREE.BackSide;
        }
      }else{
        this.mesh.material.side = THREE.DoubleSide;
      }
    }
  }
}

ObjectGroup.prototype.getSideInArea = function(areaName){
  if (this.areaSideConfigurations){
    if (!(typeof this.areaSideConfigurations[areaName] == UNDEFINED)){
      return this.areaSideConfigurations[areaName];
    }
  }
  if (this.defaultSide){
    return this.defaultSide;
  }
  return SIDE_BOTH;
}

ObjectGroup.prototype.setSideInArea = function(areaName, side){
  if (!this.areaSideConfigurations){
    this.areaSideConfigurations = new Object();
  }
  this.areaSideConfigurations[areaName] = side;
}

ObjectGroup.prototype.getVisibilityInArea = function(areaName){
  if (this.areaVisibilityConfigurations){
    if (!(typeof this.areaVisibilityConfigurations[areaName] == UNDEFINED)){
      return this.areaVisibilityConfigurations[areaName];
    }
  }
  return true;
}

ObjectGroup.prototype.setVisibilityInArea = function(areaName, isVisible){
  if (!this.areaVisibilityConfigurations){
    this.areaVisibilityConfigurations = new Object();
  }
  this.areaVisibilityConfigurations[areaName] = isVisible;
}

ObjectGroup.prototype.loadState = function(){
  this.physicsBody.position.set(
    this.state.physicsPX, this.state.physicsPY, this.state.physicsPZ
  );
  this.physicsBody.quaternion.set(
    this.state.physicsQX, this.state.physicsQY, this.state.physicsQZ, this.state.physicsQW
  );
  this.physicsBody.angularVelocity.set(
    this.state.physicsAVX, this.state.physicsAVY, this.state.physicsAVZ
  );
  this.physicsBody.velocity.set(
    this.state.physicsVX, this.state.physicsVY, this.state.physicsVZ
  );
  this.mesh.position.set(
    this.state.positionX, this.state.positionY, this.state.positionZ
  );
  this.mesh.quaternion.set(
    this.state.quaternionX, this.state.quaternionY, this.state.quaternionZ, this.state.quaternionW
  );
  if (this.pivotObject){
    delete this.pivotObject;
    delete this.pivotOffsetX;
    delete this.pivotOffsetY;
    delete this.pivotOffsetZ;
  }
  if (this.originalPivotObject){
    this.pivotObject = this.originalPivotObject;
    this.pivotOffsetX = this.originalPivotOffsetX;
    this.pivotOffsetY = this.originalPivotOffsetY;
    this.pivotOffsetZ = this.originalPivotOffsetZ;
  }
}

ObjectGroup.prototype.saveState = function(){
  this.state = new Object();
  this.state.physicsPX = this.physicsBody.position.x;
  this.state.physicsPY = this.physicsBody.position.y;
  this.state.physicsPZ = this.physicsBody.position.z;
  this.state.physicsQX = this.physicsBody.quaternion.x;
  this.state.physicsQY = this.physicsBody.quaternion.y;
  this.state.physicsQZ = this.physicsBody.quaternion.z;
  this.state.physicsQW = this.physicsBody.quaternion.w;
  this.state.physicsAVX = this.physicsBody.angularVelocity.x;
  this.state.physicsAVY = this.physicsBody.angularVelocity.y;
  this.state.physicsAVZ = this.physicsBody.angularVelocity.z;
  this.state.physicsVX = this.physicsBody.velocity.x;
  this.state.physicsVY = this.physicsBody.velocity.y;
  this.state.physicsVZ = this.physicsBody.velocity.z;
  this.state.positionX = this.mesh.position.x;
  this.state.positionY = this.mesh.position.y;
  this.state.positionZ = this.mesh.position.z;
  this.state.quaternionX = this.mesh.quaternion.x;
  this.state.quaternionY = this.mesh.quaternion.y;
  this.state.quaternionZ = this.mesh.quaternion.z;
  this.state.quaternionW = this.mesh.quaternion.w;
  if (this.pivotObject){
    this.originalPivotObject = this.pivotObject;
    this.originalPivotOffsetX = this.pivotOffsetX;
    this.originalPivotOffsetY = this.pivotOffsetY;
    this.originalPivotOffsetZ = this.pivotOffsetZ;
  }
}

ObjectGroup.prototype.areGeometriesIdentical = function(){
  var uuid = 0;
  for (var objName in this.group){
    var obj = this.group[objName];
    if (!uuid){
      uuid = this.group[objName].mesh.geometry.uuid;
    }else{
      if (uuid != this.group[objName].mesh.geometry.uuid){
        return false;
      }
    }
  }
  return true;
}

ObjectGroup.prototype.handleRenderSide = function(val){
  this.renderSide = val;
  if (val == 0){
    this.mesh.material.side = THREE.DoubleSide;
    this.defaultSide = SIDE_BOTH;
  }else if (val == 1){
    this.mesh.material.side = THREE.FrontSide;
    this.defaultSide = SIDE_FRONT;
  }else if (val == 2){
    this.mesh.material.side = THREE.BackSide;
    this.defaultSide = SIDE_BACK;
  }
}

ObjectGroup.prototype.textureCompare = function(txt1, txt2){
  if (txt1.roygbivTextureName != txt2.roygbivTextureName){
    return false;
  }
  if (txt1.roygbivTexturePackName != txt2.roygbivTexturePackName){
    return false;
  }
  if (txt1.offset.x != txt2.offset.x || txt1.offset.y != txt2.offset.y){
    return false;
  }
  if (txt1.repeat.x != txt2.repeat.x || txt1.repeat.y != txt2.repeat.y){
    return false;
  }
  if (txt1.flipX != txt2.flipX || txt1.flipY != txt2.flipY){
    return false;
  }
  if (txt1.wrapS != txt2.wrapS || txt1.wrapT != txt2.wrapT){
    return false;
  }
  return true;
}

ObjectGroup.prototype.handleTextures = function(){
  this.diffuseTexture = 0;
  this.emissiveTexture = 0;
  this.alphaTexture = 0;
  this.aoTexture = 0;
  this.displacementTexture = 0;
  var totalTextureCount = 0;
  for (var objName in this.group){
    var obj = this.group[objName];
    if (obj.hasDiffuseMap()){
      var txt = obj.mesh.material.uniforms.diffuseMap.value;
      if (!this.diffuseTexture){
        this.diffuseTexture = txt;
      }else{
        if (!this.textureCompare(this.diffuseTexture, txt)){
          throw new Error("Cannot merge objects with different texture properties.");
          return;
        }
      }
    }
    if (obj.hasEmissiveMap()){
      var txt = obj.mesh.material.uniforms.emissiveMap.value;
      if (!this.emissiveTexture){
        this.emissiveTexture = txt;
      }else{
        if (!this.textureCompare(this.emissiveTexture, txt)){
          throw new Error("Cannot merge objects with different texture properties.");
          return;
        }
      }
    }
    if (obj.hasAlphaMap()){
      var txt = obj.mesh.material.uniforms.alphaMap.value;
      if (!this.alphaTexture){
        this.alphaTexture = txt;
      }else{
        if (!this.textureCompare(this.alphaTexture, txt)){
          throw new Error("Cannot merge objects with different texture properties.");
          return;
        }
      }
    }
    if (obj.hasAOMap()){
      var txt = obj.mesh.material.uniforms.aoMap.value;
      if (!this.aoTexture){
        this.aoTexture = txt;
      }else{
        if (!this.textureCompare(this.aoTexture, txt)){
          throw new Error("Cannot merge objects with different texture properties.");
          return;
        }
      }
    }
    if (obj.hasDisplacementMap() && VERTEX_SHADER_TEXTURE_FETCH_SUPPORTED){
      var txt = obj.mesh.material.uniforms.displacementMap.value;
      if (!this.displacementTexture){
        this.displacementTexture = txt;
      }else{
        if (!this.textureCompare(this.displacementTexture, txt)){
          throw new Error("Cannot merge objects with different texture properties.");
          return;
        }
      }
    }
  }
  this.hasTexture = (this.diffuseTexture != 0) ||
                    (this.emissiveTexture != 0)  ||
                    (this.alphaTexture != 0) ||
                    (this.aoTexture != 0) ||
                    (this.displacementTexture != 0);
}

ObjectGroup.prototype.push = function(array, value, index, isIndexed){
  if (!isIndexed){
    array.push(value);
  }else{
    array[index] = value;
  }
}

ObjectGroup.prototype.mergeInstanced = function(){
  this.isInstanced = true;
  var refGeometry;
  for (var objName in this.group){
    refGeometry = this.group[objName].mesh.geometry;
    break;
  }
  this.geometry = new THREE.InstancedBufferGeometry();

  this.geometry.setIndex(refGeometry.index);

  var positionOffsets = [], quaternions = [], alphas = [], colors = [], textureInfos = [],
      emissiveIntensities = [], emissiveColors = [], aoIntensities = [], displacementInfos = [],
      textureMatrixInfos = [];
  var count = 0;
  for (var objName in this.group){
    var obj = this.group[objName];
    positionOffsets.push(obj.mesh.position.x);
    positionOffsets.push(obj.mesh.position.y);
    positionOffsets.push(obj.mesh.position.z);
    quaternions.push(obj.mesh.quaternion.x);
    quaternions.push(obj.mesh.quaternion.y);
    quaternions.push(obj.mesh.quaternion.z);
    quaternions.push(obj.mesh.quaternion.w);
    alphas.push(obj.mesh.material.uniforms.alpha.value);
    colors.push(obj.material.color.r);
    colors.push(obj.material.color.g);
    colors.push(obj.material.color.b);
    if (this.emissiveTexture){
      if (obj.hasEmissiveMap()){
        emissiveIntensities.push(obj.mesh.material.uniforms.emissiveIntensity.value);
        emissiveColors.push(obj.mesh.material.uniforms.emissiveColor.value.r);
        emissiveColors.push(obj.mesh.material.uniforms.emissiveColor.value.g);
        emissiveColors.push(obj.mesh.material.uniforms.emissiveColor.value.b);
      }else{
        emissiveIntensities.push(1);
        emissiveColors.push(1);
        emissiveColors.push(1);
        emissiveColors.push(1);
      }
    }
    if (this.aoTexture){
      if (obj.hasAOMap()){
        aoIntensities.push(obj.mesh.material.uniforms.aoIntensity.value);
      }else{
        aoIntensities.push(1);
      }
    }
    if (this.hasTexture){
      if (obj.hasTexture()){
        textureMatrixInfos.push(obj.getTextureOffsetX());
        textureMatrixInfos.push(obj.getTextureOffsetY());
        textureMatrixInfos.push(obj.getTextureRepeatX());
        textureMatrixInfos.push(obj.getTextureRepeatY());
      }else{
        textureMatrixInfos.push(0);
        textureMatrixInfos.push(0);
        textureMatrixInfos.push(0);
        textureMatrixInfos.push(0);
      }
      if (obj.hasDiffuseMap()){
        textureInfos.push(10);
      }else{
        textureInfos.push(-10);
      }
      if (obj.hasEmissiveMap()){
        textureInfos.push(10);
      }else{
        textureInfos.push(-10);
      }
      if (obj.hasAlphaMap()){
        textureInfos.push(10);
      }else{
        textureInfos.push(-10);
      }
      if (obj.hasAOMap()){
        textureInfos.push(10);
      }else{
        textureInfos.push(-10);
      }
      if (obj.hasDisplacementMap()){
        displacementInfos.push(obj.mesh.material.uniforms.displacementInfo.value.x);
        displacementInfos.push(obj.mesh.material.uniforms.displacementInfo.value.y);
      }else{
        displacementInfos.push(-100);
        displacementInfos.push(-100);
      }
    }
    count ++;
  }

  this.geometry.maxInstancedCount = count;

  var positionOffsetBufferAttribute = new THREE.InstancedBufferAttribute(
    new Float32Array(positionOffsets), 3
  );
  var quaternionsBufferAttribute = new THREE.InstancedBufferAttribute(
    new Float32Array(quaternions), 4
  );
  var alphaBufferAttribute = new THREE.InstancedBufferAttribute(
    new Float32Array(alphas), 1
  );
  var colorBufferAttribute = new THREE.InstancedBufferAttribute(
    new Float32Array(colors) , 3
  );
  var textureInfoBufferAttribute;
  var textureMatrixInfosBufferAttribute;
  var emissiveIntensityBufferAttribute;
  var emissiveColorBufferAttribute;
  var aoIntensityBufferAttribute;
  var displacementInfoBufferAttribute;
  if (this.hasTexture){
    textureInfoBufferAttribute = new THREE.InstancedBufferAttribute(
      new Int16Array(textureInfos), 4
    );
    textureMatrixInfosBufferAttribute = new THREE.InstancedBufferAttribute(
      new Float32Array(textureMatrixInfos), 4
    );
    textureInfoBufferAttribute.setDynamic(false);
    textureMatrixInfosBufferAttribute.setDynamic(false);
    this.geometry.addAttribute("textureInfo", textureInfoBufferAttribute);
    this.geometry.addAttribute("textureMatrixInfo", textureMatrixInfosBufferAttribute);
    this.geometry.addAttribute("uv", refGeometry.attributes.uv);
  }
  if (this.emissiveTexture){
    emissiveIntensityBufferAttribute = new THREE.InstancedBufferAttribute(
      new Float32Array(emissiveIntensities), 1
    );
    emissiveColorBufferAttribute = new THREE.InstancedBufferAttribute(
      new Float32Array(emissiveColors), 3
    );
    emissiveIntensityBufferAttribute.setDynamic(false);
    emissiveColorBufferAttribute.setDynamic(false);
    this.geometry.addAttribute("emissiveIntensity", emissiveIntensityBufferAttribute);
    this.geometry.addAttribute("emissiveColor", emissiveColorBufferAttribute);
  }
  if (this.aoTexture){
    aoIntensityBufferAttribute = new THREE.InstancedBufferAttribute(
      new Float32Array(aoIntensities), 1
    );
    aoIntensityBufferAttribute.setDynamic(false);
    this.geometry.addAttribute("aoIntensity", aoIntensityBufferAttribute);
  }
  if (this.displacementTexture){
    displacementInfoBufferAttribute = new THREE.InstancedBufferAttribute(
      new Float32Array(displacementInfos), 2
    );
    displacementInfoBufferAttribute.setDynamic(false);
    this.geometry.addAttribute("displacementInfo", displacementInfoBufferAttribute);
    this.geometry.addAttribute("normal", refGeometry.attributes.normal);
  }

  positionOffsetBufferAttribute.setDynamic(false);
  quaternionsBufferAttribute.setDynamic(false);
  alphaBufferAttribute.setDynamic(false);
  colorBufferAttribute.setDynamic(false);

  this.geometry.addAttribute("positionOffset", positionOffsetBufferAttribute);
  this.geometry.addAttribute("quaternion", quaternionsBufferAttribute);
  this.geometry.addAttribute("alpha", alphaBufferAttribute);
  this.geometry.addAttribute("color", colorBufferAttribute);
  this.geometry.addAttribute("position", refGeometry.attributes.position);

}

ObjectGroup.prototype.merge = function(){

  this.handleTextures();

  if (this.areGeometriesIdentical() && INSTANCING_SUPPORTED){
    this.mergeInstanced();
    return;
  }

  this.geometry = new THREE.BufferGeometry();
  var pseudoGeometry = new THREE.Geometry();

  var isIndexed = true;

  var miMap = new Object();
  var mi = 0;
  for (var childName in this.group){
    var childObj = this.group[childName];
    if (childObj.type == "box" || childObj.type == "sphere" || childObj.type == "cylinder"){
      isIndexed = false;
    }
    var childGeom = childObj.getNormalGeometry();
    miMap[mi] = childObj.name;
    for (var i = 0; i<childGeom.faces.length; i++){
      childGeom.faces[i].materialIndex = mi;
    }
    mi++;
    childObj.mesh.updateMatrix();
    pseudoGeometry.merge(childGeom, childObj.mesh.matrix);
  }

  this.isIndexed = isIndexed;

  var max = 0;
  var indexCache;
  var faces = pseudoGeometry.faces;
  var indexCache;
  if (isIndexed){
    indexCache = new Object();
    for (var i = 0; i<faces.length; i++){
      var face = faces[i];
      var a = face.a;
      var b = face.b;
      var c = face.c;
      if (a > max){
        max = a;
      }
      if (b > max){
        max = b;
      }
      if (c > max){
        max = c;
      }
    }
  }

  var indices = [];
  var vertices = pseudoGeometry.vertices;
  var faceVertexUVs = pseudoGeometry.faceVertexUvs[0];
  var positions, normals, colors, uvs, alphas, emissiveIntensities, emissiveColors, aoIntensities,
            displacementInfos, textureInfos, textureMatrixInfos;
  if (max > 0){
    positions = new Array((max + 1) * 3);
    colors = new Array((max + 1) * 3);
    alphas = new Array(max + 1);
    if (this.displacementTexture){
      normals = new Array((max + 1) * 3);
      displacementInfos = new Array((max + 1) * 2);
    }
    if (this.hasTexture){
      uvs = new Array((max + 1) * 2);
      textureInfos = new Array((max + 1) * 4);
      textureMatrixInfos = new Array((max + 1) * 4);
    }
    if (this.emissiveTexture){
      emissiveIntensities = new Array(max + 1);
      emissiveColors = new Array((max + 1) * 3);
    }
    if (this.aoTexture){
      aoIntensities = new Array(max + 1);
    }
  }else{
    positions = [];
    colors = [];
    alphas = [];
    if (this.displacementTexture){
      normals = [];
      displacementInfos = [];
    }
    if (this.hasTexture){
      uvs = [];
      textureInfos = [];
      textureMatrixInfos = [];
    }
    if (this.emissiveTexture){
      emissiveIntensities = [];
      emissiveColors = [];
    }
    if (this.aoTexture){
      aoIntensities = [];
    }
  }
  for (var i = 0; i<faces.length; i++){
    var face = faces[i];
    var addedObject = addedObjects[miMap[face.materialIndex]];
    var a = face.a;
    var b = face.b;
    var c = face.c;

    var aSkipped = false;
    var bSkipped = false;
    var cSkipped = false;
    if (isIndexed){
      indices.push(a);
      indices.push(b);
      indices.push(c);
      if (indexCache[a]){
        aSkipped = true;
        this.skippedVertexCount ++;
      }else{
        indexCache[a] = true;
      }
      if (indexCache[b]){
        bSkipped = true;
        this.skippedVertexCount ++;
      }else{
        indexCache[b] = true;
      }
      if (indexCache[c]){
        cSkipped = true;
        this.skippedVertexCount ++;
      }else{
        indexCache[c] = true;
      }
    }

    var vertex1 = vertices[a];
    var vertex2 = vertices[b];
    var vertex3 = vertices[c];
    var vertexNormals = face.vertexNormals;
    var vertexNormal1 = vertexNormals[0];
    var vertexNormal2 = vertexNormals[1];
    var vertexNormal3 = vertexNormals[2];
    var color = addedObject.material.color;
    var uv1 = faceVertexUVs[i][0];
    var uv2 = faceVertexUVs[i][1];
    var uv3 = faceVertexUVs[i][2];
    // POSITIONS
    if (!aSkipped){
      this.push(positions, vertex1.x, (3*a), isIndexed);
      this.push(positions, vertex1.y, ((3*a) + 1), isIndexed);
      this.push(positions, vertex1.z, ((3*a) + 2), isIndexed);
    }
    if (!bSkipped){
      this.push(positions, vertex2.x, (3*b), isIndexed);
      this.push(positions, vertex2.y, ((3*b) + 1), isIndexed);
      this.push(positions, vertex2.z, ((3*b) + 2), isIndexed);
    }
    if (!cSkipped){
      this.push(positions, vertex3.x, (3*c), isIndexed);
      this.push(positions, vertex3.y, ((3*c) + 1), isIndexed);
      this.push(positions, vertex3.z, ((3*c) + 2), isIndexed);
    }
    if (this.displacementTexture){
      if (!aSkipped){
        this.push(normals, vertexNormal1.x, (3*a), isIndexed);
        this.push(normals, vertexNormal1.y, ((3*a) + 1), isIndexed);
        this.push(normals, vertexNormal1.z, ((3*a) + 2), isIndexed);
      }
      if (!bSkipped){
        this.push(normals, vertexNormal2.x, (3*b), isIndexed);
        this.push(normals, vertexNormal2.y, ((3*b) + 1), isIndexed);
        this.push(normals, vertexNormal2.z, ((3*b) + 2), isIndexed);
      }
      if (!cSkipped){
        this.push(normals, vertexNormal3.x, (3*c), isIndexed);
        this.push(normals, vertexNormal3.y, ((3*c) + 1), isIndexed);
        this.push(normals, vertexNormal3.z, ((3*c) + 2), isIndexed);
      }
    }
    // COLORS
    if (!aSkipped){
      this.push(colors, color.r, (3*a), isIndexed);
      this.push(colors, color.g, ((3*a) + 1), isIndexed);
      this.push(colors, color.b, ((3*a) + 2), isIndexed);
    }
    if (!bSkipped){
      this.push(colors, color.r, (3*b), isIndexed);
      this.push(colors, color.g, ((3*b) + 1), isIndexed);
      this.push(colors, color.b, ((3*b) + 2), isIndexed);
    }
    if (!cSkipped){
      this.push(colors, color.r, (3*c), isIndexed);
      this.push(colors, color.g, ((3*c) + 1), isIndexed);
      this.push(colors, color.b, ((3*c) + 2), isIndexed);
    }
    // UV
    if (this.hasTexture){
      if (!aSkipped){
        this.push(uvs, uv1.x, (2*a), isIndexed);
        this.push(uvs, uv1.y, ((2*a) + 1), isIndexed);
      }
      if (!bSkipped){
        this.push(uvs, uv2.x, (2*b), isIndexed);
        this.push(uvs, uv2.y, ((2*b) + 1), isIndexed);
      }
      if (!cSkipped){
        this.push(uvs, uv3.x, (2*c), isIndexed);
        this.push(uvs, uv3.y, ((2*c) + 1), isIndexed);
      }
    }
    // DISPLACEMENT INFOS
    if (this.displacementTexture){
      if (!aSkipped){
        if (addedObject.hasDisplacementMap()){
          this.push(
            displacementInfos,
            addedObject.mesh.material.uniforms.displacementInfo.value.x,
            (2*a),
            isIndexed
          );
          this.push(
            displacementInfos,
            addedObject.mesh.material.uniforms.displacementInfo.value.y,
            ((2*a) + 1),
            isIndexed
          );
        }else{
          this.push(displacementInfos, -100, (2*a), isIndexed);
          this.push(displacementInfos, -100, ((2*a) + 1), isIndexed);
        }
      }
      if (!bSkipped){
        if (addedObject.hasDisplacementMap()){
          this.push(
            displacementInfos,
            addedObject.mesh.material.uniforms.displacementInfo.value.x,
            (2*b),
            isIndexed
          );
          this.push(
            displacementInfos,
            addedObject.mesh.material.uniforms.displacementInfo.value.y,
            ((2*b) + 1),
            isIndexed
          );
        }else{
          this.push(displacementInfos, -100, (2*b), isIndexed);
          this.push(displacementInfos, -100, ((2*b) + 1), isIndexed);
        }
      }
      if (!cSkipped){
        if (addedObject.hasDisplacementMap()){
          this.push(
            displacementInfos,
            addedObject.mesh.material.uniforms.displacementInfo.value.x,
            (2*c),
            isIndexed
          );
          this.push(
            displacementInfos,
            addedObject.mesh.material.uniforms.displacementInfo.value.y,
            ((2*c) + 1),
            isIndexed
          );
        }else{
          this.push(displacementInfos, -100, (2*c), isIndexed);
          this.push(displacementInfos, -100, ((2*c) + 1), isIndexed);
        }
      }
    }
    // ALPHA
    var alpha = addedObject.mesh.material.uniforms.alpha.value;
    if (!aSkipped){
      this.push(alphas, alpha, a, isIndexed);
    }
    if (!bSkipped){
      this.push(alphas, alpha, b, isIndexed);
    }
    if (!cSkipped){
      this.push(alphas, alpha, c, isIndexed);
    }
    // EMISSIVE INTENSITY AND EMISSIVE COLOR
    if (this.emissiveTexture){
      var emissiveIntensity;
      if (addedObject.hasEmissiveMap()){
        emissiveIntensity = addedObject.mesh.material.uniforms.emissiveIntensity.value;
      }else{
        emissiveIntensity = 0;
      }
      if (!aSkipped){
        this.push(emissiveIntensities, emissiveIntensity, a, isIndexed);
      }
      if (!bSkipped){
        this.push(emissiveIntensities, emissiveIntensity, b, isIndexed);
      }
      if (!cSkipped){
        this.push(emissiveIntensities, emissiveIntensity, c, isIndexed);
      }
      var emissiveColor;
      if (addedObject.hasEmissiveMap()){
        emissiveColor = addedObject.mesh.material.uniforms.emissiveColor.value;
      }else{
        emissiveColor = WHITE_COLOR;
      }
      if (!aSkipped){
        this.push(emissiveColors, emissiveColor.r, (3*a), isIndexed);
        this.push(emissiveColors, emissiveColor.g, ((3*a) + 1), isIndexed);
        this.push(emissiveColors, emissiveColor.b, ((3*a) + 2), isIndexed);
      }
      if (!bSkipped){
        this.push(emissiveColors, emissiveColor.r, (3*b), isIndexed);
        this.push(emissiveColors, emissiveColor.g, ((3*b) + 1), isIndexed);
        this.push(emissiveColors, emissiveColor.b, ((3*b) + 2), isIndexed);
      }
      if (!cSkipped){
        this.push(emissiveColors, emissiveColor.r, (3*c), isIndexed);
        this.push(emissiveColors, emissiveColor.g, ((3*c) + 1), isIndexed);
        this.push(emissiveColors, emissiveColor.b, ((3*c) + 2), isIndexed);
      }
    }
    // AO INTENSITY
    if (this.aoTexture){
      var aoIntensity;
      if (addedObject.hasAOMap()){
        aoIntensity = addedObject.mesh.material.uniforms.aoIntensity.value;
      }else{
        aoIntensity = 0;
      }
      if (!aSkipped){
        this.push(aoIntensities, aoIntensity, a, isIndexed);
      }
      if (!bSkipped){
        this.push(aoIntensities, aoIntensity, b, isIndexed);
      }
      if (!cSkipped){
        this.push(aoIntensities, aoIntensity, c, isIndexed);
      }
    }
    // TEXTURE INFOS AND TEXTURE MATRIX INFOS
    if (this.hasTexture){
      if (!aSkipped){
        if (addedObject.hasDiffuseMap()){
          this.push(textureInfos, 10, (4*a), isIndexed);
        }else{
          this.push(textureInfos, -10, (4*a), isIndexed);
        }
        if (addedObject.hasEmissiveMap()){
          this.push(textureInfos, 10, ((4*a) + 1), isIndexed);
        }else{
          this.push(textureInfos, -10, ((4*a) + 1), isIndexed);
        }
        if (addedObject.hasAlphaMap()){
          this.push(textureInfos, 10, ((4*a) + 2), isIndexed);
        }else{
          this.push(textureInfos, -10, ((4*a) + 2), isIndexed);
        }
        if (addedObject.hasAOMap()){
          this.push(textureInfos, 10, ((4*a) + 3), isIndexed);
        }else{
          this.push(textureInfos, -10, ((4*a) + 3), isIndexed);
        }
      }
      if (!bSkipped){
        if (addedObject.hasDiffuseMap()){
          this.push(textureInfos, 10, (4*b), isIndexed);
        }else{
          this.push(textureInfos, -10, (4*b), isIndexed);
        }
        if (addedObject.hasEmissiveMap()){
          this.push(textureInfos, 10, ((4*b) + 1), isIndexed);
        }else{
          this.push(textureInfos, -10, ((4*b) + 1), isIndexed);
        }
        if (addedObject.hasAlphaMap()){
          this.push(textureInfos, 10, ((4*b) + 2), isIndexed);
        }else{
          this.push(textureInfos, -10, ((4*b) + 2), isIndexed);
        }
        if (addedObject.hasAOMap()){
          this.push(textureInfos, 10, ((4*b) + 3), isIndexed);
        }else{
          this.push(textureInfos, -10, ((4*b) + 3), isIndexed);
        }
      }
      if (!cSkipped){
        if (addedObject.hasDiffuseMap()){
          this.push(textureInfos, 10, (4*c), isIndexed);
        }else{
          this.push(textureInfos, -10, (4*c), isIndexed);
        }
        if (addedObject.hasEmissiveMap()){
          this.push(textureInfos, 10, ((4*c) + 1), isIndexed);
        }else{
          this.push(textureInfos, -10, ((4*c) + 1), isIndexed);
        }
        if (addedObject.hasAlphaMap()){
          this.push(textureInfos, 10, ((4*c) + 2), isIndexed);
        }else{
          this.push(textureInfos, -10, ((4*c) + 2), isIndexed);
        }
        if (addedObject.hasAOMap()){
          this.push(textureInfos, 10, ((4*c) + 3), isIndexed);
        }else{
          this.push(textureInfos, -10, ((4*c) + 3), isIndexed);
        }
      }
      if (!aSkipped){
        if (addedObject.hasTexture()){
          this.push(textureMatrixInfos, addedObject.getTextureOffsetX(), (4*a), isIndexed);
          this.push(textureMatrixInfos, addedObject.getTextureOffsetY(), ((4*a) + 1), isIndexed);
          this.push(textureMatrixInfos, addedObject.getTextureRepeatX(), ((4*a) + 2), isIndexed);
          this.push(textureMatrixInfos, addedObject.getTextureRepeatY(), ((4*a) + 3), isIndexed);
        }else{
          this.push(textureMatrixInfos, 0, (4*a), isIndexed);
          this.push(textureMatrixInfos, 0, ((4*a) + 1), isIndexed);
          this.push(textureMatrixInfos, 0, ((4*a) + 2), isIndexed);
          this.push(textureMatrixInfos, 0, ((4*a) + 3), isIndexed);
        }
      }
      if (!bSkipped){
        if (addedObject.hasTexture()){
          this.push(textureMatrixInfos, addedObject.getTextureOffsetX(), (4*b), isIndexed);
          this.push(textureMatrixInfos, addedObject.getTextureOffsetY(), ((4*b) + 1), isIndexed);
          this.push(textureMatrixInfos, addedObject.getTextureRepeatX(), ((4*b) + 2), isIndexed);
          this.push(textureMatrixInfos, addedObject.getTextureRepeatY(), ((4*b) + 3), isIndexed);
        }else{
          this.push(textureMatrixInfos, 0, (4*b), isIndexed);
          this.push(textureMatrixInfos, 0, ((4*b) + 1), isIndexed);
          this.push(textureMatrixInfos, 0, ((4*b) + 2), isIndexed);
          this.push(textureMatrixInfos, 0, ((4*b) + 3), isIndexed);
        }
      }
      if (!cSkipped){
        if (addedObject.hasTexture()){
          this.push(textureMatrixInfos, addedObject.getTextureOffsetX(), (4*c), isIndexed);
          this.push(textureMatrixInfos, addedObject.getTextureOffsetY(), ((4*c) + 1), isIndexed);
          this.push(textureMatrixInfos, addedObject.getTextureRepeatX(), ((4*c) + 2), isIndexed);
          this.push(textureMatrixInfos, addedObject.getTextureRepeatY(), ((4*c) + 3), isIndexed);
        }else{
          this.push(textureMatrixInfos, 0, (4*c), isIndexed);
          this.push(textureMatrixInfos, 0, ((4*c) + 1), isIndexed);
          this.push(textureMatrixInfos, 0, ((4*c) + 2), isIndexed);
          this.push(textureMatrixInfos, 0, ((4*c) + 3), isIndexed);
        }
      }
    }
  }

  var positionsTypedArray = new Float32Array(positions);
  var colorsTypedArray = new Float32Array(colors);
  var alphasTypedArray = new Float32Array(alphas);

  if (this.displacementTexture){
    var normalsTypedArray = new Float32Array(normals);
    var displacementInfosTypedArray = new Float32Array(displacementInfos);
    var normalsBufferAttribute = new THREE.BufferAttribute(normalsTypedArray, 3);
    var displacementInfosBufferAttribute = new THREE.BufferAttribute(displacementInfosTypedArray, 2);
    normalsBufferAttribute.setDynamic(false);
    displacementInfosBufferAttribute.setDynamic(false);
    this.geometry.addAttribute('normal', normalsBufferAttribute);
    this.geometry.addAttribute('displacementInfo', displacementInfosBufferAttribute);
  }
  if (this.hasTexture){
    var uvsTypedArray = new Float32Array(uvs);
    var textureInfosTypedArray = new Int8Array(textureInfos);
    var textureMatrixInfosTypedArray = new Float32Array(textureMatrixInfos);
    var uvsBufferAttribute = new THREE.BufferAttribute(uvsTypedArray, 2);
    var textureInfosBufferAttribute = new THREE.BufferAttribute(textureInfosTypedArray, 4);
    var textureMatrixInfosBufferAttribute = new THREE.BufferAttribute(textureMatrixInfosTypedArray, 4);
    uvsBufferAttribute.setDynamic(false);
    textureInfosBufferAttribute.setDynamic(false);
    textureMatrixInfosBufferAttribute.setDynamic(false);
    this.geometry.addAttribute('uv', uvsBufferAttribute);
    this.geometry.addAttribute('textureInfo', textureInfosBufferAttribute);
    this.geometry.addAttribute('textureMatrixInfo', textureMatrixInfosBufferAttribute);
  }
  if (this.emissiveTexture){
    var emissiveIntensitiesTypedArray = new Float32Array(emissiveIntensities);
    var emissiveColorsTypedArray = new Float32Array(emissiveColors);
    var emissiveIntensitiesBufferAttribute = new THREE.BufferAttribute(emissiveIntensitiesTypedArray, 1);
    var emissiveColorsBufferAttribute = new THREE.BufferAttribute(emissiveColorsTypedArray, 3);
    emissiveIntensitiesBufferAttribute.setDynamic(false);
    emissiveColorsBufferAttribute.setDynamic(false);
    this.geometry.addAttribute('emissiveIntensity', emissiveIntensitiesBufferAttribute);
    this.geometry.addAttribute('emissiveColor', emissiveColorsBufferAttribute);
  }
  if (this.aoTexture){
    var aoIntensitiesTypedArray = new Float32Array(aoIntensities);
    var aoIntensitiesBufferAttribute = new THREE.BufferAttribute(aoIntensitiesTypedArray, 1);
    aoIntensitiesBufferAttribute.setDynamic(false);
    this.geometry.addAttribute('aoIntensity', aoIntensitiesBufferAttribute);
  }

  var positionsBufferAttribute = new THREE.BufferAttribute(positionsTypedArray, 3);
  var colorsBufferAttribute = new THREE.BufferAttribute(colorsTypedArray, 3);
  var alphasBufferAttribute = new THREE.BufferAttribute(alphasTypedArray, 1);

  positionsBufferAttribute.setDynamic(false);
  colorsBufferAttribute.setDynamic(false);
  alphasBufferAttribute.setDynamic(false);

  if (isIndexed){
    var indicesTypedArray = new Uint16Array(indices);
    var indicesBufferAttribute = new THREE.BufferAttribute(indicesTypedArray, 1);
    indicesBufferAttribute.setDynamic(false);
    this.geometry.setIndex(indicesBufferAttribute);
  }

  this.geometry.addAttribute('position', positionsBufferAttribute);
  this.geometry.addAttribute('color', colorsBufferAttribute);
  this.geometry.addAttribute('alpha', alphasBufferAttribute);

  pseudoGeometry = null;
}

ObjectGroup.prototype.glue = function(){
  var group = this.group;
  var physicsMaterial = new CANNON.Material();
  var physicsBody = new CANNON.Body({mass: 0, material: physicsMaterial});
  var centerPosition = this.getInitialCenter();
  var graphicsGroup = new THREE.Group();
  var centerX = centerPosition.x;
  var centerY = centerPosition.y;
  var centerZ = centerPosition.z;
  var referenceVector = new CANNON.Vec3(
    centerX, centerY, centerZ
  );
  var referenceVectorTHREE = new THREE.Vector3(
    centerX, centerY, centerZ
  );

  physicsBody.position = referenceVector;
  graphicsGroup.position.copy(physicsBody.position);

  var gridSystemNamesMap = new Object();

  var hasAnyPhysicsShape = false;
  for (var objectName in group){
    var addedObject = group[objectName];
    addedObject.setAttachedProperties();

    this.totalVertexCount += addedObject.mesh.geometry.attributes.position.count;
    // GLUE PHYSICS ************************************************
    if (!addedObject.noMass){
      var shape = addedObject.physicsBody.shapes[0];
      physicsBody.addShape(shape, addedObject.physicsBody.position.vsub(referenceVector), addedObject.physicsBody.quaternion);
      hasAnyPhysicsShape = true;
    }
    // GLUE GRAPHICS ***********************************************
    addedObject.mesh.position.sub(referenceVectorTHREE);
    graphicsGroup.add(addedObject.mesh);
    // PREPARE GRAPHICS FOR CLICK EVENTS ***************************
    addedObject.mesh.addedObject = 0;
    addedObject.mesh.objectGroupName = this.name;
    // TO MANAGE CLICK EVENTS
    if (addedObject.destroyedGrids){
      for (var gridName in addedObject.destroyedGrids){
        addedObject.destroyedGrids[gridName].destroyedObjectGroup = this.name;
      }
    }
    // THESE ARE USEFUL FOR SCRIPTING
    addedObject.parentObjectName = this.name;
    this.childObjectsByName[addedObject.name] = addedObject;
    // THESE ARE NECESSARY FOR BVHANDLER
    gridSystemNamesMap[addedObject.metaData.gridSystemName] = true;
    addedObjectsInsideGroups[addedObject.name] = addedObject;
    addedObject.indexInParent = graphicsGroup.children.length - 1;

  }

  this.gridSystemNames = Object.keys(gridSystemNamesMap);

  physicsBody.addedObject = this;

  this.merge();
  this.destroyParts();
  var meshGenerator = new MeshGenerator(this.geometry);
  if (!this.isInstanced){
    this.mesh = meshGenerator.generateMergedMesh(graphicsGroup, this);
  }else{
    this.mesh = meshGenerator.generateInstancedMesh(graphicsGroup, this);
    this.mesh.frustumCulled = false;
  }

  if (this.aoTexture){
    this.injectMacro("HAS_AO", true, true);
  }
  if (this.emissiveTexture){
    this.injectMacro("HAS_EMISSIVE", true, true);
  }
  if (this.diffuseTexture){
    this.injectMacro("HAS_DIFFUSE", true, true);
  }
  if (this.alphaTexture){
    this.injectMacro("HAS_ALPHA", true, true);
  }
  if (this.displacementTexture && VERTEX_SHADER_TEXTURE_FETCH_SUPPORTED){
    this.injectMacro("HAS_DISPLACEMENT", true, false);
  }
  if (this.hasTexture){
    this.injectMacro("HAS_TEXTURE", true, true);
  }

  this.mesh.objectGroupName = this.name;
  scene.add(this.mesh);
  if (hasAnyPhysicsShape){
    physicsWorld.addBody(physicsBody);
  }else{
    this.noMass = true;
    this.cannotSetMass = true;
  }

  this.graphicsGroup = graphicsGroup;

  this.graphicsGroup.position.copy(this.mesh.position);
  this.graphicsGroup.quaternion.copy(this.mesh.quaternion);
  this.graphicsGroup.updateMatrix();

  this.physicsBody = physicsBody;
  this.initQuaternion = this.graphicsGroup.quaternion.clone();

  this.collisionCallbackFunction = function(collisionEvent){
    if (!collisionEvent.body.addedObject || (!this.isVisibleOnThePreviewScene() && !this.physicsKeptWhenHidden)){
      return;
    }
    if (isPhysicsWorkerEnabled()){
      // WE WILL HANDLE PHYSICS CALCULATIONS INSIDE THE WORKER
      return;
    }
    var targetObjectName = collisionEvent.target.addedObject.name;
    var contact = collisionEvent.contact;
    var collisionPosition = new Object();
    var collisionImpact = contact.getImpactVelocityAlongNormal();
    collisionPosition.x = contact.bi.position.x + contact.ri.x;
    collisionPosition.y = contact.bi.position.y + contact.ri.y;
    collisionPosition.z = contact.bi.position.z + contact.ri.z;
    var quatX = this.mesh.quaternion.x;
    var quatY = this.mesh.quaternion.y;
    var quatZ = this.mesh.quaternion.z;
    var quatW = this.mesh.quaternion.w;
    var collisionInfo = reusableCollisionInfo.set(
      targetObjectName,
      collisionPosition.x,
      collisionPosition.y,
      collisionPosition.z,
      collisionImpact,
      quatX,
      quatY,
      quatZ,
      quatW
    );
    var curCollisionCallbackRequest = collisionCallbackRequests[this.name];
    if (curCollisionCallbackRequest){
      curCollisionCallbackRequest(collisionInfo);
    }
  };

  this.physicsBody.addEventListener(
    "collide",
    this.collisionCallbackFunction.bind(this)
  );

  this.gridSystemName = this.group[Object.keys(this.group)[0]].metaData.gridSystemName;
}

ObjectGroup.prototype.destroyParts = function(){
  for (var objName in this.group){
    var addedObject = addedObjects[objName];
    if (addedObject){
      addedObject.destroy();
      delete addedObjects[objName];
      disabledObjectNames[objName] = 1;
    }
  }
}

ObjectGroup.prototype.detach = function(){
  this.graphicsGroup.position.copy(this.mesh.position);
  this.graphicsGroup.quaternion.copy(this.mesh.quaternion);
  this.graphicsGroup.updateMatrixWorld();
  var worldQuaternions = new Object();
  var worldPositions = new Object();
  var previewSceneWorldPositions = new Object();
  var previewSceneWorldQuaternions = new Object();
  var physicsQuaternions = new Object();
  for (var objectName in this.group){
    if (mode == 0){
      worldQuaternions[objectName] = this.group[objectName].mesh.getWorldQuaternion(REUSABLE_QUATERNION);
      worldQuaternions[objectName] = REUSABLE_QUATERNION.clone();
      this.group[objectName].mesh.getWorldPosition(REUSABLE_VECTOR);
      worldPositions[objectName] = REUSABLE_VECTOR.clone();
    }else if (mode == 1){
      this.group[objectName].mesh.getWorldQuaternion(REUSABLE_QUATERNION);
      worldQuaternions[objectName] = REUSABLE_QUATERNION.clone();
      this.group[objectName].mesh.getWorldPosition(REUSABLE_VECTOR);
      worldPositions[objectName] = REUSABLE_VECTOR.clone();
    }
    if (this.physicsBody.initQuaternion instanceof THREE.Quaternion){
      this.physicsBody.initQuaternion = new CANNON.Quaternion().copy(this.physicsBody.initQuaternion);
    }
    if (this.physicsBody.initQuaternion.x == 0 && this.physicsBody.initQuaternion.y == 0 &&
              this.physicsBody.initQuaternion.z == 0 && this.physicsBody.initQuaternion.w == 1){
        if (this.group[objectName].type != "ramp"){
          physicsQuaternions[objectName] = this.group[objectName].physicsBody.initQuaternion;
        }else{
          physicsQuaternions[objectName] = this.physicsBody.initQuaternion;
        }
    }else{
      if (this.group[objectName].type != "ramp"){
        var cloneQuaternion = new CANNON.Quaternion().copy(this.physicsBody.initQuaternion);
        physicsQuaternions[objectName] = cloneQuaternion.mult(this.group[objectName].physicsBody.initQuaternion);
      }else{
        physicsQuaternions[objectName] = this.physicsBody.initQuaternion;
      }
    }
  }
  for (var i = this.graphicsGroup.children.length -1; i>=0; i--){
    this.graphicsGroup.remove(this.graphicsGroup.children[i]);
  }

  this.destroy(true);
  for (var objectName in this.group){
    var addedObject = this.group[objectName];

    if (!addedObject.noMass){
      physicsWorld.add(addedObject.physicsBody);
    }
    scene.add(addedObject.mesh);

    addedObject.mesh.objectGroupName = 0;
    addedObject.mesh.addedObject = addedObject;

    addedObjects[objectName] = addedObject;

    if (addedObject.destroyedGrids){
      for (var gridName in addedObject.destroyedGrids){
        addedObject.destroyedGrids[gridName].destroyedAddedObject = addedObject.name;
      }
    }
    delete addedObject.parentObjectName;
    delete addedObjectsInsideGroups[addedObject.name];
    delete addedObject.indexInParent;

    addedObject.mesh.position.set(
      addedObject.positionXWhenAttached,
      addedObject.positionYWhenAttached,
      addedObject.positionZWhenAttached
    );
    addedObject.physicsBody.position.set(
      addedObject.positionXWhenAttached,
      addedObject.positionYWhenAttached,
      addedObject.positionZWhenAttached
    );
    addedObject.physicsBody.initPosition.copy(addedObject.physicsBody.position);
    addedObject.mesh.quaternion.set(
      addedObject.qxWhenAttached,
      addedObject.qyWhenAttached,
      addedObject.qzWhenAttached,
      addedObject.qwWhenAttached
    );
    addedObject.physicsBody.quaternion.set(
      addedObject.pqxWhenAttached,
      addedObject.pqyWhenAttached,
      addedObject.pqzWhenAttached,
      addedObject.pqwWhenAttached
    );
    addedObject.physicsBody.initQuaternion.copy(addedObject.physicsBody.quaternion);

    delete addedObject.positionXWhenAttached;
    delete addedObject.positionYWhenAttached;
    delete addedObject.positionZWhenAttached;
    delete addedObject.qxWhenAttached;
    delete addedObject.qyWhenAttached;
    delete addedObjects.qzWhenAttached;
    delete addedObject.qwWhenAttached;
    delete addedObject.pqxWhenAttached;
    delete addedObject.pqyWhenAttached;
    delete addedObject.pqzWhenAttached;
    delete addedObject.pqwWhenAttached;

  }

  rayCaster.refresh();

}

ObjectGroup.prototype.setQuaternion = function(axis, val){
  if (axis == "x"){
    this.graphicsGroup.quaternion.x = val;
    this.physicsBody.quaternion.x = val;
    this.initQuaternion.x = val;
    this.physicsBody.initQuaternion.x = val;
    this.mesh.quaternion.x = val;
  }else if (axis == "y"){
    this.graphicsGroup.quaternion.y = val;

    this.physicsBody.quaternion.y = val;
    this.initQuaternion.y = val;
    this.physicsBody.initQuaternion.y = val;
    this.mesh.quaternion.y = val;
  }else if (axis == "z"){
    this.graphicsGroup.quaternion.z = val;
    this.physicsBody.quaternion.z = val;
    this.initQuaternion.z = val;
    this.physicsBody.initQuaternion.z = val;
    this.mesh.quaternion.z = val;
  }else if (axis == "w"){
    this.graphicsGroup.quaternion.w = val;
    this.physicsBody.quaternion.w = val;
    this.initQuaternion.w = val;
    this.physicsBody.initQuaternion.w = val;
    this.mesh.quaternion.w = val;
  }
}

ObjectGroup.prototype.rotate = function(axis, radian, fromScript){
  if (axis == "x"){
    this.mesh.rotateOnWorldAxis(
      THREE_AXIS_VECTOR_X,
      radian
    );
  }else if (axis == "y"){
    this.mesh.rotateOnWorldAxis(
      THREE_AXIS_VECTOR_Y,
      radian
    );
  }else if (axis == "z"){
    this.mesh.rotateOnWorldAxis(
      THREE_AXIS_VECTOR_Z,
      radian
    );
  }

  this.physicsBody.quaternion.copy(this.mesh.quaternion);
  this.graphicsGroup.quaternion.copy(this.mesh.quaternion);

  if (!fromScript){
    this.initQuaternion = this.mesh.quaternion.clone();
    this.physicsBody.initQuaternion.copy(
      this.physicsBody.quaternion
    );
    if (axis == "x"){
      this.rotationX += radian;
    }else if (axis == "y"){
      this.rotationY += radian;
    }else if (axis == "z"){
      this.rotationZ += radian;
    }
  }

  if (this.mesh.visible){
    rayCaster.updateObject(this);
  }

}

ObjectGroup.prototype.translate = function(axis, amount, fromScript){
  var physicsBody = this.physicsBody;
  if (axis == "x"){
    this.mesh.translateX(amount);
  }else if (axis == "y"){
    this.mesh.translateY(amount);
  }else if (axis == "z"){
    this.mesh.translateZ(amount);
  }
  physicsBody.position.copy(this.mesh.position);
  this.graphicsGroup.position.copy(this.mesh.position);
  if (this.mesh.visible){
    rayCaster.updateObject(this);
  }
}

ObjectGroup.prototype.destroy = function(isUndo){
  this.removeBoundingBoxesFromScene();
  scene.remove(this.mesh);
  physicsWorld.remove(this.physicsBody);
  for (var name in this.group){
    var childObj= this.group[name];
    if (childObj.destroyedGrids){
      for (var gridName in childObj.destroyedGrids){
        if (!isUndo){
          delete childObj.destroyedGrids[gridName].destroyedAddedObject;
        }else{
          childObj.destroyedGrids[gridName].destroyedAddedObject = childObj.name;
        }
        delete childObj.destroyedGrids[gridName].destroyedObjectGroup;
      }
    }
    this.group[name].dispose();
    delete disabledObjectNames[name];
  }
  this.mesh.material.dispose();
  this.mesh.geometry.dispose();

  rayCaster.refresh();

}

ObjectGroup.prototype.export = function(){
  var exportObj = new Object();
  exportObj.name = this.name;
  exportObj.group = new Object();
  for (var objectName in this.group){
    exportObj.group[objectName] = this.group[objectName].export();
  }
  exportObj.mass = this.mass;
  if (!this.mass){
    exportObj.mass = 0;
  }

  if (this.isDynamicObject){
    exportObj.isDynamicObject = this.isDynamicObject;
  }

  if (this.isSlippery){
    exportObj.isSlippery = true;
  }else{
    exportObj.isSlippery = false;
  }

  if (this.isChangeable){
    exportObj.isChangeable = true;
  }else{
    exportObj.isChangeable = false;
  }
  if (this.isColorizable){
    exportObj.isColorizable = true;
  }else{
    exportObj.isColorizable = false;
  }

  if (this.noMass){
    exportObj.noMass = true;
  }else{
    exportObj.noMass = false;
  }

  exportObj.quaternionX = this.initQuaternion.x;
  exportObj.quaternionY = this.initQuaternion.y;
  exportObj.quaternionZ = this.initQuaternion.z;
  exportObj.quaternionW = this.initQuaternion.w;

  exportObj.isBasicMaterial = this.isBasicMaterial;

  var blendingModeInt = this.mesh.material.blending;
  if (blendingModeInt == NO_BLENDING){
    exportObj.blendingMode = "NO_BLENDING";
  }else if (blendingModeInt == NORMAL_BLENDING){
    exportObj.blendingMode = "NORMAL_BLENDING";
  }else if (blendingModeInt == ADDITIVE_BLENDING){
    exportObj.blendingMode = "ADDITIVE_BLENDING";
  }else if (blendingModeInt == SUBTRACTIVE_BLENDING){
    exportObj.blendingMode = "SUBTRACTIVE_BLENDING";
  }else if (blendingModeInt == MULTIPLY_BLENDING){
    exportObj.blendingMode = "MULTIPLY_BLENDING";
  }

  if (this.renderSide){
    exportObj.renderSide = this.renderSide;
  }

  if (this.areaVisibilityConfigurations){
    exportObj.areaVisibilityConfigurations = this.areaVisibilityConfigurations;
  }
  if (this.areaSideConfigurations){
    exportObj.areaSideConfigurations = this.areaSideConfigurations;
  }

  if (this.pivotObject){
    exportObj.hasPivot = true;
    exportObj.pivotOffsetX = this.pivotOffsetX;
    exportObj.pivotOffsetY = this.pivotOffsetY;
    exportObj.pivotOffsetZ = this.pivotOffsetZ;
    exportObj.positionX = this.mesh.position.x;
    exportObj.positionY = this.mesh.position.y;
    exportObj.positionZ = this.mesh.position.z;
    exportObj.quaternionX = this.mesh.quaternion.x;
    exportObj.quaternionY = this.mesh.quaternion.y;
    exportObj.quaternionZ = this.mesh.quaternion.z;
    exportObj.quaternionW = this.mesh.quaternion.w;
    exportObj.pivotQX = this.pivotObject.quaternion.x;
    exportObj.pivotQY = this.pivotObject.quaternion.y;
    exportObj.pivotQZ = this.pivotObject.quaternion.z;
    exportObj.pivotQW = this.pivotObject.quaternion.w;
    exportObj.insidePivotQX = this.pivotObject.children[0].quaternion.x;
    exportObj.insidePivotQY = this.pivotObject.children[0].quaternion.y;
    exportObj.insidePivotQZ = this.pivotObject.children[0].quaternion.z;
    exportObj.insidePivotQW = this.pivotObject.children[0].quaternion.w;
  }else if (this.pivotRemoved){
    exportObj.pivotRemoved = true;
    exportObj.positionX = this.mesh.position.x;
    exportObj.positionY = this.mesh.position.y;
    exportObj.positionZ = this.mesh.position.z;
    exportObj.quaternionX = this.mesh.quaternion.x;
    exportObj.quaternionY = this.mesh.quaternion.y;
    exportObj.quaternionZ = this.mesh.quaternion.z;
    exportObj.quaternionW = this.mesh.quaternion.w;
  }

  if (this.softCopyParentName){
    exportObj.softCopyParentName = this.softCopyParentName;
  }

  exportObj.totalAlpha = this.mesh.material.uniforms.totalAlpha.value;
  if (this.mesh.material.uniforms.totalAOIntensity){
    exportObj.totalAOIntensity = this.mesh.material.uniforms.totalAOIntensity.value;
  }
  if (this.mesh.material.uniforms.totalEmissiveIntensity){
    exportObj.totalEmissiveIntensity = this.mesh.material.uniforms.totalEmissiveIntensity.value;
  }
  if (this.mesh.material.uniforms.totalEmissiveColor){
    exportObj.totalEmissiveColor = "#"+this.mesh.material.uniforms.totalEmissiveColor.value.getHexString();
  }

  return exportObj;
}

ObjectGroup.prototype.getInitialCenter = function(){
  var group = this.group;
  var centerX = 0;
  var centerY = 0;
  var centerZ = 0;
  var count = 0;
  for (var objectName in group){
    var bodyPosition = group[objectName].physicsBody.position;
    count ++;
    centerX += bodyPosition.x;
    centerY += bodyPosition.y;
    centerZ += bodyPosition.z;
  }
  centerX = centerX / count;
  centerY = centerY / count;
  centerZ = centerZ / count;
  var obj = new Object();
  obj.x = centerX;
  obj.y = centerY;
  obj.z = centerZ;
  return obj;
}

ObjectGroup.prototype.setMass = function(mass){
  if (mass != 0){
    this.isDynamicObject = true;
    this.physicsBody.type = CANNON.Body.DYNAMIC;
  }else{
    this.isDynamicObject = false;
    this.physicsBody.type = CANNON.Body.STATIC;
  }
  this.physicsBody.mass = mass;
  this.physicsBody.updateMassProperties();
  this.physicsBody.aabbNeedsUpdate = true;
  this.mass = mass;
}

ObjectGroup.prototype.isVisibleOnThePreviewScene = function(){
  return !(this.isHidden);
}

ObjectGroup.prototype.setBlending = function(blendingModeInt){
  this.mesh.material.blending = blendingModeInt;
  if (blendingModeInt == NO_BLENDING){
    this.blendingMode = "NO_BLENDING";
  }else if (blendingModeInt == NORMAL_BLENDING){
    this.blendingMode = "NORMAL_BLENDING";
  }else if (blendingModeInt == ADDITIVE_BLENDING){
    this.blendingMode = "ADDITIVE_BLENDING";
  }else if (blendingModeInt == SUBTRACTIVE_BLENDING){
    this.blendingMode = "SUBTRACTIVE_BLENDING";
  }else if (blendingModeInt == MULTIPLY_BLENDING){
    this.blendingMode = "MULTIPLY_BLENDING";
  }
}

ObjectGroup.prototype.getBlendingText = function(){
  var blendingModeInt = this.mesh.material.blending;
  if (blendingModeInt == NO_BLENDING){
    return "None";
  }else if (blendingModeInt == NORMAL_BLENDING){
    return "Normal";
  }else if (blendingModeInt == ADDITIVE_BLENDING){
    return "Additive";
  }else if (blendingModeInt == SUBTRACTIVE_BLENDING){
    return "Subtractive";
  }else if (blendingModeInt == MULTIPLY_BLENDING){
    return "Multiply";
  }
}

ObjectGroup.prototype.updateBoundingBoxes = function(){
  this.graphicsGroup.position.copy(this.mesh.position);
  this.graphicsGroup.quaternion.copy(this.mesh.quaternion);
  this.graphicsGroup.updateMatrixWorld();
  for (var objName in this.group){
    this.group[objName].updateBoundingBoxes(this.boundingBoxes);
  }
}

ObjectGroup.prototype.generateBoundingBoxes = function(){
  if (!this.mesh){
    return;
  }
  this.boundingBoxes = [];
  this.mesh.updateMatrixWorld();
  this.graphicsGroup.position.copy(this.mesh.position);
  this.graphicsGroup.quaternion.copy(this.mesh.quaternion);
  this.graphicsGroup.updateMatrixWorld();
  for (var objName in this.group){
    this.group[objName].generateBoundingBoxes(this.boundingBoxes);
  }
}

ObjectGroup.prototype.visualiseBoundingBoxes = function(){
  if (this.bbHelper){
    scene.remove(this.bbHelper);
  }
  var box3 = new THREE.Box3();
  for (var objName in this.group){
    var boundingBoxes = this.group[objName].boundingBoxes;
    for (var i = 0; i < boundingBoxes.length; i++){
      box3.expandByPoint(boundingBoxes[i].min);
      box3.expandByPoint(boundingBoxes[i].max);
    }
  }
  this.bbHelper = new THREE.Box3Helper(box3, LIME_COLOR);
  scene.add(this.bbHelper);
}

ObjectGroup.prototype.removeBoundingBoxesFromScene = function(){
  if (this.bbHelper){
    scene.remove(this.bbHelper);
  }
}

ObjectGroup.prototype.setSlippery = function(isSlippery){
  if (isSlippery){
    if (!isPhysicsWorkerEnabled()){
      this.setFriction(0);
    }
    this.isSlippery = true;
  }else{
    if (!isPhysicsWorkerEnabled()){
      this.setFriction(friction);
    }
    this.isSlippery = false;
  }
}

ObjectGroup.prototype.setFriction = function(val){
  var physicsMaterial = this.physicsBody.material;
  for (var objName in addedObjects){
    var otherMaterial = addedObjects[objName].physicsBody.material;
    var contact = physicsWorld.getContactMaterial(physicsMaterial, otherMaterial);
    if (contact){
      contact.friction = val;
    }else{
      contact = new CANNON.ContactMaterial(physicsMaterial,otherMaterial, {
        friction: val,
        restitution: 0.3,
        contactEquationStiffness: 1e8,
        contactEquationRelaxation: 3
      });
      physicsWorld.addContactMaterial(contact);
    }
  }
  for (var objName in objectGroups){
    if (objName == this.name){
      continue;
    }
    var otherMaterial = objectGroups[objName].physicsBody.material;
    var contact = physicsWorld.getContactMaterial(physicsMaterial, otherMaterial);
    if (contact){
      contact.friction = val;
    }else{
      contact = new CANNON.ContactMaterial(physicsMaterial, otherMaterial, {
        friction: val,
        restitution: 0.3,
        contactEquationStiffness: 1e8,
        contactEquationRelaxation: 3
      });
      physicsWorld.addContactMaterial(contact);
    }
  }
}

ObjectGroup.prototype.makePivot = function(offsetX, offsetY, offsetZ){
  var obj = this;
  var pseudoMesh = new THREE.Mesh(obj.mesh.geometry, obj.mesh.material);
  pseudoMesh.position.copy(obj.mesh.position);
  pseudoMesh.quaternion.copy(obj.mesh.quaternion);
  var pivot = new THREE.Object3D();
  pivot.add(pseudoMesh);
  pivot.position.set(
    pseudoMesh.position.x + offsetX,
    pseudoMesh.position.y + offsetY,
    pseudoMesh.position.z + offsetZ
  );
  pseudoMesh.position.x = -offsetX;
  pseudoMesh.position.y = -offsetY;
  pseudoMesh.position.z = -offsetZ;
  pivot.pseudoMesh = pseudoMesh;
  pivot.offsetX = offsetX;
  pivot.offsetY = offsetY;
  pivot.offsetZ = offsetZ;
  pivot.rotation.order = 'YXZ';
  pivot.sourceObject = this;
  return pivot;
}

ObjectGroup.prototype.rotateAroundPivotObject = function(axis, radians){
  if (!this.pivotObject){
    return;
  }
  this.updatePivot();
  this.pivotObject.updateMatrix();
  this.pivotObject.updateMatrixWorld();
  if (axis == "x"){
    this.pivotObject.rotation.x += radians;
  }else if (axis == "y"){
    this.pivotObject.rotation.y += radians;
  }else if (axis == "z"){
    this.pivotObject.rotation.z += radians;
  }
  this.pivotObject.updateMatrix();
  this.pivotObject.updateMatrixWorld();
  this.pivotObject.pseudoMesh.updateMatrix();
  this.pivotObject.pseudoMesh.updateMatrixWorld();
  this.pivotObject.pseudoMesh.matrixWorld.decompose(REUSABLE_VECTOR, REUSABLE_QUATERNION, REUSABLE_VECTOR_2);
  this.mesh.position.copy(REUSABLE_VECTOR);
  this.mesh.quaternion.copy(REUSABLE_QUATERNION);
  this.physicsBody.quaternion.copy(this.mesh.quaternion);
  this.physicsBody.position.copy(this.mesh.position);
  if (this.mesh.visible){
    rayCaster.updateObject(this);
  }
}

ObjectGroup.prototype.updatePivot = function(){
  if (!this.pivotObject){
    return;
  }
  this.pivotObject.position.copy(this.mesh.position);
  this.pivotObject.translateX(this.pivotOffsetX);
  this.pivotObject.translateY(this.pivotOffsetY);
  this.pivotObject.translateZ(this.pivotOffsetZ);
}

ObjectGroup.prototype.copy = function(name, isHardCopy, copyPosition, gridSystem, fromScript){
  var positionBeforeDetached = this.mesh.position.clone();
  var quaternionBeforeDetached = this.mesh.quaternion.clone();
  var physicsPositionBeforeDetached = this.physicsBody.position.clone();
  var physicsQuaternionBeforeDetached = this.physicsBody.quaternion.clone();
  var initQuaternionBeforeDetached = this.initQuaternion.clone();
  var massWhenDetached = this.physicsBody.mass;
  var noMass = this.noMass;
  var slippery = this.isSlippery;
  var isChangeable = this.isChangeable;
  var isColorizable = this.isColorizable;
  var renderSide = this.renderSide;
  var blending = this.mesh.material.blending;
  var totalAlphaBeforeDetached = this.mesh.material.uniforms.totalAlpha.value;
  var totalAOIntensityBeforeDetached;
  var totalEmissiveIntensityBeforeDetached;
  var totalEmissiveColorBeforeDetached;
  var oldMaterial = this.mesh.material;
  if (this.mesh.material.uniforms.totalAOIntensity){
    totalAOIntensityBeforeDetached = this.mesh.material.uniforms.totalAOIntensity.value;
  }
  if (this.mesh.material.uniforms.totalEmissiveIntensity){
    totalEmissiveIntensityBeforeDetached = this.mesh.material.uniforms.totalEmissiveIntensity.value;
  }
  if (this.mesh.material.uniforms.totalEmissiveColor){
    totalEmissiveColorBeforeDetached = this.mesh.material.uniforms.totalEmissiveColor.value;
  }
  var isTransparentBeforeDetached = this.mesh.material.transparent;
  this.detach();
  var newGroup = new Object();
  for (var objName in this.group){
    this.group[objName].skipToggleGrid = true;
    var copiedChild = this.group[objName].copy(
      generateUniqueObjectName(), isHardCopy, REUSABLE_VECTOR.set(0, 0, 0), gridSystem, fromScript
    );
    copiedChild.mesh.position.copy(this.group[objName].mesh.position);
    copiedChild.mesh.quaternion.copy(this.group[objName].mesh.quaternion);
    copiedChild.physicsBody.position.copy(this.group[objName].physicsBody.position);
    copiedChild.physicsBody.quaternion.copy(this.group[objName].physicsBody.quaternion);
    copiedChild.metaData["positionX"] = copiedChild.mesh.position.x;
    copiedChild.metaData["positionY"] = copiedChild.mesh.position.y;
    copiedChild.metaData["positionZ"] = copiedChild.mesh.position.z;
    copiedChild.metaData["centerX"] = copiedChild.mesh.position.x;
    copiedChild.metaData["centerY"] = copiedChild.mesh.position.y;
    copiedChild.metaData["centerZ"] = copiedChild.mesh.position.z;
    newGroup[copiedChild.name] = copiedChild;
    addedObjects[copiedChild.name] = copiedChild;
    this.group[objName].skipToggleGrid = false;
  }
  var newObjGroup = new ObjectGroup(name, newGroup);
  newObjGroup.handleTextures();
  newObjGroup.glue();
  newObjGroup.mesh.position.copy(copyPosition);
  newObjGroup.physicsBody.position.copy(copyPosition);
  newObjGroup.mesh.quaternion.copy(quaternionBeforeDetached);
  newObjGroup.physicsBody.quaternion.copy(physicsQuaternionBeforeDetached);
  newObjGroup.graphicsGroup.position.copy(newObjGroup.mesh.position);
  newObjGroup.graphicsGroup.quaternion.copy(newObjGroup.mesh.quaternion);
  this.glue();
  newObjGroup.isBasicMaterial = this.isBasicMaterial;
  this.physicsBody.position.copy(physicsPositionBeforeDetached);
  this.physicsBody.quaternion.copy(physicsQuaternionBeforeDetached);
  this.mesh.position.copy(positionBeforeDetached);
  this.mesh.quaternion.copy(quaternionBeforeDetached);
  var dx = newObjGroup.mesh.position.x - this.mesh.position.x;
  var dy = newObjGroup.mesh.position.y - this.mesh.position.y;
  var dz = newObjGroup.mesh.position.z - this.mesh.position.z;
  for (var objName in newObjGroup.group){
    newObjGroup.group[objName].positionXWhenAttached += dx;
    newObjGroup.group[objName].positionYWhenAttached += dy;
    newObjGroup.group[objName].positionZWhenAttached += dz;
    newObjGroup.group[objName].metaData["positionX"] += dx;
    newObjGroup.group[objName].metaData["positionY"] += dy;
    newObjGroup.group[objName].metaData["positionZ"] += dz;
    newObjGroup.group[objName].metaData["centerX"] += dx;
    newObjGroup.group[objName].metaData["centerY"] += dy;
    newObjGroup.group[objName].metaData["centerZ"] += dz;
  }
  this.isChangeable = isChangeable;
  this.isColorizable = isColorizable;
  newObjGroup.isChangeable = isChangeable;
  newObjGroup.isColorizable = isColorizable;
  if (slippery){
    this.setSlippery(slippery);
    newObjGroup.setSlippery(slippery);
  }
  this.noMass = noMass;
  newObjGroup.noMass = noMass;
  if (noMass){
    physicsWorld.remove(this.physicsBody);
    physicsWorld.remove(newObjGroup.physicsBody);
  }
  newObjGroup.graphicsGroup.position.copy(newObjGroup.mesh.position);
  newObjGroup.graphicsGroup.quaternion.copy(newObjGroup.mesh.quaternion);
  this.initQuaternion.copy(initQuaternionBeforeDetached);
  newObjGroup.initQuaternion.copy(initQuaternionBeforeDetached);
  this.setMass(massWhenDetached);
  newObjGroup.cannotSetMass = this.cannotSetMass;
  if (this.physicsBody.mass != 0){
    newObjGroup.setMass(this.physicsBody.mass);
  }
  if (!(typeof renderSide == UNDEFINED)){
    this.handleRenderSide(renderSide);
    newObjGroup.handleRenderSide(renderSide);
  }

  this.setBlending(blending);
  newObjGroup.setBlending(this.mesh.material.blending);

  this.mesh.material.transparent = isTransparentBeforeDetached;
  newObjGroup.mesh.material.transparent = isTransparentBeforeDetached;
  this.mesh.material.uniforms.totalAlpha.value = totalAlphaBeforeDetached;
  if (this.mesh.material.uniforms.totalAOIntensity){
    this.mesh.material.uniforms.totalAOIntensity.value = totalAOIntensityBeforeDetached;
  }
  if (this.mesh.material.uniforms.totalEmissiveIntensity){
    this.mesh.material.uniforms.totalEmissiveIntensity.value = totalEmissiveIntensityBeforeDetached;
  }
  if (this.mesh.material.uniforms.totalEmissiveColor){
    this.mesh.material.uniforms.totalEmissiveColor.value = totalEmissiveColorBeforeDetached;
  }

  this.mesh.material = oldMaterial;

  if (!isHardCopy){
    newObjGroup.mesh.material = this.mesh.material;
    newObjGroup.softCopyParentName = this.name;
  }else{
    newObjGroup.mesh.material.uniforms.totalAlpha.value = this.mesh.material.uniforms.totalAlpha.value;
    if (newObjGroup.mesh.material.uniforms.totalAOIntensity){
      newObjGroup.mesh.material.uniforms.totalAOIntensity.value = this.mesh.material.uniforms.totalAOIntensity.value;
    }
    if (newObjGroup.mesh.material.uniforms.totalEmissiveIntensity){
      newObjGroup.mesh.material.uniforms.totalEmissiveIntensity.value = this.mesh.material.uniforms.totalEmissiveIntensity.value;
    }
    if (newObjGroup.mesh.material.uniforms.totalEmissiveColor){
      newObjGroup.mesh.material.uniforms.totalEmissiveColor.value = new THREE.Color().copy(this.mesh.material.uniforms.totalEmissiveColor.value);
    }
  }

  if (this.pivotObject){
    var pivot = newObjGroup.makePivot(this.pivotOffsetX, this.pivotOffsetY, this.pivotOffsetZ);
    newObjGroup.pivotObject = pivot;
    newObjGroup.pivotOffsetX = this.pivotOffsetX;
    newObjGroup.pivotOffsetY = this.pivotOffsetY;
    newObjGroup.pivotOffsetZ = this.pivotOffsetZ;
    newObjGroup.pivotRemoved = false;
  }

  newObjGroup.createdWithScript = fromScript;

  return newObjGroup;
}

ObjectGroup.prototype.updateOpacity = function(val){
  this.mesh.material.uniforms.totalAlpha.value = val;
  if (val != 1){
    this.mesh.material.transparent = true;
  }else{
    this.mesh.material.transparent = this.isTransparent;
  }
}
ObjectGroup.prototype.incrementOpacity = function(val){
  this.mesh.material.uniforms.totalAlpha.value += val;
  if (this.mesh.material.uniforms.totalAlpha.value != 1){
    this.mesh.material.transparent = true;
  }else{
    this.mesh.material.transparent = this.isTransparent;
  }
}

ObjectGroup.prototype.injectMacro = function(macro, insertVertexShader, insertFragmentShader){
  if (insertVertexShader){
    this.mesh.material.vertexShader = this.mesh.material.vertexShader.replace(
      "#define INSERTION", "#define INSERTION\n#define "+macro
    )
  };
  if (insertFragmentShader){
    this.mesh.material.fragmentShader = this.mesh.material.fragmentShader.replace(
      "#define INSERTION", "#define INSERTION\n#define "+macro
    )
  };
  this.mesh.material.needsUpdate = true;
}

ObjectGroup.prototype.removeMacro = function(macro, removeVertexShader, removeFragmentShader){
  if (removeVertexShader){
    this.mesh.material.vertexShader = this.mesh.material.vertexShader.replace("\n#define "+macro, "");
  }
  if (removeFragmentShader){
    this.mesh.material.fragmentShader = this.mesh.material.fragmentShader.replace("\n#define "+macro, "");
  }
  this.mesh.material.needsUpdate = true;
}

ObjectGroup.prototype.setFog = function(){
  if (!this.mesh.material.uniforms.fogInfo){
    this.injectMacro("HAS_FOG", false, true);
    this.mesh.material.uniforms.fogInfo = GLOBAL_FOG_UNIFORM;
  }
  if (fogBlendWithSkybox){
    if (!this.mesh.material.uniforms.cubeTexture){
      this.injectMacro("HAS_SKYBOX_FOG", true, true);
      this.mesh.material.uniforms.worldMatrix = new THREE.Uniform(this.mesh.matrixWorld);
      this.mesh.material.uniforms.cubeTexture = GLOBAL_CUBE_TEXTURE_UNIFORM;
      this.mesh.material.uniforms.cameraPosition = GLOBAL_CAMERA_POSITION_UNIFORM;
    }
  }
  this.mesh.material.needsUpdate = true;
}

ObjectGroup.prototype.removeFog = function(){
  this.removeMacro("HAS_FOG", false, true);
  this.removeMacro("HAS_SKYBOX_FOG", true, true);
  delete this.mesh.material.uniforms.fogInfo;
  delete this.mesh.material.uniforms.cubeTexture;
  delete this.mesh.material.uniforms.worldMatrix;
  delete this.mesh.material.uniforms.cameraPosition;
  this.mesh.material.needsUpdate = true;
}

var MarkedPoint = function(name, x, y, z, fromX, fromY, fromZ, gridDestroyed){
  this.name = name;
  this.x = x;
  this.y = y;
  this.z = z;
  this.fromX = fromX;
  this.fromY = fromY;
  this.fromZ = fromZ;
  this.gridDestroyed = gridDestroyed;
  if (!isDeployment){
    var txt = "@@1 (@@2, @@3, @@4)".replace("@@1", name).replace("@@2", x).replace("@@3", y).replace("@@4", z);
    this.text = new AddedText(null, defaultFont, txt, new THREE.Vector3(x, y, z), new THREE.Color("yellow"), 1, 15);
    this.text.setBackground("magenta", 1);
    this.text.setMarginBetweenChars(7);
    this.text.refInnerHeight = 569;
    this.text.refCharSize = 15;
    this.text.handleResize();
    if (!gridDestroyed){
      var lineMaterial = new THREE.LineBasicMaterial({
    	 color: "lime"
      });
      var lineGeometry = new THREE.Geometry();
      lineGeometry.vertices.push(new THREE.Vector3(fromX, fromY, fromZ));
      lineGeometry.vertices.push(new THREE.Vector3((fromX + x) / 2, (fromY + y) / 2, (fromZ + z) / 2));
      lineGeometry.vertices.push(new THREE.Vector3(x, y, z));
      this.line = new THREE.Line(lineGeometry, lineMaterial);
      scene.add(this.line);
    }
  }
  this.isHidden = false;
}

MarkedPoint.prototype.export = function(){
  var exportObj = new Object();
  exportObj.name = this.name;
  exportObj.x = this.x;
  exportObj.y = this.y;
  exportObj.z = this.z;
  exportObj.fromX = this.fromX;
  exportObj.fromY = this.fromY;
  exportObj.fromZ = this.fromZ;
  exportObj.gridDestroyed = this.gridDestroyed;
  exportObj.isHidden = this.isHidden;
  if (this.showAgainOnTheNextModeSwitch){
    exportObj.isHidden = false;
    exportObj.showAgainOnTheNextModeSwitch = true;
  }else if (this.showAgainOnTheNextModeSwitch != false){
    exportObj.showAgainOnTheNextModeSwitch = true;
  }
  return exportObj;
}

MarkedPoint.prototype.destroy = function(){
  if (!this.isHidden){
    this.text.destroy();
  }
}

MarkedPoint.prototype.hide = function(showAgainOnTheNextModeSwitch){
  if (this.isHidden){
    return;
  }
  if (this.text){
    this.text.mesh.visible = false;
  }
  if (this.line){
    this.line.visible = false;
  }
  this.isHidden = true;
  if (showAgainOnTheNextModeSwitch){
    this.showAgainOnTheNextModeSwitch = true;
  }
}

MarkedPoint.prototype.show = function(){
  if (!this.isHidden){
    return;
  }
  if (this.text){
    this.text.mesh.visible = true;
  }
  if (this.line){
    this.line.visible = true;
  }
  this.isHidden = false;
}

var ColorNames = function(){
  this.colorDefinitionsObj = {
    "aliceblue": "#f0f8ff",
    "antiquewhite": "#faebd7",
    "aqua": "#00ffff",
    "aquamarine": "#7fffd4",
    "azure": "#f0ffff",
    "beige": "#f5f5dc",
    "bisque": "#ffe4c4",
    "black": "#000000",
    "blanchedalmond": "#ffebcd",
    "blue": "#0000ff",
    "blueviolet": "#8a2be2",
    "brown": "#a52a2a",
    "burlywood": "#deb887",
    "cadetblue": "#5f9ea0",
    "chartreuse": "#7fff00",
    "chocolate": "#d2691e",
    "coral": "#ff7f50",
    "cornflowerblue": "#6495ed",
    "cornsilk": "#fff8dc",
    "crimson": "#dc143c",
    "cyan": "#00ffff",
    "darkblue": "#00008b",
    "darkcyan": "#008b8b",
    "darkgoldenrod": "#b8860b",
    "darkgray": "#a9a9a9",
    "darkgreen": "#006400",
    "darkgrey": "#a9a9a9",
    "darkkhaki": "#bdb76b",
    "darkmagenta": "#8b008b",
    "darkolivegreen": "#556b2f",
    "darkorange": "#ff8c00",
    "darkorchid": "#9932cc",
    "darkred": "#8b0000",
    "darksalmon": "#e9967a",
    "darkseagreen": "#8fbc8f",
    "darkslateblue": "#483d8b",
    "darkslategray": "#2f4f4f",
    "darkslategrey": "#2f4f4f",
    "darkturquoise": "#00ced1",
    "darkviolet": "#9400d3",
    "deeppink": "#ff1493",
    "deepskyblue": "#00bfff",
    "dimgray": "#696969",
    "dimgrey": "#696969",
    "dodgerblue": "#1e90ff",
    "firebrick": "#b22222",
    "floralwhite": "#fffaf0",
    "forestgreen": "#228b22",
    "fuchsia": "#ff00ff",
    "gainsboro": "#dcdcdc",
    "ghostwhite": "#f8f8ff",
    "gold": "#ffd700",
    "goldenrod": "#daa520",
    "gray": "#808080",
    "green": "#008000",
    "greenyellow": "#adff2f",
    "grey": "#808080",
    "honeydew": "#f0fff0",
    "hotpink": "#ff69b4",
    "indianred": "#cd5c5c",
    "indigo": "#4b0082",
    "ivory": "#fffff0",
    "khaki": "#f0e68c",
    "lavender": "#e6e6fa",
    "lavenderblush": "#fff0f5",
    "lawngreen": "#7cfc00",
    "lemonchiffon": "#fffacd",
    "lightblue": "#add8e6",
    "lightcoral": "#f08080",
    "lightcyan": "#e0ffff",
    "lightgoldenrodyellow": "#fafad2",
    "lightgray": "#d3d3d3",
    "lightgreen": "#90ee90",
    "lightgrey": "#d3d3d3",
    "lightpink": "#ffb6c1",
    "lightsalmon": "#ffa07a",
    "lightseagreen": "#20b2aa",
    "lightskyblue": "#87cefa",
    "lightslategray": "#778899",
    "lightslategrey": "#778899",
    "lightsteelblue": "#b0c4de",
    "lightyellow": "#ffffe0",
    "lime": "#00ff00",
    "limegreen": "#32cd32",
    "linen": "#faf0e6",
    "magenta": "#ff00ff",
    "maroon": "#800000",
    "mediumaquamarine": "#66cdaa",
    "mediumblue": "#0000cd",
    "mediumorchid": "#ba55d3",
    "mediumpurple": "#9370db",
    "mediumseagreen": "#3cb371",
    "mediumslateblue": "#7b68ee",
    "mediumspringgreen": "#00fa9a",
    "mediumturquoise": "#48d1cc",
    "mediumvioletred": "#c71585",
    "midnightblue": "#191970",
    "mintcream": "#f5fffa",
    "mistyrose": "#ffe4e1",
    "moccasin": "#ffe4b5",
    "navajowhite": "#ffdead",
    "navy": "#000080",
    "oldlace": "#fdf5e6",
    "olive": "#808000",
    "olivedrab": "#6b8e23",
    "orange": "#ffa500",
    "orangered": "#ff4500",
    "orchid": "#da70d6",
    "palegoldenrod": "#eee8aa",
    "palegreen": "#98fb98",
    "paleturquoise": "#afeeee",
    "palevioletred": "#db7093",
    "papayawhip": "#ffefd5",
    "peachpuff": "#ffdab9",
    "peru": "#cd853f",
    "pink": "#ffc0cb",
    "plum": "#dda0dd",
    "powderblue": "#b0e0e6",
    "purple": "#800080",
    "rebeccapurple": "#663399",
    "red": "#ff0000",
    "rosybrown": "#bc8f8f",
    "royalblue": "#4169e1",
    "saddlebrown": "#8b4513",
    "salmon": "#fa8072",
    "sandybrown": "#f4a460",
    "seagreen": "#2e8b57",
    "seashell": "#fff5ee",
    "sienna": "#a0522d",
    "silver": "#c0c0c0",
    "skyblue": "#87ceeb",
    "slateblue": "#6a5acd",
    "slategray": "#708090",
    "slategrey": "#708090",
    "snow": "#fffafa",
    "springgreen": "#00ff7f",
    "steelblue": "#4682b4",
    "tan": "#d2b48c",
    "teal": "#008080",
    "thistle": "#d8bfd8",
    "tomato": "#ff6347",
    "turquoise": "#40e0d0",
    "violet": "#ee82ee",
    "wheat": "#f5deb3",
    "white": "#ffffff",
    "whitesmoke": "#f5f5f5",
    "yellow": "#ffff00",
    "yellowgreen": "#9acd32"
  }
  this.colorNames = [];
  for (colorName in this.colorDefinitionsObj){
    this.colorNames.push(colorName);
  }
}

ColorNames.prototype.generateRandomColor = function(){
  return this.colorNames[Math.floor(Math.random() * this.colorNames.length)];
};

/*
 * A speed-improved perlin and simplex noise algorithms for 2D.
 *
 * Based on example code by Stefan Gustavson (stegu@itn.liu.se).
 * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
 * Better rank ordering method by Stefan Gustavson in 2012.
 * Converted to Javascript by Joseph Gentle.
 *
 * Version 2012-03-09
 *
 * This code was placed in the public domain by its original author,
 * Stefan Gustavson. You may use it as you see fit, but
 * attribution is appreciated.
 *
 */

(function(global){
  var module = global.noise = {};

  function Grad(x, y, z) {
    this.x = x; this.y = y; this.z = z;
  }
  
  Grad.prototype.dot2 = function(x, y) {
    return this.x*x + this.y*y;
  };

  Grad.prototype.dot3 = function(x, y, z) {
    return this.x*x + this.y*y + this.z*z;
  };

  var grad3 = [new Grad(1,1,0),new Grad(-1,1,0),new Grad(1,-1,0),new Grad(-1,-1,0),
               new Grad(1,0,1),new Grad(-1,0,1),new Grad(1,0,-1),new Grad(-1,0,-1),
               new Grad(0,1,1),new Grad(0,-1,1),new Grad(0,1,-1),new Grad(0,-1,-1)];

  var p = [151,160,137,91,90,15,
  131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,
  190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,
  88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,
  77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,
  102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,
  135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,
  5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,
  223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,
  129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,
  251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,
  49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,
  138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];
  // To remove the need for index wrapping, double the permutation table length
  var perm = new Array(512);
  var gradP = new Array(512);

  // This isn't a very good seeding function, but it works ok. It supports 2^16
  // different seed values. Write something better if you need more seeds.
  module.seed = function(seed) {
    if(seed > 0 && seed < 1) {
      // Scale the seed out
      seed *= 65536;
    }

    seed = Math.floor(seed);
    if(seed < 256) {
      seed |= seed << 8;
    }

    for(var i = 0; i < 256; i++) {
      var v;
      if (i & 1) {
        v = p[i] ^ (seed & 255);
      } else {
        v = p[i] ^ ((seed>>8) & 255);
      }

      perm[i] = perm[i + 256] = v;
      gradP[i] = gradP[i + 256] = grad3[v % 12];
    }
  };

  module.seed(0);

  /*
  for(var i=0; i<256; i++) {
    perm[i] = perm[i + 256] = p[i];
    gradP[i] = gradP[i + 256] = grad3[perm[i] % 12];
  }*/

  // Skewing and unskewing factors for 2, 3, and 4 dimensions
  var F2 = 0.5*(Math.sqrt(3)-1);
  var G2 = (3-Math.sqrt(3))/6;

  var F3 = 1/3;
  var G3 = 1/6;

  // 2D simplex noise
  module.simplex2 = function(xin, yin) {
    var n0, n1, n2; // Noise contributions from the three corners
    // Skew the input space to determine which simplex cell we're in
    var s = (xin+yin)*F2; // Hairy factor for 2D
    var i = Math.floor(xin+s);
    var j = Math.floor(yin+s);
    var t = (i+j)*G2;
    var x0 = xin-i+t; // The x,y distances from the cell origin, unskewed.
    var y0 = yin-j+t;
    // For the 2D case, the simplex shape is an equilateral triangle.
    // Determine which simplex we are in.
    var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords
    if(x0>y0) { // lower triangle, XY order: (0,0)->(1,0)->(1,1)
      i1=1; j1=0;
    } else {    // upper triangle, YX order: (0,0)->(0,1)->(1,1)
      i1=0; j1=1;
    }
    // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
    // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
    // c = (3-sqrt(3))/6
    var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords
    var y1 = y0 - j1 + G2;
    var x2 = x0 - 1 + 2 * G2; // Offsets for last corner in (x,y) unskewed coords
    var y2 = y0 - 1 + 2 * G2;
    // Work out the hashed gradient indices of the three simplex corners
    i &= 255;
    j &= 255;
    var gi0 = gradP[i+perm[j]];
    var gi1 = gradP[i+i1+perm[j+j1]];
    var gi2 = gradP[i+1+perm[j+1]];
    // Calculate the contribution from the three corners
    var t0 = 0.5 - x0*x0-y0*y0;
    if(t0<0) {
      n0 = 0;
    } else {
      t0 *= t0;
      n0 = t0 * t0 * gi0.dot2(x0, y0);  // (x,y) of grad3 used for 2D gradient
    }
    var t1 = 0.5 - x1*x1-y1*y1;
    if(t1<0) {
      n1 = 0;
    } else {
      t1 *= t1;
      n1 = t1 * t1 * gi1.dot2(x1, y1);
    }
    var t2 = 0.5 - x2*x2-y2*y2;
    if(t2<0) {
      n2 = 0;
    } else {
      t2 *= t2;
      n2 = t2 * t2 * gi2.dot2(x2, y2);
    }
    // Add contributions from each corner to get the final noise value.
    // The result is scaled to return values in the interval [-1,1].
    return 70 * (n0 + n1 + n2);
  };

  // 3D simplex noise
  module.simplex3 = function(xin, yin, zin) {
    var n0, n1, n2, n3; // Noise contributions from the four corners

    // Skew the input space to determine which simplex cell we're in
    var s = (xin+yin+zin)*F3; // Hairy factor for 2D
    var i = Math.floor(xin+s);
    var j = Math.floor(yin+s);
    var k = Math.floor(zin+s);

    var t = (i+j+k)*G3;
    var x0 = xin-i+t; // The x,y distances from the cell origin, unskewed.
    var y0 = yin-j+t;
    var z0 = zin-k+t;

    // For the 3D case, the simplex shape is a slightly irregular tetrahedron.
    // Determine which simplex we are in.
    var i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords
    var i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords
    if(x0 >= y0) {
      if(y0 >= z0)      { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; }
      else if(x0 >= z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; }
      else              { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }
    } else {
      if(y0 < z0)      { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; }
      else if(x0 < z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; }
      else             { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; }
    }
    // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),
    // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and
    // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where
    // c = 1/6.
    var x1 = x0 - i1 + G3; // Offsets for second corner
    var y1 = y0 - j1 + G3;
    var z1 = z0 - k1 + G3;

    var x2 = x0 - i2 + 2 * G3; // Offsets for third corner
    var y2 = y0 - j2 + 2 * G3;
    var z2 = z0 - k2 + 2 * G3;

    var x3 = x0 - 1 + 3 * G3; // Offsets for fourth corner
    var y3 = y0 - 1 + 3 * G3;
    var z3 = z0 - 1 + 3 * G3;

    // Work out the hashed gradient indices of the four simplex corners
    i &= 255;
    j &= 255;
    k &= 255;
    var gi0 = gradP[i+   perm[j+   perm[k   ]]];
    var gi1 = gradP[i+i1+perm[j+j1+perm[k+k1]]];
    var gi2 = gradP[i+i2+perm[j+j2+perm[k+k2]]];
    var gi3 = gradP[i+ 1+perm[j+ 1+perm[k+ 1]]];

    // Calculate the contribution from the four corners
    var t0 = 0.6 - x0*x0 - y0*y0 - z0*z0;
    if(t0<0) {
      n0 = 0;
    } else {
      t0 *= t0;
      n0 = t0 * t0 * gi0.dot3(x0, y0, z0);  // (x,y) of grad3 used for 2D gradient
    }
    var t1 = 0.6 - x1*x1 - y1*y1 - z1*z1;
    if(t1<0) {
      n1 = 0;
    } else {
      t1 *= t1;
      n1 = t1 * t1 * gi1.dot3(x1, y1, z1);
    }
    var t2 = 0.6 - x2*x2 - y2*y2 - z2*z2;
    if(t2<0) {
      n2 = 0;
    } else {
      t2 *= t2;
      n2 = t2 * t2 * gi2.dot3(x2, y2, z2);
    }
    var t3 = 0.6 - x3*x3 - y3*y3 - z3*z3;
    if(t3<0) {
      n3 = 0;
    } else {
      t3 *= t3;
      n3 = t3 * t3 * gi3.dot3(x3, y3, z3);
    }
    // Add contributions from each corner to get the final noise value.
    // The result is scaled to return values in the interval [-1,1].
    return 32 * (n0 + n1 + n2 + n3);

  };

  // ##### Perlin noise stuff

  function fade(t) {
    return t*t*t*(t*(t*6-15)+10);
  }

  function lerp(a, b, t) {
    return (1-t)*a + t*b;
  }

  // 2D Perlin Noise
  module.perlin2 = function(x, y) {
    // Find unit grid cell containing point
    var X = Math.floor(x), Y = Math.floor(y);
    // Get relative xy coordinates of point within that cell
    x = x - X; y = y - Y;
    // Wrap the integer cells at 255 (smaller integer period can be introduced here)
    X = X & 255; Y = Y & 255;

    // Calculate noise contributions from each of the four corners
    var n00 = gradP[X+perm[Y]].dot2(x, y);
    var n01 = gradP[X+perm[Y+1]].dot2(x, y-1);
    var n10 = gradP[X+1+perm[Y]].dot2(x-1, y);
    var n11 = gradP[X+1+perm[Y+1]].dot2(x-1, y-1);

    // Compute the fade curve value for x
    var u = fade(x);

    // Interpolate the four results
    return lerp(
        lerp(n00, n10, u),
        lerp(n01, n11, u),
       fade(y));
  };

  // 3D Perlin Noise
  module.perlin3 = function(x, y, z) {
    // Find unit grid cell containing point
    var X = Math.floor(x), Y = Math.floor(y), Z = Math.floor(z);
    // Get relative xyz coordinates of point within that cell
    x = x - X; y = y - Y; z = z - Z;
    // Wrap the integer cells at 255 (smaller integer period can be introduced here)
    X = X & 255; Y = Y & 255; Z = Z & 255;

    // Calculate noise contributions from each of the eight corners
    var n000 = gradP[X+  perm[Y+  perm[Z  ]]].dot3(x,   y,     z);
    var n001 = gradP[X+  perm[Y+  perm[Z+1]]].dot3(x,   y,   z-1);
    var n010 = gradP[X+  perm[Y+1+perm[Z  ]]].dot3(x,   y-1,   z);
    var n011 = gradP[X+  perm[Y+1+perm[Z+1]]].dot3(x,   y-1, z-1);
    var n100 = gradP[X+1+perm[Y+  perm[Z  ]]].dot3(x-1,   y,   z);
    var n101 = gradP[X+1+perm[Y+  perm[Z+1]]].dot3(x-1,   y, z-1);
    var n110 = gradP[X+1+perm[Y+1+perm[Z  ]]].dot3(x-1, y-1,   z);
    var n111 = gradP[X+1+perm[Y+1+perm[Z+1]]].dot3(x-1, y-1, z-1);

    // Compute the fade curve value for x, y, z
    var u = fade(x);
    var v = fade(y);
    var w = fade(z);

    // Interpolate
    return lerp(
        lerp(
          lerp(n000, n100, u),
          lerp(n001, n101, u), w),
        lerp(
          lerp(n010, n110, u),
          lerp(n011, n111, u), w),
       v);
  };

})(this);

var Particle = function(x, y, z, material, lifetime){
  this.isParticle = true;
  this.x = x;
  this.y = y;
  this.z = z;
  this.material = material;
  this.lifetime = lifetime;
  this.isExpired = false;

  this.positionHistoryCounter = 0;
  this.readyForCollisionCheckFlag = false;

  this.positionHistoryArray = new Array(PARTICLE_POSITION_HISTORY_SIZE);
  for (var i = 0; i<this.positionHistoryArray.length; i++){
    this.positionHistoryArray[i] = new THREE.Vector3();
  }

  this.collisionTimeOffset = 0;

  if (!(typeof lifetime == "undefined")){
    var vect = this.positionHistoryArray[this.positionHistoryCounter];
    this.getPosition(null, vect);
    this.positionHistoryCounter ++;
  }

}

Particle.prototype.setFromPseudoObject = function(pseudoObject){
  this.angularAcceleration = pseudoObject.angularAcceleration;
  this.angularMotionRadius = pseudoObject.angularMotionRadius;
  this.angularQuaternionW = pseudoObject.angularQuaternionW;
  this.angularQuaternionX = pseudoObject.angularQuaternionX;
  this.angularQuaternionY = pseudoObject.angularQuaternionY;
  this.angularQuaternionZ = pseudoObject.angularQuaternionZ;
  this.angularVelocity = pseudoObject.angularVelocity;
  this.gpuAcceleration = new THREE.Vector3(pseudoObject.ax, pseudoObject.ay, pseudoObject.az);
  this.initialAngle = pseudoObject.initialAngle;
  this.lifetime = pseudoObject.lifetime;
  this.motionMode = pseudoObject.motionMode;
  this.respawnSet = pseudoObject.respawnSet;
  this.startDelay = pseudoObject.startDelay;
  this.trailFlag = pseudoObject.trailFlag;
  this.useWorldPositionFlag = pseudoObject.useWorldPositionFlag;
  this.uuid = parseInt(pseudoObject.uuid);
  this.gpuVelocity = new THREE.Vector3(pseudoObject.vx, pseudoObject.vy, pseudoObject.vz);
  this.x = pseudoObject.x;
  this.y = pseudoObject.y;
  this.z = pseudoObject.z;
  this.parentCollisionWorkerIndex = pseudoObject.parentCollisionWorkerIndex;
  this.fromPseudoObject = true;
  this.parent = new Object();
  var parentInitPosition = particleSystemInitialPositions[this.parentCollisionWorkerIndex];
  this.parent.x = parentInitPosition.x;
  this.parent.y = parentInitPosition.y;
  this.parent.z = parentInitPosition.z;
  var parentVelocity = particleSystemVelocities[this.parentCollisionWorkerIndex];
  this.parent.vx = parentVelocity.x;
  this.parent.vy = parentVelocity.y;
  this.parent.vz = parentVelocity.z;
  var parentAcceleration = particleSystemAccelerations[this.parentCollisionWorkerIndex];
  this.parent.ax = parentAcceleration.x;
  this.parent.ay = parentAcceleration.y;
  this.parent.az = parentAcceleration.z;
  this.parent.mesh = new Object();
  this.parent.mesh.matrixWorld = particleSystemMatrices[this.parentCollisionWorkerIndex];
  this.parent.name = pseudoObject.parentName;
  this.index = pseudoObject.index;
  this.collisionTimeOffset = pseudoObject.collisionTimeOffset;

  var vect = this.positionHistoryArray[this.positionHistoryCounter];
  this.getPosition(null, vect);
  this.positionHistoryCounter ++;
}

Particle.prototype.generateCollisionWorkerInfo = function(){
  var collisionWorkerInfo = new Object();
  collisionWorkerInfo.uuid = this.uuid;
  collisionWorkerInfo.parentCollisionWorkerIndex = this.parent.collisionWorkerIndex;
  collisionWorkerInfo.x = this.x;
  collisionWorkerInfo.y = this.y;
  collisionWorkerInfo.z = this.z;
  collisionWorkerInfo.startDelay = this.startDelay;
  collisionWorkerInfo.lifetime = this.lifetime;
  collisionWorkerInfo.respawnSet = this.respawnSet;
  collisionWorkerInfo.trailFlag = this.trailFlag;
  collisionWorkerInfo.useWorldPositionFlag = this.useWorldPositionFlag;
  collisionWorkerInfo.vx = this.gpuVelocity.x;
  collisionWorkerInfo.vy = this.gpuVelocity.y;
  collisionWorkerInfo.vz = this.gpuVelocity.z;
  collisionWorkerInfo.ax = this.gpuAcceleration.x;
  collisionWorkerInfo.ay = this.gpuAcceleration.y;
  collisionWorkerInfo.az = this.gpuAcceleration.z;
  collisionWorkerInfo.motionMode = this.motionMode;
  collisionWorkerInfo.initialAngle = this.initialAngle;
  collisionWorkerInfo.angularAcceleration = this.angularAcceleration;
  collisionWorkerInfo.angularVelocity = this.angularVelocity;
  collisionWorkerInfo.angularMotionRadius = this.angularMotionRadius;
  collisionWorkerInfo.angularQuaternionX = this.angularQuaternionX;
  collisionWorkerInfo.angularQuaternionY = this.angularQuaternionY;
  collisionWorkerInfo.angularQuaternionZ = this.angularQuaternionZ;
  collisionWorkerInfo.angularQuaternionW = this.angularQuaternionW;
  collisionWorkerInfo.parentName = this.parent.name;
  collisionWorkerInfo.index = this.index;
  collisionWorkerInfo.collisionTimeOffset = this.collisionTimeOffset;
  return JSON.stringify(collisionWorkerInfo);
}

// WORLD COORDINATES OF THIS PARTICLE
Particle.prototype.getPosition = function(axis, targetVector){
  if (this.isExpired || !this.parent || this.isParticleExpired() || (this.parent && !this.parent.mesh)){
    return;
  }
  var x = this.x;
  var y = this.y;
  var z = this.z;
  var time = this.getTime();
  // CONVERTED FROM THE GPU SHADER CODE
  if (this.useWorldPositionFlag){
    var repeatTime = this.findRepeatTime();
    if (this.lifetime <= 0.0001){
      repeatTime = this.startDelay;
    }

    if (!(typeof this.stopTick == "undefined") && this.parent.stopped && repeatTime > this.stopTick){
      repeatTime = this.stopTick;
    }

    var pix = this.parent.x;
    var piy = this.parent.y;
    var piz = this.parent.z;
    var newX = pix + (this.parent.vx * repeatTime) + (0.5 * repeatTime * repeatTime * this.parent.ax);
    var newY = piy + (this.parent.vy * repeatTime) + (0.5 * repeatTime * repeatTime * this.parent.ay);
    var newZ = piz + (this.parent.vz * repeatTime) + (0.5 * repeatTime * repeatTime * this.parent.az);
    newX = newX + x + (this.gpuVelocity.x * time) + (0.5 * time * time * this.gpuAcceleration.x);
    newY = newY + y + (this.gpuVelocity.y * time) + (0.5 * time * time * this.gpuAcceleration.y);
    newZ = newZ + z + (this.gpuVelocity.z * time) + (0.5 * time * time * this.gpuAcceleration.z);
    REUSABLE_VECTOR.set(newX, newY, newZ);
  }else{
    if (this.motionMode == MOTION_MODE_NORMAL){
      if (!this.trailFlag){
        var dx = (this.gpuVelocity.x * time) + (0.5 * this.gpuAcceleration.x * time * time);
        var dy = (this.gpuVelocity.y * time) + (0.5 * this.gpuAcceleration.y * time * time);
        var dz = (this.gpuVelocity.z * time) + (0.5 * this.gpuAcceleration.z * time * time);
        x += dx;
        y += dy;
        z += dz;
        REUSABLE_VECTOR.set(x, y, z);
      }else{
        var dx = (this.parent.vx * time) + (0.5 * this.parent.ax * time * time);
        var dy = (this.parent.vy * time) + (0.5 * this.parent.ay * time * time);
        var dz = (this.parent.vz * time) + (0.5 * this.parent.az * time * time);
        x += dx;
        y += dy;
        z += dz;
        REUSABLE_VECTOR.set(x, y, z);
      }
    }else if (this.motionMode == MOTION_MODE_CIRCULAR){
      var initialAngle = this.initialAngle;
      var angularAcceleration = this.angularAcceleration;
      var angularVelocity = this.angularVelocity;
      var angularMotionRadius = this.angularMotionRadius;
      REUSABLE_QUATERNION2.set(
        this.angularQuaternionX, this.angularQuaternionY, this.angularQuaternionZ, this.angularQuaternionW
      );
      var angleNow = initialAngle + (
        (angularVelocity * time) + (0.5 * angularAcceleration * time * time)
      );
      var tmpCircularX = angularMotionRadius * Math.cos(angleNow);
      var tmpCircularZ = angularMotionRadius * Math.sin(angleNow);
      REUSABLE_VECTOR.set(tmpCircularX, 0, tmpCircularZ);
      REUSABLE_VECTOR.applyQuaternion(REUSABLE_QUATERNION2);
    }
  }
  if (!this.useWorldPositionFlag){
    REUSABLE_VECTOR.applyMatrix4(this.parent.mesh.matrixWorld);
  }
  if (axis){
    if (axis.toLowerCase() == "x"){
      return REUSABLE_VECTOR.x;
    }else if (axis.toLowerCase() == "y"){
      return REUSABLE_VECTOR.y;
    }else if (axis.toLowerCase() == "z"){
      return REUSABLE_VECTOR.z;
    }
  }else{
    if (!targetVector){
      return REUSABLE_VECTOR.clone();
    }else{
      targetVector.set(REUSABLE_VECTOR.x, REUSABLE_VECTOR.y, REUSABLE_VECTOR.z);
    }
  }
}

Particle.prototype.fireCollisionCallback = function(){
  var request = particleCollisionCallbackRequests[this.uuid];
  if (!request){
    return;
  }
  request();
}

Particle.prototype.updatePositionHistory = function(){
  if (this.readyForCollisionCheckFlagNextIteration){
    this.readyForCollisionCheckFlag = true;
  }
  var vect = this.positionHistoryArray[this.positionHistoryCounter];
  var tmp = this.parent.tick;
  this.parent.tick += (this.collisionTimeOffset * (1/60));
  this.getPosition(null, vect);
  this.parent.tick = tmp;
  this.positionHistoryCounter ++;
  if (this.positionHistoryCounter == PARTICLE_POSITION_HISTORY_SIZE){
    this.readyForCollisionCheckFlagNextIteration = true;
    this.positionHistoryCounter = 0;
  }
  return;
}

Particle.prototype.generateLine = function(){
  var index1 = this.positionHistoryCounter - 1;
  if (index1 < 0){
    index1 = PARTICLE_POSITION_HISTORY_SIZE - 1;
  }
  var index2 = this.positionHistoryCounter;
  REUSABLE_LINE.set(this.positionHistoryArray[index1], this.positionHistoryArray[index2]);
}

Particle.prototype.handleCollisions = function(fromWorker){
  var timer1 = performance.now();
  this.updatePositionHistory();
  if (!this.readyForCollisionCheckFlag){
    return;
  }
  var rIndex = this.positionHistoryCounter - 1;
  if (rIndex < 0){
    rIndex = PARTICLE_POSITION_HISTORY_SIZE - 1;
  }
  var results;
  if (fromWorker){
    results = worldBinHandler.query(this.positionHistoryArray[rIndex]);
  }else{
    results = rayCaster.binHandler.query(this.positionHistoryArray[rIndex]);
  }
  for (var objName in results){
    var result = results[objName];
    if (result == 5){
      var obj = addedObjects[objName];
      if (!obj){
        return;
      }
      this.generateLine();
      var intersectionPoint;
      if (!fromWorker){
        intersectionPoint = obj.intersectsLine(REUSABLE_LINE);
      }else{
        intersectsLine(objName, this);
        continue;
      }
      if (intersectionPoint){
        this.fireCollisionCallback();
      }
    }else{
      var obj;
      var parent = objectGroups[objName];
      if (!parent){
        return;
      }
      for (var childName in result){
        if (!fromWorker){
          obj = parent.group[childName];
        }else{
          obj = true;
        }
        if (!obj){
          return;
        }
        this.generateLine();
        if (!fromWorker){
          var intersectionPoint = obj.intersectsLine(REUSABLE_LINE);
        }else{
          if (intersectsLine(objName, this, childName)){
            continue;
          }
        }
        if (intersectionPoint){
          this.fireCollisionCallback();
          return;
        }
      }
    }
  }
  this.lastUpdatetime = performance.now() - timer1;
}


Particle.prototype.assignUUID = function(){
  this.uuid = TOTAL_PARTICLE_COLLISION_LISTEN_COUNT;
}

// CONVERTED FROM THE GPU GLSL CODE
Particle.prototype.isParticleExpired = function(){
  if (this.parent.tick < this.startDelay){
    return false;
  }
  if (this.lifetime > 0.0 && this.parent.tick >= (this.lifetime + this.startDelay) && !this.respawnSet){
    return true;
  }
  return false;
}

// CONVERTED FROM THE GPU GLSL CODE
Particle.prototype.isRecentlyRespawned = function(timeNow){
  var respawnFlag = this.respawnSet;
  var lifetime = this.lifetime;

  if (this.parent.stopped){
    lifetime = this.stopLifetime;
  }

  if (!respawnFlag){
    return false;
  }
  var timeThen = (timeNow - 0.01666666666);
  var timeNowModulated = timeNow - (lifetime * Math.floor(timeNow/lifetime));
  var timeThenModulated = timeThen - (lifetime * Math.floor(timeThen/lifetime));
  if (timeNowModulated < timeThenModulated){
    return true;
  }
  return false;
}
// CONVERTED FROM THE GPU GLSL CODE
Particle.prototype.findRepeatTime = function(){
  var startTime = this.startDelay;
  var respawnFlag = this.respawnSet;
  var time = this.parent.tick;
  if (!time){
    time = 0;
  }
  if (!respawnFlag){
    return startTime;
  }
  var x = time;
  for (var i = 0.0; i<10000000.0; i += 0.0000000001){
    var recentlyRespawnedFlag = this.isRecentlyRespawned((x - startTime));
    if (recentlyRespawnedFlag){
      return x;
    }
    x = x - 0.01666666666;
    if (x < startTime || x < 0.0){
      break;
    }
  }
  return time;
}
// CONVERTED FROM THE GPU GLSL CODE
Particle.prototype.getTime = function(){
  var startDelay = this.startDelay;
  var parentTime = this.parent.tick;
  if (this.lifetime > 0 && parentTime >= (startDelay + this.lifetime) && !this.respawnSet){
    return 0;
  }

  if (this.trailFlag){
    var trailTime = this.findRepeatTime();
    var diff = parentTime - trailTime;
    return (trailTime - diff);
  }

  if (parentTime >= startDelay){
    var timeOfThis = (parentTime - startDelay);
    if (this.respawnSet && this.lifetime > 0){
      timeOfThis = timeOfThis - (this.lifetime * Math.floor(timeOfThis/this.lifetime));
    }
    return timeOfThis;
  }else{
    return 0;
  }
}

var ParticleSystem = function(copyPS, name, particles, x, y, z, vx, vy, vz, ax, ay, az, motionMode, updateFunction, fromWorker){

  this.isParticleSystem = true;

  this.collisionWorkerInfo = new Object();
  this.copyPS = copyPS;

  this.name = name;
  this.particles = particles;
  this.x = x;
  this.y = y;
  this.z = z;

  this.motionMode = motionMode;

  this.collisionTimeOffset = 0;
  this.positionHistoryCounter = 0;
  this.positionLine = new THREE.Line3(new THREE.Vector3(x, y, z), new THREE.Vector3(x, y, z));

  this.vx = vx, this.vy = vy, this.vz = vz, this.ax = ax, this.ay = ay, this.az = az;

  var textureMerger = 0;

  var texturesObj = new Object();
  var textureCount = 0;
  var mergedTextureHash = "";
  var noTargetColor = true;
  for (var i = 0; i<particles.length; i++){
    if (!particles[i].material.noTargetColor){
      noTargetColor = false;
    }
    if (particles[i].material.texture){
      if (!texturesObj[particles[i].material.texture]){
        mergedTextureHash = particles[i].material.texture + PIPE;
      }
      texturesObj[particles[i].material.texture] = textures[particles[i].material.texture];
      textureCount ++;
    }
  }
  this.noTargetColor = noTargetColor;
  this.texturesObj = texturesObj;

  if (textureCount > 0 && !mergedTextureCache[mergedTextureHash]){
    textureMerger = new TextureMerger(texturesObj);
    mergedTextureCache[mergedTextureHash] = textureMerger;
  }else if (textureCount > 0 && mergedTextureCache[mergedTextureHash]){
    textureMerger = mergedTextureCache[mergedTextureHash];
  }

  this.performanceCounter1 = 0;
  this.performanceCounter2 = 0;
  this.lastUpdatePerformance = 0;

  this.totalParticleCount = 0;

  this.destroyedChildCount = 0;

  this.tick = 0;

  this.updateFunction = updateFunction;

  this.particlesWithCollisionCallbacks = new Map();

  this.gpuMotionUpdateBuffer = [];


  this.REUSABLE_VECTOR = new THREE.Vector3();
  this.REUSABLE_VELOCITY_VECTOR = new THREE.Vector3();
  this.REUSABLE_ACCELERATION_VECTOR = new THREE.Vector3();

  var len = this.particles.length;

  if (fromWorker){
    return this;
  }

  this.geometry = new THREE.BufferGeometry();
  this.expiredFlags = new Float32Array(len); // This is dynamic
  this.flags2 = new Float32Array(len * 4); // sizes - transparencies - textureFlag - times
  if (!this.copyPS){
    this.positions = new Float32Array(len * 3); // This is used to store initialAngle and angularAcceleration info for MOTION_MODE_CIRCULAR
    if (textureCount > 0){
      this.rgbThresholds = new Float32Array(len * 3);
      this.uvCoordinates = new Float32Array(len * 4); // startU - startV - endU - endV
    }
    this.velocities = new Float32Array(len * 3);
    this.accelerations = new Float32Array(len * 3);
    this.flags1 = new Float32Array(len * 4); // respawn - alphaDelta - trailFlag - lifeTimes
    this.flags3 = new Float32Array(len * 4); // alphaVariationMode - motionMode - angularVelocity - angularMotionRadius
    this.flags4 = new Float32Array(len * 4); // color.r - color.g - color.b - useWorldPositionFlag
    if (!noTargetColor){
      this.targetColors = new Float32Array(len * 4);
    }
    this.angularQuaternions = new Float32Array(len * 4);
  }else{
    this.positions = this.copyPS.positions;
    if (textureCount > 0){
      this.rgbThresholds = this.copyPS.rgbThresholds;
      this.uvCoordinates = this.copyPS.uvCoordinates;
    }
    this.velocities = this.copyPS.velocities
    this.accelerations = this.copyPS.accelerations
    this.flags1 = this.copyPS.flags1;
    this.flags3 = this.copyPS.flags3;
    this.flags4 = this.copyPS.flags4;
    if (!noTargetColor){
      this.targetColors = this.copyPS.targetColors;
    }
    this.angularQuaternions = this.copyPS.angularQuaternions;
  }

  var i2 = 0;
  var i3 = 0;
  var i4 = 0;
  var i5 = 0;
  var i6 = 0;
  var i7 = 0;
  var i8 = 0;
  var i9 = 0;
  var i10 = 0;

  if (!this.copyPS){
    for (var i = 0; i<particles.length; i++){
      var particle = particles[i];

      particle.parent = this;

      if (particle.trailMode){
        this.hasTrailedParticle = true;
      }

      var rgbFilterX = 0;
      var rgbFilterY = 0;
      var rgbFilterZ = 0;

      if (particle.material.rgbFilter){
        rgbFilterX = particle.material.rgbFilter.x;
        rgbFilterY = particle.material.rgbFilter.y;
        rgbFilterZ = particle.material.rgbFilter.z;
      }

      if (particle.motionMode == MOTION_MODE_NORMAL){
        this.positions[i2] = particle.x;
      }else{
        this.positions[i2] = particle.initialAngle;
      }
      if (this.rgbThresholds){
        this.rgbThresholds[i2] = rgbFilterX;
      }
      i2++;
      if (particle.motionMode == MOTION_MODE_NORMAL){
        this.positions[i2] = particle.y;
      }else{
        this.positions[i2] = particle.angularAcceleration;
      }
      if (this.rgbThresholds){
        this.rgbThresholds[i2] = rgbFilterY;
      }
      i2++;
      this.positions[i2] = particle.z;
      if (this.rgbThresholds){
        this.rgbThresholds[i2] = rgbFilterZ;
      }
      i2++;

      if (!noTargetColor){
        this.targetColors[i4++] = particle.material.targetRed;
        this.targetColors[i4++] = particle.material.targetGreen;
        this.targetColors[i4++] = particle.material.targetBlue;
        this.targetColors[i4++] = particle.material.colorStep;
      }

      this.flags4[i9++] = particle.material.red;
      this.flags4[i9++] = particle.material.green;
      this.flags4[i9++] = particle.material.blue;
      if (particle.useWorldPositionFlag){
        this.flags4[i9++] = 20;
      }else{
        this.flags4[i9++] = 0;
      }

      particle.parent = this;
      particle.index = this.totalParticleCount;
      this.totalParticleCount ++;

      this.flags2[i6++] = particle.material.size;
      this.flags2[i6++] = particle.material.alpha;
      this.expiredFlags[i] = 0;
      if (textureCount > 0){
        if (particle.material.texture){
          this.flags2[i6++] = 10;
          var range = textureMerger.ranges[particle.material.texture];
          this.uvCoordinates[i10++] = range.startU;
          this.uvCoordinates[i10++] = range.startV;
          this.uvCoordinates[i10++] = range.endU;
          this.uvCoordinates[i10++] = range.endV;
        }else{
          this.flags2[i6++] = -10;
          this.uvCoordinates[i10++] = -10;
          this.uvCoordinates[i10++] = -10;
          this.uvCoordinates[i10++] = -10;
          this.uvCoordinates[i10++] = -10;
        }
      }else{
        this.flags2[i6++] = -10;
      }

      var startDelay = 0;
      if (!(typeof particle.startDelay == UNDEFINED)){
        startDelay = particle.startDelay;
      }
      this.flags2[i6++] = startDelay;

      if (particle.respawnSet){
        this.flags1[i5++] = 7;
      }else{
        this.flags1[i5++] = 0;
      }

      if (particle.gpuMotion){
        this.accelerations[i3] = particle.gpuAcceleration.x;
        this.velocities[i3++] = particle.gpuVelocity.x;
        this.accelerations[i3] = particle.gpuAcceleration.y;
        this.velocities[i3++] = particle.gpuVelocity.y;
        this.accelerations[i3] = particle.gpuAcceleration.z;
        this.velocities[i3++] = particle.gpuVelocity.z;
      }else{
        this.accelerations[i3] = 0;
        this.velocities[i3++] = 0;
        this.accelerations[i3] = 0;
        this.velocities[i3++] = 0;
        this.accelerations[i3] = 0;
        this.velocities[i3++] = 0;
      }

      if (!(typeof particle.alphaDelta == UNDEFINED)){
        this.flags1[i5++] = particle.alphaDelta;
      }else{
        this.flags1[i5++] = 0;
      }

      if (!particle.trailFlag){
        this.flags1[i5++] = 0.0;
      }else{
        if (this.motionMode == MOTION_MODE_CIRCULAR){
          this.flags1[i5++] = 0.0;
        }else{
          this.flags1[i5++] = 7.0;
        }
      }

      this.flags1[i5++] = particle.lifetime;

      if (particle.alphaVariationMode == ALPHA_VARIATION_MODE_NORMAL){
        this.flags3[i7++] = 5;
      }else if (particle.alphaVariationMode == ALPHA_VARIATION_MODE_SIN){
        this.flags3[i7++] = 15;
      }else if (particle.alphaVariationMode == ALPHA_VARIATION_MODE_COS){
        this.flags3[i7++] = 25;
      }else{
        this.flags3[i7++] = -20;
      }

      if (particle.motionMode == MOTION_MODE_NORMAL){
        this.flags3[i7++] = 5;
      }else if (particle.motionMode == MOTION_MODE_CIRCULAR){
        this.flags3[i7++] = 15;
      }else{
        this.flags3[i7++] = -20;
      }

      this.flags3[i7++] = particle.angularVelocity;
      this.flags3[i7++] = particle.angularMotionRadius;

      this.angularQuaternions[i8++] = particle.angularQuaternionX;
      this.angularQuaternions[i8++] = particle.angularQuaternionY;
      this.angularQuaternions[i8++] = particle.angularQuaternionZ;
      this.angularQuaternions[i8++] = particle.angularQuaternionW;

      if (particle.checkForCollisions){
        if (!this.hasParticleCollision){
          if (TOTAL_PARTICLE_SYSTEMS_WITH_PARTICLE_COLLISIONS >= MAX_PARTICLE_SYSTEMS_WITH_PARTICLE_COLLISIONS){
            throw new Error("Maximum "+MAX_PARTICLE_SYSTEMS_WITH_PARTICLE_COLLISIONS+" particles can have collidable particles.");
            return;
          }
          TOTAL_PARTICLE_SYSTEMS_WITH_PARTICLE_COLLISIONS ++;
          this.hasParticleCollision = true;
        }
        this.particlesWithCollisionCallbacks.set(particle.uuid, particle);
        if (isCollisionWorkerEnabled()){
          if (!this.checkForCollisionBuffer){
            this.checkForCollisionBuffer = new Object();
          }
          this.checkForCollisionBuffer[particle.uuid] = particle;
        }
      }

    }
  }else{
    for (var i = 0; i<this.particles.length; i++){
      var particle = this.particles[i];
      this.expiredFlags[i] = 0;
      this.flags2[i6++] = particle.material.size;
      this.flags2[i6++] = particle.material.alpha;
      if (particle.material.texture){
        this.flags2[i6++] = 10;
      }else{
        this.flags2[i6++] = -10;
      }
      this.flags2[i6++] = particle.originalStartDelay;
    }
  }

  if (this.copyPS){

    this.positionBufferAttribute = this.copyPS.positionBufferAttribute;
    if (this.copyPS.rgbThresholdBufferAttribute){
      this.rgbThresholdBufferAttribute = this.copyPS.rgbThresholdBufferAttribute;
    }
    this.velocityBufferAttribute = this.copyPS.velocityBufferAttribute;
    this.accelerationBufferAttribute = this.copyPS.accelerationBufferAttribute;
    if (!noTargetColor){
      this.targetColorBufferAttribute = this.copyPS.targetColorBufferAttribute;
    }
    this.flags1BufferAttribute = this.copyPS.flags1BufferAttribute;
    this.flags3BufferAttribute = this.copyPS.flags3BufferAttribute;
    this.flags4BufferAttribute = this.copyPS.flags4BufferAttribute;
    this.angularQuaternionsBufferAttribute = this.copyPS.angularQuaternionsBufferAttribute;
    if (this.copyPS.uvCoordinatesBufferAttribute){
      this.uvCoordinatesBufferAttribute = this.copyPS.uvCoordinatesBufferAttribute;
    }

    this.expiredFlagBufferAttribute = new THREE.BufferAttribute(this.expiredFlags, 1);
    this.flags2BufferAttribute = new THREE.BufferAttribute(this.flags2, 4);
    this.expiredFlagBufferAttribute.setDynamic(true);
    this.flags2BufferAttribute.setDynamic(true);
  }else{
    this.positionBufferAttribute = new THREE.BufferAttribute(this.positions, 3);
    if (this.rgbThresholds){
      this.rgbThresholdBufferAttribute = new THREE.BufferAttribute(this.rgbThresholds, 3);
      this.rgbThresholdBufferAttribute.setDynamic(false);
    }
    this.expiredFlagBufferAttribute = new THREE.BufferAttribute(this.expiredFlags, 1);
    this.velocityBufferAttribute = new THREE.BufferAttribute(this.velocities, 3);
    this.accelerationBufferAttribute = new THREE.BufferAttribute(this.accelerations, 3);
    if (!noTargetColor){
      this.targetColorBufferAttribute = new THREE.BufferAttribute(this.targetColors, 4);
      this.targetColorBufferAttribute.setDynamic(false);
    }
    this.flags1BufferAttribute = new THREE.BufferAttribute(this.flags1, 4);
    this.flags2BufferAttribute = new THREE.BufferAttribute(this.flags2, 4);
    this.flags3BufferAttribute = new THREE.BufferAttribute(this.flags3, 4);
    this.flags4BufferAttribute = new THREE.BufferAttribute(this.flags4, 4);
    this.angularQuaternionsBufferAttribute = new THREE.BufferAttribute(this.angularQuaternions, 4);
    if (this.uvCoordinates){
      this.uvCoordinatesBufferAttribute = new THREE.BufferAttribute(this.uvCoordinates, 4);
      this.uvCoordinatesBufferAttribute.setDynamic(false);
    }

    this.positionBufferAttribute.setDynamic(false);
    this.expiredFlagBufferAttribute.setDynamic(true);
    this.velocityBufferAttribute.setDynamic(false);
    this.accelerationBufferAttribute.setDynamic(false);
    this.flags1BufferAttribute.setDynamic(false);
    this.flags2BufferAttribute.setDynamic(true);
    this.flags3BufferAttribute.setDynamic(false);
    this.flags4BufferAttribute.setDynamic(false);
    this.angularQuaternionsBufferAttribute.setDynamic(false);

  }

  this.geometry.addAttribute('position', this.positionBufferAttribute);
  if (this.rgbThresholdBufferAttribute){
    this.geometry.addAttribute('rgbThreshold', this.rgbThresholdBufferAttribute);
  }
  this.geometry.addAttribute('expiredFlag', this.expiredFlagBufferAttribute);
  this.geometry.addAttribute('velocity', this.velocityBufferAttribute);
  this.geometry.addAttribute('acceleration', this.accelerationBufferAttribute);
  if (!noTargetColor){
    this.geometry.addAttribute('targetColor', this.targetColorBufferAttribute);
  }
  this.geometry.addAttribute('flags1', this.flags1BufferAttribute);
  this.geometry.addAttribute('flags2', this.flags2BufferAttribute);
  this.geometry.addAttribute('flags3', this.flags3BufferAttribute);
  this.geometry.addAttribute('flags4', this.flags4BufferAttribute);
  this.geometry.addAttribute('angularQuaternion', this.angularQuaternionsBufferAttribute);
  if (this.uvCoordinatesBufferAttribute){
    this.geometry.addAttribute('uvCoordinates', this.uvCoordinatesBufferAttribute);
  }
  this.geometry.setDrawRange(0, particles.length);


  this.velocity = new THREE.Vector3(vx, vy, vz);
  this.acceleration = new THREE.Vector3(ax, ay, az);
  var motionModeFlag = -10.0;
  if (this.motionMode == MOTION_MODE_NORMAL){
    motionModeFlag = 5.0;
  }else if (this.motionMode == MOTION_MODE_CIRCULAR){
    motionModeFlag = 20.0;
  }

  var texture;
  if (textureMerger){
    texture = textureMerger.mergedTexture;
  }

  if (!this.copyPS){
    this.material = new THREE.RawShaderMaterial({
      vertexShader: ShaderContent.particleVertexShader,
      fragmentShader: ShaderContent.particleFragmentShader,
      transparent: true,
      side: THREE.DoubleSide,
      uniforms:{
        modelViewMatrix: new THREE.Uniform(new THREE.Matrix4()),
        projectionMatrix: GLOBAL_PROJECTION_UNIFORM,
        worldMatrix: new THREE.Uniform(new THREE.Matrix4()),
        viewMatrix: GLOBAL_VIEW_UNIFORM,
        time: new THREE.Uniform(0.0),
        dissapearCoef: new THREE.Uniform(0.0),
        stopInfo: new THREE.Uniform(new THREE.Vector3(-10, -10, -10)),
        parentMotionMatrix: new THREE.Uniform(new THREE.Matrix3().fromArray([
          x, y, z, vx, vy, vz, ax, ay, az
        ])),
      }
    });
  }else{
    this.material = this.copyPS.material.clone();
    this.material.uniforms.projectionMatrix = GLOBAL_PROJECTION_UNIFORM;
    this.material.uniforms.viewMatrix = GLOBAL_VIEW_UNIFORM;
  }

  if (fogBlendWithSkybox){
    this.material.uniforms.cameraPosition = GLOBAL_CAMERA_POSITION_UNIFORM;
    this.material.uniforms.cubeTexture = GLOBAL_CUBE_TEXTURE_UNIFORM;
    this.injectMacro(this.material, "HAS_SKYBOX_FOG", true, true);
  }
  if (fogActive){
    this.material.uniforms.fogInfo = GLOBAL_FOG_UNIFORM;
    this.injectMacro(this.material, "HAS_FOG", false, true);
  }
  if (texture){
    this.material.uniforms.texture = new THREE.Uniform(texture);
    this.injectMacro(this.material, "HAS_TEXTURE", true, true);
  }
  if (!noTargetColor){
    this.injectMacro(this.material, "HAS_TARGET_COLOR", true, false);
  }

  this.mesh = new THREE.Points(this.geometry, this.material);
  this.mesh.position.set(x, y, z);
  this.mesh.frustumCulled = false;
  this.mesh.visible = false;

  scene.add(this.mesh);
  particleSystemPool[name] = this;

}

ParticleSystem.prototype.generatePSCollisionInfo = function(){
  var obj = this.collisionWorkerInfo;
  obj.name = this.name;
  obj.psCollisionWorkerIndex = this.psCollisionWorkerIndex;
  obj.psCollisionWorkerSegment = this.psCollisionWorkerSegment;
  obj.x = this.x;
  obj.y = this.y;
  obj.z = this.z;
  obj.vx = this.vx;
  obj.vy = this.vy;
  obj.vz = this.vz;
  obj.ax = this.ax;
  obj.ay = this.ay;
  obj.az = this.az;
  obj.motionMode = this.motionMode;
  obj.angularVelocity = this.angularVelocity;
  obj.angularAcceleration = this.angularAcceleration;
  obj.angularMotionRadius = this.angularMotionRadius;
  obj.angularQuaternionX = this.angularQuaternionX;
  obj.angularQuaternionY = this.angularQuaternionY;
  obj.angularQuaternionZ = this.angularQuaternionZ;
  obj.angularQuaternionW = this.angularQuaternionW;
  obj.initialAngle = this.initialAngle;
  obj.lifetime = this.lifetime;
  obj.collisionTimeOffset = this.collisionTimeOffset;
  return obj;
}

ParticleSystem.prototype.generateNewPSInfo = function(){
  return this.name+","+this.collisionWorkerIndex+","+this.x+","+this.y+","+this.z+","+
         this.vx+","+this.vy+","+this.vz+","+this.ax+","+this.ay+","+this.az;
}

ParticleSystem.prototype.notifyParticleCollisionCallbackChange = function(particle){
  if (particle.checkForCollisions){
    this.particlesWithCollisionCallbacks.set(particle.uuid, particle);
  }else{
    this.particlesWithCollisionCallbacks.delete(particle.uuid);
  }
}

ParticleSystem.prototype.destroy = function(){
  if (this.mesh){
    scene.remove(this.mesh);
    this.mesh.geometry.dispose();
    this.mesh.material.dispose();
    this.mesh = 0;
    this.particles = 0;
    this.destroyed = true;
    if (particleSystemCollisionCallbackRequests[this.name]){
      TOTAL_PARTICLE_SYSTEM_COLLISION_LISTEN_COUNT --;
    }
    delete particleSystemCollisionCallbackRequests[this.name];
    this.checkForCollisions = false;
    if (this.psPool){
      particleSystemPools[this.psPool].remove(this);
    }
    if (this.psMerger){
      this.psMerger.removePS(this);
    }
  }
}

ParticleSystem.prototype.stop = function(newLifetime){
  this.velocity.x = 0;
  this.velocity.y = 0;
  this.velocity.z = 0;
  this.acceleration.x = 0;
  this.acceleration.y = 0;
  this.acceleration.z = 0;
  this.originalCheckForCollisions = this.checkForCollisions;
  this.checkForCollisions = false;
  if (!this.psMerger){
    this.material.uniforms.stopInfo.value.set(10.0, this.tick, newLifetime);
  }else{
    this.psMerger.material.uniforms.stopInfoArray.value[this.mergedIndex].set(10.0, this.tick, newLifetime);
  }
  this.originalLifetime = this.lifetime;
  this.lifetime = (this.tick + newLifetime);
  this.stopped = true;
  this.stoppedX = this.mesh.position.x;
  this.stoppedY = this.mesh.position.y;
  this.stoppedZ = this.mesh.position.z;
  if(!isCollisionWorkerEnabled()){
    this.particlesWithCollisionCallbacks.forEach(this.particleIterationStopFunc);
  }
}

ParticleSystem.prototype.particleIterationStopFunc = function(value, key){
  var particle = value;
  particle.stopLifetime = newLifetime;
  particle.respawnSet = false;
  particle.stopTick = this.tick;
  particle.lifetime = newLifetime;
  if (particle.startDelay > this.tick){
    particle.startDelay = this.tick;
  }
}

ParticleSystem.prototype.setBlending = function(mode){
  this.material.blending = mode;
}

ParticleSystem.prototype.removeParticle = function(particle){
  var selectedGeometry;
  var selectedOffset = particle.index;
  if (this.psMerger){
    selectedOffset += this.expiredFlagOffset;
    selectedGeometry = this.psMerger.geometry;
  }else{
    selectedGeometry = this.geometry;
  }
  selectedGeometry.attributes.expiredFlag.updateRange.push({
    offset: selectedOffset, count: 1
  });
  selectedGeometry.attributes.expiredFlag.array[particle.index] = 7;
  selectedGeometry.attributes.expiredFlag.needsUpdate = true;
  particle.isExpired = true;
  if (particle.uuid){
    this.particlesWithCollisionCallbacks.delete(particle.uuid);
  }
}

ParticleSystem.prototype.rewindParticle = function(particle, delay){
  var selectedGeometry;
  var sIndex = (particle.index * 4) + 3;
  if (this.psMerger){
    selectedGeometry = this.psMerger.geometry;
    sIndex += this.flags2Offset;
  }else{
    selectedGeometry = this.geometry;
  }
  selectedGeometry.attributes.flags2.updateRange.push({
    offset: sIndex, count: 1
  });
  particle.startDelay = this.tick + delay;
  selectedGeometry.attributes.flags2.array[sIndex] = particle.startDelay;
  selectedGeometry.attributes.flags2.needsUpdate = true;
}

ParticleSystem.prototype.calculatePseudoPosition = function(fromWorker){
  var pseudoTick = this.tick + (this.collisionTimeOffset * (1/60));
  var vx = 0, vy = 0, vz = 0, ax = 0, ay = 0, az = 0;
  if (!fromWorker){
    if (this.velocity){
      vx = this.velocity.x;
      vy = this.velocity.y;
      vz = this.velocity.z;
    }
    if (this.acceleration){
      ax = this.acceleration.x;
      ay = this.acceleration.y;
      az = this.acceleration.z;
    }
  }else{
    vx = this.vx;
    vy = this.vy;
    vz = this.vz;
    ax = this.ax;
    ay = this.ay;
    az = this.az;
  }
  if (this.motionMode == MOTION_MODE_NORMAL){
    var dx = (vx * pseudoTick) + (0.5 * ax * pseudoTick * pseudoTick);
    var dy = (vy * pseudoTick) + (0.5 * ay * pseudoTick * pseudoTick);
    var dz = (vz * pseudoTick) + (0.5 * az * pseudoTick * pseudoTick);
    REUSABLE_VECTOR.set(this.x + dx, this.y + dy, this.z + dz);
    return REUSABLE_VECTOR;
  }else if (this.motionMode == MOTION_MODE_CIRCULAR){
    var angleNow = this.initialAngle +
        (this.angularVelocity * pseudoTick) +
          (0.5 * this.angularAcceleration * pseudoTick * pseudoTick);
    REUSABLE_VECTOR.set(
          (this.angularMotionRadius * Math.cos(angleNow)),
          this.y,
          (this.angularMotionRadius * Math.sin(angleNow))
    );
    if (!(this.angularQuaternionX == 0 && this.angularQuaternionY == 0 && this.angularQuaternionZ == 0 && this.angularQuaternionW == 1)){
      REUSABLE_VECTOR.applyQuaternion(REUSABLE_QUATERNION.set(
        this.angularQuaternionX, this.angularQuaternionY, this.angularQuaternionZ, this.angularQuaternionW
      ));
    }
    REUSABLE_VECTOR.x += this.x;
    REUSABLE_VECTOR.y += this.y;
    REUSABLE_VECTOR.z += this.z;
    return REUSABLE_VECTOR;
  }
}

ParticleSystem.prototype.update = function(){

  if (this.destroyed){
    return;
  }

  this.tick += (1/60);

  if (isMobile){
    if (this.tick > 20){
      this.tick =  0;
    }
  }else{
    if (this.tick > MAX_PS_TIME){
      this.tick = 0;
    }
  }

  if (!this.psMerger){
    this.material.uniforms.time.value = this.tick;
    this.material.uniforms.modelViewMatrix.value = this.mesh.modelViewMatrix;
    this.material.uniforms.worldMatrix.value = this.mesh.matrixWorld;
  }else{
    this.mesh.updateMatrixWorld(true);
    this.mesh.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, this.mesh.matrixWorld);
    this.psMerger.material.uniforms.modelViewMatrixArray.value[this.mergedIndex] = this.mesh.modelViewMatrix;
    this.psMerger.material.uniforms.timeArray.value[this.mergedIndex] = this.tick;
  }


  var vx = 0, vy = 0, vz = 0, ax = 0, ay = 0, az = 0;

  if (this.velocity){
    vx = this.velocity.x;
    vy = this.velocity.y;
    vz = this.velocity.z;
  }

  if (this.acceleration){
    ax = this.acceleration.x;
    ay = this.acceleration.y;
    az = this.acceleration.z;
  }

  if (this.motionMode == MOTION_MODE_NORMAL && !this.stopped){
    var dx = (vx * this.tick) + (0.5 * ax * this.tick * this.tick);
    var dy = (vy * this.tick) + (0.5 * ay * this.tick * this.tick);
    var dz = (vz * this.tick) + (0.5 * az * this.tick * this.tick);

    if (dx != 0 || dy != 0 || dz != 0){
      this.mesh.position.set(
        (this.x + dx),
        (this.y + dy),
        (this.z + dz)
      );
    }
  }else if (this.motionMode == MOTION_MODE_CIRCULAR && !this.stopped){
    var angleNow = this.initialAngle +
        (this.angularVelocity * this.tick) +
          (0.5 * this.angularAcceleration * this.tick * this.tick);
    this.mesh.position.set(
      (this.angularMotionRadius * Math.cos(angleNow)),
      this.y,
      (this.angularMotionRadius * Math.sin(angleNow))
    );
    if (!(this.angularQuaternionX == 0 && this.angularQuaternionY == 0 && this.angularQuaternionZ == 0 && this.angularQuaternionW == 1)){
      this.mesh.position.applyQuaternion(REUSABLE_QUATERNION.set(
        this.angularQuaternionX, this.angularQuaternionY, this.angularQuaternionZ, this.angularQuaternionW
      ));
    }
    this.mesh.position.set(
      this.mesh.position.x + this.x,
      this.mesh.position.y + this.y,
      this.mesh.position.z + this.z
    );
  }

  if (this.stopped){
    this.mesh.position.set(this.stoppedX, this.stoppedY, this.stoppedZ);
  }

  if (this.updateFunction){
    this.updateFunction();
  }

  if (!isCollisionWorkerEnabled()){
    this.particlesWithCollisionCallbacks.forEach(this.particleIterationCollisionFunc);
  }

  if (this.gpuMotionUpdateBuffer.length > 0){
    var firstIndex = this.gpuMotionUpdateBuffer[0].index;
    for (var i = 0; i<this.gpuMotionUpdateBuffer.length; i++){
      this.updateGPUMotion(this.gpuMotionUpdateBuffer[i]);
      if (this.gpuMotionUpdateBuffer[i].index < firstIndex){
        firstIndex = this.gpuMotionUpdateBuffer[i].index;
      }
    }
    this.partialGPUMotionBufferUpdate(firstIndex);
    this.gpuMotionUpdateBuffer = [];
  }

  if (this.tick >= this.lifetime && this.lifetime > 0){
    if (this.expirationFunction){
      this.expirationFunction(this.name);
    }
    if (!this.psMerger){
      delete particleSystems[this.name];
    }else{
      this.psMerger.material.uniforms.hiddenArray.value[this.mergedIndex] = 20.0;
      this.psMerger.notifyPSVisibilityChange(this, false);
    }
    this.mesh.visible = false;
    if (!(typeof this.psPool == UNDEFINED)){
      particleSystemPools[this.psPool].notifyPSAvailable(this);
    }
  }

  if (this.checkForCollisions && !isPSCollisionWorkerEnabled() && this.mesh && this.mesh.visible){
    this.handleCollisions();
  }
}

ParticleSystem.prototype.particleIterationCollisionFunc = function(value){
  var particle = value;
  if (!particle.isExpired){
    particle.handleCollisions();
  }
}

ParticleSystem.prototype.partialGPUMotionBufferUpdate = function(firstIndex){
  this.geometry.attributes.velocity.updateRange.offset = 3 * firstIndex;
  this.geometry.attributes.velocity.updateRange.count = this.particles.length * 3;
  this.geometry.attributes.acceleration.updateRange.offset = 3 * firstIndex;
  this.geometry.attributes.acceleration.updateRange.count = this.particles.length * 3;
  this.geometry.attributes.velocity.needsUpdate = true;
  this.geometry.attributes.acceleration.needsUpdate = true;
}

ParticleSystem.prototype.rotate = function(axis, radians, fromScript){
  if (axis.toLowerCase() == "x"){
    this.mesh.rotateX(radians);
  }else if (axis.toLowerCase() == "y"){
    this.mesh.rotateY(radians);
  }else if (axis.toLowerCase() == "z"){
    this.mesh.rotateZ(radians);
  }
}

ParticleSystem.prototype.getVelocityAtTime = function(time, targetVector){
  if (this.motionMode == MOTION_MODE_NORMAL){
    if (!targetVector){
      var vec = ROYGBIV.vector(0, 0, 0);
      vec.x = this.velocity.x + (this.acceleration.x * time);
      vec.y = this.velocity.y + (this.acceleration.y * time);
      vec.z = this.velocity.z + (this.acceleration.z * time);
      return vec;
    }else{
      targetVector.x = this.velocity.x + (this.acceleration.x * time);
      targetVector.y = this.velocity.y + (this.acceleration.y * time);
      targetVector.z = this.velocity.z + (this.acceleration.z * time);
      return targetVector;
    }
  }else if (this.motionMode == MOTION_MODE_CIRCULAR){
    return (this.angularVelocity + (this.angularAcceleration * time));
  }
}

ParticleSystem.prototype.fireCollisionCallback = function(collisionInfo){
  var request = particleSystemCollisionCallbackRequests[this.name];
  if (!request){
    return;
  }
  request(collisionInfo);
}

ParticleSystem.prototype.handleCollisions = function(fromWorker){
  var results;
  var pseudoPosition;
  if (this.collisionTimeOffset == 0){
    if (fromWorker){
      results = worldBinHandler.query(this.mesh.position);
    }else{
      results = rayCaster.binHandler.query(this.mesh.position);
    }
  }else{
    pseudoPosition = this.calculatePseudoPosition(fromWorker);
    if (fromWorker){
      results = worldBinHandler.query(pseudoPosition);
    }else{
      results = rayCaster.binHandler.query(pseudoPosition);
    }
  }
  if (this.positionHistoryCounter == 0){
    var end = this.positionLine.end;
    if (this.collisionTimeOffset == 0){
      this.positionLine.set(this.mesh.position, end);
    }else{
      this.positionLine.set(pseudoPosition, end);
    }
  }else if (this.positionHistoryCounter == 1){
    var start = this.positionLine.start;
    if (this.collisionTimeOffset == 0){
      this.positionLine.set(start, this.mesh.position);
    }else{
      this.positionLine.set(start, pseudoPosition);
    }
  }
  this.positionHistoryCounter ++;
  if (this.positionHistoryCounter == 2){
    this.positionHistoryCounter = 0;
  }
  for (var objName in results){
    var result = results[objName];
    if (result == 5){
      var obj = addedObjects[objName];
      if (!obj){
        return;
      }
      var intersectionPoint;
      if (!fromWorker){
        intersectionPoint = obj.intersectsLine(this.positionLine);
      }else{
        var res = intersectsLine(objName, this);
        if (res){
          return;
        }
        continue;
      }
      if (intersectionPoint){
        var collisionInfo = reusableCollisionInfo.set(
          objName, intersectionPoint.x, intersectionPoint.y, intersectionPoint.z,
          0, obj.mesh.quaternion.x, obj.mesh.quaternion.y, obj.mesh.quaternion.z,
          obj.mesh.quaternion.w, INTERSECTION_NORMAL, this.tick
        );
        this.fireCollisionCallback(collisionInfo);
      }
    }else{
      var obj;
      var parent = objectGroups[objName];
      if (!parent){
        return;
      }
      for (var childName in result){
        if (!fromWorker){
          obj = parent.group[childName];
        }else{
          obj = true;
        }
        if (!obj){
          return;
        }
        if (!fromWorker){
          var intersectionPoint = obj.intersectsLine(this.positionLine);
        }else{
          if (intersectsLine(objName, this, childName)){
            return;
          }
        }
        if (intersectionPoint){
          var collisionInfo = reusableCollisionInfo.set(
            objName, intersectionPoint.x, intersectionPoint.y, intersectionPoint.z,
            0, parent.mesh.quaternion.x, parent.mesh.quaternion.y,
            parent.mesh.quaternion.z, parent.mesh.quaternion.w,
            INTERSECTION_NORMAL, this.tick
          );
          this.fireCollisionCallback(collisionInfo);
          return;
        }
      }
    }
  }
}

ParticleSystem.prototype.injectMacro = function(material, macro, insertVertexShader, insertFragmentShader){
  if (insertVertexShader){
    material.vertexShader = material.vertexShader.replace(
      "#define INSERTION", "#define INSERTION\n#define "+macro
    )
  };
  if (insertFragmentShader){
    material.fragmentShader = material.fragmentShader.replace(
      "#define INSERTION", "#define INSERTION\n#define "+macro
    )
  };
  material.needsUpdate = true;
}

ParticleSystem.prototype.removeMacro = function(material, macro, removeVertexShader, removeFragmentShader){
  if (removeVertexShader){
    material.vertexShader = material.vertexShader.replace("\n#define "+macro, "");
  }
  if (removeFragmentShader){
    material.fragmentShader = material.fragmentShader.replace("\n#define "+macro, "");
  }
  material.needsUpdate = true;
}

var ObjectTrail = function(configurations){
  this.object = configurations.object;
  this.alpha = configurations.alpha;

  var OBJECT_TRAIL_MAX_TIME_IN_SECS = OBJECT_TRAIL_MAX_TIME_IN_SECS_DEFAULT;
  if (!(typeof configurations.maxTimeInSeconds == UNDEFINED)){
    OBJECT_TRAIL_MAX_TIME_IN_SECS = configurations.maxTimeInSeconds;
  }
  this.OBJECT_TRAIL_MAX_TIME_IN_SECS = OBJECT_TRAIL_MAX_TIME_IN_SECS;

  var geometry;
  if (this.object.isAddedObject){
    geometry = this.object.getNormalGeometry();
    var color = this.object.material.color;
    for (var i = 0; i<geometry.faces.length; i++){
      geometry.faces[i].roygbivObjectName = this.object.name;
      if (this.object.hasEmissiveMap()){
        geometry.faces[i].faceEmissiveIntensity = this.object.mesh.material.uniforms.emissiveIntensity.value;
        geometry.faces[i].faceEmissiveColor = this.object.mesh.material.uniforms.emissiveColor.value;
      }else{
        geometry.faces[i].faceEmissiveIntensity = 0;
        geometry.faces[i].faceEmissiveColor = WHITE_COLOR;
      }
    }
    this.isAddedObject = true;
  }else if (this.object.isObjectGroup){
    this.isAddedObject = false;
    geometry = new THREE.Geometry();
    var miMap = new Object();
    var mi = 0;
    for (var objectName in this.object.group){
      var childObj = this.object.group[objectName];
      miMap[mi] = childObj.name;
      var childGeom = childObj.getNormalGeometry();
      for (var i = 0; i<childGeom.faces.length; i++){
        var color = childObj.material.color;
        childGeom.faces[i].materialIndex = mi;
      }
      mi++;
      childObj.mesh.updateMatrix();
      geometry.merge(childGeom, childObj.mesh.matrix);
    }
    for (var i = 0; i<geometry.faces.length; i++){
      var mi = geometry.faces[i].materialIndex;
      var objName = miMap[mi];
      geometry.faces[i].roygbivObjectName = objName;
      var childObj = this.object.group[objName];
      if (childObj.hasEmissiveMap()){
        geometry.faces[i].faceEmissiveIntensity = childObj.mesh.material.uniforms.emissiveIntensity.value * this.object.mesh.material.uniforms.totalEmissiveIntensity.value;
        geometry.faces[i].faceEmissiveColor = childObj.mesh.material.uniforms.emissiveColor.value;
      }else{
        geometry.faces[i].faceEmissiveIntensity = 0;
        geometry.faces[i].faceEmissiveColor = WHITE_COLOR;
      }
    }
  }

  var texturesObject = new Object();
  if (this.object.mesh.material.uniforms.diffuseMap){
    this.diffuseTexture = this.object.mesh.material.uniforms.diffuseMap.value;
    this.hasTexture = true;
  }
  if (this.object.mesh.material.uniforms.displacementMap && VERTEX_SHADER_TEXTURE_FETCH_SUPPORTED){
    this.displacementTexture = this.object.mesh.material.uniforms.displacementMap.value;
    this.hasTexture = true;
  }
  if (this.object.mesh.material.uniforms.alphaMap){
    this.alphaTexture = this.object.mesh.material.uniforms.alphaMap.value;
    this.hasTexture = true;
  }
  if (this.object.mesh.material.uniforms.emissiveMap){
    this.emissiveTexture = this.object.mesh.material.uniforms.emissiveMap.value;
    this.hasTexture = true;
  }

  var faces = geometry.faces;
  var vertices = geometry.vertices;
  var faceVertexUVs = geometry.faceVertexUvs;

  var geometry = new THREE.BufferGeometry();
  var positionsTypedArray = new Float32Array(faces.length * 3 * 3 * 60 * OBJECT_TRAIL_MAX_TIME_IN_SECS);
  var colorsTypedArray = new Float32Array(faces.length * 3 * 3 * 60 * OBJECT_TRAIL_MAX_TIME_IN_SECS);
  var coordIndicesTypedArray = new Float32Array(faces.length * 3 * 60 * OBJECT_TRAIL_MAX_TIME_IN_SECS);
  var quatIndicesTypedArray = new Float32Array(faces.length * 3 * 60 * OBJECT_TRAIL_MAX_TIME_IN_SECS);
  var emissiveIntensitiesTypedArray;
  var emissiveColorsTypedArray;
  var normalsTypedArray;
  var displacementInfosTypedArray;
  var faceVertexUVsTypedArray;
  var textureFlagsTypedArray;
  var objPositions = [];
  var objColors = [];
  var objNormals;
  var objUVs;
  var objEmissiveIntensities;
  var objEmissiveColors;
  var objTextureFlags;
  var objDisplacementInfos;
  if (this.emissiveTexture){
    objEmissiveIntensities = [];
    objEmissiveColors = [];
    emissiveIntensitiesTypedArray = new Float32Array(faces.length * 3 * 60 * OBJECT_TRAIL_MAX_TIME_IN_SECS);
    emissiveColorsTypedArray = new Float32Array(faces.length * 3 * 3 * 60 * OBJECT_TRAIL_MAX_TIME_IN_SECS);
  }
  if (this.displacementTexture){
    objNormals = [];
    objDisplacementInfos = [];
    normalsTypedArray = new Float32Array(faces.length * 3 * 3 * 60 * OBJECT_TRAIL_MAX_TIME_IN_SECS);
    displacementInfosTypedArray = new Float32Array(faces.length * 3 * 2 * 60 * OBJECT_TRAIL_MAX_TIME_IN_SECS);
  }
  if (this.hasTexture){
    objUVs = [];
    objTextureFlags = [];
    objTextureMatrixInfos = [];
    faceVertexUVsTypedArray = new Float32Array(faces.length * 3 * 2 * 60 * OBJECT_TRAIL_MAX_TIME_IN_SECS);
    textureFlagsTypedArray = new Float32Array(faces.length * 3 * 3 * 60 * OBJECT_TRAIL_MAX_TIME_IN_SECS);
    textureMatrixInfosTypedArray = new Float32Array(faces.length * 3 * 4 * 60 * OBJECT_TRAIL_MAX_TIME_IN_SECS);
  }

  for (var i = 0; i < faces.length; i++){
    var face = faces[i];
    var a = face.a;
    var b = face.b;
    var c = face.c;
    var vertex1 = vertices[a];
    var vertex2 = vertices[b];
    var vertex3 = vertices[c];

    objPositions.push(vertex1);
    objPositions.push(vertex2);
    objPositions.push(vertex3);

    var curFaceVertexUV = faceVertexUVs[0][i];
    var vUVary;
    if (this.hasTexture){
      vUVary = [];
      for (var ix = 0; ix<3; ix++){
        var vuv = curFaceVertexUV[ix];
        vUVary.push(new THREE.Vector2(vuv.x, vuv.y));
      }
      objUVs.push(vUVary[0]);
      objUVs.push(vUVary[1]);
      objUVs.push(vUVary[2]);
      if (this.displacementTexture){
        objNormals.push(face.normal);
        objNormals.push(face.normal);
        objNormals.push(face.normal);
      }
    }


    var objName = face.roygbivObjectName;
    var obj;
    if (this.isAddedObject){
      obj = addedObjects[objName];
    }else{
      obj = this.object.group[objName];
    }

    if (this.hasTexture){
      objTextureMatrixInfos.push(new THREE.Vector4(
        obj.getTextureOffsetX(), obj.getTextureOffsetY(), obj.getTextureRepeatX(), obj.getTextureRepeatY()
      ));
    }

    if (this.displacementTexture){
      var displacementInfo = new THREE.Vector2(-100, -100);
      if (obj.hasDisplacementMap()){
        displacementInfo.x = obj.mesh.material.uniforms.displacementInfo.value.x;
        displacementInfo.y = obj.mesh.material.uniforms.displacementInfo.value.y;
      }
      objDisplacementInfos.push(displacementInfo);
      objDisplacementInfos.push(displacementInfo);
      objDisplacementInfos.push(displacementInfo);
    }

    objColors.push(obj.material.color);
    objColors.push(obj.material.color);
    objColors.push(obj.material.color);

    if (this.emissiveTexture){
      objEmissiveIntensities.push(face.faceEmissiveIntensity);
      objEmissiveIntensities.push(face.faceEmissiveIntensity);
      objEmissiveIntensities.push(face.faceEmissiveIntensity);
      objEmissiveColors.push(face.faceEmissiveColor);
      objEmissiveColors.push(face.faceEmissiveColor);
      objEmissiveColors.push(face.faceEmissiveColor);
    }

    if (this.hasTexture){
      var textureFlagsVec = new THREE.Vector3();
      if (obj.hasDiffuseMap()){
        textureFlagsVec.x = 20;
      }else{
        textureFlagsVec.x = -20;
      }
      if (obj.hasEmissiveMap()){
        textureFlagsVec.y = 20;
      }else{
        textureFlagsVec.y = -20;
      }
      if (obj.hasAlphaMap()){
        textureFlagsVec.z = 20;
      }else{
        textureFlagsVec.z = -20;
      }
      objTextureFlags.push(textureFlagsVec);
      objTextureFlags.push(textureFlagsVec);
      objTextureFlags.push(textureFlagsVec);
    }
  }

  var i2 = 0;
  var i3 = 0;
  var i4 = 0;
  var i5 = 0;
  var i6 = 0;
  var i7 = 0;
  var i8 = 0;
  var i9 = 0;
  var i10 = 0;
  var i11 = 0;
  var i12 = 0;
  var i13 = 0;
  var i14 = 0;
  var i15 = 0;
  var i16 = 0;
  for (var i = 0; i<faces.length * OBJECT_TRAIL_MAX_TIME_IN_SECS * 3 * 60; i++){
    positionsTypedArray[i2++] = objPositions[i3].x;
    positionsTypedArray[i2++] = objPositions[i3].y;
    positionsTypedArray[i2++] = objPositions[i3].z;
    colorsTypedArray[i9++] = objColors[i3].r;
    colorsTypedArray[i9++] = objColors[i3].g;
    colorsTypedArray[i9++] = objColors[i3].b;
    coordIndicesTypedArray[i] = i4;
    quatIndicesTypedArray[i] = i6;
    if (this.displacementTexture){
      normalsTypedArray[i10++] = objNormals[i3].x;
      normalsTypedArray[i10++] = objNormals[i3].y;
      normalsTypedArray[i10++] = objNormals[i3].z;
      displacementInfosTypedArray[i13++] = objDisplacementInfos[i8].x;
      displacementInfosTypedArray[i13++] = objDisplacementInfos[i8].y;
    }
    if (this.hasTexture){
      faceVertexUVsTypedArray[i7++] = objUVs[i8].x;
      faceVertexUVsTypedArray[i7++] = objUVs[i8].y;
      textureFlagsTypedArray[i12++] = objTextureFlags[i3].x;
      textureFlagsTypedArray[i12++] = objTextureFlags[i3].y;
      textureFlagsTypedArray[i12++] = objTextureFlags[i3].z;
      textureMatrixInfosTypedArray[i15++] = objTextureMatrixInfos[i16].x;
      textureMatrixInfosTypedArray[i15++] = objTextureMatrixInfos[i16].y;
      textureMatrixInfosTypedArray[i15++] = objTextureMatrixInfos[i16].z;
      textureMatrixInfosTypedArray[i15++] = objTextureMatrixInfos[i16].w;
    }
    if (this.emissiveTexture){
      emissiveIntensitiesTypedArray[i] = objEmissiveIntensities[i11];
      emissiveColorsTypedArray[i14++] = objEmissiveColors[i3].r;
      emissiveColorsTypedArray[i14++] = objEmissiveColors[i3].g;
      emissiveColorsTypedArray[i14++] = objEmissiveColors[i3].b;
    }
    i3++;
    if (i3 >= objPositions.length){
      i3 = 0;
    }
    if (this.hasTexture){
      i8++;
      if (i8 >= objUVs.length){
        i8 = 0;
      }
    }
    if (this.emissiveTexture){
      i11++;
      if (i11 >= objEmissiveIntensities.length){
        i11 = 0;
      }
    }
    if (this.hasTexture){
      i16++;
      if (i16 >= objTextureMatrixInfos.length){
        i16 = 0;
      }
    }
    i5 ++;
    if (i5 == objPositions.length){
      i4 += 3;
      i6 += 4;
      if (i4 >= 60 * OBJECT_TRAIL_MAX_TIME_IN_SECS * 3){
        i4 = 0;
      }
      if (i6 >= 60 * OBJECT_TRAIL_MAX_TIME_IN_SECS * 4){
        i6 = 0;
      }
      i5 = 0;
    }
  }

  var positionBufferAttribute = new THREE.BufferAttribute(positionsTypedArray, 3);
  var colorBufferAttribute = new THREE.BufferAttribute(colorsTypedArray, 3);
  var coordIndicesBufferAttribute = new THREE.BufferAttribute(coordIndicesTypedArray, 1);
  var quatIndicesBufferAttribute = new THREE.BufferAttribute(quatIndicesTypedArray, 1);
  var emissiveIntensityBufferAttribute;
  var emissiveColorsBufferAttribute;
  var normalBufferAttribute;
  var faceVertexUVsBufferAttribute;
  var textureFlagsBufferAttribute;
  var displacementInfosBufferAttribute;
  var textureMatrixInfosBufferAttribute;

  if (this.emissiveTexture){
    emissiveIntensityBufferAttribute = new THREE.BufferAttribute(emissiveIntensitiesTypedArray, 1);
    emissiveColorsBufferAttribute = new THREE.BufferAttribute(emissiveColorsTypedArray, 3);
    emissiveIntensityBufferAttribute.setDynamic(false);
    emissiveColorsBufferAttribute.setDynamic(false);
    geometry.addAttribute('emissiveIntensity', emissiveIntensityBufferAttribute);
    geometry.addAttribute('emissiveColor', emissiveColorsBufferAttribute);
  }
  if (this.displacementTexture){
    normalBufferAttribute = new THREE.BufferAttribute(normalsTypedArray, 3);
    displacementInfosBufferAttribute = new THREE.BufferAttribute(displacementInfosTypedArray, 2);
    normalBufferAttribute.setDynamic(false);
    displacementInfosBufferAttribute.setDynamic(false);
    geometry.addAttribute('normal', normalBufferAttribute);
    geometry.addAttribute('displacementInfo', displacementInfosBufferAttribute);
  }
  if (this.hasTexture){
    faceVertexUVsBufferAttribute = new THREE.BufferAttribute(faceVertexUVsTypedArray, 2);
    textureFlagsBufferAttribute = new THREE.BufferAttribute(textureFlagsTypedArray, 3);
    textureMatrixInfosBufferAttribute = new THREE.BufferAttribute(textureMatrixInfosTypedArray, 4);
    faceVertexUVsBufferAttribute.setDynamic(false);
    textureFlagsBufferAttribute.setDynamic(false);
    textureMatrixInfosBufferAttribute.setDynamic(false);
    geometry.addAttribute('faceVertexUV', faceVertexUVsBufferAttribute);
    geometry.addAttribute('textureFlags', textureFlagsBufferAttribute);
    geometry.addAttribute('textureMatrixInfo', textureMatrixInfosBufferAttribute);
  }

  positionBufferAttribute.setDynamic(false);
  colorBufferAttribute.setDynamic(false);
  coordIndicesBufferAttribute.setDynamic(false);
  quatIndicesBufferAttribute.setDynamic(false);

  geometry.addAttribute('position', positionBufferAttribute);
  geometry.addAttribute('color', colorBufferAttribute);
  geometry.addAttribute('coordIndex', coordIndicesBufferAttribute);
  geometry.addAttribute('quatIndex', quatIndicesBufferAttribute);

  var objectCoordinateSize = parseInt(60 * OBJECT_TRAIL_MAX_TIME_IN_SECS * 3);
  var objectQuaternionSize = parseInt(60 * OBJECT_TRAIL_MAX_TIME_IN_SECS * 4);

  var objectCoordinates = new Array(objectCoordinateSize);
  var objectQuaternions = new Array(objectQuaternionSize);
  var i2 = 0;
  var i3 = 0;

  var posit, quat;
  if (this.isAddedObject){
    posit = this.object.mesh.position;
    quat = this.object.mesh.quaternion;
  }else{
    posit = this.object.graphicsGroup.position;
    quat = this.object.graphicsGroup.quaternion;
  }

  this.mesh = new MeshGenerator(geometry).generateObjectTrail(
    this, objectCoordinateSize, objectQuaternionSize,
    posit, quat, objectCoordinates, objectQuaternions
  );

  this.mesh.frustumCulled = false;
  this.mesh.visible = false;
  scene.add(this.mesh);
  objectTrails[this.object.name] = this;

  this.objectCoordinateCounter = 0;
  this.objectQuaternionCounter = 0;

}

ObjectTrail.prototype.stop = function(){
  this.mesh.visible = false;
  delete activeObjectTrails[this.object.name];
}

ObjectTrail.prototype.start = function(){
  this.mesh.visible = true;
  activeObjectTrails[this.object.name] = this;
}

ObjectTrail.prototype.update = function(){
  var OBJECT_TRAIL_MAX_TIME_IN_SECS = this.OBJECT_TRAIL_MAX_TIME_IN_SECS;
  var posit, quat;
  if (this.isAddedObject){
    posit = this.object.mesh.position;
    quat = this.object.mesh.quaternion;
  }else{
    posit = this.object.mesh.position;
    quat = this.object.mesh.quaternion;
  }
  this.mesh.material.uniforms.objectCoordinates.value[this.objectCoordinateCounter++] = posit.x;
  this.mesh.material.uniforms.objectCoordinates.value[this.objectCoordinateCounter++] = posit.y;
  this.mesh.material.uniforms.objectCoordinates.value[this.objectCoordinateCounter++] = posit.z;
  this.mesh.material.uniforms.objectQuaternions.value[this.objectQuaternionCounter++] = quat.x;
  this.mesh.material.uniforms.objectQuaternions.value[this.objectQuaternionCounter++] = quat.y;
  this.mesh.material.uniforms.objectQuaternions.value[this.objectQuaternionCounter++] = quat.z;
  this.mesh.material.uniforms.objectQuaternions.value[this.objectQuaternionCounter++] = quat.w;
  this.mesh.material.uniforms.currentPosition.value = posit;
  this.mesh.material.uniforms.currentQuaternion.value = quat;
  if (this.objectCoordinateCounter >= 60 * OBJECT_TRAIL_MAX_TIME_IN_SECS * 3){
    this.objectCoordinateCounter = 0;
  }
  if (this.objectQuaternionCounter >= 60 * OBJECT_TRAIL_MAX_TIME_IN_SECS * 4){
    this.objectQuaternionCounter = 0;
  }
}

ObjectTrail.prototype.destroy = function(){
  if (this.mesh){
    scene.remove(this.mesh);
    this.mesh.geometry.dispose();
    this.mesh.material.dispose();
    this.mesh = 0;
    this.destroyed = true;
  }
}

ObjectTrail.prototype.injectMacro = function(material, macro, insertVertexShader, insertFragmentShader){
  if (insertVertexShader){
    material.vertexShader = material.vertexShader.replace(
      "#define INSERTION", "#define INSERTION\n#define "+macro
    )
  };
  if (insertFragmentShader){
    material.fragmentShader = material.fragmentShader.replace(
      "#define INSERTION", "#define INSERTION\n#define "+macro
    )
  };
  material.needsUpdate = true;
}

ObjectTrail.prototype.removeMacro = function(material, macro, removeVertexShader, removeFragmentShader){
  if (removeVertexShader){
    material.vertexShader = material.vertexShader.replace("\n#define "+macro, "");
  }
  if (removeFragmentShader){
    material.fragmentShader = material.fragmentShader.replace("\n#define "+macro, "");
  }
  material.needsUpdate = true;
}

var ParticleMaterial = function(configurations){
  this.isParticleMaterial = true;
  this.color = configurations.color;
  this.targetColor = configurations.targetColor;
  this.texture = configurations.textureName;
  this.size = configurations.size;
  this.alpha = configurations.alpha;
  this.rgbFilter = configurations.rgbFilter;
  this.colorStep = configurations.colorStep;

  this.noTargetColor = false;
  if (!this.targetColor){
    this.noTargetColor = true;
    this.targetColor = this.color;
  }

  if (!(typeof this.colorStep == UNDEFINED)){
    this.colorStep *= 2;
  }

  this.color = this.color.toLowerCase();
  var threeColor = REUSABLE_COLOR.set(this.color);
  this.red = threeColor.r;
  this.green = threeColor.g;
  this.blue = threeColor.b;
  this.targetColor = this.targetColor.toLowerCase();
  threeColor = REUSABLE_COLOR.set(this.targetColor);
  this.targetRed = threeColor.r;
  this.targetGreen = threeColor.g;
  this.targetBlue = threeColor.b;
}

//  _______________________________________
// |                                       |
// | ROYGBIV Engine scripting API          |
// |_______________________________________|
//
// Function types:
//  * Getter functions
//  * Object manipulation functions
//  * Utility functions
//  * Listener functions
//  * Particle system functions
//  * Crosshair functions
//  * Text functions
var Roygbiv = function(){
  this.functionNames = [
    "getObject",
    "getParticleSystem",
    "getChildObject",
    "getRandomColor",
    "hide",
    "show",
    "vector",
    "distance",
    "sub",
    "add",
    "moveTowards",
    "applyNoise",
    "sphericalDistribution",
    "boxDistribution",
    "applyForce",
    "rotate",
    "rotateAroundXYZ",
    "setPosition",
    "color",
    "setMass",
    "runScript",
    "isRunning",
    "translate",
    "getPosition",
    "opacity",
    "getOpacity",
    "setCollisionListener",
    "removeCollisionListener",
    "createParticleMaterial",
    "createParticle",
    "createParticleSystem",
    "scale",
    "setBlending",
    "setParticleSystemRotation",
    "setParticleSystemQuaternion",
    "kill",
    "createSmoke",
    "getMarkedPosition",
    "createTrail",
    "createPlasma",
    "setExpireListener",
    "removeExpireListener",
    "normalizeVector",
    "computeQuaternionFromVectors",
    "circularDistribution",
    "multiplyScalar",
    "createFireExplosion",
    "createMagicCircle",
    "createCircularExplosion",
    "createDynamicTrail",
    "createObjectTrail",
    "destroyObjectTrail",
    "generateParticleSystemName",
    "rewindParticle",
    "createLaser",
    "createWaterfall",
    "createSnow",
    "getParticleSystemVelocityAtTime",
    "stopParticleSystem",
    "startParticleSystem",
    "hideParticleSystem",
    "getCameraDirection",
    "getCameraPosition",
    "createParticleSystemPool",
    "getParticleSystemPool",
    "addParticleSystemToPool",
    "getParticleSystemFromPool",
    "removeParticleSystemFromPool",
    "destroyParticleSystemPool",
    "createConfettiExplosion",
    "copyParticleSystem",
    "setVector",
    "quaternion",
    "fadeAway",
    "mergeParticleSystems",
    "createCrosshair",
    "selectCrosshair",
    "changeCrosshairColor",
    "hideCrosshair",
    "startCrosshairRotation",
    "stopCrosshairRotation",
    "pauseCrosshairRotation",
    "expandCrosshair",
    "shrinkCrosshair",
    "setParticleSystemPosition",
    "startObjectTrail",
    "stopObjectTrail",
    "setObjectVelocity",
    "setObjectClickListener",
    "removeObjectClickListener",
    "setObjectColor",
    "resetObjectColor",
    "setScreenClickListener",
    "removeScreenClickListener",
    "setScreenMouseDownListener",
    "removeScreenMouseDownListener",
    "setScreenMouseUpListener",
    "removeScreenMouseUpListener",
    "setScreenMouseMoveListener",
    "removeScreenMouseMoveListener",
    "requestPointerLock",
    "convertEulerToDegrees",
    "setScreenPointerLockChangeListener",
    "removeScreenPointerLockChangeListener",
    "setParticleSystemPoolConsumedListener",
    "removeParticleSystemPoolConsumedListener",
    "setParticleSystemPoolAvailableListener",
    "removeParticleSystemPoolAvailableListener",
    "disableDefaultControls",
    "isKeyPressed",
    "setCameraPosition",
    "lookAt",
    "applyAxisAngle",
    "trackObjectPosition",
    "untrackObjectPosition",
    "createRotationPivot",
    "setRotationPivot",
    "unsetRotationPivot",
    "rotateCamera",
    "translateCamera",
    "requestFullScreen",
    "setFullScreenChangeCallbackFunction",
    "removeFullScreenChangeCallbackFunction",
    "isMouseDown",
    "createInitializedParticleSystemPool",
    "intersectionTest",
    "getEndPoint",
    "isMobile",
    "lerp",
    "resetObjectVelocity",
    "setFPSDropCallbackFunction",
    "removeFPSDropCallbackFunction",
    "setPerformanceDropCallbackFunction",
    "removePerformanceDropCallbackFunction",
    "setBloom",
    "unsetBloom",
    "getViewport",
    "setUserInactivityCallbackFunction",
    "removeUserInactivityCallbackFunction",
    "pause",
    "setScreenKeydownListener",
    "removeScreenKeydownListener",
    "setScreenKeyupListener",
    "removeScreenKeyupListener",
    "getText",
    "setText",
    "setTextColor",
    "setTextAlpha",
    "setTextPosition",
    "setTextBackground",
    "removeTextBackground",
    "onTextClick",
    "removeTextClickListener",
    "setTextCenterPosition",
    "hideText",
    "showText",
    "getFPS"
  ];

  this.globals = new Object();

}

// GETTER FUNCTIONS ************************************************************

// getObject
//   Returns the object or glued object having the name given as the parameter,
//   or zero if no such object or glued object is found.
Roygbiv.prototype.getObject = function(name){
  if (mode == 0){
    return;
  }
  var addedObject = addedObjects[name];
  var objectGroup = objectGroups[name];
  if (addedObject){
    return addedObject;
  }
  if (objectGroup){
    return objectGroup;
  }
  return 0;
}

// getParticleSystem
//  Returns the particle system having the name given as the parameter,
//  or zero if no such particle system is found.
Roygbiv.prototype.getParticleSystem = function(name){
  if (mode == 0){
    return;
  }
  var particleSystem = particleSystemPool[name];
  if (particleSystem){
    return particleSystem;
  }else{
    return 0;
  }
}

// getChildObject
//  Returns a child object having the name given as the second parameter
//  of a glued object given as the first parameter, or zero if no such object
//  is found.
Roygbiv.prototype.getChildObject = function(gluedObject, childObjectName){
  if (mode == 0){
    return;
  }
  if (!gluedObject){
    throw new Error("getChildObject error: glued object is undefined.");
    return;
  }
  if (!(gluedObject.isObjectGroup)){
    throw new Error("getChildObject error: Type not supported.");
    return;
  }
  var child = gluedObject.childObjectsByName[childObjectName];
  if (child){
    return child;
  }
  return 0;
}

// getRandomColor
//  Returns the HTML name of a random color.
Roygbiv.prototype.getRandomColor = function(){
  if (mode == 0){
    return;
  }
  return ColorNames.generateRandomColor();
}

// getPosition
//  Returns the (x, y, z) coordinates of an object, glued object or a particle system.
//  If a specific axis is specified, only the position on the specified axis is returned.
Roygbiv.prototype.getPosition = function(object, targetVector, axis){
  if (mode == 0){
    return;
  }
  if (!object){
    throw new Error("getPosition error: Object is undefined.");
    return;
  }
  if (axis){
    if (axis.toLowerCase() != "x" && axis.toLowerCase() != "y" && axis.toLowerCase() != "z"){
      throw new Error("getPosition error: Axis must be one of x, y, or z.");
      return;
    }
  }
  if (!(typeof targetVector == UNDEFINED) && !(targetVector == null)){
    if (isNaN(targetVector.x) || isNaN(targetVector.y) || isNaN(targetVector.z)){
      throw new Error("getPosition error: Bad targetVector parameter.");
      return;
    }
  }
  if (object.isAddedObject){
    if (axis){
      if (object.parentObjectName){
        var parentObject = objectGroups[object.parentObjectName];
        parentObject.graphicsGroup.position.copy(parentObject.mesh.position);
        parentObject.graphicsGroup.quaternion.copy(parentObject.mesh.quaternion);
        parentObject.graphicsGroup.updateMatrix();
        parentObject.graphicsGroup.updateMatrixWorld();
        var child = parentObject.graphicsGroup.children[object.indexInParent];
        child.getWorldPosition(REUSABLE_VECTOR);
        var worldPosition = REUSABLE_VECTOR;
        if (axis.toLowerCase() == "x"){
          return worldPosition.x;
        }else if (axis.toLowerCase() == "y"){
          return worldPosition.y;
        }else if (axis.toLowerCase() == "z"){
          return worldPosition.z;
        }
      }
      if (axis.toLowerCase() == "x"){
        return object.mesh.position.x;
      }else if (axis.toLowerCase() == "y"){
        return object.mesh.position.y;
      }else if (axis.toLowerCase() == "z"){
        return object.mesh.position.z;
      }
    }else{
      if (object.parentObjectName){
        var parentObject = objectGroups[object.parentObjectName];
        parentObject.graphicsGroup.position.copy(parentObject.mesh.position);
        parentObject.graphicsGroup.quaternion.copy(parentObject.mesh.quaternion);
        parentObject.graphicsGroup.updateMatrix();
        parentObject.graphicsGroup.updateMatrixWorld();
        var child = parentObject.graphicsGroup.children[object.indexInParent];
        child.getWorldPosition(REUSABLE_VECTOR);
        var worldPosition = REUSABLE_VECTOR;
        if (targetVector){
          targetVector.x = worldPosition.x;
          targetVector.y = worldPosition.y;
          targetVector.z = worldPosition.z;
          return targetVector;
        }else{
          return this.vector(worldPosition.x, worldPosition.y, worldPosition.z);
        }
      }
      if (targetVector){
        targetVector.x = object.mesh.position.x;
        targetVector.y = object.mesh.position.y;
        targetVector.z = object.mesh.position.z;
        return targetVector;
      }else{
        return this.vector(
          object.mesh.position.x,
          object.mesh.position.y,
          object.mesh.position.z
        );
      }
    }
  }else if (object.isObjectGroup){
    if (axis){
      if (axis.toLowerCase() == "x"){
        return object.mesh.position.x;
      }else if (axis.toLowerCase() == "y"){
        return object.mesh.position.y;
      }else if (axis.toLowerCase() == "z"){
        return object.mesh.position.z;
      }
    }else{
      if (targetVector){
        targetVector.x = object.mesh.position.x;
        targetVector.y = object.mesh.position.y;
        targetVector.z = object.mesh.position.z;
        return targetVector;
      }else{
        return this.vector(
          object.mesh.position.x,
          object.mesh.position.y,
          object.mesh.position.z
        );
      }
    }
  }else if (object.isParticleSystem){
    if (axis){
      if (axis.toLowerCase() == "x"){
        return object.mesh.position.x;
      }else if (axis.toLowerCase() == "y"){
        return object.mesh.position.y;
      }else if (axis.toLowerCase() == "z"){
        return object.mesh.position.z;
      }
    }else{
      if (targetVector){
        targetVector.x = object.mesh.position.x;
        targetVector.y = object.mesh.position.y;
        targetVector.z = object.mesh.position.z;
        return targetVector;
      }else{
        return this.vector(
          object.mesh.position.x,
          object.mesh.position.y,
          object.mesh.position.z
        );
      }
    }
  }else{
    throw new Error("getPosition error: Object type not supported.");
    return;
  }
}

// getOpacity
//  Returns the opacity of given object.
Roygbiv.prototype.getOpacity = function(object){
  if (mode == 0){
    return;
  }
  if (!object){
    throw new Error("getOpacity error: Object is undefined.");
    return;
  }
  var isAddedObject = (object.isAddedObject);
  var isObjectGroup = (object.isObjectGroup);
  if (!(isAddedObject || isObjectGroup)){
    throw new Error("getOpacity error: Type not supported.");
    return;
  }
  if (isAddedObject){
    return object.mesh.material.uniforms.alpha.value;
  }
  return object.mesh.material.uniforms.totalAlpha.value;
}

// getMarkedPosition
//  Returns (x,y,z) coordinates of a point marked using the mark command.
Roygbiv.prototype.getMarkedPosition = function(markedPointName){
  if (mode == 0){
    return;
  }
  if (typeof markedPointName == UNDEFINED){
    throw new Error("getMarkedPosition error: markedPointName is not defined.");
    return;
  }
  var markedPoint = markedPoints[markedPointName];
  if (!markedPoint){
    throw new Error("getMarkedPosition error: No such marked point.");
    return;
  }
  return this.vector(markedPoint.x, markedPoint.y, markedPoint.z);
}

// getParticleSystemVelocityAtTime
// Calcualtes and returns the velocity vector of a particle system at given time.
// For particles with circular motion, this function returns the angular velocity
// at given time.
Roygbiv.prototype.getParticleSystemVelocityAtTime = function(particleSystem, time, targetVector){
  if (mode == 0){
    return;
  }
  if (!particleSystem){
    throw new Error("getParticleSystemVelocityAtTime error: particleSystem is not defined.");
    return;
  }
  if (!(particleSystem.isParticleSystem)){
    throw new Error("getParticleSystemVelocityAtTime error: Unsupported particleSystem type.");
    return;
  }
  if (typeof time == UNDEFINED){
    throw new Error("getParticleSystemVelocityAtTime error: time is not defined.");
    return;
  }
  if (isNaN(time)){
    throw new Error("getParticleSystemVelocityAtTime error: time is not a number.");
    return;
  }
  if (!(typeof targetVector == UNDEFINED)){
    if (isNaN(targetVector.x ) || isNaN(targetVector.y) || isNaN(targetVector.z)){
      throw new Error("getParticleSystemVelocityAtTime error: Bad targetVector parameter.");
      return;
    }
  }
  return particleSystem.getVelocityAtTime(time, targetVector);
}

// getCameraDirection
// Returns the direction vector of the camera.
Roygbiv.prototype.getCameraDirection = function(targetVector){
  if (mode == 0){
    return;
  }
  if (!(typeof targetVector == UNDEFINED)){
    if (isNaN(targetVector.x) || isNaN(targetVector.y) || isNaN(targetVector.z)){
      throw new Error("getCameraDirection error: Bad targetVector parameter.");
      return;
    }
  }
  REUSABLE_VECTOR.set(0, 0, -1).applyQuaternion(camera.quaternion);
  if (!targetVector){
    return this.vector(REUSABLE_VECTOR.x, REUSABLE_VECTOR.y, REUSABLE_VECTOR.z);
  }else{
    targetVector.x = REUSABLE_VECTOR.x;
    targetVector.y = REUSABLE_VECTOR.y;
    targetVector.z = REUSABLE_VECTOR.z;
    return targetVector;
  }
}

// getCameraPosition
// Returns the position of the camera.
Roygbiv.prototype.getCameraPosition = function(targetVector){
  if (mode == 0){
    return;
  }
  if (!(typeof targetVector == UNDEFINED)){
    if (isNaN(targetVector.x) || isNaN(targetVector.y) || isNaN(targetVector.z)){
      throw new Error("getCameraPosition error: Bad targetVector parameter.");
      return;
    }
  }
  if (!targetVector){
    return this.vector(camera.position.x, camera.position.y, camera.position.z);
  }else{
    targetVector.x = camera.position.x;
    targetVector.y = camera.position.y;
    targetVector.z = camera.position.z;
    return targetVector;
  }
}

// getParticleSystemPool
// Finds a particle system pool by name and returns it.
Roygbiv.prototype.getParticleSystemPool = function(name){
  if (mode == 0){
    return;
  }
  if (typeof name == UNDEFINED){
    throw new Error("getParticleSystemPool error: name is not defined.");
    return;
  }
  var psPool = particleSystemPools[name];
  if (!psPool){
    throw new Error("getParticleSystemPool error: No such particle system pool.");
    return;
  }
  return psPool;
}

// getParticleSystemFromPool
// Returns an available particle system from the pool, or false if there is
// not an available particle system inside the pool. The particle systems become
// available when hidden or expired.
Roygbiv.prototype.getParticleSystemFromPool = function(pool){
  if (mode == 0){
    return;
  }
  if (typeof pool == UNDEFINED){
    throw new Error("getParticleSystemFromPool error: pool is not defined.");
    return;
  }
  if (!(pool.isParticleSystemPool)){
    throw new Error("getParticleSystemFromPool error: Type not supported.");
    return;
  }
  if (pool.destroyed){
    throw new Error("getParticleSystemFromPool error: pool is destroyed.");
    return;
  }
  return pool.get();
}

// getEndPoint
// Gets an end point of an object. The axis may be +x,-x,+y,-y,+z or -z. Note that
// object groups do not support this function but child objects do. This function
// may be useful in cases where for example a particle system needs to be started
// from the tip point of an object.
Roygbiv.prototype.getEndPoint = function(object, axis, targetVector){
  if (mode == 0){
    return;
  }
  if (typeof object == UNDEFINED){
    throw new Error("getEndPoint error: object is not defined.");
    return;
  }
  if (!(object.isAddedObject)){
    throw new Error("getEndPoint error: object is not an AddedObject.");
    return;
  }
  if (typeof axis == UNDEFINED){
    throw new Error("getEndPoint error: axis is not defined.");
    return;
  }
  if (typeof targetVector == UNDEFINED){
    throw new Error("getEndPoint error: targetVector is not defined.");
    return;
  }
  if (isNaN(targetVector.x) || isNaN(targetVector.y) || isNaN(targetVector.z)){
    throw new Error("getEndPoint error: targetVector is not a vector.");
    return;
  }
  axis = axis.toLowerCase();
  if (axis == "+x" || axis == "-x" || axis == "+y" || axis == "-y" || axis == "+z" || axis == "-z"){
    var endPoint = object.getEndPoint(axis);
    targetVector.x = endPoint.x;
    targetVector.y = endPoint.y;
    targetVector.z = endPoint.z;
    return targetVector;
  }else{
    throw new Error("getEndPoint error: Invalid axis.");
    return;
  }
}

// getViewport
// Returns the current viewport object having startX, startY, width and height parameters.
// Do not modify the values of the returned object.
Roygbiv.prototype.getViewport = function(){
  if (mode == 0){
    return;
  }
  return currentViewport;
}

// getText
// Returns a text object or 0 if the text does not exist.
Roygbiv.prototype.getText = function(textName){
  if (mode == 0){
    return;
  }
  if (typeof textName == UNDEFINED){
    throw new Error("getText error: textName is not defined.");
    return;
  }
  var text = addedTexts[textName];
  if (text){
    return text;
  }
  return 0;
}

// getFPS
// Returns the current FPS.
Roygbiv.prototype.getFPS = function(){
  if (mode == 0){
    return;
  }
  return fpsHandler.fps;
}

// OBJECT MANIPULATION FUNCTIONS ***********************************************

// hide
//  Hides an object or a glued object, removes it from the scene. Does nothing
//  if the object is already hidden. The additional keepPhysics parameter can
//  be used in order to hide only the graphical representation of the object
//  but keep its physicsal body. The default value of keepPhysics is false.
Roygbiv.prototype.hide = function(object, keepPhysics){
  if (mode == 0){
    return;
  }
  var keepPhysicsValue = false;
  if (!(typeof keepPhysics == UNDEFINED)){
    if (!(typeof keepPhysics == "boolean")){
      throw new Error("hide error: Bad keepPhysics parameter.");
      return;
    }
    keepPhysicsValue = keepPhysics;
  }
  if (!object){
    throw new Error("hide error: object is not defined.");
    return;
  }
  if (object.isAddedObject){
    if (!addedObjects[object.name]){
      throw new Error("hide error: Cannot hide a child object. Use the parent object instead.");
      return;
    }
    if (keepPhysicsValue && object.noMass){
      throw new Error("hide error: Object has no mass. Cannot keep mass.");
    }
    if (!object.isChangeable){
      throw new Error("hide error: Object is not marked as changeable.");
      return;
    }
    if (object.isVisibleOnThePreviewScene()){
      object.mesh.visible = false;
      // The reason we use delayed execution here is that
      // during the collision callback, cannon.js crashes if a body
      // is removed. It is safe to remove the bodies after the
      // physics iteration.
      if (!keepPhysicsValue){
        if (!object.noMass){
          setTimeout(function(){
            physicsWorld.removeBody(object.physicsBody);
            object.physicsKeptWhenHidden = false;
          });
        }
      }else{
        object.physicsKeptWhenHidden = true;
      }
      object.isHidden = true;
      rayCaster.binHandler.hide(object);
    }
  }else if (object.isObjectGroup){
    if (keepPhysicsValue && object.noMass){
      throw new Error("hide error: Object has no mass. Cannot keep mass.");
    }
    if (!object.isChangeable){
      throw new Error("hide error: object is not marked as changeable.");
      return;
    }
    if (object.isVisibleOnThePreviewScene()){
      object.mesh.visible = false;
      if (!keepPhysicsValue){
        if (!object.noMass){
          setTimeout(function(){
            physicsWorld.removeBody(object.physicsBody);
            object.physicsKeptWhenHidden = false;
          });
        }
      }else{
        object.physicsKeptWhenHidden = true;
      }
      object.isHidden = true;
      rayCaster.binHandler.hide(object);
    }
  }else{
    throw new Error("hide error: Unsupported type.");
    return;
  }
}

// show
//  Makes a hidden object or glued object visible. Does nothing if the object is
//  already visible.
Roygbiv.prototype.show = function(object){
  if (mode == 0){
    return;
  }
  if (!object){
    throw new Error("show error: object is not defined.");
    return;
  }
  if (object.isAddedObject){
    if (!addedObjects[object.name]){
      throw new Error("show error: Cannot show a child object. Use the parent object instead.");
      return;
    }
    if (!object.isChangeable){
      throw new Error("show error: object is not marked as changeable.");
      return;
    }
    if (!object.isVisibleOnThePreviewScene()){
      object.mesh.visible = true;
      if (!object.physicsKeptWhenHidden){
        if (!object.noMass){
          setTimeout(function(){
            physicsWorld.addBody(object.physicsBody);
          });
        }
      }
      object.isHidden = false;
      rayCaster.binHandler.show(object);
    }
  }else if (object.isObjectGroup){
    if (!object.isChangeable){
      throw new Error("show error: object is not marked as changeable.");
      return;
    }
    if (!object.isVisibleOnThePreviewScene()){
      object.mesh.visible = true;
      if (!object.physicsKeptWhenHidden){
        if (!object.noMass){
          setTimeout(function(){
            physicsWorld.addBody(object.physicsBody);
          });
        }
      }
      object.isHidden = false;
      rayCaster.binHandler.show(object);
    }
  }else{
    throw new Error("show error: Unsupported type.");
    return;
  }
}

// applyForce
// Applies a physical force to an object or a glued object from a given point.
Roygbiv.prototype.applyForce = function(object, force, point){
  if (mode == 0){
    return;
  }
  if (!object){
    throw new Error("applyForce error: object is not defined.");
    return;
  }
  if (!(object.isAddedObject) && !(object.isObjectGroup)){
    throw new Error("applyForce error: object type is not supported.");
    return;
  }
  if (object.noMass){
    throw new Error("applyForce error: object does not have a mass.");
    return;
  }
  if (!object.isDynamicObject){
    throw new Error("applyForce error: object is not dynamic.");
    return;
  }
  if (!force){
    throw new Error("applyForce error: force is not defined.");
    return;
  }
  if (!point){
    throw new Error("applyForce error: point is not defined.");
    return;
  }
  if (typeof force.x == UNDEFINED || typeof force.y == UNDEFINED || typeof force.z == UNDEFINED){
    throw new Error("applyForce error: force is not a vector.");
    return;
  }
  if (typeof point.x == UNDEFINED || typeof point.y == UNDEFINED || typeof point.z == UNDEFINED){
    throw new Error("applyForce error: point is not a vector.");
  }
  if (!isPhysicsWorkerEnabled()){
    REUSABLE_CANNON_VECTOR.set(force.x, force.y, force.z);
    REUSABLE_CANNON_VECTOR_2.set(point.x, point.y, point.z);
    object.physicsBody.applyImpulse(
      REUSABLE_CANNON_VECTOR,
      REUSABLE_CANNON_VECTOR_2
    );
  }
}

// rotate
//  Rotates an object or a glued object around a given world axis by given radians.
//  The parameter axis must be one of x, y or z. Objects are rotated around
//  their own centers, so their positions do not change when rotated using this
//  function.
Roygbiv.prototype.rotate = function(object, axis, radians){
  if (mode == 0){
    return;
  }
  if (!object){
    throw new Error("rotate error: Object undefined.");
    return;
  }
  if (typeof axis == "UNDEFINED"){
    throw new Error("rotate error: axis is not defined.");
    return;
  }
  axis = axis.toLowerCase();
  if (axis != "x" && axis != "y" && axis != "z"){
    throw new Error("rotate error: Axis must be one of x, y, or z.");
    return;
  }
  if (isNaN(radians)){
    throw new Error("rotate error: Radians value is not a number.");
    return;
  }
  if (!(object.isAddedObject) && !(object.isObjectGroup) && !(object.isParticleSystem)){
    throw new Error("rotate error: Type not supported.");
    return;
  }
  var isObject = false;
  if ((object.isAddedObject) || (object.isObjectGroup)){
    isObject = true;
  }
  if (object.isAddedObject && object.parentObjectName){
    var parentObject = objectGroups[object.parentObjectName];
    if (parentObject){
      this.rotateAroundXYZ(
        parentObject,
        object.getPositionAtAxis("x"),
        object.getPositionAtAxis("y"),
        object.getPositionAtAxis("z"),
        radians,
        axis
      );
      return;
    }
  }
  if ((object.isAddedObject) || (object.isObjectGroup)){
    if (!object.isChangeable){
      throw new Error("rotate error: object is not marked as changeable.");
      return;
    }
  }
  if (object.pivotObject){
    object.rotateAroundPivotObject(axis, radians);
    return;
  }
  object.rotate(axis, radians, true);
}

// rotateAroundXYZ
//  Rotates an object or a glued object around the given (x, y, z)
//  Unlike the rotate function, the positions of the objects can change when rotated
//  using this function. If the optional skipLocalRotation flag is set, the object is
//  not rotated in its local axis system.
Roygbiv.prototype.rotateAroundXYZ = function(object, x, y, z, radians, axis, skipLocalRotation){
  if (mode == 0){
    return;
  }
  if (!object){
    throw new Error("rotateAroundXYZ error: Object is undefined.");
    return;
  }
  if (isNaN(x)){
    throw new Error("rotateAroundXYZ error: X is not a number.");
    return;
  }
  if (isNaN(y)){
    throw new Error("rotateAroundXYZ error: Y is not a number.");
    return;
  }
  if (isNaN(z)){
    throw new Error("rotateAroundXYZ error: Z is not a number.");
    return;
  }
  if (isNaN(radians)){
    throw new Error("rotateAroundXYZ error: Radian value is not a number.");
    return;
  }
  if (typeof axis == UNDEFINED){
    throw new Error("rotateAroundXYZ error: axis is not defined.");
  }
  if (axis.toLowerCase() != "x" && axis.toLowerCase() != "y" && axis.toLowerCase() != "z"){
    throw new Error("rotateAroundXYZ error: Axis must be one of x,y or z");
    return;
  }
  if (!(typeof skipLocalRotation == UNDEFINED)){
    if (!(typeof skipLocalRotation == "boolean")){
      throw new Error("rotateAroundXYZ error: skipLocalRotation must be a boolean.");
    }
  }
  var axisVector;
  if (axis.toLowerCase() == "x"){
    axisVector = THREE_AXIS_VECTOR_X;
  }else if (axis.toLowerCase() == "y"){
    axisVector = THREE_AXIS_VECTOR_Y;
  }else if (axis.toLowerCase() == "z"){
    axisVector = THREE_AXIS_VECTOR_Z;
  }
  var mesh;
  if (object.isAddedObject){
    if (object.parentObjectName){
      var parentObject = objectGroups[object.parentObjectName];
      if (parentObject){
        this.rotateAroundXYZ(
          parentObject,
          x, y, z,
          radians,
          axis,
          skipLocalRotation
        );
        return;
      }
    }
    if (!object.isChangeable){
      throw new Error("rotateAroundXYZ error: object is not marked as changeable.");
      return;
    }
    mesh = object.mesh;
  }else if (object.isObjectGroup){
    if (!object.isChangeable){
      throw new Error("rotateAroundXYZ error: object is not marked as changeable.");
      return;
    }
    mesh = object.mesh;
  }else{
    throw new Error("rotateAroundXYZ error: Type not supported.");
    return;
  }
  var point = REUSABLE_VECTOR.set(x, y, z);
  mesh.parent.localToWorld(mesh.position);
  mesh.position.sub(point);
  mesh.position.applyAxisAngle(axisVector, radians);
  mesh.position.add(point);
  mesh.parent.worldToLocal(mesh.position);
  if (!skipLocalRotation){
    mesh.rotateOnAxis(axisVector, radians);
  }
  if (object.isAddedObject){
    object.setPhysicsAfterRotationAroundPoint(axis, radians);
    if (object.mesh.visible){
      rayCaster.updateObject(object);
    }
  }else if (object.isObjectGroup){
    object.physicsBody.quaternion.copy(mesh.quaternion);
    object.physicsBody.position.copy(mesh.position);
    if (object.mesh.visible){
      rayCaster.updateObject(object);
    }
  }
}

// setPosition
//  Puts an object or glued object to the specified (x, y, z) coordinate.
Roygbiv.prototype.setPosition = function(obj, x, y, z){
  if (mode == 0){
    return;
  }
  if (!obj){
    throw new Error("setPosition error: Object is undefined");
    return;
  }
  if (isNaN(x)){
    throw new Error("setPosition error: X is not a number.");
    return;
  }
  if (isNaN(y)){
    throw new Error("setPosition error: Y is not a number.");
    return;
  }
  if (isNaN(z)){
    throw new Error("setPosition error: Z is not a number.");
    return;
  }
  if (obj.isAddedObject){
    if (obj.parentObjectName){
      var objGroup = objectGroups[obj.parentObjectName];
      if (objGroup){
        this.setPosition(objGroup, x, y, z);
        return;
      }else{
        throw new Error("setPosition error: Parent not defined.");
        return;
      }
    }
    if (!obj.isChangeable){
      throw new Error("setPosition error: object is not marked as changeable.");
      return;
    }
    obj.mesh.position.set(x, y, z);
    obj.physicsBody.position.set(x, y, z);
    if (obj.mesh.visible){
      rayCaster.updateObject(obj);
    }
  }else if (obj.isObjectGroup){
    if (!obj.isChangeable){
      throw new Error("setPosition error: object is not marked as changeable.");
      return;
    }
    obj.mesh.position.set(x, y, z);
    obj.graphicsGroup.position.set(x, y, z);
    obj.physicsBody.position.set(x, y, z);
    if (obj.mesh.visible){
      rayCaster.updateObject(obj);
    }
  }else{
    throw new Error("setPosition error: Type not supported.");
    return;
  }
}

// setMass
//  Sets the mass property of an object or a glued object. Objects are considered
//  dynamic if and only if their mass is greater than zero.
Roygbiv.prototype.setMass = function(object, mass){
  if (mode == 0){
    return;
  }
  if (!object){
    throw new Error("setMass error: Object is undefined.");
    return;
  }
  if (typeof mass == UNDEFINED){
    throw new Error("setMass error: mass is undefined.");
    return;
  }
  if (isNaN(mass)){
    throw new Error("setMass error: mass is not a number.");
    return;
  }
  if (!(object.isAddedObject) && !(object.isObjectGroup)){
    throw new Error("setMass error: Unsupported type.");
    return;
  }
  if (!object.isChangeable){
    throw new Error("setMass error: object is not marked as changeable.");
    return;
  }
  if (object.noMass){
    throw new Error("setMass error: object has no mass property.");
    return;
  }
  if ((object.isAddedObject) && !(addedObjects[object.name])){
    throw new Error("setMass error: Cannot set mass of child objects. Use the parent object instead.");
    return;
  }
  if (typeof object.originalMass == UNDEFINED){
    object.originalMass = object.mass;
  }
  if (typeof object.mass == UNDEFINED){
    object.originalMass = 0;
    object.mass = 0;
  }
  object.setMass(mass);
  if (object.isAddedObject){
    if (mass > 0){
      dynamicObjects[object.name] = object;
    }else{
      delete dynamicObjects[object.name];
    }
  }else if (object.isObjectGroup){
    if (mass > 0){
      dynamicObjectGroups[object.name] = object;
    }else{
      delete dynamicObjectGroups[object.name];
    }
  }
}

// translate
//  Translates an object or glued object on the given axis by the given amount.
//  Axis must be one of x, y or z.
Roygbiv.prototype.translate = function(object, axis, amount){
  if (mode == 0){
    return;
  }
  if (!object){
    throw new Error("translate error: Object not defined.");
    return;
  }
  axis = axis.toLowerCase();
  if (axis != "x" && axis!= "y" && axis != "z"){
    throw new Error("translate error: Axis must be one of x, y, or z.");
    return;
  }
  if (isNaN(amount)){
    throw new Error("translate error: Amount is not a number.");
    return;
  }
  if (object.isAddedObject){
    if (object.parentObjectName){
      var parentObject = objectGroups[object.parentObjectName];
      if (parentObject){
        this.translate(parentObject, axis, amount);
        return;
      }
    }
    if (!object.isChangeable){
      throw new Error("translate error: object is not marked as changeable.");
      return;
    }
    object.translate(axis, amount, true);
  }else if (object.isObjectGroup){
    if (!object.isChangeable){
      throw new Error("translate error: object is not marked as changeable.");
      return;
    }
    object.translate(axis, amount, true);
  }else {
    throw new Error("translate error: Type not supported.");
    return;
  }
}

// opacity
//  Increases/decreases the opacity of given object.
Roygbiv.prototype.opacity = function(object, delta){
  if (mode == 0){
    return;
  }
  if(!object){
    throw new Error("opacity error: Object is not defined.");
    return;
  }
  if (isNaN(delta)){
    throw new Error("opacity error: Delta is not a number.");
    return;
  }
  var isAddedObject = (object.isAddedObject);
  var isObjectGroup = (object.isObjectGroup);
  if (!((isAddedObject) || (isObjectGroup))){
    throw new Error("opacity error: Type not supported.");
    return;
  }
  if (object.parentObjectName){
    throw new Error("opacity error: Cannot set opacity to child objects.");
    return;
  }
  if (!object.initOpacitySet && (isAddedObject)){
    object.initOpacity = object.mesh.material.uniforms.alpha.value;
    object.initOpacitySet = true;
  }else if (!object.initOpacitySet && (isObjectGroup)){
    object.initOpacity = object.mesh.material.uniforms.totalAlpha.value;
    object.initOpacitySet = true;
  }

  object.incrementOpacity(delta);

  if (isAddedObject){
    if (object.mesh.material.uniforms.alpha.value < 0){
      object.updateOpacity(0);
    }
    if (object.mesh.material.uniforms.alpha.value > 1){
      object.updateOpacity(1);
    }
  }else if (isObjectGroup){
    if (object.mesh.material.uniforms.totalAlpha.value < 0){
      object.updateOpacity(0);
    }
    if (object.mesh.material.uniforms.totalAlpha.value > 1){
      object.updateOpacity(1);
    }
  }

}

// setObjectVelocity
//  Sets the velocity of an object or a glued object. The object must be a dynamic object
//  (mass > 0) in order to have a velocity.
Roygbiv.prototype.setObjectVelocity = function(object, velocityVector, axis){
  if (mode == 0){
    return;
  }
  if (typeof object == UNDEFINED){
    throw new Error("setObjectVelocity error: object is not defined.");
    return;
  }
  if (!(object.isAddedObject) && !(object.isObjectGroup)){
    throw new Error("setObjectVelocity error: Type not supported.");
    return;
  }
  if (!object.isChangeable){
    throw new Error("setObjectVelocity error: object is not marked as changeable.");
    return;
  }
  if ((object.isAddedObject) && !addedObjects[object.name]){
    throw new Error("setObjectVelocity error: Cannot set velocity to child objects. Use parent object instead.");
    return;
  }
  if (!object.isDynamicObject){
    throw new Error("setObjectVelocity error: Object must have a mass greater than zero.");
    return;
  }
  if (typeof velocityVector == UNDEFINED){
    throw new Error("setObjectVelocity error: velocityVector is not defined.");
    return;
  }
  if (isNaN(velocityVector.x) || isNaN(velocityVector.y) || isNaN(velocityVector.z)){
    throw new Error("setObjectVelocity error: Bad velocityVector parameter.");
    return;
  }
  if (!(typeof axis == UNDEFINED)){
    if (axis != "X" && axis != "x" && axis != "y" && axis != "Y" && axis != "z" && axis != "Z"){
      throw new Error("setObjectVelocity error: Bad axis parameter.");
      return;
    }
    if (axis == "x" || axis == "X"){
      object.physicsBody.velocity.x = velocityVector.x;
    }else if (axis == "y" || axis == "Y"){
      object.physicsBody.velocity.y = velocityVector.y;
    }else if (axis == "z" || axis == "Z"){
      object.physicsBody.velocity.z = velocityVector.z;
    }
    return;
  }
  object.physicsBody.velocity.set(velocityVector.x, velocityVector.y, velocityVector.z);
}

// setObjectColor
// Modifies the color and alpha value of an object or an object group.
Roygbiv.prototype.setObjectColor = function(object, colorName, alpha){
  if (mode == 0){
    return;
  }
  if (typeof object == UNDEFINED){
    throw new Error("setObjectColor error: object is not defined.");
    return;
  }
  if (!(object.isAddedObject) && !(object.isObjectGroup)){
    throw new Error("setObjectColor error: Type not supported.");
    return;
  }
  if (!object.isColorizable){
    throw new Error("setObjectColor error: Object is not marked as colorizable.");
    return;
  }
  if (typeof colorName == UNDEFINED){
    throw new Error("setObjectColor error: colorName is not defined.");
    return;
  }
  if (typeof alpha == UNDEFINED){
    alpha = 1;
  }else{
    if (isNaN(alpha)){
      throw new Error("setObjectColor error: alpha is not a number.");
      return;
    }
  }
  REUSABLE_COLOR.set(colorName);
  object.forceColor(REUSABLE_COLOR.r, REUSABLE_COLOR.g, REUSABLE_COLOR.b, alpha);
}

// resetObjectColor
// Resets the color and alpha value of an object or an object group.
Roygbiv.prototype.resetObjectColor = function(object){
  if (mode == 0){
    return;
  }
  if (typeof object == UNDEFINED){
    throw new Error("resetObjectColor error: object is not defined.");
    return;
  }
  if (!(object.isAddedObject) && !(object.isObjectGroup)){
    throw new Error("resetObjectColor error: Type not supported.");
    return;
  }
  if (!object.isColorizable){
    throw new Error("setObjectColor error: Object is not marked as colorizable.");
    return;
  }
  object.resetColor();
}

// setRotationPivot
// Sets a rotation pivot for an object created with createRotationPivot API.
Roygbiv.prototype.setRotationPivot = function(rotationPivot){
  if (mode == 0){
    return;
  }
  if (typeof rotationPivot == UNDEFINED){
    throw new Error("setRotationPivot error: rotationPivot is not defined.");
    return;
  }
  if (!(rotationPivot.isObject3D)){
    throw new Error("setRotationPivot error: Bad rotationPivot type.");
    return;
  }
  var sourceObject = rotationPivot.sourceObject;
  if (sourceObject.pivotObject){
    rotationPivot.position.copy(sourceObject.pivotObject.position);
    rotationPivot.quaternion.copy(sourceObject.pivotObject.quaternion);
    rotationPivot.rotation.copy(sourceObject.pivotObject.rotation);
  }
  sourceObject.pivotObject = rotationPivot;
  sourceObject.pivotOffsetX = rotationPivot.offsetX;
  sourceObject.pivotOffsetY = rotationPivot.offsetY;
  sourceObject.pivotOffsetZ = rotationPivot.offsetZ;
}

// unsetRotationPivot
// Unsets a rotation pivot point for an object set with setRotationPivot API.
Roygbiv.prototype.unsetRotationPivot = function(object){
  if (mode == 0){
    return;
  }
  if (typeof object == UNDEFINED){
    throw new Error("unsetRotationPivot error: object is not defined.");
    return;
  }
  if (!((object.isAddedObject) || (object.isObjectGroup))){
    throw new Error("unsetRotationPivot error: Type not supported.");
    return;
  }
  if (!object.pivotObject){
    throw new Error("unsetRotationPivot error: Object does not have a pivot point.");
    return;
  }
  delete object.pivotObject;
  delete object.pivotOffsetX;
  delete object.pivotOffsetY;
  delete object.pivotOffsetZ;
}

// resetObjectVelocity
// Resets the velocity and angular velocity of an object.
Roygbiv.prototype.resetObjectVelocity = function(object){
  if (mode == 0){
    return;
  }
  if (typeof object == UNDEFINED){
    throw new Error("resetObjectVelocity error: object is not defined.");
    return;
  }
  if (!(object.isAddedObject || object.isObjectGroup)){
    throw new Error("resetObjectVelocity error: Type not supported.");
    return;
  }
  if (!object.isChangeable){
    throw new Error("resetObjectVelocity error: object is not marked as changeable.");
    return;
  }
  if (object.parentObjectName){
    throw new Error("resetObjectVelocity error: Cannot set velocity to child objects. Use parent object instead.");
    return;
  }
  if (!object.isDynamicObject){
    throw new Error("resetObjectVelocity error: Object must have a mass greater than zero.");
    return;
  }
  object.physicsBody.velocity.set(0, 0, 0);
  object.physicsBody.angularVelocity.set(0, 0, 0);
}

// PARTICLE SYSTEM FUNCTIONS ***************************************************

// createParticleMaterial
// Returns a material for a particle. The configurations are:
// color: The HTML color name of the particle. (mandatory)
// size: The size of the particle. (mandatory)
// alpha: The alpha value of the particle. (mandatory)
// textureName: The texture name of the particle, if the particle has any texture. (optional)
// rgbFilter: A vector containing RGB threshold values. Pixels that have RGB values below the
// rgbFilter values are discarded. This can be used to eliminate texture background colors etc. (optional)
// targetColor: Target color name of the particle. If set, the color of the particle changes between
// the color and the targetColor by colorStep in each frame render. (optional)
// colorStep: A float between [0,1] that represents the variation of color between the color and the
// targetColor. (optional)
Roygbiv.prototype.createParticleMaterial = function(configurations){
  if (mode == 0){
    return;
  }
  var color = configurations.color;
  var size = configurations.size;
  var alpha = configurations.alpha;
  var textureName = configurations.textureName;
  var rgbFilter = configurations.rgbFilter;
  var targetColor = configurations.targetColor;
  var colorStep = configurations.colorStep;

  if (typeof color == UNDEFINED){
    throw new Error("createParticleMaterial error: color is a mandatory parameter.");
    return;
  }
  if (typeof size == UNDEFINED){
    throw new Error("createParticleMaterial error: size is a mandatory parameter.");
    return;
  }
  if (isNaN(size)){
    throw new Error("createParticleMaterial error: Bad size parameter.");
    return;
  }
  if (size <= 0){
    throw new Error("createParticleMaterial error: size must be greater than zero.");
    return;
  }
  if (typeof alpha == UNDEFINED){
    throw new Error("createParticleMaterial error: alpha is a mandatory parameter.");
    return;
  }
  if (isNaN(alpha)){
    throw new Error("createParticleMaterial error: Bad alpha parameter.");
    return;
  }
  if (alpha < 0 || alpha > 1){
    throw new Error("createParticleMaterial error: alpha must be between [0,1]");
    return;
  }
  if (!(typeof textureName == UNDEFINED)){
    var texture = textures[textureName];
    if (typeof texture == UNDEFINED){
      throw new Error("createParticleMaterial error: No such texture.");
      return;
    }
    if (!(texture instanceof THREE.Texture)){
      throw new Error("createParticleMaterial error: Texture not ready.");
      return;
    }
    if (texture instanceof THREE.CompressedTexture){
      throw new Error("createParticleMaterial error: Compressed textures are not supported for particle systems.");
      return;
    }
  }
  if (!(typeof rgbFilter == UNDEFINED)){
    if (isNaN(rgbFilter.x) || isNaN(rgbFilter.y) || isNaN(rgbFilter.z)){
      throw new Error("createParticleMaterial error: Bad rgbFilter parameter.");
      return;
    }
  }
  if (!(typeof targetColor == UNDEFINED)){
    if (typeof colorStep == UNDEFINED){
      throw new Error("createParticleMaterial error: colorStep is mandatory if targetColor is specified.");
      return;
    }
  }
  if (!(typeof colorStep == UNDEFINED) && configurations.colorStep != 0){
    if (isNaN(colorStep)){
      throw new Error("createParticleMaterial error: Bad colorStep parameter.");
      return;
    }
    if (colorStep > 1 || colorStep <= 0){
      throw new Error("createParticleMaterial error: colorStep must be between ]0,1]");
      return;
    }
  }else{
    configurations.colorStep = 0;
  }
  return new ParticleMaterial(configurations);
}

// createParticle
//  Creates and returns a new particle based on following configurations:
//  position: The initial local coordinates of the particle. This is mandatory unless the motionMode is MOTION_MODE_CIRCULAR. (optional)
//  material: The material of the particle created using createParticleMaterial function. (mandatory)
//  lifetime: The expiration time in seconds of the particle. Set this to 0 for unexpirable particles. (mandatory)
//  respawn:  The particle will be respawned to its initial position after its expiration if this parameter is set to true. (mandatory)
//  alphaVariation: The variation of the alpha value of the parameter on each frame. (optional)
//  alphaVariationMode: The alpha variation formula. This can be one of ALPHA_VARIATION_MODE_NORMAL, ALPHA_VARIATION_MODE_SIN or ALPHA_VARIATION_MODE_COS.
//  For ALPHA_VARIATION_MODE_NORMAL the alpha value changes linearly (t * alphaVariation), for ALPHA_VARIATION_MODE_SIN the alpha changes according to
//  the sine function (sin(alphaVariation * t)) and for ALPHA_VARIATION_MODE_COS the alpha value changes according to the cos function
//  (cos(alphaVariation * t)). Default value is ALPHA_VARIATION_MODE_NORMAL. (optional)
//  startDelay: The amount of delay in seconds before the particle is created. (optional)
//  trailMode: This can be set to true to achieve trail effect. Default is false. The velocity and acceleration of particles are redundant for the trail mode. This is used only if the motionMode is MOTION_MODE_NORMAL. (optional)
//  useWorldPosition: If set to true, the particle uses the world coordinates instead of local coordinates of its parent.
//  Circular motion of particles are ignored in this case. (optional)
//  velocity: The velocity vector of the particle.  This is used only if the motionMode is MOTION_MODE_NORMAL. (optional)
//  acceleration: The acceleration vector of the particle.  This is used only if the motionMode is MOTION_MODE_NORMAL. (optional)
//  initialAngle: The initial angle value (radians) of the particle. This is mandatory unless the motionMode is MOTION_MODE_NORMAL. (optional)
//  angularVelocity: The angular velocity (w) value of the particle. This is used only if the motionMode is MOTION_MODE_CIRCULAR. (optional)
//  angularAcceleration: The angular acceleration value of the particle. This is used only if the motionMode is MOTION_MODE_CIRCULAR. (optional)
//  angularMotionRadius: The radius value of the angular motion. This is used only if the motionMode is MOTION_MODE_CIRCULAR. (optional)
//  angularQuaternion: If set this quaternion value is applied to particles with circular motion (motionMode = MOTION_MODE_CIRCULAR). By
//  default the particles that have MOTION_MODE_CIRCULAR as motionMode are initially created on the XZ plane, so the angularQuaternion parameter
//  is used to change the initial rotation of the circular motion. This value can be calculated this way:
//  angularQuaternion = ROYGBIV.computeQuaternionFromVectors(ROYGBIV.vector(0,1,0), [desired normal value]) (optional)
//  motionMode: The motion mode of the particle. This can be MOTION_MODE_NORMAL or MOTION_MODE_CIRCULAR. MOTION_MODE_NORMAL represents
//  the motion with uniform acceleration and the MOTION_MODE_CIRCULAR represents the uniform circular motion. The default value is
//  MOTION_MODE_NORMAL. (optional)
Roygbiv.prototype.createParticle = function(configurations){
  if (mode == 0){
    return;
  }

  if (!configurations){
    throw new Error("createParticle error: configurations are not defined.");
    return;
  }

  var position = configurations.position;
  var material = configurations.material;
  var lifetime = configurations.lifetime;
  var respawn = configurations.respawn;
  var alphaVariation = configurations.alphaVariation;
  var alphaVariationMode = configurations.alphaVariationMode;
  var startDelay = configurations.startDelay;
  var trailMode = configurations.trailMode;
  var useWorldPosition = configurations.useWorldPosition;
  var velocity = configurations.velocity;
  var acceleration = configurations.acceleration;
  var initialAngle = configurations.initialAngle;
  var angularVelocity = configurations.angularVelocity;
  var angularAcceleration = configurations.angularAcceleration;
  var angularMotionRadius = configurations.angularMotionRadius;
  var angularQuaternion = configurations.angularQuaternion;
  var motionMode = configurations.motionMode;

  if (!(typeof motionMode == UNDEFINED)){
    if  (motionMode != MOTION_MODE_NORMAL && motionMode != MOTION_MODE_CIRCULAR){
      throw new Error("createParticle error: motionMode must be MOTION_MODE_NORMAL or MOTION_MODE_CIRCULAR.");
      return;
    }
  }else{
    motionMode = MOTION_MODE_NORMAL;
  }

  if (typeof position == UNDEFINED && motionMode == MOTION_MODE_NORMAL){
    throw new Error("createParticle error: position is a mandatory parameter for MOTION_MODE_NORMAL.");
    return;
  }
  if (motionMode == MOTION_MODE_NORMAL){
    initialAngle = 0;
    if (isNaN(position.x) || isNaN(position.y) || isNaN(position.z)){
      throw new Error("createParticle error: position is not a vector.");
      return;
    }
  }
  if (typeof initialAngle == UNDEFINED && motionMode == MOTION_MODE_CIRCULAR){
    throw new Error("createParticle error: initialAngle is a mandatory for MOTION_MODE_CIRCULAR.");
    return;
  }
  if (motionMode == MOTION_MODE_CIRCULAR){
    position = this.vector(0, 0, 0);
    if (isNaN(initialAngle)){
      throw new Error("createParticle error: Bad initialAngle parameter.");
      return;
    }
  }
  if (!material){
    throw new Error("createParticle error: material is a mandatory parameter.");
    return;
  }
  if (!(material.isParticleMaterial)){
    throw new Error("createParticle error: Material type not supported.");
    return;
  }
  if (isNaN(position.x) || isNaN(position.y) || isNaN(position.z)){
    throw new Error("createParticle error: position is not a vector.");
    return;
  }
  if (typeof lifetime == UNDEFINED){
    throw new Error("createParticle error: lifetime is a mandatory parameter.");
    return;
  }
  if (isNaN(lifetime)){
    throw new Error("createParticle error: lifetime is not a number.");
    return;
  }
  if (typeof respawn == UNDEFINED){
    throw new Error("createParticle error: respawn is a mandatory parameter.");
    return;
  }
  if (!(typeof(respawn) == typeof(true))){
    throw new Error("createParticle error: respawn is not a boolean.");
    return;
  }
  if (!(typeof alphaVariation == UNDEFINED)){
    if (isNaN(alphaVariation)){
      throw new Error("createParticle error: Bad alphaVariation parameter.");
      return;
    }
  }
  if (!(typeof alphaVariationMode == UNDEFINED)){
    if (isNaN(alphaVariationMode)){
      throw new Error("createParticle error: Bad alphaVariationMode parameter.");
      return;
    }
    if (alphaVariationMode != ALPHA_VARIATION_MODE_NORMAL &&
              alphaVariationMode != ALPHA_VARIATION_MODE_SIN &&
                  alphaVariationMode != ALPHA_VARIATION_MODE_COS){
          throw new Error("createParticle error: alphaVariationMode must be one of ALPHA_VARIATION_MODE_NORMAL, ALPHA_VARIATION_MODE_SIN or ALPHA_VARIATION_MODE_COS.");
          return;
        }
  }

  if (!(typeof startDelay == UNDEFINED)){
    if (isNaN(startDelay)){
      throw new Error("createParticle error: Bad startDelay parameter.");
      return;
    }
    if (startDelay < 0){
      throw new Error("createParticle error: startDelay must be a positive number.");
      return;
    }
  }else{
    startDelay = 0;
  }

  if (!(typeof trailMode == UNDEFINED)){
    if (typeof trailMode != typeof(true)){
      throw new Error("createParticle error: Bad trailMode parameter.");
      return;
    }
    if (trailMode){
      if(lifetime == 0){
        throw new Error("createParticle error: Lifetime must be greater than zero for trail particles.");
        return;
      }
      if (!respawn){
        throw new Error("createParticle error: respawn property must be true for trail particles.");
        return;
      }
    }
  }else{
    trailMode = false;
  }
  if (!(typeof velocity == UNDEFINED)){
    if (isNaN(velocity.x) || isNaN(velocity.y) || isNaN(velocity.z)){
      throw new Error("createParticle error: Bad velocity parameter.");
      return;
    }
  }else{
    velocity = this.vector(0, 0, 0);
  }
  if (!(typeof acceleration == UNDEFINED)){
    if (isNaN(acceleration.x) || isNaN(acceleration.y) || isNaN(acceleration.z)){
      throw new Error("createParticle error: Bad acceleration parameter.");
      return;
    }
  }else{
    acceleration = this.vector(0, 0, 0);
  }
  if (!(typeof angularVelocity == UNDEFINED)){
    if (isNaN(angularVelocity)){
      throw new Error("createParticle error: Bad angularVelocity parameter.");
      return;
    }
  }else{
    angularVelocity = 0;
  }
  if (!(typeof angularAcceleration == UNDEFINED)){
    if (isNaN(angularAcceleration)){
      throw new Error("createParticle error: Bad angularAcceleration parameter.");
      return;
    }
  }else{
    angularAcceleration = 0;
  }
  if (!(typeof angularMotionRadius == UNDEFINED)){
    if (isNaN(angularMotionRadius)){
      throw new Error("createParticle error: Bad angularMotionRadius parameter.");
      return;
    }
  }else{
    angularMotionRadius = 0;
  }
  if (!(typeof angularQuaternion == UNDEFINED)){
    if (isNaN(angularQuaternion.x) || isNaN(angularQuaternion.y)
                    || isNaN(angularQuaternion.z) || isNaN(angularQuaternion.w)){
      throw new Error("createParticle error: Bad angularQuaternion parameter.");
      return;
    }
  }else{
    angularQuaternion = REUSABLE_QUATERNION.set(0, 0, 0, 1);
  }
  if (!(typeof useWorldPosition == UNDEFINED)){
    if (typeof useWorldPosition != typeof(true)){
      throw new Error("createParticle error: useWorldPosition is not a boolean.");
      return;
    }
  }else{
    useWorldPosition = false;
  }

  var particle = new Particle(position.x, position.y, position.z, material, lifetime);
  if (respawn){
    particle.respawnSet = true;
  }
  if (!(typeof alphaVariation == UNDEFINED)){
    particle.alphaDelta = alphaVariation;
  }else{
    particle.alphaDelta = 0;
  }
  if (!(typeof alphaVariationMode == UNDEFINED)){
    particle.alphaVariationMode = alphaVariationMode;
  }else{
    particle.alphaVariationMode = ALPHA_VARIATION_MODE_NORMAL;
  }
  particle.startDelay = startDelay;
  particle.originalStartDelay = startDelay;
  particle.trailFlag = trailMode;
  particle.useWorldPositionFlag = useWorldPosition;

  // There used to be a CPU motion mode which is no longer supported so the
  // gpuMotion flag is true by default.
  particle.gpuMotion = true;
  particle.gpuVelocity = velocity;
  particle.gpuAcceleration = acceleration;
  particle.initialAngle = initialAngle;
  particle.angularVelocity = angularVelocity;
  particle.angularAcceleration = angularAcceleration;
  particle.angularMotionRadius = angularMotionRadius;
  particle.angularQuaternion = angularQuaternion;
  particle.motionMode = motionMode;
  particle.angularQuaternionX = angularQuaternion.x;
  particle.angularQuaternionY = angularQuaternion.y;
  particle.angularQuaternionZ = angularQuaternion.z;
  particle.angularQuaternionW = angularQuaternion.w;

  return particle;
}

// createParticleSystem
// Creates a new particle system based on following configurations:
// name: The unique name of the particle system. (mandatory)
// particles: An array of particles created using createParticle function. (mandatory)
// position: The initial position of the particle system. (mandatory)
// lifetime: The maximum lifetime of the particle system in seconds. This can be set to 0 for infinite particle systems.(mandatory)
// velocity: The velocity vector of the particle system. This is used only if the motionMode is MOTION_MODE_NORMAL. (optional)
// acceleration: The acceleration vector of the particle. This is used only if the motionMode is MOTION_MODE_NORMAL. system (optional)
// angularVelocity: The angular velocity (w) of the particle. This is used only if the motionMode is MOTION_MODE_CIRCULAR. (optional)
// angularAcceleration: The angular acceleration of the particle. This is used only if the motionMode is MOTION_MODE_CIRCULAR. (optional)
// angularMotionRadius: The radius value of the imaginary circlie on which the angular motion is performed. This is used only if the motionMode is MOTION_MODE_CIRCULAR. (optional)
// angularQuaternion: If set this quaternion value is applied to the position of this particle system if the motionMode is MOTION_MODE_CIRCULAR. By
// default the particle systems that have MOTION_MODE_CIRCULAR as motionMode are initially created on the XZ plane, so the angularQuaternion parameter
// is used to change the initial rotation of the circular motion. This value can be calculated this way:
// angularQuaternion = ROYGBIV.computeQuaternionFromVectors(ROYGBIV.vector(0,1,0), [desired normal value]) (optional)
// initialAngle: The initial angle of the circular motion. This is used only if the motionMode is MOTION_MODE_CIRCULAR. (optional)
// motionMode: The motion mode of the particle system. This can be MOTION_MODE_NORMAL or MOTION_MODE_CIRCULAR. MOTION_MODE_NORMAL represents
// the motion with uniform accelerationa and the MOTION_MODE_CIRCULAR represents the circular motion with uniform acceleration. The
// default value is MOTION_MODE_NORMAL. (optional)
// updateFunction: The update function of this particle system that is executed on each render. (optional)
Roygbiv.prototype.createParticleSystem = function(configurations){
  if (mode == 0){
    return;
  }

  if (TOTAL_PARTICLE_SYSTEM_COUNT >= MAX_PARTICLE_SYSTEM_COUNT){
    throw new Error("createParticleSystem error: Cannot create more than "+MAX_PARTICLE_SYSTEM_COUNT+" particle systems.");
    return;
  }

  if (!configurations){
    throw new Error("createParticleSystem error: configurations is not defined.");
    return;
  }

  var name = configurations.name;
  var particles = configurations.particles;
  var position = configurations.position;
  var lifetime = configurations.lifetime;
  var updateFunction = configurations.updateFunction;
  var velocity = configurations.velocity;
  var acceleration = configurations.acceleration;
  var angularVelocity = configurations.angularVelocity;
  var angularAcceleration = configurations.angularAcceleration;
  var angularMotionRadius = configurations.angularMotionRadius;
  var angularQuaternion = configurations.angularQuaternion;
  var initialAngle = configurations.initialAngle;
  var motionMode = configurations.motionMode;

  if (!name){
    throw new Error("createParticleSystem error: name is a mandatory configuration.");
    return;
  }
  if (name.indexOf(',') !== -1){
    throw new Error("createParticleSystem error: name cannot contain coma.");
    return;
  }
  if (particleSystemPool[name]){
    throw new Error("createParticleSystem error: name must be unique.");
    return;
  }
  if (!particles){
    throw new Error("createParticleSystem error: particles is a mandatory configuration.");
    return;
  }
  if (particles.length == 0){
    throw new Error("createParticleSystem error: particles array is empty.");
    return;
  }
  if (!position){
    throw new Error("createParticleSystem error: position is a mandatory configuration.");
    return;
  }
  if (typeof position.x == UNDEFINED || typeof position.y == UNDEFINED || typeof position.z == UNDEFINED){
    throw new Error("createParticleSystem error: position is not a vector.");
    return;
  }
  if (isNaN(position.x) || isNaN(position.y) || isNaN(position.z)){
    throw new Error("createParticleSystem error: position is not a vector.");
    return;
  }
  if (typeof lifetime == UNDEFINED){
    throw new Error("createParticleSystem error: lifetime is a mandatory parameter.");
    return;
  }
  if (isNaN(lifetime)){
    throw new Error("createParticleSystem error: Bad lifetime parameter.");
    return;
  }
  if (lifetime < 0){
    throw new Error("createParticleSystem error: lifetime must be a positive number.");
    return;
  }

  if (!(typeof velocity == UNDEFINED)){
    if (isNaN(velocity.x) || isNaN(velocity.y) || isNaN(velocity.z)){
      throw new Error("createParticleSystem error: Bad velocity parameter.");
      return;
    }
  }

  if (!(typeof acceleration == UNDEFINED)){
    if (isNaN(acceleration.x) || isNaN(acceleration.y) || isNaN(acceleration.z)){
      throw new Error("createParticleSystem error: Bad acceleration parameter.");
      return;
    }
  }

  if (particles.length >= MAX_VERTICES_ALLOWED_IN_A_PARTICLE_SYSTEM){
    throw new Error("createParticleSystem error: Maximum allowed particle size "+MAX_VERTICES_ALLOWED_IN_A_PARTICLE_SYSTEM+" exceeded.");
    return;
  }

  if (!(typeof angularVelocity == UNDEFINED)){
    if (isNaN(angularVelocity)){
      throw new Error("createParticleSystem error: Bad angularVelocity parameter.");
      return;
    }
  }else{
    angularVelocity = 0;
  }

  if (!(typeof angularAcceleration == UNDEFINED)){
    if (isNaN(angularAcceleration)){
      throw new Error("createParticleSystem error: Bad angularAcceleration parameter.");
      return;
    }
  }else{
    angularAcceleration = 0;
  }

  if (!(typeof angularMotionRadius == UNDEFINED)){
    if (isNaN(angularMotionRadius)){
      throw new Error("createParticleSystem error: Bad angularMotionRadius parameter.");
      return;
    }
  }else{
    angularMotionRadius = 0;
  }

  if (!(typeof angularQuaternion == UNDEFINED)){
    if (isNaN(angularQuaternion.x) || isNaN(angularQuaternion.y) || isNaN(angularQuaternion.z) || isNaN(angularQuaternion.w)){
      throw new Error("createParticleSystem error: Bad angularQuaternion parameter.");
    }
  }else{
    angularQuaternion = REUSABLE_QUATERNION.set(0, 0, 0, 1);
  }

  if (!(typeof initialAngle == UNDEFINED)){
    if (isNaN(initialAngle)){
      throw new Error("createParticleSystem error: Bad initialAngle parameter.");
      return;
    }
  }else{
    initialAngle = 0;
  }

  if (!(typeof motionMode == UNDEFINED)){
    if (motionMode != MOTION_MODE_NORMAL && motionMode != MOTION_MODE_CIRCULAR){
      throw new Error("createParticleSystem error: motionMode must be MOTION_MODE_NORMAL or MOTION_MODE_CIRCULAR.");
      return;
    }
  }else{
    motionMode = MOTION_MODE_NORMAL;
  }

  var vx = 0, vy = 0, vz = 0, ax = 0, ay = 0, az = 0;
  if (velocity){
    vx = velocity.x;
    vy = velocity.y;
    vz = velocity.z;
  }
  if (acceleration){
    ax = acceleration.x;
    ay = acceleration.y;
    az = acceleration.z;
  }

  if (!updateFunction){
    updateFunction = null;
  }

  var particleSystem = new ParticleSystem(
    null, name, particles, position.x, position.y, position.z,
    vx, vy, vz, ax, ay, az, motionMode,
    updateFunction
  );

  particleSystem.lifetime = lifetime;

  particleSystem.angularVelocity = angularVelocity;
  particleSystem.angularAcceleration = angularAcceleration;
  particleSystem.angularMotionRadius = angularMotionRadius;
  particleSystem.angularQuaternionX = angularQuaternion.x;
  particleSystem.angularQuaternionY = angularQuaternion.y;
  particleSystem.angularQuaternionZ = angularQuaternion.z;
  particleSystem.angularQuaternionW = angularQuaternion.w;
  particleSystem.initialAngle = initialAngle;

  TOTAL_PARTICLE_SYSTEM_COUNT ++;

  return particleSystem;
}

// scale
//  Modifies the scale of a particle system.
Roygbiv.prototype.scale = function(object, scaleVector){
  if (mode == 0){
    return;
  }
  if (!scaleVector){
    throw new Error("scale error: scaleVector is not defined.");
    return;
  }
  if (typeof scaleVector.x == UNDEFINED || typeof scaleVector.y == UNDEFINED || typeof scaleVector.z == UNDEFINED){
    throw new Error("scal error: scaleVector is not a vector.");
    return;
  }
  if (isNaN(scaleVector.x) || isNaN(scaleVector.y) || isNaN(scaleVector.z)){
    throw new Error("scale error: scaleVector is not a vector.");
    return;
  }
  if (!object){
    throw new Error("scale error: object is undefined.");
    return;
  }
  if (!(object.isParticleSystem)){
    throw new Error("scale error: Type not supported.");
    return;
  }

  object.mesh.scale.set(scaleVector.x, scaleVector.y, scaleVector.z);
}

// setBlending
//  Sets the blending mode of a particle system. Blending mode can be one of
//  NO_BLENDING, NORMAL_BLENDING, ADDITIVE_BLENDING, SUBTRACTIVE_BLENDING or
//  MULTIPLY_BLENDING
Roygbiv.prototype.setBlending = function(particleSystem, mode){
  if (mode == 0){
    return;
  }
  if (!particleSystem){
    throw new Error("setBlending error: particleSystem is not defined.");
    return;
  }
  if (typeof mode == UNDEFINED){
    throw new Error("setBlending error: mode is not defined.");
    return;
  }
  if (!(particleSystem.isParticleSystem)){
    throw new Error("setBlending error: Unsupported type.");
    return;
  }
  if (mode != NO_BLENDING && mode != NORMAL_BLENDING && mode != ADDITIVE_BLENDING && mode != SUBTRACTIVE_BLENDING && mode != MULTIPLY_BLENDING){
    throw new Error("setBlending error: Bad mode parameter.");
    return;
  }
  particleSystem.setBlending(mode);
}

// setParticleSystemRotation
//  Sets the rotation of a particle system around given axis.
Roygbiv.prototype.setParticleSystemRotation = function(particleSystem, axis, rad){
  if (mode == 0){
    return;
  }
  if (!particleSystem){
    throw new Error("setParticleSystemRotation error: particleSystem is not defined.");
    return;
  }
  if (!axis){
    throw new Error("setParticleSystemRotation error: axis is not defined.");
    return;
  }
  if (typeof rad == UNDEFINED){
    throw new Error("setParticleSystemRotation error: rad is not defined.");
    return;
  }
  axis = axis.toLowerCase();
  if (axis != "x" && axis != "y" && axis != "z"){
    throw new Error("setParticleSystemRotation error: axis should be one of x, y and z");
    return;
  }
  if (isNaN(rad)){
    throw new Error("setParticleSystemRotation error: Bad parameters.");
    return;
  }
  if (!particleSystem.mesh.visible){
    throw new Error("setParticleSystemRotation error: particleSystem is not visible.");
    return;
  }
  if (particleSystem.checkForCollisions){
    throw new Error("setParticleSystemRotation error: particleSystem has a collision callback attached. Cannot set rotation.");
    return;
  }
  if (particleSystem.particlesWithCollisionCallbacks.size > 0){
    throw new Error("setParticleSystemRotation error: particleSystem has a collidable particle. Cannot set rotation.");
    return;
  }
  if (particleSystem.hasTrailedParticle){
    throw new Error("setParticleSystemRotation error: particleSystem has a trailed particle. Cannot set rotation.");
    return;
  }
  if (particleSystem.velocity.x != 0 || particleSystem.velocity.y != 0 || particleSystem.velocity.z != 0 ||
          particleSystem.acceleration.x != 0 || particleSystem.acceleration.y != 0 || particleSystem.acceleration.z != 0){

      throw new Error("setParticleSystemRotation error: particleSystem has a defined motion. Cannot set rotation.");
      return;
  }

  if (axis == "x"){
    particleSystem.mesh.rotation.x = rad;
  }else if (axis == "y"){
    particleSystem.mesh.rotation.y = rad;
  }else if (axis == "z"){
    particleSystem.mesh.rotation.z = rad;
  }

  particleSystem.hasManualRotationSet = true;

}

// setParticleSystemQuaternion
//  Sets the quaternion of given particle system.
Roygbiv.prototype.setParticleSystemQuaternion = function(particleSystem, quatX, quatY, quatZ, quatW){
  if (mode == 0){
    return;
  }
  if (!particleSystem){
    throw new Error("setParticleSystemQuaternion error: particleSystem is not defined.");
    return;
  }
  if (!(particleSystem.isParticleSystem)){
    throw new Error("setParticleSystemQuaternion error: Unsupported type.");
    return;
  }
  if (isNaN(quatX) || isNaN(quatY) || isNaN(quatZ) || isNaN(quatW)){
    throw new Error("setParticleSystemQuaternion error: Bad parameters.");
    return;
  }

  if (!particleSystem.mesh.visible){
    throw new Error("setParticleSystemQuaternion error: particleSystem is not visible.");
    return;
  }
  if (particleSystem.checkForCollisions){
    throw new Error("setParticleSystemQuaternion error: particleSystem has a collision callback attached. Cannot set quaternion.");
    return;
  }
  if (particleSystem.particlesWithCollisionCallbacks.size > 0){
    throw new Error("setParticleSystemQuaternion error: particleSystem has a collidable particle. Cannot set quaternion.");
    return;
  }
  if (particleSystem.hasTrailedParticle){
    throw new Error("setParticleSystemQuaternion error: particleSystem has a trailed particle. Cannot set quaternion.");
    return;
  }
  if (particleSystem.velocity.x != 0 || particleSystem.velocity.y != 0 || particleSystem.velocity.z != 0 ||
          particleSystem.acceleration.x != 0 || particleSystem.acceleration.y != 0 || particleSystem.acceleration.z != 0){

      throw new Error("setParticleSystemQuaternion error: particleSystem has a defined motion. Cannot set quaternion.");
      return;
  }

  particleSystem.mesh.quaternion.set(quatX, quatY, quatZ, quatW);
  particleSystem.hasManualQuaternionSet = true;
}

// kill
//  Destroys a particle or a particle system.
Roygbiv.prototype.kill = function(object){
  if (mode == 0){
    return;
  }
  if (!object){
    throw new Error("kill error: object is not defined.");
    return;
  }
  if (!(object.isParticle) && !(object.isParticleSystem)){
    throw new Error("kill error: Unsupported type.");
    return;
  }
  if (object.isParticle){
    object.isExpired = true;
    if (object.parent){
      object.parent.removeParticle(object);
      object.parent.destroyedChildCount ++;
      if (object.parent.destroyedChildCount == object.parent.particles.length){
        object.parent.destroy();
        delete particleSystems[object.parent.name];
        delete particleSystemPool[object.parent.name];
        TOTAL_PARTICLE_SYSTEM_COUNT --;
      }
    }
  }else if (object.isParticleSystem){
    object.destroy();
    delete particleSystems[object.name];
    delete particleSystemPool[object.name];
    TOTAL_PARTICLE_SYSTEM_COUNT --;
  }
}

// createSmoke
//  Returns a new smoke like particle system based on following configurations:
//  name: The unique name of the particle system (mandatory)
//  position: The initial position of the particle system (mandatory)
//  expireTime: The maximum lifetime of the particle system in seconds. This can be set to 0 for infinite particle systems. (mandatory)
//  smokeSize: Size of the smoke source (mandatory)
//  particleSize: The size of each smoke particle (mandatory)
//  particleCount: Count of smoke particles (mandatory)
//  colorName: Color name of each particle (mandatory)
//  textureName: Name of the smoke texture (optional)
//  movementAxis: The axis vector on which the smoke particles move. Default value is (0,1,0) (optional)
//  velocity: The average velocity of particles on the movementAxis (mandatory)
//  acceleration: The average acceleration of particles on the movementAxis (mandatory)
//  randomness: A number representing the turbulence factor of the smoke particles (mandatory)
//  lifetime: The average lifetime of particles (mandatory)
//  alphaVariation: A number between -1 and 0 represents the variaton of alpha of the smoke particles on each frame (mandatory)
//  accelerationDirection: The direction vector of acceleration. If set, the smoke is accelerated
//  along this vector instead of the movementAxis This can be used to achieve
//  realistic smoke movement on inclined surfaces or to simulate winds. (optional)
//  updateFunction: The update function of the particle system that will be executed on each frame render. (optional)
//  startDelay: The average delay in seconds before the particles are visible on the screen. (optional)
//  rgbFilter: This can be used to eliminate texture background colors. (optional)
Roygbiv.prototype.createSmoke = function(configurations){
  if (mode == 0){
    return;
  }

  if (!configurations){
    throw new Error("createSmoke error: configurations is not defined.");
    return;
  }

  var smokeSize = configurations.smokeSize;
  var name = configurations.name;
  if (typeof name == UNDEFINED){
    throw new Error("createSmoke error: name is a mandatory configuration.");
    return;
  }
  if (particleSystemPool[name]){
    throw new Error("createSmoke error: name must be unique.");
    return;
  }

  var position = configurations.position;
  if (typeof position == UNDEFINED){
    throw new Error("createSmoke error: position is a mandatory parameter.");
    return;
  }else{
    if (isNaN(position.x) || isNaN(position.y) || isNaN(position.z)){
      throw new Error("createSmoke error: Bad position parameter.");
      return;
    }
  }
  var expireTime = configurations.expireTime;
  if (typeof expireTime == UNDEFINED){
    throw new Error("createSmoke error: expireTime is a mandatory parameter.");
    return;
  }else{
    if (isNaN(expireTime)){
      throw new Error("createSmoke error: Bad expireTime parameter.");
      return;
    }else{
      if (expireTime < 0){
        throw new Error("createSmoke error: expireTime must be greater than zero.");
        return;
      }
    }
  }

  if (typeof smokeSize == UNDEFINED){
    throw new Error("createSmoke error: smokeSize is a mandatory configuration.");
    return;
  }
  if (isNaN(smokeSize)){
    throw new Error("createSmoke error: Bad smokeSize parameter");
    return;
  }
  var particleSize = configurations.particleSize;
  if (typeof particleSize == UNDEFINED){
    throw new Error("createSmoke error: particleSize is a mandatory configuration.");
    return;
  }
  if (isNaN(particleSize)){
    throw new Error("createSmoke error: Bad particleSize parameter.");
    return;
  }
  var particleCount = configurations.particleCount;
  if (typeof particleCount == UNDEFINED){
    throw new Error("createSmoke error: particleCount is a mandatory configuration.");
    return;
  }
  if (isNaN(particleCount)){
    throw new Error("createSmoke error: Bad particleCount parameter.");
    return;
  }
  if (particleCount <= 0){
    throw new Error("createSmoke error: particleCount must be greater than zero.");
    return;
  }
  var colorName = configurations.colorName;
  if (typeof colorName == UNDEFINED){
    throw new Error("createSmoke error: colorName is a mandatory configuration.");
    return;
  }
  var textureName = configurations.textureName;
  var isTextured = false;
  var texture;
  if (!(typeof textureName == UNDEFINED)){
    if (!textures[textureName]){
      throw new Error("createSmoke error: No such texture.");
      return;
    }
    texture = textures[textureName];
    if (!(texture instanceof THREE.Texture)){
      throw new Error("createSmoke error: Texture not ready.");
      return;
    }
    isTextured = true;
  }
  var movementAxis = configurations.movementAxis;
  if (!(typeof movementAxis == UNDEFINED)){
    if (isNaN(movementAxis.x) || isNaN(movementAxis.y) || isNaN(movementAxis.z)){
      throw new Error("createSmoke error: Bad movementAxis parameter.");
    }
  }else{
    movementAxis = ROYGBIV.vector(0, 1, 0);
  }
  var velocity = configurations.velocity;
  if (typeof velocity == UNDEFINED){
    throw new Error("createSmoke error: velocity is a mandatory configuration.");
    return;
  }
  if (isNaN(velocity)){
    throw new Error("createSmoke error: Bad velocity parameter.");
    return;
  }
  var acceleration = configurations.acceleration;
  if (typeof acceleration == UNDEFINED){
    throw new Error("createSmoke error: acceleration is a mandatory configuration.");
    return;
  }
  if (isNaN(acceleration)){
    throw new Error("createSmoke error: Bad acceleration parameter.");
    return;
  }
  var randomness = configurations.randomness;
  if (typeof randomness == UNDEFINED){
    throw new Error("createSmoke error: randomness is a mandatory configuration.");
    return;
  }
  if (isNaN(randomness)){
    throw new Error("createSmoke error: Bad randomness parameter.");
    return;
  }
  var lifetime = configurations.lifetime;
  if (typeof lifetime == UNDEFINED){
    throw new Error("createSmoke error: lifetime is a mandatory configuration.");
    return;
  }
  if (isNaN(lifetime)){
    throw new Error("createSmoke error: Bad lifetime parameter.");
    return;
  }
  if (lifetime <= 0){
    throw new Error("createSmoke error: lifetime must be greater than zero.");
    return;
  }
  var alphaVariation = configurations.alphaVariation;
  if (typeof alphaVariation == UNDEFINED){
    throw new Error("createSmoke error: alphaVariation is a mandatory configuration.");
    return;
  }
  if (isNaN(alphaVariation)){
    throw new Error("createSmoke error: Bad alphaVariation parameter.");
    return;
  }
  if (alphaVariation < -1 || alphaVariation > 1){
    throw new Error("createSmoke error: alphaVariation must be between [-1,1]");
    return;
  }

  var updateFunction = configurations.updateFunction;
  if (updateFunction){
    if (!(updateFunction instanceof Function)){
      throw new Error("createSmoke error: updateFunction must be a function.");
      return;
    }
  }

  var startDelay = configurations.startDelay;
  if (typeof startDelay == UNDEFINED){
    startDelay = 0;
  }else{
    if (isNaN(startDelay)){
      throw new Error("createSmoke error: Bad startDelay parameter.");
      return;
    }
  }

  var rgbFilter = configurations.rgbFilter;
  if (!(typeof rgbFilter == UNDEFINED)){
    if (isNaN(rgbFilter.x) || isNaN(rgbFilter.y) || isNaN(rgbFilter.z)){
      throw new Error("createSmoke error: Bad rgbFilter parameter.");
      return;
    }
  }

  var accelerationDirection = configurations.accelerationDirection;
  if (!(typeof accelerationDirection == UNDEFINED)){
    if (isNaN(accelerationDirection.x) || isNaN(accelerationDirection.y) || isNaN(accelerationDirection.z)){
      throw new Error("createSmoke error: Bad accelerationDirection parameter.");
      return;
    }
  }

  var particleMaterialConfigurations = new Object();
  particleMaterialConfigurations.color = colorName;
  particleMaterialConfigurations.size = particleSize;
  particleMaterialConfigurations.alpha = 1;
  if (isTextured){
    particleMaterialConfigurations.textureName = textureName;
  }
  if (rgbFilter){
    particleMaterialConfigurations.rgbFilter = rgbFilter;
  }

  var quat = ROYGBIV.computeQuaternionFromVectors(
    ROYGBIV.vector(0, 1, 0),
    movementAxis
  );
  var quaternion2, quaternionInverse;
  var referenceVector = ROYGBIV.vector(0, 1, 0);
  var referenceQuaternion = this.computeQuaternionFromVectors(
    this.vector(0, 0, 1), referenceVector
  );
  if (accelerationDirection){
    quaternion2 = this.computeQuaternionFromVectors(referenceVector, accelerationDirection);
    quaternionInverse = quat.clone().inverse();
  }

  var particleMaterial = this.createParticleMaterial(particleMaterialConfigurations);

  var particles = [];
  var particleConfigurations = new Object();
  for (var i = 0; i<particleCount; i++){
    particleConfigurations.position = this.applyNoise(this.circularDistribution(smokeSize, referenceQuaternion));
    particleConfigurations.material = particleMaterial;
    particleConfigurations.lifetime = lifetime * Math.random();
    particleConfigurations.respawn = true;
    particleConfigurations.alphaVariation = alphaVariation;
    particleConfigurations.startDelay = startDelay * Math.random();
    var decidedVelocity = this.vector(0, velocity * Math.random(), 0);
    var decidedAcceleration = this.vector(
      randomness * (Math.random() - 0.5),
      acceleration * Math.random(),
      randomness * (Math.random() - 0.5)
    );
    if (!accelerationDirection){
      particleConfigurations.velocity = decidedVelocity;
      particleConfigurations.acceleration = decidedAcceleration;
    }else{
      REUSABLE_VECTOR_4.set(decidedAcceleration.x, decidedAcceleration.y, decidedAcceleration.z);
      REUSABLE_VECTOR_4.applyQuaternion(quaternionInverse);
      REUSABLE_VECTOR_4.applyQuaternion(quaternion2);
      particleConfigurations.velocity = decidedVelocity;
      particleConfigurations.acceleration = this.vector(
        REUSABLE_VECTOR_4.x, REUSABLE_VECTOR_4.y, REUSABLE_VECTOR_4.z
      );
    }
    particles.push(this.createParticle(particleConfigurations));
  }

  var particleSystemConfigurations = new Object();
  particleSystemConfigurations.name = name;
  particleSystemConfigurations.particles = particles;
  particleSystemConfigurations.position = position;
  particleSystemConfigurations.lifetime = expireTime;
  if (updateFunction){
    particleSystemConfigurations.updateFunction = updateFunction;
  }

  var smoke = this.createParticleSystem(particleSystemConfigurations);
  smoke.mesh.applyQuaternion(quat);
  return smoke;
}

// createTrail
//  Creates a trail particle system. The configurations are:
//  name: The unique name of the particle system. (mandatory)
//  position: The initial position of the particle system. (mandatory)
//  expireTime: The maximum lifetime of the particle system in seconds. This can be set to 0 for infinite particle systems. (mandatory)
//  particleCount: The count of particles in the particle system. (mandatory)
//  velocity: The velocity of the particle system. (mandatory)
//  acceleration: The acceleration of the particle system. (mandatory)
//  lifetime: The average lifetime of the particles. This can be set to zero for infinite particles (mandatory)
//  alphaVariation: The average variation of alpha of particles on each frame. Expected value is between [-1,0] (mandatory)
//  startDelay: The average start delay of particles. (mandatory)
//  colorName: The HTML color name of particles. (mandatory)
//  particleSize: The size of each particle. (mandatory)
//  size: The size of the particle system. (mandatory)
//  textureName: Name of the texture mapped to particles. (optional)
//  rgbFilter: This can be used to eliminate texture background colors. (optional)
//  targetColor: Target color name of the particle. If set, the color of the particle changes
//  between the color and the targetColor by colorStep in each frame render. (optional)
//  colorStep: A float between [0,1] that represents the variation of color between the color and the
//  targetColor. (optional)
//  updateFunction: The update function of the particle system that is executed on each frame render. (optional)
Roygbiv.prototype.createTrail = function(configurations){
  if (mode == 0){
    return;
  }
  var name = configurations.name;
  var position = configurations.position;
  var expireTime = configurations.expireTime;
  var particleCount = configurations.particleCount;
  var velocity = configurations.velocity;
  var acceleration = configurations.acceleration;
  var lifetime = configurations.lifetime;
  var alphaVariation = configurations.alphaVariation;
  var startDelay = configurations.startDelay;
  var colorName = configurations.colorName;
  var particleSize = configurations.particleSize;
  var size = configurations.size;
  var textureName = configurations.textureName;
  var rgbFilter = configurations.rgbFilter;
  var targetColor = configurations.targetColor;
  var colorStep = configurations.colorStep;
  var updateFunction = configurations.updateFunction;

  if (typeof name == UNDEFINED){
    throw new Error("createTrail error: name is a mandatory configuration.");
    return;
  }
  if (particleSystemPool[name]){
    throw new Error("createTrail error: name must be unique.");
    return;
  }
  if (typeof position == UNDEFINED){
    throw new Error("createTrail error: position is a mandatory configuration.");
    return;
  }
  if (isNaN(position.x) || isNaN(position.y) || isNaN(position.z)){
    throw new Error("createTrail error: Bad position parameter.");
    return;
  }
  if (typeof expireTime == UNDEFINED){
    throw new Error("createTrail error: expireTime is a mandatory configuration.");
    return;
  }
  if (isNaN(expireTime)){
    throw new Error("createTrail error: Bad expireTime parameter.");
    return;
  }
  if (expireTime < 0){
    throw new Error("createTrail error: expireTime must be greater than zero.");
    return;
  }
  if (typeof particleCount == UNDEFINED){
    throw new Error("createTrail error: particleCount is a mandatory configuration.");
    return;
  }
  if (isNaN(particleCount)){
    throw new Error("createTrail error: Bad particleCount configuration.");
    return;
  }
  if (particleCount == 0){
    throw new Error("createTrail error: particleCount must be greater than zero.");
    return;
  }
  if (typeof velocity == UNDEFINED){
    throw new Error("createTrail error: velocity is a mandatory configuration.");
    return;
  }
  if (isNaN(velocity.x) || isNaN(velocity.y) || isNaN(velocity.z)){
    throw new Error("createTrail error: Bad velocity parameter.");
    return;
  }
  if (typeof acceleration == UNDEFINED){
    throw new Error("createTrail error: acceleration is a mandatory parameter.");
    return;
  }
  if (isNaN(acceleration.x) || isNaN(acceleration.y) || isNaN(acceleration.z)){
    throw new Error("createTrail error: Bad acceleration parameter.");
    return;
  }
  if (typeof lifetime == UNDEFINED){
    throw new Error("createTrail error: lifetime is a mandatory parameter.");
    return;
  }
  if (isNaN(lifetime)){
    throw new Error("createTrail error: Bad lifetime parameter.");
    return;
  }
  if (typeof alphaVariation == UNDEFINED){
    throw new Error("createTrail error: alphaVariation is a mandatory configuration.");
    return;
  }
  if (isNaN(alphaVariation)){
    throw new Error("createTrail error: Bad alphaVariation parameter.");
    return;
  }
  if (alphaVariation > 0 || alphaVariation < -1){
    throw new Error("createTrail error: alphaVariation must be between [-1,0]");
    return;
  }
  if (typeof startDelay == UNDEFINED){
    throw new Error("createTrail error: startDelay is a mandatory configuration.");
    return;
  }
  if (isNaN(startDelay)){
    throw new Error("createTrail error: Bad startDelay parameter.");
    return;
  }
  if (startDelay < 0){
    throw new Error("createTrail error: startDelay must be greater than zero.");
    return;
  }
  if (typeof colorName == UNDEFINED){
    throw new Error("createTrail error: colorName is a mandatory configuration.");
    return;
  }
  if (typeof particleSize == UNDEFINED){
    throw new Error("createTrail error: particleSize is a mandatory configuration.");
    return;
  }
  if (isNaN(particleSize)){
    throw new Error("createTrail error: Bad particleSize parameter.");
    return;
  }
  if (particleSize <= 0){
    throw new Error("createTrail error: particleSize must be greater than zero.");
    return;
  }
  if (typeof size == UNDEFINED){
    throw new Error("createTrail error: size is a mandatory configuration.");
    return;
  }
  if (isNaN(size)){
    throw new Error("createTrail error: Bad size parameter.");
    return;
  }
  if (size <= 0){
    throw new Error("createTrail error: size must be greater than zero.");
    return;
  }
  var texture;
  if (!(typeof textureName == UNDEFINED)){
    texture = textures[textureName];
    if (!texture){
      throw new Error("createTrail error: No such texture.");
      return;
    }
    if (!(texture instanceof THREE.Texture)){
      throw new Error("createTrail error: Texture not ready.");
      return;
    }
  }
  if (!(typeof rgbFilter == UNDEFINED)){
    if (isNaN(rgbFilter.x) || isNaN(rgbFilter.y) || isNaN(rgbFilter.z)){
      throw new Error("createSmoke error: Bad rgbFilter parameter.");
      return;
    }
  }
  if (!(typeof updateFunction == UNDEFINED)){
    if (!(updateFunction instanceof Function)){
      throw new Error("createSmoke error: updateFunction is not a function.");
      return;
    }
  }

  var particleMaterialConfigurations = new Object();
  particleMaterialConfigurations.color = colorName;
  particleMaterialConfigurations.size = particleSize;
  particleMaterialConfigurations.alpha = 1;
  particleMaterialConfigurations.targetColor = targetColor;
  particleMaterialConfigurations.colorStep = colorStep;
  if (textureName){
    particleMaterialConfigurations.textureName = textureName;
  }
  if (rgbFilter){
    particleMaterialConfigurations.rgbFilter = rgbFilter;
  }

  var particleMaterial = this.createParticleMaterial(particleMaterialConfigurations);

  var particles = [];
  var particleConfigurations = new Object();
  for (var i = 0; i < particleCount; i++){
    particleConfigurations.position = this.applyNoise(this.sphericalDistribution(size));
    particleConfigurations.material = particleMaterial;
    particleConfigurations.lifetime = lifetime * Math.random();
    particleConfigurations.respawn = true;
    particleConfigurations.alphaVariation = alphaVariation;
    particleConfigurations.startDelay = startDelay * Math.random();
    particleConfigurations.trailMode = true;
    particleConfigurations.useWorldPosition = true;
    particles.push(this.createParticle(particleConfigurations));
  }
  var particleSystemConfigurations = new Object();
  particleSystemConfigurations.name = name;
  particleSystemConfigurations.particles = particles;
  particleSystemConfigurations.position = position;
  particleSystemConfigurations.velocity = velocity;
  particleSystemConfigurations.acceleration = acceleration;
  particleSystemConfigurations.lifetime = expireTime;
  particleSystemConfigurations.updateFunction = updateFunction;
  return this.createParticleSystem(particleSystemConfigurations);
}

// createPlasma
// Returns a plasma like particle system (see Doom 4 - plasma rifle). The configurations are:
// name: The unique name of the particle system. (mandatory)
// position: The initial position of the particle system. (mandatory)
// expireTime: The maximum lifetime of the particle system in seconds. This can be set to 0 for infinite particle systems. (mandatory)
// velocity: The velocity of the particle system. (mandatory)
// acceleration: The acceleration of the particle system. (mandatory)
// radius: The radius of the plasma. (mandatory)
// avgParticleSpeed: The average circular velocity of particles. (mandatory)
// particleCount: The count of particles. (mandatory)
// particleSize: The size of particles. (mandatory)
// alpha: The alpha value of particles. Default value is 1.(optional)
// colorName: The HTML color name of plasma particles. (mandatory)
// textureName: The texture name of plasma particles. (optional)
// rgbFilter: This can be used to eliminate texture background colors. (optional)
// alphaVariation: If set, the alpha value of particles would change according to the formula: sin(alphaVariation * t) (optional)
Roygbiv.prototype.createPlasma = function(configurations){
  if (mode == 0){
    return;
  }
  var name = configurations.name;
  var position = configurations.position;
  var expireTime = configurations.expireTime;
  var velocity = configurations.velocity;
  var acceleration = configurations.acceleration;
  var radius = configurations.radius;
  var avgParticleSpeed = configurations.avgParticleSpeed;
  var particleCount = configurations.particleCount;
  var particleSize = configurations.particleSize;
  var alpha = configurations.alpha;
  var colorName = configurations.colorName;
  var textureName = configurations.textureName;
  var rgbFilter = configurations.rgbFilter;
  var alphaVariation = configurations.alphaVariation;
  if (typeof name == UNDEFINED){
    throw new Error("createPlasma error: name is a mandatory configuration.");
    return;
  }
  if (particleSystemPool[name]){
    throw new Error("createPlasma error: name must be unique.");
    return;
  }
  if (typeof position == UNDEFINED){
    throw new Error("createPlasma error: position is a mandatory configuration.");
    return;
  }
  if (isNaN(position.x) || isNaN(position.y) || isNaN(position.z)){
    throw new Error("createPlasma error: Bad position parameter.");
    return;
  }
  if (typeof expireTime == UNDEFINED){
    throw new Error("createPlasma error: expireTime is a mandatory configuration.");
    return;
  }
  if (isNaN(expireTime)){
    throw new Error("createPlasma error: Bad expireTime parameter.");
    return;
  }
  if (expireTime < 0){
    throw new Error("createPlasma error: expireTime must be greater than zero.");
    return;
  }
  if (typeof velocity == UNDEFINED){
    throw new Error("createPlasma error: velocity is a mandatory configuration.");
    return;
  }
  if (isNaN(velocity.x) || isNaN(velocity.y) || isNaN(velocity.z)){
    throw new Error("createPlasma error: Bad velocity parameter.");
    return;
  }
  if (typeof acceleration == UNDEFINED){
    throw new Error("createPlasma error: acceleration is a mandatory configuration.");
    return;
  }
  if (isNaN(acceleration.x) || isNaN(acceleration.y) || isNaN(acceleration.z)){
    throw new Error("createPlasma error: Bad acceleration parameter.");
    return;
  }
  if (typeof radius == UNDEFINED){
    throw new Error("createPlasma error: radius is a mandatory parameter.");
    return;
  }
  if (isNaN(radius)){
    throw new Error("createPlasma error: Bad radius parameter.");
    return;
  }
  if (radius <= 0){
    throw new Error("createPlasma error: radius must be greater than zero.");
    return;
  }
  if (typeof avgParticleSpeed == UNDEFINED){
    throw new Error("createPlasma error: avgParticleSpeed is a mandatory configuration.");
    return;
  }
  if (isNaN(avgParticleSpeed)){
    throw new Error("createPlasma error: Bad avgParticleSpeed parameter.");
    return;
  }
  if (typeof particleCount == UNDEFINED){
    throw new Error("createPlasma error: particleCount is a mandatory parameter.");
    return;
  }
  if (isNaN(particleCount)){
    throw new Error("createPlasma error: Bad particleCount parameter.");
    return;
  }
  if (particleCount <= 0){
    throw new Error("createPlasma error: particleCount must be greater than zero.");
    return;
  }
  if (typeof colorName == UNDEFINED){
    throw new Error("createPlasma error: colorName is a mandatory configuration.");
    return;
  }
  var isTextured = false;
  if (!(typeof textureName == UNDEFINED)){
    var texture = textures[textureName];
    if (!texture){
      throw new Error("createPlasma error: No such texture.");
      return;
    }
    if (!(texture instanceof THREE.Texture)){
      throw new Error("createPlasma error: Texture not ready.");
      return;
    }
    isTextured = true;
  }
  if (typeof particleSize == UNDEFINED){
    throw new Error("createPlasma error: particleSize is a mandatory parameter.");
    return;
  }
  if (isNaN(particleSize)){
    throw new Error("createPlasma error: Bad particleSize parameter.");
    return;
  }
  if (typeof alpha == UNDEFINED){
    alpha = 1;
  }else{
    if (isNaN(alpha)){
      throw new Error("createPlasma error: Bad alpha parameter.");
      return;
    }
    if (alpha > 1 || alpha < 0){
      throw new Error("createPlasma error: alpha must be between [0, 1]");
      return;
    }
  }
  if (!(typeof rgbFilter == UNDEFINED)){
    if (isNaN(rgbFilter.x) || isNaN(rgbFilter.y) || isNaN(rgbFilter.z)){
      throw new Error("createPlasma error: Bad rgbFilter parameter.");
      return;
    }
  }
  var alphaVariationSet = false;
  if (!(typeof alphaVariation == UNDEFINED)){
    if (isNaN(alphaVariation)){
      throw new Error("createPlasma error: Bad alphaVariation parameter.");
      return;
    }
    alphaVariationSet = true;
  }

  var particleMaterialConfigurations = new Object();
  particleMaterialConfigurations.color = colorName;
  particleMaterialConfigurations.size = particleSize;
  particleMaterialConfigurations.alpha = alpha;
  if (isTextured){
    particleMaterialConfigurations.textureName = textureName;
  }
  if (rgbFilter){
    particleMaterialConfigurations.rgbFilter = rgbFilter;
  }

  var particleMaterial = this.createParticleMaterial(particleMaterialConfigurations);
  var particles = [];
  var particleConfigurations = new Object();
  if (alphaVariationSet){
    particleConfigurations.alphaVariationMode = ALPHA_VARIATION_MODE_SIN;
    particleConfigurations.alphaVariation = alphaVariation;
  }
  particleConfigurations.motionMode = MOTION_MODE_CIRCULAR;
  particleConfigurations.angularMotionRadius = radius;
  var tmpVec = ROYGBIV.vector(0, 1, 0);
  for (var i = 0; i < particleCount; i++){
    particleConfigurations.angularVelocity = avgParticleSpeed * (Math.random() - 0.5);
    particleConfigurations.initialAngle = 360 * Math.random();
    particleConfigurations.angularQuaternion = ROYGBIV.computeQuaternionFromVectors(
      tmpVec, ROYGBIV.vector(
        radius * (Math.random() - 0.5), radius * (Math.random() - 0.5) , radius * (Math.random() - 0.5)
      ));
    particleConfigurations.material = particleMaterial;
    particleConfigurations.lifetime = 0;
    particleConfigurations.respawn = false;
    particles.push(this.createParticle(particleConfigurations));
  }

  var particleSystemConfigurations = new Object();
  particleSystemConfigurations.name = name;
  particleSystemConfigurations.particles = particles;
  particleSystemConfigurations.position = position;
  particleSystemConfigurations.velocity = velocity;
  particleSystemConfigurations.acceleration = acceleration;
  particleSystemConfigurations.lifetime = expireTime;
  return this.createParticleSystem(particleSystemConfigurations);
}

// createFireExplosion
// Returns a fire explosion particle system. The configurations are:
// position: The initial position of the particle system. (mandatory)
// expireTime: The maximum lifetime of the particle system in seconds. This can be set to 0 for
// infinite particle systems. (mandatory)
// name: The unique name of the particle system. (mandatory)
// radius: The radius of the explosion. (mandatory)
// particleSize: The size of each explosion particles. (mandatory)
// particleCount: Count of explosion particles. (mandatory)
// fireColorName: The fire color name of the explosion. Default value is white. (optional)
// smokeColorName: The smoke color name of the explosion. Default value is black. (optional)
// colorStep: The variaton of color between the fire color and the smoke color on each frame.
// The value is expected to be between [0, 1]. (mandatory)
// alphaVariationCoef: The alpha variation coefficient of the particle system. The alpha value
// of the explosion particles vary by sin(alphaVariationCoef * time) on each frame. (mandatory)
// explosionDirection: The direction vector of the explosion. (mandatory)
// explosionSpeed: The speed coefficient of explosion. (mandatory)
// lifetime: The average lifetime of the explosion particles. (mandatory)
// accelerationDirection: The direction vector of acceleration. If set, the explosion is accelerated
// along this vector instead of the explosionDirection. This can be used to achieve
// realistic smoke movement for explosions on inclined surfaces or to simulate winds. (optional)
// textureName: Name of the explosion fire texture. (optional)
// rgbFilter: This can be used to eliminate texture background colors. (optional)
// updateFunction: The update function of the particle system that will be executed on each
// frame render. (optional)
Roygbiv.prototype.createFireExplosion = function(configurations){
  if (mode == 0){
    return;
  }
  var position = configurations.position;
  var expireTime = configurations.expireTime;
  var name = configurations.name;
  var radius = configurations.radius;
  var particleSize = configurations.particleSize;
  var particleCount = configurations.particleCount;
  var fireColorName = configurations.fireColorName;
  var smokeColorName = configurations.smokeColorName;
  var colorStep = configurations.colorStep;
  var alphaVariationCoef = configurations.alphaVariationCoef;
  var explosionDirection = configurations.explosionDirection;
  var explosionSpeed = configurations.explosionSpeed;
  var lifetime = configurations.lifetime;
  var accelerationDirection = configurations.accelerationDirection;
  var textureName = configurations.textureName;
  var rgbFilter = configurations.rgbFilter;
  var updateFunction = configurations.updateFunction;
  if (typeof position == UNDEFINED){
    throw new Error("createFireExplosion error: position is a mandatory configuration.");
    return;
  }
  if (isNaN(position.x) || isNaN(position.y) || isNaN(position.z)){
    throw new Error("createFireExplosion error: Bad position configuration.");
    return;
  }
  if (typeof expireTime == UNDEFINED){
    throw new Error("createFireExplosion error: expireTime is a mandatory configuration.");
    return;
  }
  if (isNaN(expireTime)){
    throw new Error("createFireExplosion error: Bad expireTime parameter.");
    return;
  }
  if (expireTime < 0){
    throw new Error("createFireExplosion error: expireTime cannot be negative.");
    return;
  }
  if (typeof name == UNDEFINED){
    throw new Error("createFireExplosion error: name is a mandatory configuration.");
    return;
  }
  if (particleSystemPool[name]){
    throw new Error("createFireExplosion error: name must be unique.");
    return;
  }
  if (typeof radius == UNDEFINED){
    throw new Error("createFireExplosion error: radius is a mandatory configuration.");
    return;
  }
  if (isNaN(radius)){
    throw new Error("createFireExplosion error: Bad radius parameter.");
    return;
  }
  if (radius <= 0){
    throw new Error("createFireExplosion error: radius must be greater than zero.");
    return;
  }
  if (typeof particleSize == UNDEFINED){
    throw new Error("createFireExplosion error: particleSize is a mandatory configuration.");
    return;
  }
  if (isNaN(particleSize)){
    throw new Error("createFireExplosion error: Bad particleSize parameter.");
    return;
  }
  if (particleSize <= 0){
    throw new Error("createFireExplosion error: particleSize must be greater than zero.");;
    return;
  }
  if (typeof particleCount == UNDEFINED){
    throw new Error("createFireExplosion error: particleCount is a mandatory configuration.");
    return;
  }
  if (isNaN(particleCount)){
    throw new Error("createFireExplosion error: Bad particleCount parameter.");
    return;
  }
  if (particleCount <= 0){
    throw new Error("createFireExplosion error: particleCount must be greater than zero.");
    return;
  }
  if (typeof fireColorName == UNDEFINED){
    fireColorName = "white";
  }
  if (typeof smokeColorName == UNDEFINED){
    smokeColorName = "black";
  }
  if (typeof colorStep == UNDEFINED){
    throw new Error("createFireExplosion error: colorStep is a mandatory configuration.");
    return;
  }
  if (isNaN(colorStep)){
    throw new Error("createFireExplosion error: Bad colorStep parameter.");
    return;
  }
  if (colorStep < 0 || colorStep > 1){
    throw new Error("createFireExplosion error: colorStep is expected to be between [0,1].");
    return;
  }
  if (typeof alphaVariationCoef == UNDEFINED){
    throw new Error("createFireExplosion error: alphaVariationCoef is a mandatory configuration.");
    return;
  }
  if (isNaN(alphaVariationCoef)){
    throw new Error("createFireExplosion error: Bad alphaVariationCoef parameter.");
    return;
  }
  if (typeof explosionDirection == UNDEFINED){
    throw new Error("createFireExplosion error: explosionDirection is a mandatory configuration.");
    return;
  }
  if (isNaN(explosionDirection.x) || isNaN(explosionDirection.y) || isNaN(explosionDirection.z)){
    throw new Error("createFireExplosion error: Bad explosionDirection parameter.");
    return;
  }
  if (typeof explosionSpeed == UNDEFINED){
    throw new Error("createFireExplosion error: explosionSpeed is a mandatory configuration.");
    return;
  }
  if (isNaN(explosionSpeed)){
    throw new Error("createFireExplosion error: Bad explosionSpeed parameter.");
    return;
  }
  if (typeof lifetime == UNDEFINED){
    throw new Error("createFireExplosion error: lifetime is a mandatory configuration.");
    return;
  }
  if (isNaN(lifetime)){
    throw new Error("createFireExplosion error: Bad lifetime parameter.");
    return;
  }
  if (lifetime <= 0){
    throw new Error("createFireExplosion error: lifetime must be greater than zero.");
    return;
  }
  if (!(typeof accelerationDirection == UNDEFINED)){
    if (isNaN(accelerationDirection.x) || isNaN(accelerationDirection.y) || isNaN(accelerationDirection.z)){
      throw new Error("createFireExplosion error: Bad accelerationDirection parameter.");
      return;
    }
  }
  if (!(typeof textureName == UNDEFINED)){
    var texture = textures[textureName];
    if (typeof texture == UNDEFINED){
      throw new Error("createFireExplosion error: No such texture.");
      return;
    }
    if (!(texture instanceof THREE.Texture)){
      throw new Error("createFireExplosion error: Texture not ready.");
      return;
    }
  }
  if (!(typeof rgbFilter == UNDEFINED)){
    if (isNaN(rgbFilter.x) || isNaN(rgbFilter.y) || isNaN(rgbFilter.z)){
      throw new Error("createFireExplosion error: Bad rgbFilter parameter.");
      return;
    }
  }
  if (!(typeof updateFunction == UNDEFINED)){
    if (!(updateFunction instanceof Function)){
      throw new Error("createFireExplosion error: updateFunction is not a function.");
      return;
    }
  }

  var particleMaterialConfigurations = new Object();
  particleMaterialConfigurations.color = fireColorName;
  particleMaterialConfigurations.size = particleSize;
  particleMaterialConfigurations.alpha = 0;
  particleMaterialConfigurations.targetColor = smokeColorName;
  particleMaterialConfigurations.colorStep = colorStep;
  particleMaterialConfigurations.textureName = textureName;
  particleMaterialConfigurations.rgbFilter = rgbFilter;
  var particleMaterial = this.createParticleMaterial(particleMaterialConfigurations);
  var particles = [];
  var particleConfigurations = new Object();
  var defaultNormal = this.vector(0, 1, 0);
  var referenceQuaternion = this.computeQuaternionFromVectors(
    this.vector(0, 0, 1), defaultNormal
  );
  var quaternion = this.computeQuaternionFromVectors(defaultNormal, explosionDirection);
  var quaternionInverse;
  var quaternion2;
  if (accelerationDirection){
    quaternion2 = this.computeQuaternionFromVectors(defaultNormal, accelerationDirection);
    quaternionInverse = quaternion.clone().inverse();
  }
  particleConfigurations.material = particleMaterial;
  particleConfigurations.respawn = true;
  particleConfigurations.alphaVariation = alphaVariationCoef;
  particleConfigurations.alphaVariationMode = ALPHA_VARIATION_MODE_SIN;
  for (var i = 0; i < particleCount; i++){
    particleConfigurations.position = this.applyNoise(this.circularDistribution(radius));
    particleConfigurations.lifetime = lifetime * Math.random();
    particleConfigurations.startDelay = (Math.random() / 5);
    var particle = this.createParticle(particleConfigurations);
    particles.push(particle);
    var x = explosionSpeed * (Math.random() - 0.5);
    var y = (explosionSpeed / 2) * Math.random();
    var z = explosionSpeed * (Math.random() - 0.5);
    var velocity = this.vector(x, y, z);
    var acceleration = this.vector((-1 * x / 1.5), (Math.random() * explosionSpeed), (-1 * z / 1.5));
    if (accelerationDirection){
      REUSABLE_VECTOR_4.set(acceleration.x, acceleration.y, acceleration.z);
      REUSABLE_VECTOR_4.applyQuaternion(quaternionInverse);
      REUSABLE_VECTOR_4.applyQuaternion(quaternion2);
      particleConfigurations.velocity = velocity;
      particleConfigurations.acceleration = this.vector(
        REUSABLE_VECTOR_4.x, REUSABLE_VECTOR_4.y, REUSABLE_VECTOR_4.z
      );
    }else{
      particleConfigurations.velocity = velocity;
      particleConfigurations.acceleration = acceleration;
    }
  }

  var particleSystemConfigurations = new Object();
  particleSystemConfigurations.name = name;
  particleSystemConfigurations.position = position;
  particleSystemConfigurations.particles = particles;
  particleSystemConfigurations.lifetime = expireTime;
  var explosion = this.createParticleSystem(particleSystemConfigurations);
  explosion.mesh.applyQuaternion(quaternion);
  return explosion;
}

// createMagicCircle
// Creates a magic circle effect. Configurations are:
// name: The unique name of the circle. (mandatory)
// position: The center position of the circle. (mandatory)
// particleCount: The count of particles. (mandatory)
// expireTime: The expiration time of the circle. (mandatory)
// speed: The turning speed value of the particles. (mandatory)
// acceleration: The turning acceleration value of the particles. (mandatory)
// radius: The radius of the circle. (mandatory)
// circleNormal: The normal vector of the circle. By default the circle is located on the XZ plane (normal: (0,1,0)). (optional)
// circleDistortionCoefficient: The average distortion value of the circle. If this is not set, the particles form a perfect circle. (optional)
// lifetime: The lifetime of the particles. For the magic circles the respawn flag is always true so the lifetime value can be used to achieve
// color changes from target color to the initial color. In that case the period value of the circular motion can be used:
// T = (2 * PI) / (angular velocity) (optional)
// angleStep: The angular difference between the particles (Math.PI/k). This can be set to zero for randomly distributed particles. Default value is 0.
// angleStep can be useful to achieve circular trail effects. (optional)
// particleSize: The size of particles. (mandatory)
// colorName: The HTML color name of the particles. (mandatory)
// targetColorName: The target color name of the particles. (optional)
// colorStep: The color step value of the particles between [0,1]. (optional)
// alpha: The alpha value of the particles. (mandatory)
// alphaVariation: The variaton of alpha value of the particle on each frame. (optional)
// alphaVariationMode: The alpha variation formula. This can be one of ALPHA_VARIATION_MODE_NORMAL, ALPHA_VARIATION_MODE_SIN or ALPHA_VARIATION_MODE_COS.
// For ALPHA_VARIATION_MODE_NORMAL the alpha value changes linearly (t * alphaVariation), for ALPHA_VARIATION_MODE_SIN the alpha changes according to
// the sine function (sin(alphaVariation * t)) and for ALPHA_VARIATION_MODE_COS the alpha value changes according to the cos function
// (cos(alphaVariation * t)). Default value is ALPHA_VARIATION_MODE_NORMAL. (optional)
// textureName: The name of texture of the particles. (optional)
// rgbFilter: This can be used to eliminate texture background colors. (optional)
// updateFunction: The update function of the particle system that is executed on each frame render. (optional)
Roygbiv.prototype.createMagicCircle = function(configurations){
  if (mode == 0){
    return;
  }
  var name = configurations.name;
  var position = configurations.position;
  var particleCount = configurations.particleCount;
  var expireTime = configurations.expireTime;
  var speed = configurations.speed;
  var acceleration = configurations.acceleration;
  var radius = configurations.radius;
  var circleNormal = configurations.circleNormal;
  var circleDistortionCoefficient = configurations.circleDistortionCoefficient;
  var lifetime = configurations.lifetime;
  var angleStep = configurations.angleStep;
  var particleSize = configurations.particleSize;
  var colorName = configurations.colorName;
  var targetColorName = configurations.targetColorName;
  var colorStep = configurations.colorStep;
  var alpha = configurations.alpha;
  var alphaVariation = configurations.alphaVariation;
  var alphaVariationMode = configurations.alphaVariationMode;
  var textureName = configurations.textureName;
  var rgbFilter = configurations.rgbFilter;
  var updateFunction = configurations.updateFunction;

  if (typeof name == UNDEFINED){
    throw new Error("createMagicCircle error: name is a mandatory configuration.");
    return;
  }
  if (particleSystemPool[name]){
    throw new Error("createMagicCircle error: name must be unique.");
    return;
  }
  if (typeof position == UNDEFINED){
    throw new Error("createMagicCircle error: position is a mandatory configuration.");
    return;
  }
  if (isNaN(position.x) || isNaN(position.y) || isNaN(position.z)){
    throw new Error("createMagicCircle error: Bad position parameter.");
    return;
  }
  if (typeof particleCount == UNDEFINED){
    throw new Error("createMagicCircle error: particleCount is a mandatory configuration.");
    return;
  }
  if (isNaN(particleCount)){
    throw new Error("createMagicCircle error: Bad particleCount parameter.");
    return;
  }
  if (particleCount <= 0){
    throw new Error("createMagicCircle error: particleCount must be greater than zero.");
    return;
  }
  if (typeof expireTime == UNDEFINED){
    throw new Error("createMagicCircle error: expireTime is a mandatory configuration.");
    return;
  }
  if (isNaN(expireTime)){
    throw new Error("createMagicCircle error: Bad expireTime parameter.");
    return;
  }
  if (expireTime < 0){
    throw new Error("createMagicCircle error: expireTime must be greater than zero.");
    return;
  }
  if (typeof speed == UNDEFINED){
    throw new Error("createMagicCircle error: speed is a mandatory configuration.");
    return;
  }
  if (isNaN(speed)){
    throw new Error("createMagicCircle error: Bad speed parameter.");
    return;
  }
  if (typeof acceleration == UNDEFINED){
    throw new Error("createMagicCircle error: acceleration is a mandatory configuration.");
    return;
  }
  if (isNaN(acceleration)){
    throw new Error("createMagicCircle error: Bad acceleration parameter.");
    return;
  }
  if (typeof radius == UNDEFINED){
    throw new Error("createMagicCircle error: radius is a mandatory configuration.");
    return;
  }
  if (isNaN(radius)){
    throw new Error("createMagicCircle error: Bad radius parameter.");
    return;
  }
  if (typeof circleNormal == UNDEFINED){
    circleNormal = this.vector(0, 1, 0);
  }else{
    if (isNaN(circleNormal.x) || isNaN(circleNormal.y) || isNaN(circleNormal.z)){
      throw new Error("createMagicCircle error: Bad circleNormal parameter.");
      return;
    }
  }
  if (typeof circleDistortionCoefficient == UNDEFINED){
    circleDistortionCoefficient = 1;
  }else{
    if (isNaN(circleDistortionCoefficient)){
      throw new Error("createMagicCircle error: Bad circleDistortionCoefficient parameter.");
      return;
    }
    if (circleDistortionCoefficient == 0){
      circleDistortionCoefficient = 1;
    }
  }
  if (typeof lifetime == UNDEFINED){
    lifetime = 0;
  }else{
    if (isNaN(lifetime)){
      throw new Error("createMagicCircle error: Bad lifetime parameter.");
      return;
    }
    if (lifetime < 0){
      throw new Error("createMagicCircle error: lifetime cannot be smaller than zero.");
      return;
    }
  }
  if (typeof angleStep == UNDEFINED){
    angleStep = 0;
  }else{
    if (isNaN(angleStep)){
      throw new Error("createMagicCircle error: Bad angleStep parameter.");
      return;
    }
  }
  if (typeof particleSize == UNDEFINED){
    throw new Error("createMagicCircle error: particleSize is a mandatory configuration.");
    return;
  }
  if (isNaN(particleSize)){
    throw new Error("createMagicCircle error: Bad particleSize parameter.");
    return;
  }
  if (particleSize <= 0){
    throw new Error("createMagicCircle error: particleSize must be a positive number.");
    return;
  }
  if (typeof colorName == UNDEFINED){
    throw new Error("createMagicCircle error: colorName is a mandatory configuration.");
    return;
  }
  if(!(typeof colorStep == UNDEFINED)){
    if (isNaN(colorStep)){
      throw new Error("createMagicCircle error: Bad colorStep parameter.");
      return;
    }
    if (colorStep < 0 || colorStep > 1){
      throw new Error("createMagicCircle error: colorStep should be between [0,1].");
      return;
    }
  }
  if (typeof alpha == UNDEFINED){
    throw new Error("createMagicCircle error: alpha is a mandatory configuration.");
    return;
  }
  if (isNaN(alpha)){
    throw new Error("createMagicCircle error: Bad alpha parameter.");
    return;
  }
  if (alpha < 0 || alpha > 1){
    throw new Error("createMagicCircle error: alpha must be between [0,1].");
    return;
  }
  if (typeof alphaVariation == UNDEFINED){
    alphaVariation = 0;
  }else{
    if (isNaN(alphaVariation)){
      throw new Error("createMagicCircle error: Bad alphaVariation parameter.");
      return;
    }
  }
  if (typeof alphaVariationMode == UNDEFINED){
    alphaVariationMode = ALPHA_VARIATION_MODE_NORMAL;
  }else{
    if (alphaVariationMode != ALPHA_VARIATION_MODE_NORMAL && alphaVariationMode != ALPHA_VARIATION_MODE_COS && alphaVariationMode != ALPHA_VARIATION_MODE_SIN){
      throw new Error("createMagicCircle error: alphaVariationMode must be ALPHA_VARIATION_MODE_NORMAL, ALPHA_VARIATION_MODE_COS or ALPHA_VARIATION_MODE_SIN.");
      return;
    }
  }
  if (!(typeof textureName == UNDEFINED)){
    var texture = textures[textureName];
    if (typeof texture == UNDEFINED){
      throw new Error("createMagicCircle error: No such texture.");
      return;
    }
    if (!(texture instanceof THREE.Texture)){
      throw new Error("createMagicCircle error: Texture not ready.");
      return;
    }
  }
  if (!(typeof rgbFilter == UNDEFINED)){
    if (isNaN(rgbFilter.x) || isNaN(rgbFilter.y) || isNaN(rgbFilter.z)){
      throw new Error("createMagicCircle error: Bad rgbFilter parameter.");
      return;
    }
  }
  if (!(typeof updateFunction == UNDEFINED)){
    if (!(updateFunction instanceof Function)){
      throw new Error("createMagicCircle error: updateFunction is not a function.");
      return;
    }
  }

  var particleMaterialConfigurations = new Object();
  particleMaterialConfigurations.color = colorName;
  particleMaterialConfigurations.size = particleSize;
  particleMaterialConfigurations.alpha = alpha;
  particleMaterialConfigurations.textureName = textureName;
  particleMaterialConfigurations.rgbFilter = rgbFilter;
  particleMaterialConfigurations.targetColor = targetColorName;
  particleMaterialConfigurations.colorStep = colorStep;
  var particleMaterial = this.createParticleMaterial(particleMaterialConfigurations);
  var particles = [];
  var particleConfigurations = new Object();
  particleConfigurations.material = particleMaterial;
  particleConfigurations.angularVelocity = speed;
  particleConfigurations.angularAcceleration = acceleration;
  particleConfigurations.lifetime = lifetime;
  particleConfigurations.respawn = true;
  particleConfigurations.motionMode = MOTION_MODE_CIRCULAR;
  particleConfigurations.alphaVariation = alphaVariation;
  particleConfigurations.alphaVariationMode = alphaVariationMode;
  var referenceQuaternion = this.computeQuaternionFromVectors(
    this.vector(0, 1, 0), circleNormal
  );
  var angularCounter = 0;
  for (var i = 0; i<particleCount; i++){
    particleConfigurations.angularMotionRadius = radius +
                      (circleDistortionCoefficient * (Math.random() - 0.5));
    if (angleStep == 0){
      particleConfigurations.initialAngle = 1000 * Math.random();
    }else{
      particleConfigurations.initialAngle = angularCounter;
      angularCounter += angleStep;
    }
    particleConfigurations.angularQuaternion = referenceQuaternion;
    particles.push(this.createParticle(particleConfigurations));
  }

  var particleSystemConfigurations = new Object();
  particleSystemConfigurations.name = name;
  particleSystemConfigurations.particles = particles;
  particleSystemConfigurations.position = position;
  particleSystemConfigurations.lifetime = expireTime;
  particleSystemConfigurations.updateFunction = updateFunction;
  return this.createParticleSystem(particleSystemConfigurations);

}

// createCircularExplosion
// Creates a circular explosion effect. The configurations are:
// name: The unique name of the particle system. (mandatory)
// particleCount: The count of particles. (mandatory)
// position: The center position of the explosion. (mandatory)
// radius: The initial radius of the explosion. (mandatory)
// colorName: The color name of the particles. (mandatory)
// targetColorName: The target color name of the particles. (optional)
// colorStep: The variation of color between colorName and targetColorName on each frame.
// The expected value is between [0, 1]. (optional)
// particleSize: The size of particles. (mandatory)
// alpha: The alpha value of particles. (mandatory)
// textureName: The name of texture of the particles. (optional)
// rgbFilter: This can be used to eliminate texture background colors. (optional)
// alphaVariation: The alpha variaton of particles. The expected value is between [-1, 0] (mandatory)
// speed: The speed value of explosion. (mandatory)
// normal: The normal vector of the explosion. The default value is (0, 1, 0) (optional)
// expireTime: The expiration time of the particle system. This can be set 0 for infinite particle systems. (mandatory)
// updateFunction: The update function of the particle system that is executed on each frame render. (optional)
Roygbiv.prototype.createCircularExplosion = function(configurations){
  if (mode == 0){
    return;
  }
  var name = configurations.name;
  var particleCount = configurations.particleCount;
  var position = configurations.position;
  var radius = configurations.radius;
  var colorName = configurations.colorName;
  var targetColorName = configurations.targetColorName;
  var colorStep = configurations.colorStep;
  var particleSize = configurations.particleSize;
  var alpha = configurations.alpha;
  var textureName = configurations.textureName;
  var rgbFilter = configurations.rgbFilter;
  var alphaVariation = configurations.alphaVariation;
  var speed = configurations.speed;
  var normal = configurations.normal;
  var expireTime = configurations.expireTime;
  var updateFunction = configurations.updateFunction;

  if (typeof name == UNDEFINED){
    throw new Error("createCircularExplosion error: name is a mandatory configuration.");
    return;
  }
  if (particleSystemPool[name]){
    throw new Error("createCircularExplosion error: name must be unique.");
    return;
  }
  if (typeof particleCount == UNDEFINED){
    throw new Error("createCircularExplosion error: particleCount is a mandatory configuration.");
    return;
  }
  if (isNaN(particleCount)){
    throw new Error("createCircularExplosion error: Bad particleCount parameter.");
    return;
  }
  if (particleCount <= 0){
    throw new Error("createCircularExplosion error: particleCount must be greater than zero.");
    return;
  }
  if (typeof position == UNDEFINED){
    throw new Error("createCircularExplosion error: position is a mandatory configuration.");
    return;
  }
  if (isNaN(position.x) || isNaN(position.y) || isNaN(position.y)){
    throw new Error("createCircularExplosion error: Bad position parameter.");
    return;
  }
  if (typeof radius == UNDEFINED){
    throw new Error("createCircularExplosion error: radius is a mandatory configuration.");
    return;
  }
  if (isNaN(radius)){
    throw new Error("createCircularExplosion error: Bad radius parameter.");
    return;
  }
  if (typeof colorName == UNDEFINED){
    throw new Error("createCircularExplosion error: colorName is a mandatory configuration.");
    return;
  }
  if (typeof particleSize == UNDEFINED){
    throw new Error("createCircularExplosion error: particleSize is a mandatory configuration.");
    return;
  }
  if (isNaN(particleSize)){
    throw new Error("createCircularExplosion error: Bad particleSize parameter.");
    return;
  }
  if (particleSize <= 0){
    throw new Error("createCircularExplosion error: particleSize must be greater than zero.");
    return;
  }
  if (typeof alpha == UNDEFINED){
    throw new Error("createCircularExplosion error: alpha is a mandatory configuration.");
    return;
  }
  if (isNaN(alpha)){
    throw new Error("createCircularExplosion error: Bad alpha parameter.");
    return;
  }
  if (alpha < 0 || alpha > 1){
    throw new Error("createCircularExplosion error: alpha must be between [0,1].");
    return;
  }
  if (!(typeof textureName == UNDEFINED)){
    var texture = textures[textureName];
    if (!texture){
      throw new Error("createCircularExplosion error: No such texture.");
      return;
    }
    if (!(texture instanceof THREE.Texture)){
      throw new Error("createCircularExplosion error: Texture not ready.");
      return;
    }
  }
  if (!(typeof rgbFilter == UNDEFINED)){
    if (isNaN(rgbFilter.x) || isNaN(rgbFilter.y) || isNaN(rgbFilter.z)){
      throw new Error("createCircularExplosion error: Bad rgbFilter parameter.");
      return;
    }
  }
  if ((typeof alphaVariation == UNDEFINED)){
    throw new Error("createCircularExplosion error: alphaVariation is a mandatory configuration.");
    return;
  }
  if (isNaN(alphaVariation)){
    throw new Error("createCircularExplosion error: Bad alphaVariation parameter.");
    return;
  }
  if (alphaVariation < -1 || alphaVariation > 0){
    throw new Error("createCircularExplosion error: alphaVariation is expected to be between [-1,0].");
    return;
  }
  if (typeof speed == UNDEFINED){
    throw new Error("createCircularExplosion error: speed is a mandatory parameter.");
    return;
  }
  if (!(typeof normal == UNDEFINED)){
    if (isNaN(normal.x) || isNaN(normal.y) || isNaN(normal.z)){
      throw new Error("createCircularExplosion error: Bad normal parameter.");
      return;
    }
  }else{
    normal = this.vector(0, 1, 0);
  }
  if (typeof expireTime == UNDEFINED){
    throw new Error("createCircularExplosion error: expireTime is a mandatory configuration.");
    return;
  }
  if (isNaN(expireTime)){
    throw new Error("createCircularExplosion error: Bad expireTime parameter.");
    return;
  }
  if (expireTime < 0){
    throw new Error("createCircularExplosion error: expireTime must be a positive number.");
    return;
  }
  if (!(typeof updateFunction == UNDEFINED)){
    if (!(updateFunction instanceof Function)){
      throw new Error("createCircularExplosion error: updateFunction is not a function.");
      return;
    }
  }
  if (!(typeof colorStep == UNDEFINED)){
    if (isNaN(colorStep)){
      throw new Error("createCircularExplosion error: Bad colorStep parameter.");
      return;
    }
    if (colorStep < 0 || colorStep > 1){
      throw new Error("createCircularExplosion error: colorStep is expected to be between [0,1].");
      return;
    }
  }

  var particleMaterialConfigurations = new Object();
  particleMaterialConfigurations.color = colorName;
  particleMaterialConfigurations.size = particleSize;
  particleMaterialConfigurations.alpha = alpha;
  particleMaterialConfigurations.textureName = textureName;
  particleMaterialConfigurations.rgbFilter = rgbFilter;
  particleMaterialConfigurations.targetColor = targetColorName;
  particleMaterialConfigurations.colorStep = colorStep;
  var particleMaterial = this.createParticleMaterial(particleMaterialConfigurations);
  var particles = [];
  var particleConfigurations = new Object();
  particleConfigurations.material = particleMaterial;
  particleConfigurations.lifetime = 0;
  particleConfigurations.alphaVariation = alphaVariation;
  particleConfigurations.respawn = false;
  var quat = this.computeQuaternionFromVectors(this.vector(0, 0, 1), normal);
  for (var i = 0; i < particleCount; i++){
    particleConfigurations.position = this.circularDistribution(radius, quat);
    var velocity = this.moveTowards(position, particleConfigurations.position, 1);
    particleConfigurations.velocity = this.multiplyScalar(velocity, speed);
    particleConfigurations.acceleration = particleConfigurations.velocity;
    particles.push(this.createParticle(particleConfigurations));
  }
  var particleSystemConfigurations = new Object();
  particleSystemConfigurations.name = name;
  particleSystemConfigurations.particles = particles;
  particleSystemConfigurations.position = position;
  particleSystemConfigurations.lifetime = expireTime;
  particleSystemConfigurations.updateFunction = updateFunction;
  return this.createParticleSystem(particleSystemConfigurations);
}

// createDynamicTrail
// Creates a dynamic trail effect. Unlike normal trails, the particles of dynamic
// trails may have their unique velocities and accelerations. This may be useful to achieve
// smoke trails and fireballs that follow a linear path. Configurations are:
// name: The unique name of the particle system. (mandatory)
// position: The initial position of the trail. (mandatory)
// expireTime: The maximum lifetime of the trail in seconds. Expected value is greater than zero. (mandatory)
// particleCount: The particle count of the trail. (mandatory)
// size: The size of the trail. (mandatory)
// particleSize: The size of each trail particles. (mandatory)
// startDelay: The average delay of creation of trail particles in seconds. (mandatory)
// lifetime: The time passed in seconds before the particles are respawned. If set to 0 the trail would eventually be disappeared. (mandatory)
// velocity: The velocity vector of the trail. (mandatory)
// acceleration: The acceleration vector of the trail. (mandatory)
// randomness: The randomness of trail particles. (mandatory)
// alphaVariation: The average alpha variaton of trail particles. Expected value is between [-1, 0] (mandatory)
// colorName: The initial color name of trail particles. (mandatory)
// targetColorName: The target color name of trail particles. (optional)
// colorStep: A float between [0,1] that represents the variaton of color betwen the initial color and the target color. (optional)
// textureName: The texture name of trail particles. (optional)
// rgbFilter: This can be used to eliminate texture background colors. (optional)
// updateFunction: The update function of the particle system that is executed on each frame render. (optional)
Roygbiv.prototype.createDynamicTrail = function(configurations){
  if (mode == 0){
    return;
  }
  var name = configurations.name;
  var position = configurations.position;
  var expireTime = configurations.expireTime;
  var particleCount = configurations.particleCount;
  var size = configurations.size;
  var particleSize = configurations.particleSize;
  var startDelay = configurations.startDelay;
  var lifetime = configurations.lifetime;
  var velocity = configurations.velocity;
  var acceleration = configurations.acceleration;
  var randomness = configurations.randomness;
  var alphaVariation = configurations.alphaVariation;
  var colorName = configurations.colorName;
  var targetColorName = configurations.targetColorName;
  var colorStep = configurations.colorStep;
  var textureName = configurations.textureName;
  var rgbFilter = configurations.rgbFilter;
  var updateFunction = configurations.updateFunction;

  if (particleSystemPool[name]){
    throw new Error("createDynamicTrail error: Name must be unique.");
    return;
  }
  if (typeof position == UNDEFINED){
    throw new Error("createDynamicTrail error: position is a mandatory configuration.");
    return;
  }
  if (isNaN(position.x) || isNaN(position.y) || isNaN(position.z)){
    throw new Error("createDynamicTrail error: Bad position configuration.");
    return;
  }
  if (typeof expireTime == UNDEFINED){
    throw new Error("createDynamicTrail error: expireTime is a mandatory configuration.");
    return;
  }
  if (isNaN(expireTime)){
    throw new Error("createDynamicTrail error: Bad expireTime parameter.");
    return;
  }
  if (expireTime <= 0){
    throw new Error("createDynamicTrail error: expireTime is expected to be greater than zero.");
    return;
  }
  if (typeof particleCount == UNDEFINED){
    throw new Error("createDynamicTrail error: particleCount is a mandatory configuration.");
    return;
  }
  if (isNaN(particleCount)){
    throw new Error("createDynamicTrail error: Bad particleCount parameter.");
    return;
  }
  if (particleCount <= 0){
    throw new Error("createDynamicTrail error: particleCount is expected to be greater than zero.");
    return;
  }
  if (typeof size == UNDEFINED){
    throw new Error("createDynamicTrail error: size is a mandatory configuration.");
    return;
  }
  if (isNaN(size)){
    throw new Error("createDynamicTrail error: Bad size parameter.");
    return;
  }
  if (size <= 0){
    throw new Error("createDynamicTrail error: size is expected to be greater than zero.");
    return;
  }
  if (typeof particleSize == UNDEFINED){
    throw new Error("createDynamicTrail error: particleSize is a mandatory configuration.");
    return;
  }
  if (isNaN(particleSize)){
    throw new Error("createDynamicTrail error: Bad particleSize parameter.");
    return;
  }
  if (particleSize <= 0){
    throw new Error("createDynamicTrail error: particleSize is expected to be greater than zero.");
    return;
  }
  if (typeof startDelay == UNDEFINED){
    throw new Error("createDynamicTrail error: startDelay is a mandatory configuration.");
    return;
  }
  if (isNaN(startDelay)){
    throw new Error("createDynamicTrail error: Bad startDelay parameter.");
    return;
  }
  if (startDelay <= 0){
    throw new Error("createDynamicTrail error: startDelay is expected to be greater than zero.");
    return;
  }
  if (typeof lifetime == UNDEFINED){
    throw new Error("createDynamicTrail error: lifetime is a mandatory configuration.");
    return;
  }
  if (isNaN(lifetime)){
    throw new Error("createDynamicTrail error: Bad lifetime parameter.");
    return;
  }
  if (lifetime < 0){
    lifetime = 0;
  }
  if (typeof velocity == UNDEFINED){
    throw new Error("createDynamicTrail error: velocity is a mandatory configuration.");
    return;
  }
  if (isNaN(velocity.x) || isNaN(velocity.y) || isNaN(velocity.z)){
    throw new Error("createDynamicTrail error: Bad velocity parameter.");
    return;
  }
  if (typeof acceleration == UNDEFINED){
    throw new Error("createDynamicTrail error: acceleration is a mandatory configuration.");
    return;
  }
  if (isNaN(acceleration.x) || isNaN(acceleration.y) || isNaN(acceleration.z)){
    throw new Error("createDynamicTrail error: Bad acceleration parameter.");
    return;
  }
  if (typeof randomness == UNDEFINED){
    throw new Error("createDynamicTrail error: randomness is a mandatory configuration.");
    return;
  }
  if (isNaN(randomness)){
    throw new Error("createDynamicTrail error: Bad randomness parameter.");
    return;
  }
  if (typeof alphaVariation == UNDEFINED){
    throw new Error("createDynamicTrail error: alphaVariation is a mandatory configuration.");
    return;
  }
  if (isNaN(alphaVariation)){
    throw new Error("createDynamicTrail error: Bad alphaVariation parameter.");
    return;
  }
  if (alphaVariation < -1 || alphaVariation > 0){
    throw new Error("createDynamicTrail error: alphaVariation is expected to be between [-1,0]");
    return;
  }
  if (typeof colorName == UNDEFINED){
    throw new Error("createDynamicTrail error: colorName is a mandatory configuration.");
    return;
  }
  if (!(typeof targetColorName == UNDEFINED)){
    if (typeof colorStep == UNDEFINED){
      throw new Error("createDynamicTrail error: colorStep is mandatory if targetColorName is specified.");
      return;
    }
    if (isNaN(colorStep)){
      throw new Error("createDynamicTrail error: Bad colorStep parameter.");
      return;
    }
    if (colorStep < 0 || colorStep > 1){
      throw new Error("createDynamicTrail error: colorStep is expected to be betwen [0,1].");
      return;
    }
  }
  if (!(typeof textureName == UNDEFINED)){
    var texture = textures[textureName];
    if (typeof texture == UNDEFINED){
      throw new Error("createDynamicTrail error: No such texture.");
      return;
    }
    if (!(texture instanceof THREE.Texture)){
      throw new Error("createDynamicTrail error: Texture not ready.");
      return;
    }
  }
  if (!(typeof rgbFilter == UNDEFINED)){
    if (isNaN(rgbFilter.x) || isNaN(rgbFilter.y) || isNaN(rgbFilter.z)){
      throw new Error("createDynamicTrail error: Bad rgbFilter parameter.");
      return;
    }
  }
  if (!(typeof updateFunction == UNDEFINED)){
    if (!(updateFunction instanceof Function)){
      throw new Error("createDynamicTrail error: updateFunction is not a function.");
      return;
    }
  }

  var particleMaterialConfigurations = new Object();
  particleMaterialConfigurations.color = colorName;
  particleMaterialConfigurations.size = particleSize;
  particleMaterialConfigurations.alpha = 1;
  particleMaterialConfigurations.textureName = textureName;
  particleMaterialConfigurations.rgbFilter = rgbFilter;
  particleMaterialConfigurations.targetColor = targetColorName;
  particleMaterialConfigurations.colorStep = colorStep;
  var particleMaterial = this.createParticleMaterial(particleMaterialConfigurations);

  var particles = [];
  var particleConfigurations = new Object();
  particleConfigurations.material = particleMaterial;
  particleConfigurations.lifetime = lifetime;
  particleConfigurations.respawn = true;
  particleConfigurations.useWorldPosition = true;
  for (var i = 0; i < particleCount; i++){
    particleConfigurations.position = this.sphericalDistribution(size);
    particleConfigurations.startDelay = startDelay * Math.random();
    particleConfigurations.velocity = this.vector(
      randomness * (Math.random() - 0.5),
      randomness * (Math.random() - 0.5),
      randomness * (Math.random() - 0.5)
    );
    particleConfigurations.acceleration = this.vector(
      randomness * (Math.random() - 0.5),
      randomness * (Math.random() - 0.5),
      randomness * (Math.random() - 0.5)
    );
    particleConfigurations.alphaVariation = alphaVariation;
    particles.push(this.createParticle(particleConfigurations));
  }
  var particleSystemConfigurations = new Object();
  particleSystemConfigurations.name = name;
  particleSystemConfigurations.particles = particles;
  particleSystemConfigurations.position = position;
  particleSystemConfigurations.lifetime = expireTime;
  particleSystemConfigurations.velocity = velocity;
  particleSystemConfigurations.acceleration = acceleration;
  particleSystemConfigurations.updateFunction = updateFunction;
  return this.createParticleSystem(particleSystemConfigurations);
}

// createObjectTrail
// Creates an object trail effect based on following configurations:
// object: The object or object group to which the trail effect is added. (mandatory)
// alpha: The alpha value of trails between [0,1]. (mandatory)
// maxTimeInSeconds: Maximum trail time in seconds. The default value is 0.25 (optional)
Roygbiv.prototype.createObjectTrail = function(configurations){
  if (mode == 0){
    return;
  }
  var object = configurations.object;
  var alpha = configurations.alpha;

  if (typeof object == UNDEFINED){
    throw new Error("createObjectTrail error: object is a mandatory configuration.");
    return;
  }
  if (!object){
    throw new Error("createObjectTrail error: No such object.");
    return;
  }
  if (!(object.isAddedObject) && !(object.isObjectGroup)){
    throw new Error("createObjectTrail error: Bad object parameter.");
    return;
  }
  if ((object.isAddedObject) && (!addedObjects[object.name])){
    throw new Error("createObjectTrail error: Cannot create object trails for child objects. Use parent object instead.");
    return;
  }
  if (typeof alpha == UNDEFINED){
    throw new Error("createObjectTrail error: alpha is a mandatory configuration.");
    return;
  }
  if (isNaN(alpha)){
    throw new Error("createObjectTrail error: Bad alpha parameter.");
    return;
  }
  if (alpha < 0 || alpha > 1){
    throw new Error("createObjectTrail error: alpha is expected to be between [0,1].");
  }
  if (objectTrails[object.name]){
    throw new Error("createObjectTrail error: A trail is already added to object.");
    return;
  }
  if (!(typeof configurations.maxTimeInSeconds == UNDEFINED)){
    if (isNaN(configurations.maxTimeInSeconds)){
      throw new Error("createObjectTrail error: maxTimeInSeconds is not a number.");
      return;
    }
    if (configurations.maxTimeInSeconds <= 0){
      throw new Error("createObjectTrail error: maxTimeInSeconds must be greater than zero.");
      return;
    }
    if (configurations.maxTimeInSeconds > 1){
      throw new Error("createObjectTrail error: maxTimeInSeconds must not be greater than zero.");
      return;
    }
    if (configurations.maxTimeInSeconds < (1/60)){
      throw new Error("createObjectTrail error: maxTimeInSeconds must not be less than 0.01666666666 (1/60).");
      return;
    }
  }
  new ObjectTrail(configurations);
  return;
}

// destroyObjectTrail
// Destroys the trail effect of an object created using the createObjectTrail function.
Roygbiv.prototype.destroyObjectTrail = function(object){
  if (mode == 0){
    return;
  }
  if (typeof object == UNDEFINED){
    throw new Error("destroyObjectTrail error: object is not defined.");
    return;
  }
  if (!(object.isAddedObject) && !(object.isObjectGroup)){
    throw new Error("destroyObjectTrail error: Type not supported.");
    return;
  }
  var objectTrail = objectTrails[object.name];
  if (!objectTrail){
    throw new Error("destroyObjectTrail error: No trail effect is added to object.");
    return;
  }
  objectTrail.destroy();
  delete objectTrails[object.name];
  delete activeObjectTrails[object.name];
  return;
}

// generateParticleSystemName
// Generates a unique name for a particle system.
Roygbiv.prototype.generateParticleSystemName = function(){
  if (mode == 0){
    return;
  }
  var generatedName = (Date.now().toString(36) + Math.random().toString(36).substr(2, 5)).toUpperCase();
  var nameFound = true;
  while (nameFound){
    nameFound = !(typeof particleSystemPool[generatedName] == UNDEFINED);
    if (nameFound){
      generatedName = (Date.now().toString(36) + Math.random().toString(36).substr(2, 5)).toUpperCase();
    }
  }
  return generatedName;
}

// rewindParticle
// Rewinds a particle and restarts its motion. Particles using this functionality
// must have respawn = true and lifetime != 0 as configuration. The additional
// delay parameter may be used to delay the rewind process in seconds.
Roygbiv.prototype.rewindParticle = function(particle, delay){
  if (mode == 0){
    return;
  }
  if (!particle){
    throw new Error("rewindParticle error: particle is not defined.");
    return;
  }
  if (!(particle.isParticle)){
    throw new Error("rewindParticle error: Bad particle parameter.");
    return;
  }
  if (!particle.respawnSet){
    throw new Error("rewindParticle error: Particles using this functionality must have respawn = true as configuration.");
    return;
  }
  if (particle.lifetime == 0){
    throw new Error("rewindParticle error: Particles using this functionality must have lifetime != 0 as configuration.");
    return;
  }
  if (!(typeof delay == UNDEFINED)){
    if (isNaN(delay)){
      throw new Error("rewindParticle error: delay must be a number.");
    }
  }else{
    delay = 0;
  }
  if (!particle.parent){
    return;
  }
  particle.parent.rewindParticle(particle, delay);
}

// createLaser
// Creates a laser like particle system. Configurations are:
// name: The unique name of the particle system. (mandatory)
// position: The initial position of the particle system. (mandatory)
// particleCount: The count of laser particles. (mandatory)
// particleSize: The size of laser particles. (mandatory)
// direction: The direction vector of the laser. (mandatory)
// timeDiff: The difference between startDelay attribute of each laser particles in seconds. Expected value is greater than zero. (mandatory)
// expireTime: The maximum lifetime of the laser. Set this 0 for infinite laser. (mandatory)
// velocity: The velocity vector of the laser. (mandatory)
// acceleration: The acceleration vector of the laser. (mandatory)
// alpha: The opacity of laser particles. Expected value is between [0, 1]. (mandatory)
// colorName: The color name of laser particles. (mandatory)
// targetColorName: The target color name of trail particles. (optional)
// colorStep: A float between [0,1] that represents the variaton of color betwen the initial color and the target color. (optional)
// textureName: The name of texture of laser particles. (optional)
// rgbFilter: This can be used to eliminate texture background colors. (optional)
// updateFunction: The update function of the particle system that is executed on each frame render. (optional)
Roygbiv.prototype.createLaser = function(configurations){
  if (mode == 0){
    return;
  }
  var name = configurations.name;
  var position = configurations.position;
  var particleCount = configurations.particleCount;
  var particleSize = configurations.particleSize;
  var direction = configurations.direction;
  var timeDiff = configurations.timeDiff;
  var expireTime = configurations.expireTime;
  var velocity = configurations.velocity;
  var acceleration = configurations.acceleration;
  var alpha = configurations.alpha;
  var colorName = configurations.colorName;
  var targetColorName = configurations.targetColorName;
  var colorStep = configurations.colorStep;
  var textureName = configurations.textureName;
  var rgbFilter = configurations.rgbFilter;
  var updateFunction = configurations.updateFunction;
  if (typeof name == UNDEFINED){
    throw new Error("createLaser error: name is a mandatory configuration.");
    return;
  }
  if (particleSystemPool[name]){
    throw new Error("createLaser error: name must be unique.");
    return;
  }
  if (typeof position == UNDEFINED){
    throw new Error("createLaser error: position is a mandatory configuration.");
    return;
  }
  if (isNaN(position.x) || isNaN(position.y) || isNaN(position.z)){
    throw new Error("createLaser error: Bad position parameter.");
    return;
  }
  if (typeof particleCount == UNDEFINED){
    throw new Error("createLaser error: particleCount is a mandatory configuration.");
    return;
  }
  if (isNaN(particleCount)){
    throw new Error("createLaser error: particleCount must be a number.");
    return;
  }else if (particleCount <= 0){
    throw new Error("createLaser error: particleCount must be greater than zero.");
    return;
  }
  if (typeof particleSize == UNDEFINED){
    throw new Error("createLaser error: particleSize is a mandatory configuration.");
    return;
  }
  if (isNaN(particleSize)){
    throw new Error("createLaser error: particleSize must be a number.");
    return;
  }else if (particleSize <= 0){
    throw new Error("createLaser error: particleSize must be greater than zero.");
    return;
  }
  if (typeof direction == UNDEFINED){
    throw new Error("createLaser error: direction is a mandatory configuration.");
    return;
  }
  if (isNaN(direction.x) || isNaN(direction.y) || isNaN(direction.z)){
    throw new Error("createLaser error: Bad direction parameter.");
    return;
  }
  if (typeof timeDiff == UNDEFINED){
    throw new Error("createLaser error: timeDiff is a mandatory configuration.");
    return;
  }
  if (isNaN(timeDiff)){
    throw new Error("createLaser error: timeDiff must be a number.");
    return;
  }
  if (typeof expireTime == UNDEFINED){
    throw new Error("createLaser error: expireTime is a mandatory configuration.");
    return;
  }
  if (isNaN(expireTime)){
    throw new Error("createLaser error: expireTime must be a number.");
    return;
  }else if (expireTime < 0){
    throw new Error("createLaser error: expireTime cannot be a negative number.");
    return;
  }
  if (typeof velocity == UNDEFINED){
    throw new Error("createLaser error: velocity is a mandatory configuration.");
    return;
  }
  if (isNaN(velocity.x) || isNaN(velocity.y) || isNaN(velocity.z)){
    throw new Error("createLaser error: Bad velocity parameter.");
    return;
  }
  if (typeof acceleration == UNDEFINED){
    throw new Error("createLaser error: acceleration is a mandatory configuration.");
    return;
  }
  if (isNaN(acceleration.x) || isNaN(acceleration.y) || isNaN(acceleration.z)){
    throw new Error("createLaser error: Bad acceleration parameter.");
    return;
  }
  if (typeof alpha == UNDEFINED){
    throw new Error("createLaser error: alpha is a mandatory configuration.");
    return;
  }
  if (isNaN(alpha)){
    throw new Error("createLaser error: alpha must be a number.");
    return;
  }
  if (alpha > 1 || alpha < 0){
    throw new Error("createLaser error: alpha must be between [0, 1].");
    return;
  }
  if (typeof colorName == UNDEFINED){
    throw new Error("createLaser error: colorName is a mandatory configuration.");
    return;
  }

  var particleMaterialConfigurations = new Object();
  particleMaterialConfigurations.color = colorName;
  particleMaterialConfigurations.size = particleSize;
  particleMaterialConfigurations.alpha = alpha;
  particleMaterialConfigurations.textureName = textureName;
  particleMaterialConfigurations.rgbFilter = rgbFilter;
  particleMaterialConfigurations.targetColor = targetColorName;
  particleMaterialConfigurations.colorStep = colorStep;
  var particleMaterial = this.createParticleMaterial(particleMaterialConfigurations);

  var particles = [];
  var particleConfigurations = new Object();
  particleConfigurations.material = particleMaterial;
  particleConfigurations.lifetime = 0;
  particleConfigurations.respawn = false;
  var c2 = 0;
  for (var i = 0; i < particleCount; i++){
    var dx = (direction.x * c2);
    var dy = (direction.y * c2);
    var dz = (direction.z * c2);
    particleConfigurations.startDelay = c2;
    particleConfigurations.position = this.vector(dx, dy, dz);
    c2 += timeDiff;
    particles.push(this.createParticle(particleConfigurations));
  }

  var particleSystemConfigurations = new Object();
  particleSystemConfigurations.name = name;
  particleSystemConfigurations.particles = particles;
  particleSystemConfigurations.position = position;
  particleSystemConfigurations.lifetime = expireTime;
  particleSystemConfigurations.velocity = velocity;
  particleSystemConfigurations.acceleration = acceleration;
  particleSystemConfigurations.updateFunction = updateFunction;
  return this.createParticleSystem(particleSystemConfigurations);
}

// createWaterfall
// Creates a waterfall like particle system. This function initially puts the particles
// on an imaginary line on the X axis. Size and normal of this line are configurable. Configurations are:
// name: The unique name of the particle system. (mandatory)
// position: The initial position of the particle system. (mandatory)
// particleCount: The count of waterfall particles. (mandatory)
// size: The size of the waterfall. (mandatory)
// particleSize: The size of waterfall particles. (mandatory)
// particleExpireTime: The maximum expiration time in seconds of particles. (mandatory)
// speed: A number representing the speed of waterfall particles. (mandatory)
// acceleration: A number representing the acceleration of waterfall particles. (mandatory)
// avgStartDelay: The average start delay of waterfall particles. Expected value is greater than zero.(mandatory)
// colorName: The name of color of particles. (mandatory)
// alpha: The alpha value between [0, 1] of each particle. (mandatory)
// textureName: The name of texture of particles. (optional)
// rewindOnCollided: If true, the particles that are collided are rewinded. This parameter can be a performance issue if web workers are not supported. (optional)
// normal: The normal vector of the waterfall. Default value is (0, 0, 1). (optional)
// randomness: The randomness of waterfall particles. (optional)
// alphaVariation: The alpha variaton of particles. The expected value is between [-1, 0] (optional)
// targetColorName: The target color name of trail particles. (optional)
// colorStep: A float between [0,1] that represents the variaton of color betwen the initial color and the target color. (optional)
// rgbFilter: This can be used to eliminate the background colors of textures. (optional)
// updateFunction: The update function of the particle system that is executed on each frame render. (optional)
// collisionTimeOffset: This can be used to pre-calculate collisions of particles to prevent visuals errors caused by fast particles. (optional)
Roygbiv.prototype.createWaterfall = function(configurations){
  if (mode == 0){
    return;
  }
  var name = configurations.name;
  var position = configurations.position;
  var particleCount = configurations.particleCount;
  var size = configurations.size;
  var particleSize = configurations.particleSize;
  var particleExpireTime = configurations.particleExpireTime;
  var speed = configurations.speed;
  var acceleration = configurations.acceleration;
  var avgStartDelay = configurations.avgStartDelay;
  var colorName = configurations.colorName;
  var alpha = configurations.alpha;
  var textureName = configurations.textureName;
  var rewindOnCollided = configurations.rewindOnCollided;
  var normal = configurations.normal;
  var randomness = configurations.randomness;
  var alphaVariation = configurations.alphaVariation;
  var targetColorName = configurations.targetColorName;
  var colorStep = configurations.colorStep;
  var rgbFilter = configurations.rgbFilter;
  var updateFunction = configurations.updateFunction;
  var collisionTimeOffset = configurations.collisionTimeOffset;

  if (typeof name == UNDEFINED){
    throw new Error("createWaterfall error: name is a mandatory configuration.");
    return;
  }
  if (particleSystemPool[name]){
    throw new Error("createWaterfall error: name must be unique.");
    return;
  }
  if (typeof position == UNDEFINED){
    throw new Error("createWaterfall error: position is a mandatory configuration.");
    return;
  }
  if (isNaN(position.x) || isNaN(position.y) || isNaN(position.z)){
    throw new Error("createWaterfall error: Bad position parameter.");
    return;
  }
  if (typeof particleCount == UNDEFINED){
    throw new Error("createWaterfall error: particleCount is a mandatory configuration.");
    return;
  }
  if (isNaN(particleCount)){
    throw new Error("createWaterfall error: particleCount must be a number.");
    return;
  }
  if (particleCount <= 0){
    throw new Error("createWaterfall error: particleCount must be greater than zero.");
    return;
  }
  if (typeof size == UNDEFINED){
    throw new Error("createWaterfall error: size is a mandatory configuration.");
    return;
  }
  if (isNaN(size)){
    throw new Error("createWaterfall error: Bad size parameter.");
    return;
  }
  if (size <= 0){
    throw new Error("createWaterfall error: size must be greater than zero.");
    return;
  }
  if (typeof particleSize == UNDEFINED){
    throw new Error("createWaterfall error: particleSize is a mandatory configuration.");
    return;
  }
  if (isNaN(particleSize)){
    throw new Error("createWaterfall error: Bad particleSize parameter.");
    return;
  }
  if (particleSize <= 0){
    throw new Error("createWaterfall error: particleSize must be greater than zero.");
    return;
  }
  if (typeof particleExpireTime == UNDEFINED){
    throw new Error("createWaterfall error: particleExpireTime is a mandatory configuration.");
    return;
  }
  if (isNaN(particleExpireTime)){
    throw new Error("createWaterfall error: particleExpireTime must be a number.");
    return;
  }
  if (particleExpireTime <= 0){
    throw new Error("createWaterfall error: particleExpireTime must be greater than zero.");
    return;
  }
  if (typeof speed == UNDEFINED){
    throw new Error("createWaterfall error: speed is a mandatory configuration.");
    return;
  }
  if (isNaN(speed)){
    throw new Error("createWaterfall error: speed must be a number.");
    return;
  }
  if (speed <= 0){
    throw new Error("createWaterfall error: speed must be greater than zero.");
    return;
  }
  if (typeof acceleration == UNDEFINED){
    throw new Error("createWaterfall error: acceleration is a mandatory configuration.");
    return;
  }
  if (isNaN(acceleration)){
    throw new Error("createWaterfall error: acceleration must be a number.");
    return;
  }
  if (acceleration <= 0){
    throw new Error("createWaterfall error: acceleration must be greater than zero.");
    return;
  }
  if (typeof avgStartDelay == UNDEFINED){
    throw new Error("createWaterfall error: avgStartDelay is a mandatory configuration.");
    return;
  }
  if (isNaN(avgStartDelay)){
    throw new Error("createWaterfall error: avgStartDelay must be a number.");
    return;
  }
  if (avgStartDelay <= 0){
    throw new Error("createWaterfall error: avgStartDelay must be greater than zero.");
    return;
  }
  if (typeof colorName == UNDEFINED){
    throw new Error("createWaterfall error: colorName is a mandatory configuration.");
    return;
  }
  if (typeof alpha == UNDEFINED){
    throw new Error("createWaterfall error: alpha is a mandatory configuration.");
    return;
  }
  if (isNaN(alpha)){
    throw new Error("createWaterfall error: alpha must be a number.");
    return;
  }
  if (alpha < 0 || alpha > 1){
    throw new Error("createWaterfall error: alpha must be between [0, 1].");
    return;
  }
  if (!(typeof rewindOnCollided == UNDEFINED)){
    if (!(typeof rewindOnCollided == typeof(true))){
      throw new Error("createWaterfall error: rewindOnCollided must be a boolean.");
    }
  }else{
    rewindOnCollided = true;
  }
  if (!(typeof normal == UNDEFINED)){
    if (isNaN(normal.x) || isNaN(normal.y) || isNaN(normal.z)){
      throw new Error("createWaterfall error: Bad normal parameter.");
      return;
    }
  }else{
    normal = this.vector(0, 0, 1);
  }
  if (!(typeof randomness == UNDEFINED)){
    if (isNaN(randomness)){
      throw new Error("createWaterfall error: randomness must be a number.");
      return;
    }
  }else{
    randomness = 0;
  }
  if (!(typeof collisionTimeOffset == UNDEFINED)){
    if (isNaN(collisionTimeOffset)){
      throw new Error("createWaterfall error: collisionTimeOffset must be a number.");
      return;
    }
  }else{
    collisionTimeOffset = 0;
  }

  var particleMaterialConfigurations = new Object();
  particleMaterialConfigurations.color = colorName;
  particleMaterialConfigurations.size = particleSize;
  particleMaterialConfigurations.alpha = alpha;
  particleMaterialConfigurations.textureName = textureName;
  particleMaterialConfigurations.rgbFilter = rgbFilter;
  particleMaterialConfigurations.targetColor = targetColorName;
  particleMaterialConfigurations.colorStep = colorStep;
  var particleMaterial = this.createParticleMaterial(particleMaterialConfigurations);

  var particleConfigurations = new Object();
  particleConfigurations.material = particleMaterial;
  particleConfigurations.lifetime = particleExpireTime;
  particleConfigurations.respawn = true;
  particleConfigurations.alphaVariation = alphaVariation;
  particleConfigurations.velocity = this.vector(0, -1 * speed, 0);
  var particles = [];
  for (var i = 0; i < particleCount; i++){
    particleConfigurations.position = this.boxDistribution(size, 0, 0, 3);
    particleConfigurations.startDelay = avgStartDelay * Math.random();
    particleConfigurations.acceleration = this.vector(0, -1 * acceleration, 0);
    if (randomness != 0){
      particleConfigurations.acceleration.z += randomness * (Math.random() - 0.5);
      particleConfigurations.acceleration.x += randomness * (Math.random() - 0.5);
    }
    var particle = this.createParticle(particleConfigurations);
    if (rewindOnCollided){
      var roygbivContext = this;
      this.setCollisionListener(particle, function(info){
        roygbivContext.rewindParticle(this, Math.random());
      }, collisionTimeOffset);
    }
    particles.push(particle);
  }
  var particleSystemConfigurations = new Object();
  particleSystemConfigurations.name = name;
  particleSystemConfigurations.particles = particles;
  particleSystemConfigurations.position = position;
  particleSystemConfigurations.lifetime = 0;
  var waterfall = this.createParticleSystem(particleSystemConfigurations);
  var quat = this.computeQuaternionFromVectors(this.vector(0, 0, 1), normal);
  waterfall.mesh.quaternion.set(quat.x, quat.y, quat.z, quat.w);
  return waterfall;
}

// createSnow
// Creates a snow or rain like particle system. Particles are initially created
// on an imaginary rectangle on XZ plane. The normal vector and width/height values
// of this rectangle are configurable. Configurations are:
// name: The unique name of the particle system. (mandatory)
// position: The initial position of the particle system. (mandatory)
// particleCount: The count of snow particles. (mandatory)
// sizeX: The width of the particle system. (mandatory)
// sizeZ: The depth of the particle system. (mandatory)
// particleSize: The size of snow particles. (mandatory)
// particleExpireTime: The maximum expiration time in seconds of particles. (mandatory)
// speed: A number representing the speed of snow particles. (mandatory)
// acceleration: A number representing the acceleration of snow particles. (mandatory)
// avgStartDelay: The average start delay of snow particles. Expected value is greater than zero.(mandatory)
// colorName: The name of color of particles. (mandatory)
// alpha: The alpha value between [0, 1] of each particle. (mandatory)
// textureName: The name of texture of particles. (optional)
// rewindOnCollided: If true, the particles that are collided are rewinded. This parameter can be a performance issue if web workers are not supported. (optional)
// normal: The normal vector of the snow. Default value is (0, -1, 0). (optional)
// randomness: The randomness of snow particles. (optional)
// alphaVariation: The alpha variaton of particles. The expected value is between [-1, 0] (optional)
// targetColorName: The target color name of trail particles. (optional)
// colorStep: A float between [0,1] that represents the variaton of color betwen the initial color and the target color. (optional)
// rgbFilter: This can be used to eliminate the background colors of textures. (optional)
// updateFunction: The update function of the particle system that is executed on each frame render. (optional)
// collisionTimeOffset: This can be used to pre-calculate collisions of particles to prevent visuals errors caused by fast particles. (optional)
Roygbiv.prototype.createSnow = function(configurations){
  if (mode == 0){
    return;
  }
  var name = configurations.name;
  var position = configurations.position;
  var particleCount = configurations.particleCount;
  var sizeX = configurations.sizeX;
  var sizeZ = configurations.sizeZ;
  var particleSize = configurations.particleSize;
  var particleExpireTime = configurations.particleExpireTime;
  var speed = configurations.speed;
  var acceleration = configurations.acceleration;
  var avgStartDelay = configurations.avgStartDelay;
  var colorName = configurations.colorName;
  var alpha = configurations.alpha;
  var textureName = configurations.textureName;
  var rewindOnCollided = configurations.rewindOnCollided;
  var normal = configurations.normal;
  var randomness = configurations.randomness;
  var alphaVariation = configurations.alphaVariation;
  var targetColorName = configurations.targetColorName;
  var colorStep = configurations.colorStep;
  var rgbFilter = configurations.rgbFilter;
  var updateFunction = configurations.updateFunction;
  var collisionTimeOffset = configurations.collisionTimeOffset;

  if (typeof name == UNDEFINED){
    throw new Error("createSnow error: name is a mandatory configuration.");
    return;
  }
  if (particleSystemPool[name]){
    throw new Error("createSnow error: name must be unique.");
    return;
  }
  if (typeof position == UNDEFINED){
    throw new Error("createSnow error: position is a mandatory configuration.");
    return;
  }
  if (isNaN(position.x) || isNaN(position.y) || isNaN(position.z)){
    throw new Error("createSnow error: Bad position parameter.");
    return;
  }
  if (typeof particleCount == UNDEFINED){
    throw new Error("createSnow error: particleCount is a mandatory configuration.");
    return;
  }
  if (isNaN(particleCount)){
    throw new Error("createSnow error: particleCount must be a number.");
    return;
  }
  if (particleCount <= 0){
    throw new Error("createSnow error: particleCount must be greater than zero.");
    return;
  }
  if (typeof sizeX == UNDEFINED){
    throw new Error("createSnow error: sizeX is a mandatory configuration.");
    return;
  }
  if (isNaN(sizeX)){
    throw new Error("createSnow error: sizeX must be a number.");
    return;
  }
  if (sizeX <= 0){
    throw new Error("createSnow error: sizeX must be greater than zero.");
    return;
  }
  if (typeof sizeZ == UNDEFINED){
    throw new Error("createSnow error: sizeZ is a mandatory configuration.");
    return;
  }
  if (isNaN(sizeZ)){
    throw new Error("createSnow error: sizeZ must be a number.");
    return;
  }
  if (sizeZ <= 0){
    throw new Error("createSnow error: sizeZ must be greater than zero.");
    return;
  }
  if (typeof particleSize == UNDEFINED){
    throw new Error("createSnow error: particleSize is a mandatory configuration.");
    return;
  }
  if (isNaN(particleSize)){
    throw new Error("createSnow error: particleSize must be a number.");
    return;
  }
  if (particleSize <= 0){
    throw new Error("createSnow error: particleSize must be greater than zero.");
    return;
  }
  if (typeof particleExpireTime == UNDEFINED){
    throw new Error("createSnow error: particleExpireTime is a mandatory configuration.");
    return;
  }
  if (isNaN(particleExpireTime)){
    throw new Error("createSnow error: particleExpireTime is a mandatory configuration.");
    return;
  }
  if (particleExpireTime <= 0){
    throw new Error("createSnow error: particleExpireTime must be greater than zero.");
    return;
  }
  if (typeof speed == UNDEFINED){
    throw new Error("createSnow error: speed is a mandatory configuration.");
    return;
  }
  if (isNaN(speed)){
    throw new Error("createSnow error: speed must be a number.");
    return;
  }
  if (speed <= 0){
    throw new Error("createSnow error: speed must be greater than zero.");
    return;
  }
  if (typeof acceleration == UNDEFINED){
    throw new Error("createSnow error: acceleration is a mandatory configuration.");
    return;
  }
  if (isNaN(acceleration)){
    throw new Error("createSnow error: acceleration must be a number.");
    return;
  }
  if (acceleration < 0){
    throw new Error("createSnow error: acceleration cannot be a negative number.");
    return;
  }
  if (typeof avgStartDelay == UNDEFINED){
    throw new Error("createSnow error: avgStartDelay is a mandatory configuration.");
    return;
  }
  if (isNaN(avgStartDelay)){
    throw new Error("createSnow error: avgStartDelay must be a number.");
    return;
  }
  if (avgStartDelay <= 0){
    throw new Error("createSnow error: avgStartDelay must be greater than zero.");
    return;
  }
  if (typeof colorName == UNDEFINED){
    throw new Error("createSnow error: colorName is a mandatory configuration.");
    return;
  }
  if (typeof alpha == UNDEFINED){
    throw new Error("createSnow error: alpha is a mandatory configuration.");
    return;
  }
  if (isNaN(alpha)){
    throw new Error("createSnow error: alpha must be a number.");
    return;
  }
  if (alpha < 0 || alpha > 1){
    throw new Error("createSnow error: alpha must be between [0, 1].");
    return;
  }
  if (!(typeof rewindOnCollided == UNDEFINED)){
    if (!(typeof rewindOnCollided == typeof(true))){
      throw new Error("createSnow error: rewindOnCollided must be a boolean.");
      return;
    }
  }else{
    rewindOnCollided = true;
  }
  if (!(typeof normal == UNDEFINED)){
    if (isNaN(normal.x) || isNaN(normal.y) || isNaN(normal.z)){
      throw new Error("createSnow error: Bad normal parameter.");
      return;
    }
  }else{
    normal = this.vector(0, -1, 0);
  }
  if (!(typeof randomness == UNDEFINED)){
    if (isNaN(randomness)){
      throw new Error("createSnow error: randomness must be a number.");
      return;
    }
  }else{
    randomness = 0;
  }
  if (!(typeof collisionTimeOffset == UNDEFINED)){
    if (isNaN(collisionTimeOffset)){
      throw new Error("createSnow error: collisionTimeOffset must be a number.");
      return;
    }
  }else{
    collisionTimeOffset = 0;
  }

  var particleMaterialConfigurations = new Object();
  particleMaterialConfigurations.color = colorName;
  particleMaterialConfigurations.size = particleSize;
  particleMaterialConfigurations.alpha = alpha;
  particleMaterialConfigurations.textureName = textureName;
  particleMaterialConfigurations.rgbFilter = rgbFilter;
  particleMaterialConfigurations.targetColor = targetColorName;
  particleMaterialConfigurations.colorStep = colorStep;
  var particleMaterial = this.createParticleMaterial(particleMaterialConfigurations);

  var particleConfigurations = new Object();
  var particles = [];
  particleConfigurations.material = particleMaterial;
  particleConfigurations.lifetime = particleExpireTime;
  particleConfigurations.respawn = true;
  particleConfigurations.alphaVariation = alphaVariation;
  particleConfigurations.velocity = this.vector(0, -1 * speed, 0);
  for (var i = 0; i < particleCount; i++){
    particleConfigurations.acceleration = this.vector(0, -1 * acceleration, 0);
    particleConfigurations.position = this.boxDistribution(sizeX, 0 ,sizeZ, 2);
    particleConfigurations.startDelay = avgStartDelay * Math.random();
    if (randomness != 0){
      particleConfigurations.acceleration.x = randomness * (Math.random() - 0.5);
      particleConfigurations.acceleration.z = randomness * (Math.random() - 0.5);
    }
    var particle = this.createParticle(particleConfigurations);
    if (rewindOnCollided){
      var roygbivContext = this;
      this.setCollisionListener(particle, function(){
        roygbivContext.rewindParticle(this, Math.random());
      }, collisionTimeOffset);
    }
    particles.push(particle);
  }
  var particleSystemConfigurations = new Object();
  particleSystemConfigurations.name = name;
  particleSystemConfigurations.particles = particles;
  particleSystemConfigurations.position = position;
  particleSystemConfigurations.lifetime = 0;
  particleSystemConfigurations.updateFunction = updateFunction;
  var snow = this.createParticleSystem(particleSystemConfigurations);
  var quat = this.computeQuaternionFromVectors(this.vector(0, -1, 0), normal);
  snow.mesh.quaternion.set(quat.x, quat.y, quat.z, quat.w);
  return snow;
}

// stopParticleSystem
// Stops the motion of a particle system. This can be useful for smooth after collision
// effects of particle systems as it lets particles to dissapear smoothly. The particle
// system is killed after stopDuration seconds. If particle systems have collision listener
// attached, the collision listener needs to be reset when starting the particle system
// after stopping.
Roygbiv.prototype.stopParticleSystem = function(particleSystem, stopDuration){
  if (mode == 0){
    return;
  }
  if (typeof particleSystem == UNDEFINED){
    throw new Error("stopParticleSystem error: particleSystem is not defined.");
    return;
  }
  if (!(particleSystem.isParticleSystem)){
    throw new Error("stopParticleSystem error: Type not supported.");
    return;
  }
  if (typeof stopDuration == UNDEFINED){
    throw new Error("stopParticleSystem error: stopDuration is not defined.");
    return;
  }
  if (isNaN(stopDuration)){
    throw new Error("stopParticleSystem error: stopDuration is not defined.");
    return;
  }
  if (stopDuration < 0){
    throw new Error("stopParticleSystem error: stopDuration must be a positive number.");
    return;
  }
  particleSystem.stop(stopDuration);
}

// startParticleSystem
// Starts a particle system after its creation. Configurations are:
// particleSystem: The particle system to start. (mandatory)
// startPosition: The initial position vector of the particle system. (optional)
// startVelocity: The initial velocity vector of the particle system. (optional)
// startAcceleration: The initial acceleration vector of the particle system. (optional)
// startQuaternion: The initial quaternion of the particle system. Use ROYGBIV.computeQuaternionFromVectors (optional)
Roygbiv.prototype.startParticleSystem = function(configurations){
  if (mode == 0){
    return;
  }
  var particleSystem = configurations.particleSystem;
  var startPosition = configurations.startPosition;
  var startVelocity = configurations.startVelocity;
  var startAcceleration = configurations.startAcceleration;
  var startQuaternion = configurations.startQuaternion;

  if (!particleSystem){
    throw new Error("startParticleSystem error: particleSystem is a mandatory configuration.");
    return;
  }
  if (!(particleSystem.isParticleSystem)){
    throw new Error("startParticleSystem error: Type not supported.");
    return;
  }
  var startPositionSet = false, startVelocitySet = false, startAccelerationSet = false, startQuaternionSet = false;
  if (!(typeof startPosition == UNDEFINED)){
    if (isNaN(startPosition.x) || isNaN(startPosition.y) || isNaN(startPosition.z)){
      throw new Error("startParticleSystem error: Bad startPosition parameter.");
      return;
    }
    startPositionSet = true;
  }
  if (!(typeof startVelocity == UNDEFINED)){
    if (isNaN(startVelocity.x) || isNaN(startVelocity.y) || isNaN(startVelocity.z)){
      throw new Error("startParticleSystem error: Bad startVelocity parameter.");
      return;
    }
    startVelocitySet = true;
  }
  if (!(typeof startAcceleration == UNDEFINED)){
    if (isNaN(startAcceleration.x) || isNaN(startAcceleration.y) || isNaN(startAcceleration.z)){
      throw new Error("startParticleSystem error: Bad startAcceleration parameter.");
      return;
    }
    startAccelerationSet = true;
  }
  if (!(typeof startQuaternion == UNDEFINED)){
    if (isNaN(startQuaternion.x) || isNaN(startQuaternion.y) || isNaN(startQuaternion.z) || isNaN(startQuaternion.w)){
      throw new Error("startParticleSystem error: Bad startQuaternion parameter.");
      return;
    }
    startQuaternionSet = true;
  }

  particleSystem.tick = 0;
  particleSystem.motionTimer = 0;
  if (startVelocitySet){
    particleSystem.vx = startVelocity.x;
    particleSystem.vy = startVelocity.y;
    particleSystem.vz = startVelocity.z;
    if (!particleSystem.velocity){
      particleSystem.velocity = this.vector(particleSystem.vx, particleSystem.vy, particleSystem.vz);
    }else{
      particleSystem.velocity.x = particleSystem.vx;
      particleSystem.velocity.y = particleSystem.vy;
      particleSystem.velocity.z = particleSystem.vz;
    }
    if (!particleSystem.psMerger){
      particleSystem.material.uniforms.parentMotionMatrix.value.elements[3] = startVelocity.x;
      particleSystem.material.uniforms.parentMotionMatrix.value.elements[4] = startVelocity.y;
      particleSystem.material.uniforms.parentMotionMatrix.value.elements[5] = startVelocity.z;
    }else{
      var matrix = particleSystem.psMerger.material.uniforms.parentMotionMatrixArray.value[particleSystem.mergedIndex];
      matrix.elements[3] = startVelocity.x;
      matrix.elements[4] = startVelocity.y;
      matrix.elements[5] = startVelocity.z;
    }
  }
  if (startAccelerationSet){
    particleSystem.ax = startAcceleration.x;
    particleSystem.ay = startAcceleration.y;
    particleSystem.az = startAcceleration.z;
    if (!particleSystem.acceleration){
      particleSystem.acceleration = this.vector(particleSystem.ax, particleSystem.ay, particleSystem.az);
    }else{
      particleSystem.acceleration.x = particleSystem.ax;
      particleSystem.acceleration.y = particleSystem.ay;
      particleSystem.acceleration.z = particleSystem.az;
    }
    if (!particleSystem.psMerger){
      particleSystem.material.uniforms.parentMotionMatrix.value.elements[6] = startAcceleration.x;
      particleSystem.material.uniforms.parentMotionMatrix.value.elements[7] = startAcceleration.y;
      particleSystem.material.uniforms.parentMotionMatrix.value.elements[8] = startAcceleration.z;
    }else{
      var matrix = particleSystem.psMerger.material.uniforms.parentMotionMatrixArray.value[particleSystem.mergedIndex];
      matrix.elements[6] = startAcceleration.x;
      matrix.elements[7] = startAcceleration.y;
      matrix.elements[8] = startAcceleration.z;
    }
  }
  if (startQuaternionSet){
    particleSystem.mesh.quaternion.set(startQuaternion.x, startQuaternion.y, startQuaternion.z, startQuaternion.w);
  }
  if (startPositionSet){
    particleSystem.x = startPosition.x;
    particleSystem.y = startPosition.y;
    particleSystem.z = startPosition.z;
    particleSystem.mesh.position.set(particleSystem.x, particleSystem.y, particleSystem.z);
    if (!particleSystem.psMerger){
      particleSystem.material.uniforms.parentMotionMatrix.value.elements[0] = startPosition.x;
      particleSystem.material.uniforms.parentMotionMatrix.value.elements[1] = startPosition.y;
      particleSystem.material.uniforms.parentMotionMatrix.value.elements[2] = startPosition.z;
    }else{
      var matrix = particleSystem.psMerger.material.uniforms.parentMotionMatrixArray.value[particleSystem.mergedIndex];
      matrix.elements[0] = startPosition.x;
      matrix.elements[1] = startPosition.y;
      matrix.elements[2] = startPosition.z;
    }
  }
  if (!particleSystem.psMerger){
    particleSystem.material.uniforms.stopInfo.value.set(-10, -10, -10);
  }else{
    particleSystem.psMerger.material.uniforms.hiddenArray.value[particleSystem.mergedIndex] = (-20.0);
    particleSystem.psMerger.material.uniforms.stopInfoArray.value[particleSystem.mergedIndex].set(-10, -10, -10);
  }
  particleSystem.stoppedX = undefined;
  particleSystem.stoppedY = undefined;
  particleSystem.stoppedZ = undefined;
  particleSystem.stopped = false;
  if (!(typeof particleSystem.originalCheckForCollisions == UNDEFINED)){
    particleSystem.checkForCollisions = particleSystem.originalCheckForCollisions;
    particleSystem.originalCheckForCollisions = undefined;
  }
  if (!(typeof particleSystem.originalLifetime == UNDEFINED)){
    particleSystem.lifetime = particleSystem.originalLifetime;
    particleSystem.originalLifetime = undefined;
  }
  particleSystem.mesh.visible = true;
  if (!particleSystem.psMerger){
    particleSystems[particleSystem.name] = particleSystem;
    particleSystem.material.uniforms.dissapearCoef.value = 0;
  }else{
    particleSystem.psMerger.notifyPSVisibilityChange(particleSystem, true);
    particleSystem.psMerger.material.uniforms.dissapearCoefArray.value[particleSystem.mergedIndex] = 0;
  }
}

// hideParticleSystem
// Removes a particle system from the scene. Use this instead of ROYGBIV.kill() for
// reusable particle systems.
Roygbiv.prototype.hideParticleSystem = function(particleSystem){
  if (mode == 0){
    return;
  }
  if (typeof particleSystem == UNDEFINED){
    throw new Error("hideParticleSystem error: particleSystem is not defined.");
    return;
  }
  if (!(particleSystem.isParticleSystem)){
    throw new Error("hideParticleSystem error: Type not supported.");
    return;
  }
  particleSystem.tick = 0;
  particleSystem.motionMode = 0;
  particleSystem.mesh.visible = false;
  if (!particleSystem.psMerger){
    delete particleSystems[particleSystems.name];
  }
  if (!(typeof particleSystem.psPool == UNDEFINED)){
    var psPool = particleSystemPools[particleSystem.psPool];
    psPool.notifyPSAvailable(particleSystem);
  }
  if (particleSystem.psMerger){
    particleSystem.psMerger.material.uniforms.hiddenArray.value[particleSystem.mergedIndex] = (20.0);
    particleSystem.psMerger.notifyPSVisibilityChange(particleSystem, false);
  }
}

// createParticleSystemPool
// Creates a new particle system pool. Particle system pools are used to hold
// and keep track of particle systems. For instance, for a plasma gun it is suggested
// to create the plasma particle systems, put them inside a pool and get them from
// the pool every time the player shoots.
Roygbiv.prototype.createParticleSystemPool = function(name){
  if (mode == 0){
    return;
  }
  if (typeof name == UNDEFINED){
    throw new Error("createParticleSystemPool error: name is not defined.");
    return;
  }
  if (particleSystemPools[name]){
    throw new Error("createParticleSystemPool error: name must be unique.");
    return;
  }
  var psPool = new ParticleSystemPool(name);
  particleSystemPools[name] = psPool;
  return psPool;
}

// addParticleSystemToPool
// Puts a particle system to a particle system pool.
Roygbiv.prototype.addParticleSystemToPool = function(pool, particleSystem){
  if (mode == 0){
    return;
  }
  if (typeof pool == UNDEFINED){
    throw new Error("addParticleSystemToPool error: pool is not defined.");
    return;
  }
  if (typeof particleSystem == UNDEFINED){
    throw new Error("addParticleSystemToPool error: particleSystem is not defined.");
    return;
  }
  if (!(pool.isParticleSystemPool)){
    throw new Error("addParticleSystemToPool error: Pool type not supoorted.");
    return;
  }
  if (!(particleSystem.isParticleSystem)){
    throw new Error("addParticleSystemToPool error: Particle system type not supported.");
    return;
  }
  if (!(typeof particleSystem.psPool == UNDEFINED)){
    throw new Error("addParticleSystemToPool error: Particle system belongs to another pool.");
    return;
  }
  pool.add(particleSystem);
}

// removeParticleSystemFromPool
// Removes a particle system from its particle system pool.
Roygbiv.prototype.removeParticleSystemFromPool = function(particleSystem){
  if (mode == 0){
    return;
  }
  if (typeof particleSystem == UNDEFINED){
    throw new Error("removeParticleSystemFromPool error: particleSystem is not defined.");
    return;
  }
  if (!(particleSystem.isParticleSystem)){
    throw new Error("removeParticleSystemFromPool error: Type not supported.");
    return;
  }
  if (typeof particleSystem.psPool == UNDEFINED){
    throw new Error("removeParticleSystemFromPool error: particleSystem does not belong to any pool.");
    return;
  }
  var psPool = particleSystemPools[particleSystem.psPool];
  psPool.remove(particleSystem);
}

// destroyParticleSystemPool
// Destroys a particle system pool.
Roygbiv.prototype.destroyParticleSystemPool = function(pool){
  if (mode == 0){
    return;
  }
  if (typeof pool == UNDEFINED){
    throw new Error("destroyParticleSystemPool error: pool is not defined.");
    return;
  }
  if (!(pool.isParticleSystemPool)){
    throw new Error("destroyParticleSystemPool error: Type not supported.");
    return;
  }
  pool.destroy();
}

// createConfettiExplosion
// Creates a confetti like explosion. This function initially puts the particles
// to the same position on the XZ plane and defines parabolic motion for each particle.
// The configurations are:
// name: The unique name of the particle system. (mandatory)
// position: The start position of the confetti. (mandatory)
// expireTime: The expiration time of particle system in seconds. This can be set 0 for inifinite particle systems. (mandatory)
// lifetime: The average lifetime of particles in seconds. (mandatory)
// verticalSpeed: The average vertical speed of particles. (mandatory)
// horizontalSpeed: The average horizontal speed of particles. (mandatory)
// verticalAcceleration: The average vertial acceleration (gravity) of particles. Expected value is less than zero. (mandatory)
// particleCount: The count of particles. (mandatory)
// particleSize: The size of particles. (mandatory)
// colorName: The color name of particles. (mandatory)
// alpha: The alpha value of particles. (mandatory)
// collisionMethod: 0 -> Nothing happens when particles are collided with objects.
//                  1 -> Particles are destroyed when collided with objects.
//                  2 -> Particles are respawned when collided with objects.
//                  Default value is 0. (optional)
// normal: The normal vector of the particle system. Default value is (0, 1, 0) (optional)
// collisionTimeOffset: The time offset of collision listener if the collisionMethod is 1 or 2. Default value is 0. (optional)
// startDelay: The average start delay of particles. Default value is 0. (optional)
// targetColorName: The target color name of particles. (optional)
// colorStep: A float between [0, 1] that represents the variation of color between the colorName and targetColorName each frame. (optional)
// alphaVariation: The variation of alpha of particles on each frame. (optional)
// textureName: The name of texture of particles. (optional)
// rgbFilter: This can be used to eliminate background colors of textures. (optional)
Roygbiv.prototype.createConfettiExplosion = function(configurations){
  if (mode == 0){
    return;
  }
  var name = configurations.name;
  var position = configurations.position;
  var expireTime = configurations.expireTime;
  var lifetime = configurations.lifetime;
  var verticalSpeed = configurations.verticalSpeed;
  var horizontalSpeed = configurations.horizontalSpeed;
  var verticalAcceleration = configurations.verticalAcceleration;
  var particleCount = configurations.particleCount;
  var particleSize = configurations.particleSize;
  var colorName = configurations.colorName;
  var alpha = configurations.alpha;
  var collisionMethod = configurations.collisionMethod;
  var normal = configurations.normal;
  var collisionTimeOffset= configurations.collisionTimeOffset;
  var startDelay = configurations.startDelay;
  var targetColorName = configurations.targetColorName;
  var colorStep = configurations.colorStep;
  var alphaVariation = configurations.alphaVariation;
  var textureName = configurations.textureName;
  var rgbFilter = configurations.rgbFilter;

  if (typeof name == UNDEFINED){
    throw new Error("createConfettiExplosion error: name is a mandatory configuration.");
    return;
  }
  if (particleSystemPool[name]){
    throw new Error("createConfettiExplosion error: name must be unique.");
    return;
  }
  if (typeof position == UNDEFINED){
    throw new Error("createConfettiExplosion error: position is a mandatory configuration.");
    return;
  }
  if (isNaN(position.x) || isNaN(position.y) || isNaN(position.z)){
    throw new Error("createConfettiExplosion error: Bad position parameter.");
    return;
  }
  if (typeof expireTime == UNDEFINED){
    throw new Error("createConfettiExplosion error: expireTime is a mandatory configuration.");
    return;
  }
  if (isNaN(expireTime)){
    throw new Error("createConfettiExplosion error: Bad expireTime parameter.");
    return;
  }
  if (expireTime < 0){
    throw new Error("createConfettiExplosion error: expireTime cannot be a negative number.");
    return;
  }
  if (typeof lifetime == UNDEFINED){
    throw new Error("createConfettiExplosion error: lifetime is a mandatory configuration.");
    return;
  }
  if (isNaN(lifetime)){
    throw new Error("createConfettiExplosion error: Bad lifetime parameter.");
    return;
  }
  if (lifetime < 0){
    throw new Error("createConfettiExplosion error: lifetime cannot be a negative number.");
    return;
  }
  if (typeof verticalSpeed == UNDEFINED){
    throw new Error("createConfettiExplosion error: verticalSpeed is a mandatory configuration.");
    return;
  }
  if (isNaN(verticalSpeed)){
    throw new Error("createConfettiExplosion error: Bad verticalSpeed parameter.");
    return;
  }
  if (typeof horizontalSpeed == UNDEFINED){
    throw new Error("createConfettiExplosion error: horizontalSpeed is a mandatory configuration.");
    return;
  }
  if (isNaN(horizontalSpeed)){
    throw new Error("createConfettiExplosion error: Bad horizontalSpeed parameter.");
    return;
  }
  if (typeof verticalAcceleration == UNDEFINED){
    throw new Error("createConfettiExplosion error: verticalAcceleration is a mandatory configuration.");
    return;
  }
  if (isNaN(verticalAcceleration)){
    throw new Error("createConfettiExplosion error: Bad verticalAcceleration parameter.");
    return;
  }
  if (verticalAcceleration >= 0){
    throw new Error("createConfettiExplosion error: verticalAcceleration is expected to be less than zero.");
    return;
  }
  if (typeof particleCount == UNDEFINED){
    throw new Error("createConfettiExplosion error: particleCount is a mandatory configuration.");
    return;
  }
  if (isNaN(particleCount)){
    throw new Error("createConfettiExplosion error: Bad particleCount parameter.");
    return;
  }
  if (particleCount <= 0){
    throw new Error("createConfettiExplosion error: particleCount is expected to be greater than zero.");
    return;
  }
  if (typeof particleSize == UNDEFINED){
    throw new Error("createConfettiExplosion error: particleSize is a mandatory configuration.");
    return;
  }
  if (isNaN(particleSize)){
    throw new Error("createConfettiExplosion error: Bad particleSize parameter.");
    return;
  }
  if (particleSize <= 0){
    throw new Error("createConfettiExplosion error: particleSize is expected to be greater than zero.");
    return;
  }
  if (typeof colorName == UNDEFINED){
    throw new Error("createConfettiExplosion error: colorName is a mandatory configuration.");
    return;
  }
  if (typeof alpha == UNDEFINED){
    throw new Error("createConfettiExplosion error: alpha is a mandatory configuration.");
    return;
  }
  if (isNaN(alpha)){
    throw new Error("createConfettiExplosion error: Bad alpha parameter.");
    return;
  }
  if (alpha < 0 || alpha > 1){
    throw new Error("createConfettiExplosion error: alpha is expected to be between [0, 1].");
    return;
  }
  if (!(typeof collisionMethod == UNDEFINED)){
    if (collisionMethod != 0 && collisionMethod != 1 && collisionMethod != 2){
      throw new Error("createConfettiExplosion error: collisionMethod must be 0, 1, or 2.");
      return;
    }
  }else{
    collisionMethod = 0;
  }
  if (!(typeof collisionTimeOffset == UNDEFINED)){
    if (isNaN(collisionTimeOffset)){
      throw new Error("createConfettiExplosion error: Bad collisionTimeOffset parameter.");
      return;
    }
  }else{
    collisionTimeOffset = 0;
  }
  if (!(typeof startDelay == UNDEFINED)){
    if (isNaN(startDelay)){
      throw new Error("createConfettiExplosion error: Bad startDelay parameter.");
      return;
    }
    if (startDelay < 0){
      throw new Error("createConfettiExplosion error: startDelay cannot be a negative number.");
      return;
    }
  }else{
    startDelay = 0;
  }
  var normalSet = false;
  if (!(typeof normal == UNDEFINED)){
      if (isNaN(normal.x) || isNaN(normal.y) || isNaN(normal.z)){
        throw new Error("createConfettiExplosion error: Bad normal parameter.");
        return;
      }
      normalSet = true;
  }

  var particleMaterial = this.createParticleMaterial({
    color: colorName,
    size: particleSize,
    alpha: alpha,
    textureName: textureName,
    rgbFilter: rgbFilter,
    targetColor: targetColorName,
    colorStep: colorStep
  });

  var particles = [];
  var particleConfigurations = new Object();
  particleConfigurations.position = this.vector(0, 0, 0);
  particleConfigurations.material = particleMaterial;
  particleConfigurations.alphaVariation = alphaVariation;
  if (collisionMethod == 2){
    particleConfigurations.respawn = true;
  }else{
    particleConfigurations.respawn = false;
  }
  for (var i = 0; i<particleCount; i++){
    particleConfigurations.startDelay = startDelay * Math.random();
    particleConfigurations.lifetime = lifetime;
    var v1 = horizontalSpeed * (Math.random() - 0.5);
    var v2 = horizontalSpeed * (Math.random() - 0.5);
    var v3 = verticalSpeed * Math.random();
    particleConfigurations.velocity = this.vector(v1, v3, v2);
    particleConfigurations.acceleration = this.vector(0, verticalAcceleration, 0);
    var particle = this.createParticle(particleConfigurations);
    particles.push(particle);
    if (collisionMethod == 1){
      var roygbivContext = this;
      this.setCollisionListener(particle, function(info){
        roygbivContext.kill(this);
      }, collisionTimeOffset);
    }else if (collisionMethod == 2){
      var roygbivContext = this;
      this.setCollisionListener(particle, function(info){
        roygbivContext.rewindParticle(this, Math.random());
      }, collisionTimeOffset);
    }
  }

  var ps = this.createParticleSystem({
    name: name,
    particles: particles,
    position: position,
    lifetime: expireTime
  });
  if (normalSet){
    var quat = this.computeQuaternionFromVectors(this.vector(0, 1, 0), normal);
    ps.mesh.quaternion.set(quat.x, quat.y, quat.z, quat.w);
  }
  return ps;

}

// copyParticleSystem
// Returns a new copy of given particle system. This function can be used to
// improve memory usage of particle system pools. For instance, given a plasma
// gun with X plasma particle systems it is better to create one plasma particle system
// then create (X-1) copies of it than to create X plasma particle systems.
Roygbiv.prototype.copyParticleSystem = function(particleSystem, newParticleSystemName){
  if (mode == 0){
    return;
  }
  if (TOTAL_PARTICLE_SYSTEM_COUNT >= MAX_PARTICLE_SYSTEM_COUNT){
    throw new Error("copyParticleSystem error: Cannot create more than "+MAX_PARTICLE_SYSTEM_COUNT+" particle systems.");
    return;
  }
  if (typeof particleSystem == UNDEFINED){
    throw new Error("copyParticleSystem error: particleSystem is not defined.");
    return;
  }
  if (!(particleSystem.isParticleSystem)){
    throw new Error("copyParticleSystem error: Type not supported.");
    return;
  }
  if (typeof newParticleSystemName == UNDEFINED){
    throw new Error("copyParticleSystem error: newParticleSystemName is not defined.");
    return;
  }
  if (particleSystemPool[newParticleSystemName]){
    throw new Error("copyParticleSystem error: Name must be unique.");
    return;
  }

  var copyParticleSystem = new ParticleSystem(
    particleSystem, newParticleSystemName, particleSystem.particles,
    particleSystem.x, particleSystem.y, particleSystem.z,
    particleSystem.vx, particleSystem.vy, particleSystem.vz,
    particleSystem.ax, particleSystem.ay, particleSystem.az, particleSystem.motionMode,
    particleSystem.updateFunction
  );

  copyParticleSystem.lifetime = particleSystem.lifetime;

  copyParticleSystem.angularVelocity = particleSystem.angularVelocity;
  copyParticleSystem.angularAcceleration = particleSystem.angularAcceleration;
  copyParticleSystem.angularMotionRadius = particleSystem.angularMotionRadius;
  if (particleSystem.angularQuaternion){
    copyParticleSystem.angularQuaternionX = particleSystem.angularQuaternion.x;
    copyParticleSystem.angularQuaternionY = particleSystem.angularQuaternion.y;
    copyParticleSystem.angularQuaternionZ = particleSystem.angularQuaternion.z;
    copyParticleSystem.angularQuaternionW = particleSystem.angularQuaternion.w;
  }
  copyParticleSystem.initialAngle = particleSystem.initialAngle;

  TOTAL_PARTICLE_SYSTEM_COUNT ++;

  return copyParticleSystem;

}

// fadeAway
// Makes the particles of given particle system smaller on each frame. Greater
// the coefficient, faster the particles fade away. This can be used for
// smoke like particle systems to make them dissapear smoothly.
Roygbiv.prototype.fadeAway = function(particleSystem, coefficient){
  if (mode == 0){
    return;
  }
  if (typeof particleSystem == UNDEFINED){
    throw new Error("fadeAway error: particleSystem is not defined.");
    return;
  }
  if (!(particleSystem.isParticleSystem)){
    throw new Error("fadeAway error: Type not supported.");
    return;
  }
  if (typeof coefficient == UNDEFINED){
    throw new Error("fadeAway error: coefficient is not defined.");
    return;
  }
  if (isNaN(coefficient)){
    throw new Error("fadeAway error: Bad coefficient parameter.");
    return;
  }
  if (coefficient <= 0){
    throw new Error("fadeAway error: coefficient must be greater than zero.");
    return;
  }
  if (!particleSystem.psMerger){
    particleSystem.material.uniforms.dissapearCoef.value = coefficient;
  }else{
    particleSystem.psMerger.material.uniforms.dissapearCoefArray.value[particleSystem.mergedIndex] = coefficient;
  }
}

// mergeParticleSystems
// Merges all created particle systems to improve render performance.
Roygbiv.prototype.mergeParticleSystems = function(){
  if (mode == 0){
    return;
  }
  if (!MAX_VERTEX_UNIFORM_VECTORS){
    throw new Error("mergeParticleSystems error: MAX_VERTEX_UNIFORM_VECTORS is not calcualted.");
    return;
  }
  if (Object.keys(particleSystemPool).length < 2){
    throw new Error("mergeParticleSystems error: Mininmum 2 particle systems must be created in order to merge.");
    return;
  }
  var diff = parseInt(4096 / MAX_VERTEX_UNIFORM_VECTORS);
  var chunkSize = parseInt(MAX_PS_COMPRESS_AMOUNT_4096 / diff);
  var mergeObj = new Object();
  var size = 0;
  for (var psName in particleSystemPool){
    var ps = particleSystemPool[psName];
    mergeObj[psName] = ps;
    size ++;
    if (size == chunkSize){
      new ParticleSystemMerger(mergeObj, TOTAL_MERGED_COUNT);
      TOTAL_MERGED_COUNT ++;
      mergeObj = new Object();
      size = 0;
    }
  }
  if (size > 1){
    new ParticleSystemMerger(mergeObj, TOTAL_MERGED_COUNT);
    TOTAL_MERGED_COUNT ++;
  }
}

// setParticleSystemPosition
// Sets the position of a particle system. This function is designed for
// magic circle like particle systems which may follow players. This function
// should not be used for particle systems with collision callbacks or particle systems
// with defined motions in general.
Roygbiv.prototype.setParticleSystemPosition = function(particleSystem, x, y, z){
  if (mode == 0){
    return;
  }
  if (typeof particleSystem == UNDEFINED){
    throw new Error("setParticleSystemPosition error: particleSystem is not defined.");
    return;
  }
  if (!(particleSystem.isParticleSystem)){
    throw new Error("setParticleSystemPosition error: Type not supported.");
    return;
  }
  if (typeof x == UNDEFINED){
    throw new Error("setParticleSystemPosition error: x is not defined.");
    return;
  }
  if (typeof y == UNDEFINED){
    throw new Error("setParticleSystemPosition error: y is not defined.");
    return;
  }
  if (typeof z == UNDEFINED){
    throw new Error("setParticleSystemPosition error: z is not defined.");
    return;
  }
  if (isNaN(x)){
    throw new Error("setParticleSystemPosition error: x is not a number.");
    return;
  }
  if (isNaN(y)){
    throw new Error("setParticleSystemPosition error: y is not a number.");
    return;
  }
  if (isNaN(z)){
    throw new Error("setParticleSystemPosition error: z is not a number.");
    return;
  }
  if (!particleSystem.mesh.visible){
    throw new Error("setParticleSystemPosition error: particleSystem is not visible.");
    return;
  }
  if (particleSystem.checkForCollisions){
    throw new Error("setParticleSystemPosition error: particleSystem has a collision callback attached. Cannot set position.");
    return;
  }
  if (particleSystem.particlesWithCollisionCallbacks.size > 0){
    throw new Error("setParticleSystemPosition error: particleSystem has a collidable particle. Cannot set position.");
    return;
  }
  if (particleSystem.hasTrailedParticle){
    throw new Error("setParticleSystemPosition error: particleSystem has a trailed particle. Cannot set position.");
    return;
  }
  if (particleSystem.velocity.x != 0 || particleSystem.velocity.y != 0 || particleSystem.velocity.z != 0 ||
          particleSystem.acceleration.x != 0 || particleSystem.acceleration.y != 0 || particleSystem.acceleration.z != 0){

      throw new Error("setParticleSystemPosition error: particleSystem has a defined motion. Cannot set position.");
      return;
  }
  particleSystem.mesh.position.set(x, y, z);
  particleSystem.hasManualPositionSet = true;
}

// startObjectTrail
// Starts the trail effect of an object create with createObjectTrail command.
Roygbiv.prototype.startObjectTrail = function(object){
  if (mode == 0){
    return;
  }
  if (typeof object == UNDEFINED){
    throw new Error("startObjectTrail error: object is not defined.");
    return;
  }
  if (!(object.isAddedObject) && !(object.isObjectGroup)){
    throw new Error("startObjectTrail error: Type not supported.");
    return;
  }
  var objectTrail = objectTrails[object.name];
  if (!objectTrail){
    throw new Error("startObjectTrail error: No trail attached to object.");
    return;
  }
  objectTrail.start();
}

// stopObjectTrail
// Stops the trail effect of an object. The effect can be restarted using the startObjectTrail command.
Roygbiv.prototype.stopObjectTrail = function(object){
  if (mode == 0){
    return;
  }
  if (typeof object == UNDEFINED){
    throw new Error("stopObjectTrail error: object is not defined.");
    return;
  }
  if (!(object.isAddedObject) && !(object.isObjectGroup)){
    throw new Error("stopObjectTrail error: Type not supported.");
    return;
  }
  var objectTrail = objectTrails[object.name];
  if (!objectTrail){
    throw new Error("stopObjectTrail error: No trail attached to object.");
    return;
  }
  objectTrail.stop();
}

// createInitializedParticleSystemPool
// Creates a particle system pool and fills it with poolSize copies of refParticleSystem.
Roygbiv.prototype.createInitializedParticleSystemPool = function(poolName, refParticleSystem, poolSize){
  if (mode == 0){
    return;
  }
  if (typeof refParticleSystem == UNDEFINED){
    throw new Error("createInitializedParticleSystemPool error: refParticleSystem is not defined.");
    return;
  }
  if (!(refParticleSystem.isParticleSystem)){
    throw new Error("createInitializedParticleSystemPool error: refParticleSystem is not a ParticleSystem.");
    return;
  }
  if (typeof poolName == UNDEFINED){
    throw new Error("createInitializedParticleSystemPool error: poolName is not defined.");
    return;
  }
  if (particleSystemPools[poolName]){
    throw new Error("createInitializedParticleSystemPool error: poolName must be unique.");
    return;
  }
  if (typeof poolSize == UNDEFINED){
    throw new Error("createInitializedParticleSystemPool error: poolSize is not defined.");
    return;
  }
  if (isNaN(poolSize)){
    throw new Error("createInitializedParticleSystemPool error: poolSize is not a number.");
    return;
  }
  if (poolSize <= 1){
    throw new Error("createInitializedParticleSystemPool error: poolSize must be greater than 1.");
    return;
  }
  var pool = this.createParticleSystemPool(poolName);
  this.addParticleSystemToPool(pool, refParticleSystem);
  for (var i = 0; i<poolSize - 1; i++){
    this.addParticleSystemToPool(pool, this.copyParticleSystem(refParticleSystem, this.generateParticleSystemName()));
  }
  return pool;
}

// CROSSHAIR FUNCTIONS *********************************************************

// createCrosshair
// Creates a new crosshair. Configurations are:
// name: The unique name of the crosshair. (mandatory)
// textureName: The texture name of the crosshair. (mandatory)
// colorName: The color name of the crosshair. (mandatory)
// alpha: The alpha value of the crosshair. (mandatory)
// size: The size of the crosshair. (mandatory)
Roygbiv.prototype.createCrosshair = function(configurations){
  if (mode == 0){
    return;
  }
  var name = configurations.name;
  var textureName = configurations.textureName;
  var colorName = configurations.colorName;
  var alpha = configurations.alpha;
  var size = configurations.size;

  if (typeof name == UNDEFINED){
    throw new Error("createCrosshair error: name is a mandatory configuration.");
    return;
  }
  if (crosshairs[name]){
    throw new Error("createCrosshair error: name must be unique.");
    return;
  }
  if (typeof textureName == UNDEFINED){
    throw new Error("createCrosshair error: textureName is a mandatory configuration.");
    return;
  }
  var texture = textures[textureName];
  if (typeof texture == UNDEFINED){
    throw new Error("createCrosshair error: No such texture.");
    return;
  }
  if (!(texture instanceof THREE.Texture)){
    throw new Error("createCrosshair error: Texture not ready.");
    return;
  }
  if (typeof alpha == UNDEFINED){
    throw new Error("createCrosshair error: alpha is a mandatory configuration.");
    return;
  }
  if (isNaN(alpha)){
    throw new Error("createCrosshair error: Bad alpha parameter.");
    return;
  }
  if (alpha < 0 || alpha > 1){
    throw new Error("createCrosshair error: alpha must be between 0 and 1.");
    return;
  }
  if (typeof size == UNDEFINED){
    throw new Error("createCrosshair error: size is a mandatory configuration.");
    return;
  }
  if (isNaN(size)){
    throw new Error("createCrosshair error: Bad size parameter.");
    return;
  }
  if (size <= 0){
    throw new Error("createCrosshair error: size must be greater than zero.");
    return;
  }

  var color = new THREE.Color(colorName);
  new Crosshair({
    name: name,
    texture: texture,
    colorR: color.r,
    colorB: color.b,
    colorG: color.g,
    alpha: alpha,
    size: size
  });
}

// selectCrosshair
// Selects a crosshair. Only the selected crosshair is visible on the screen.
Roygbiv.prototype.selectCrosshair = function(crosshairName){
  if (mode == 0){
    return;
  }
  if (typeof crosshairName == UNDEFINED){
    throw new Error("selectCrosshair error: crosshairName is not defined.");
    return;
  }
  var crosshair = crosshairs[crosshairName];
  if (!crosshair){
    throw new Error("selectCrosshair error: No such crosshair.");
    return;
  }
  if (selectedCrosshair){
    selectedCrosshair.mesh.visible = false;
  }
  crosshair.mesh.visible = true;
  selectedCrosshair = crosshair;
}

// changeCrosshairColor
// Changes the color of the selected crosshair.
Roygbiv.prototype.changeCrosshairColor = function(colorName){
  if (mode == 0){
    return;
  }
  if (typeof colorName == UNDEFINED){
    throw new Error("changeCrosshairColor error: colorName is not defined.");
    return;
  }
  if (!selectedCrosshair){
    throw new Error("changeCrosshairColor error: No crosshair is selected.");
    return;
  }
  REUSABLE_COLOR.set(colorName);
  selectedCrosshair.material.uniforms.color.value.x = REUSABLE_COLOR.r;
  selectedCrosshair.material.uniforms.color.value.y = REUSABLE_COLOR.g;
  selectedCrosshair.material.uniforms.color.value.z = REUSABLE_COLOR.b;
}

// hideCrosshair
// Destroys the selected crosshair. selectCrosshair function should be used after this function
// in order to put a crosshair on the screen.
Roygbiv.prototype.hideCrosshair = function(){
  if (mode == 0){
    return;
  }
  if (selectedCrosshair){
    selectedCrosshair.mesh.visible = false;
    selectedCrosshair = 0;
  }
}

// startCrosshairRotation
// Starts rotation effect of the selected crosshair.
Roygbiv.prototype.startCrosshairRotation = function(angularSpeed){
  if (mode == 0){
    return;
  }
  if (!selectedCrosshair){
    throw new Error("startCrosshairRotation error: No selected crosshair.");
    return;
  }
  if (typeof angularSpeed == UNDEFINED){
    throw new Error("startCrosshairRotation error: angularSpeed is not defined.");
    return;
  }
  if (isNaN(angularSpeed)){
    throw new Error("startCrosshairRotation error: angularSpeed is not a number.");
    return;
  }
  selectedCrosshair.angularSpeed = angularSpeed;
}

// stopCrosshairRotation
// Stops rotation effect of the selected crosshair.
Roygbiv.prototype.stopCrosshairRotation = function(){
  if (mode == 0){
    return;
  }
  if (!selectedCrosshair){
    throw new Error("stopCrosshairRotation error: No selected crosshair.");
    return;
  }
  selectedCrosshair.rotationTime = 0;
  selectedCrosshair.angularSpeed = 0;
  selectedCrosshair.resetRotation();
}

// pauseCrosshairRotation
// Pauses rotation effect of the selected crosshair. startCrosshairRotation function
// can be used to continue the rotation effect.
Roygbiv.prototype.pauseCrosshairRotation = function(){
  if (mode == 0){
    return;
  }
  if (!selectedCrosshair){
    throw new Error("pauseCrosshairRotation error: No selected crosshair.");
    return;
  }
  selectedCrosshair.angularSpeed = 0;
}

// expandCrosshair
// Expands a crosshair. This can be used while shooting or walking for fps games.
// The crosshair expands by delta while its size is less than targetSize on each frame.
// This function is designed to be called inside onmousedown or onkeydown like events.
Roygbiv.prototype.expandCrosshair = function(targetSize, delta){
  if (mode == 0){
    return;
  }
  if (!selectedCrosshair){
    throw new Error("expandCrosshair error: No selected crosshair.");
    return;
  }
  if (typeof targetSize == UNDEFINED){
    throw new Error("expandCrosshair error: targetSize is not defined.");
    return;
  }
  if (isNaN(targetSize)){
    throw new Error("expandCrosshair error: Bad targetSize parameter.");
    return;
  }
  if (targetSize <= selectedCrosshair.sizeAmount){
    throw new Error("expandCrosshair error: targetSize must not be less than the size of the crosshair.");
    return;
  }
  if (typeof delta == UNDEFINED){
    throw new Error("expandCrosshair error: delta is not defined.");
    return;
  }
  if (isNaN(delta)){
    throw new Error("expandCrosshair error: Bad delta parameter.");
    return;
  }
  if (delta <= 0){
    throw new Error("expandCrosshair error: delta must be greater than zero.");
    return;
  }
  selectedCrosshair.expandTick = 0;
  selectedCrosshair.expandTargetSize = targetSize;
  selectedCrosshair.expandDelta = delta;
  selectedCrosshair.expand = true;
  selectedCrosshair.shrink = false;
}

// shrinkCrosshair
// Shrinks a crosshair. This can be used after calling the expandCrosshair function.
// The crosshair shrinks by delta while its size is greater than its initial size. This function
// is designed to be called inside onmouseup or onkeyup like events.
Roygbiv.prototype.shrinkCrosshair = function(delta){
  if (mode == 0){
    return;
  }
  if (typeof delta == UNDEFINED){
    throw new Error("shrinkCrosshair error: delta is not defined.");
    return;
  }
  if (isNaN(delta)){
    throw new Error("shrinkCrosshair error: Bad delta parameter.");
    return;
  }
  if (delta <= 0){
    throw new Error("shrinkCrosshair error: delta must be greater than zero.");
    return;
  }
  if (!selectedCrosshair){
    throw new Error("shrinkCrosshair error: No selected crosshair.");
    return;
  }
  selectedCrosshair.shrinkTick = 0;
  selectedCrosshair.expandDelta = delta;
  selectedCrosshair.material.uniforms.shrinkStartSize.value = selectedCrosshair.curSize;
  selectedCrosshair.expand = false;
  selectedCrosshair.shrink = true;
}

// LISTENER FUNCTIONS **********************************************************

// setCollisionListener
//  Sets a collision listener for an object, glued object, particle or a particle system. Using
//  this with loads of particles may cause performance issues if web worker usage is not enabled or supported.
//  Callback function given as the second parameter is fired with a CollisionInfo instance (except for particle collisions) when
//  the sourceObject is collided with other objects or glued objects of the scene.
//  The additional timeOffset parameter can be used for particles/particle systems to
//  pre-calculate future collisions. This can help to prevent visual errors of collisions
//  of rather fast particles/particle systems.
Roygbiv.prototype.setCollisionListener = function(sourceObject, callbackFunction, timeOffset){
  if (mode == 0){
    return;
  }
  if (!sourceObject){
    throw new Error("setCollisionListener error: sourceObject is not defined.");
    return;
  }
  if (!(sourceObject.isAddedObject) && !(sourceObject.isObjectGroup) && !(sourceObject.isParticle) && !(sourceObject.isParticleSystem)){
    throw new Error("setCollisionListener error: Type not supported.");
    return;
  }
  if ((sourceObject.isAddedObject) || (sourceObject.isObjectGroup)){
    if (TOTAL_OBJECT_COLLISION_LISTENER_COUNT >= MAX_OBJECT_COLLISION_LISTENER_COUNT){
      throw new Error("setCollisionListener error: Cannot set collision listener for more than "+MAX_OBJECT_COLLISION_LISTENER_COUNT+" objects.");
      return;
    }
    if (sourceObject.noMass){
      throw new Error("setCollisionListener error: Object has no mass.");
      return;
    }
    collisionCallbackRequests[sourceObject.name] = callbackFunction.bind(sourceObject);
    TOTAL_OBJECT_COLLISION_LISTENER_COUNT ++;
  }else if (sourceObject.isParticle){
    if (sourceObject.parent && sourceObject.parent.isStopped){
      throw new Error("setCollisionListener error: Particle system is stopped.");
      return;
    }
    if (sourceObject.uuid && !particleCollisionCallbackRequests[sourceObject.uuid]){
      if (TOTAL_PARTICLE_COLLISION_LISTEN_COUNT >= MAX_PARTICLE_COLLISION_LISTEN_COUNT){
        throw new Error("setCollisionListener error: Cannot set collision listener for more than "+MAX_PARTICLE_COLLISION_LISTEN_COUNT+" particles.");
        return;
      }
    }
    if (sourceObject.parent){
      if (sourceObject.parent.hasManualPositionSet){
        throw new Error("setCollisionListener error: A position is set manually to the parent particle system. Cannot listen for collisions.");
        return;
      }
      if (sourceObject.parent.hasManualRotationSet){
        throw new Error("setCollisionListener error: A rotation is set manually to the parent particle system. Cannot listen for collisions.");
        return;
      }
      if (sourceObject.parent.hasManualQuaternionSet){
        throw new Error("setCollisionListener error: A quaternion is set manually to the parent particle system. Cannot listen for collisions.");
        return;
      }
      if (!sourceObject.parent.hasParticleCollision){
        if (TOTAL_PARTICLE_SYSTEMS_WITH_PARTICLE_COLLISIONS >= MAX_PARTICLE_SYSTEMS_WITH_PARTICLE_COLLISIONS){
          throw new Error("setCollisionListener error: Maximum "+MAX_PARTICLE_SYSTEMS_WITH_PARTICLE_COLLISIONS+" can have collidable particles.");
          return;
        }
        TOTAL_PARTICLE_SYSTEMS_WITH_PARTICLE_COLLISIONS ++;
      }
    }
    if (!sourceObject.uuid){
      sourceObject.assignUUID();
    }
    var incrCounter = false;
    if (!particleCollisionCallbackRequests[sourceObject.uuid]){
      incrCounter = true;
    }
    particleCollisionCallbackRequests[sourceObject.uuid] = callbackFunction.bind(sourceObject);
    if (incrCounter){
      TOTAL_PARTICLE_COLLISION_LISTEN_COUNT ++;
    }
    sourceObject.checkForCollisions = true;
    if (!(typeof timeOffset == UNDEFINED)){
      sourceObject.collisionTimeOffset = timeOffset;
    }
    if (sourceObject.parent){
      sourceObject.parent.hasParticleCollision = true;
      sourceObject.parent.notifyParticleCollisionCallbackChange(sourceObject);
    }
  }else if (sourceObject.isParticleSystem){
    if (sourceObject.hasManualPositionSet){
      throw new Error("setCollisionListener error: A position is set manually to the particle system. Cannot listen for collisions.");
      return;
    }
    if (sourceObject.hasManualRotationSet){
      throw new Error("setCollisionListener error: A rotation is set manually to the particle system. Cannot listen for collisions.");
      return;
    }
    if (sourceObject.hasManualQuaternionSet){
      throw new Error("setCollisionListener error: A quaternion is set manually to the particle system. Cannot listen for collisions.");
      return;
    }
    var incrCounter = false;
    if (!particleSystemCollisionCallbackRequests[sourceObject.name]){
      if (TOTAL_PARTICLE_SYSTEM_COLLISION_LISTEN_COUNT >= MAX_PARTICLE_SYSTEM_COUNT){
        throw new Error("setCollisionListener error: Cannot set collision listener for more than "+MAX_PARTICLE_SYSTEM_COUNT+" particle systems.");
        return;
      }
      incrCounter = true;
    }
    particleSystemCollisionCallbackRequests[sourceObject.name] = callbackFunction.bind(sourceObject);
    sourceObject.checkForCollisions = true;
    if (!(typeof timeOffset == UNDEFINED)){
      sourceObject.collisionTimeOffset = timeOffset;
    }
    if (incrCounter){
      TOTAL_PARTICLE_SYSTEM_COLLISION_LISTEN_COUNT ++;
    }
  }
}

// removeCollisionListener
//  Removes collision listeners of an object, glued object, particle or a particle system.. Use this
//  for performance improvements if collision callbacks are no longer necessary
//  for particles or particle systems.
Roygbiv.prototype.removeCollisionListener = function(sourceObject){
  if (mode == 0){
    return;
  }
  if (!sourceObject){
    throw new Error("removeCollisionListener error: sourceObject is not defined.");
    return;
  }
  if (!(sourceObject.isAddedObject) && !(sourceObject.isObjectGroup) && !(sourceObject.isParticle) && !(sourceObject.isParticleSystem)){
    throw new Error("removeCollisionListener error: Type not supported.");
    return;
  }
  var curCallbackRequest;
  if ((sourceObject.isAddedObject) || (sourceObject.isObjectGroup)){
    curCallbackRequest = collisionCallbackRequests[sourceObject.name];
  }else if (sourceObject.isParticle){
    curCallbackRequest = particleCollisionCallbackRequests[sourceObject.uuid];
  }else if (sourceObject.isParticleSystem){
    curCallbackRequest = particleSystemCollisionCallbackRequests[sourceObject.name];
  }
  if (curCallbackRequest){
    if ((sourceObject.isAddedObject) || (sourceObject.isObjectGroup)){
      delete collisionCallbackRequests[sourceObject.name];
      TOTAL_OBJECT_COLLISION_LISTENER_COUNT --;
    }else if (sourceObject.isParticle){
      delete particleCollisionCallbackRequests[sourceObject.uuid];
      TOTAL_PARTICLE_COLLISION_LISTEN_COUNT --;
      sourceObject.checkForCollisions = false;
      if (sourceObject.parent){
        sourceObject.parent.notifyParticleCollisionCallbackChange(sourceObject);
      }
    }else if (sourceObject.isParticleSystem){
      TOTAL_PARTICLE_SYSTEM_COLLISION_LISTEN_COUNT --;
      delete particleSystemCollisionCallbackRequests[sourceObject.name];
      sourceObject.checkForCollisions = false;
    }
  }
}

// setExpireListener
// Sets an expiration listener for a particle system. The parameter callbackFunction
// is executed when sourceObject is expired. The name of the particle system is passed
// to the callbackFunction as a parameter.
Roygbiv.prototype.setExpireListener = function(sourceObject, callbackFunction){
  if (mode == 0){
    return;
  }
  if (typeof sourceObject == UNDEFINED){
    throw new Error("setExpireListener error: sourceObject is not defined.");
    return;
  }
  if (!(sourceObject.isParticleSystem)){
    throw new Error("setExpireListener error: sourceObject is not a particle system.");
    return;
  }
  if (typeof callbackFunction == UNDEFINED){
    throw new Error("setExpireListener error: callbackFunction is not defined.");
    return;
  }
  if (!(callbackFunction instanceof Function)){
    throw new Error("setExpireListener error: callbackFunction is not a function.");
    return;
  }
  if (sourceObject.destroyed){
    throw new Error("setExpireListener error: sourceObject is already expired.");
    return;
  }
  sourceObject.expirationFunction = callbackFunction;
}

// removeExpireListener
// Removes the expiration listener function of a particle system.
Roygbiv.prototype.removeExpireListener = function(sourceObject){
  if (mode == 0){
    return;
  }
  if (typeof sourceObject == UNDEFINED){
    throw new Error("removeExpireListener error: sourceObject is not defined.");
    return;
  }
  if (!(sourceObject.isParticleSystem)){
    throw new Error("removeExpireListener error: sourceObject is not a particle system.");
    return;
  }
  if (sourceObject.destroyed){
    throw new Error("removeExpireListener error: sourceObject is already expired.");
    return;
  }
  delete sourceObject.expirationFunction;
}

// setObjectClickListener
// Sets a click listener for an object or an object group. The callbackFunction is executed
// with x, y, z coordinates of the clicked point.
Roygbiv.prototype.setObjectClickListener = function(sourceObject, callbackFunction){
  if (mode == 0){
    return;
  }
  if (sourceObject == UNDEFINED){
    throw new Error("setClickListener error: sourceObject is not defined.");
    return;
  }
  if (callbackFunction == UNDEFINED){
    throw new Error("setClickListener error: callbackFunction is not defined.");
    return;
  }
  if (!(sourceObject.isAddedObject) && !(sourceObject.isObjectGroup)){
    throw new Error("setClickListener error: Type not supported.");
    return;
  }
  if (!(callbackFunction instanceof Function)){
    throw new Error("setClickListener error: callbackFunction is not a function.");
    return;
  }
  sourceObject.clickCallbackFunction = callbackFunction;
}

// removeObjectClickListener
// Removes the click listener of an object or an object group.
Roygbiv.prototype.removeObjectClickListener = function(sourceObject){
  if (mode == 0){
    return;
  }
  if (sourceObject == UNDEFINED){
    throw new Error("removeClickListener error: sourceObject is not defined.");
    return;
  }
  if (!(sourceObject.isAddedObject) && !(sourceObject.isObjectGroup)){
    throw new Error("removeClickListener error: Type not supported.");
    return;
  }
  delete sourceObject.clickCallbackFunction;
}

// setScreenClickListener
// Sets a click listener for the screen. The callbackFunction is
// executed with x, y coordinates when clicked on the screen.
Roygbiv.prototype.setScreenClickListener = function(callbackFunction){
  if (mode == 0){
    return;
  }
  if (typeof callbackFunction == UNDEFINED){
    throw new Error("setScreenClickListener error: callbackFunction is not defined.");
    return;
  }
  if (!(callbackFunction instanceof Function)){
    throw new Error("setScreenClickListener error: callbackFunction is not a function.");
    return;
  }
  screenClickCallbackFunction = callbackFunction;
}

// removeScreenClickListener
// Removes the click listener of screen.
Roygbiv.prototype.removeScreenClickListener = function(){
  if (mode == 0){
    return;
  }
  screenClickCallbackFunction = 0;
}

// setScreenMouseDownListener
// Sets a mouse down listener for screen. The callbackFunction is
// executed with x, y coordinates when mouse-downed on the screen.
Roygbiv.prototype.setScreenMouseDownListener = function(callbackFunction){
  if (mode == 0){
    return;
  }
  if (typeof callbackFunction == UNDEFINED){
    throw new Error("setScreenMouseDownListener error: callbackFunction is not defined.");
    return;
  }
  if (!(callbackFunction instanceof Function)){
    throw new Error("setScreenMouseDownListener error: callbackFunction is not a function.");
    return;
  }
  screenMouseDownCallbackFunction = callbackFunction;
}

// removeScreenMouseDownListener
// Removes the mouse down listener of screen.
Roygbiv.prototype.removeScreenMouseDownListener = function(){
  if (mode == 0){
    return;
  }
  screenMouseDownCallbackFunction = 0;
}

// setScreenMouseUpListener
// Sets mouse up listener for screen. The callbackFunction is
// executed with x, y coordinates when mouse-upped on the screen.
Roygbiv.prototype.setScreenMouseUpListener = function(callbackFunction){
  if (mode == 0){
    return;
  }
  if (typeof callbackFunction == UNDEFINED){
    throw new Error("setScreenMouseUpListener error: callbackFunction is not defined.");
    return;
  }
  if (!(callbackFunction instanceof Function)){
    throw new Error("setScreenMouseUpListener error: callbackFunction is not a function.");
    return;
  }
  screenMouseUpCallbackFunction = callbackFunction;
}

// removeScreenMouseUpListener
// Removes mouse up listener for screen.
Roygbiv.prototype.removeScreenMouseUpListener = function(){
  if (mode == 0){
    return;
  }
  screenMouseUpCallbackFunction = 0;
}

// setScreenMouseMoveListener
// Sets mouse move listener for screen. The callbackFunction is
// executed with x, y coordinates and dX, dY values when mouse moves on the screen.
Roygbiv.prototype.setScreenMouseMoveListener = function(callbackFunction){
  if (mode == 0){
    return;
  }
  if (typeof callbackFunction == UNDEFINED){
    throw new Error("setScreenMouseMoveListener error: callbackFunction is not defined.");
    return;
  }
  if (!(callbackFunction instanceof Function)){
    throw new Error("setScreenMouseMoveListener error: callbackFunction is not a function.");
    return;
  }
  screenMouseMoveCallbackFunction = callbackFunction;
}

// removeScreenMouseMoveListener
// Removes mouse move listener for screen.
Roygbiv.prototype.removeScreenMouseMoveListener = function(){
  if (mode == 0){
    return;
  }
  screenMouseMoveCallbackFunction = 0;
}

// setScreenPointerLockChangeListener
// Sets a callback function for Pointer Lock API status changes. The callbackFunction
// is executed with isPointerLocked parameter.
Roygbiv.prototype.setScreenPointerLockChangeListener = function(callbackFunction){
  if (mode == 0){
    return;
  }
  if (typeof callbackFunction == UNDEFINED){
    throw new Error("setScreenPointerLockChangeListener error: callbackFunction is not defined.");
    return;
  }
  if (!(callbackFunction instanceof Function)){
    throw new Error("setScreenPointerLockChangeListener error: callbackFunction is not a function.");
    return;
  }
  screenPointerLockChangedCallbackFunction = callbackFunction;
}

// removeScreenPointerLockChangeListener
// Removes the Pointer Lock change listener for the screen.
Roygbiv.prototype.removeScreenPointerLockChangeListener = function(){
  if (mode == 0){
    return;
  }
  screenPointerLockChangedCallbackFunction = 0;
}

// setParticleSystemPoolConsumedListener
// Sets a listener for particle system pool consumption. The callbackFunction is
// executed wheren there is no available particle system left inside the pool.
Roygbiv.prototype.setParticleSystemPoolConsumedListener = function(psPool, callbackFunction){
  if (mode == 0){
    return;
  }
  if (typeof psPool == UNDEFINED){
    throw new Error("setParticleSystemPoolConsumedListener error: psPool is not defined.");
    return;
  }
  if (typeof callbackFunction == UNDEFINED){
    throw new Error("setParticleSystemPoolConsumedListener error: callbackFunction is not defined.");
    return;
  }
  if (!(psPool.isParticleSystemPool)){
    throw new Error("setParticleSystemPoolConsumedListener error: psPool is not a ParticleSystemPool.");
    return;
  }
  if (!(callbackFunction instanceof Function)){
    throw new Error("setParticleSystemPoolConsumedListener error: callbackFunction is not a function.");
    return;
  }
  psPool.consumedCallback = callbackFunction;
}

// removeParticleSystemPoolConsumedListener
// Removes the consumption listener of a particle system pool.
Roygbiv.prototype.removeParticleSystemPoolConsumedListener = function(psPool){
  if (mode == 0){
    return;
  }
  if (typeof psPool == UNDEFINED){
    throw new Error("removeParticleSystemPoolConsumedListener error: psPool is not defined.");
    return;
  }
  if (!(psPool.isParticleSystemPool)){
    throw new Error("removeParticleSystemPoolConsumedListener error: psPool is not a ParticleSystemPool.");
    return;
  }
  psPool.consumedCallback = 0;
}

// setParticleSystemPoolAvailableListener
// Sets an availability listener for a particle system pool. The callbackFunction is executed
// when there is at least one available particle system inside the pool again.
Roygbiv.prototype.setParticleSystemPoolAvailableListener = function(psPool, callbackFunction){
  if (mode == 0){
    return;
  }
  if (typeof psPool == UNDEFINED){
    throw new Error("setParticleSystemPoolAvailableListener error: psPool is not defined.");
    return;
  }
  if (typeof callbackFunction == UNDEFINED){
    throw new Error("setParticleSystemPoolAvailableListener error: callbackFunction is not defined.");
    return;
  }
  if (!(psPool.isParticleSystemPool)){
    throw new Error("setParticleSystemPoolAvailableListener error: psPool is not a ParticleSystemPool.");
    return;
  }
  if (!(callbackFunction instanceof Function)){
    throw new Error("setParticleSystemPoolAvailableListener error: callbackFunction is not a function.");
    return;
  }
  psPool.availableCallback = callbackFunction;
}

// removeParticleSystemPoolAvailableListener
// Removes the availablity listener for a particle system pool.
Roygbiv.prototype.removeParticleSystemPoolAvailableListener = function(psPool){
  if (mode == 0){
    return;
  }
  if (typeof psPool == UNDEFINED){
    throw new Error("removeParticleSystemPoolAvailableListener error: psPool is not defined.");
    return;
  }
  if (!(psPool.isParticleSystemPool)){
    throw new Error("removeParticleSystemPoolAvailableListener error: psPool is not a ParticleSystemPool.");
    return;
  }
  psPool.availableCallback = 0;
}

// setFullScreenChangeCallbackFunction
// Sets a callback function for fullscreen change API. The callbackFunction is executed
// with isFullScreenOn boolean parameter when the fullscreen status is changed.
Roygbiv.prototype.setFullScreenChangeCallbackFunction = function(callbackFunction){
  if (mode == 0){
    return;
  }
  if (typeof callbackFunction == UNDEFINED){
    throw new Error("setFullScreenChangeCallbackFunction error: callbackFunction is not defined.");
    return;
  }
  if (!(callbackFunction instanceof Function)){
    throw new Error("setFullScreenChangeCallbackFunction error: callbackFunction is not a function.");
    return;
  }
  screenFullScreenChangeCallbackFunction = callbackFunction;
}

// removeFullScreenChangeCallbackFunction
// Removes the fullscreen change listener.
Roygbiv.prototype.removeFullScreenChangeCallbackFunction = function(){
  if (mode == 0){
    return;
  }
  screenFullScreenChangeCallbackFunction = 0;
}

// setFPSDropCallbackFunction
// Sets a callback function for FPS drops. The callbackFunction is executed
// with dropAmount parameter if the FPS is less than 60 for given second. The
// dropAmount is calculated using this formula: (60 - [current_fps])
Roygbiv.prototype.setFPSDropCallbackFunction = function(callbackFunction){
  if (mode == 0){
    return;
  }
  if (typeof callbackFunction == UNDEFINED){
    throw new Error("setFPSDropCallbackFunction error: callbackFunction is not defined.");
    return;
  }
  if (!(callbackFunction instanceof Function)){
    throw new Error("setFPSDropCallbackFunction error: callbackFunction is not a function.");
    return;
  }
  fpsDropCallbackFunction = callbackFunction;
}

// removeFPSDropCallbackFunction
// Removes the callback function for FPS drops.
Roygbiv.prototype.removeFPSDropCallbackFunction = function(){
  if (mode == 0){
    return;
  }
  fpsDropCallbackFunction = 0;
}

// setPerformanceDropCallbackFunction
// Sets a callback function for performance drops. The callbackFunction is executed
// if the FPS is under [minFPS] for [seconds] seconds. The callbackFunction is automatically
// removed after the execution, so use this function again if needed after the execution
// of the callbackFunction.
Roygbiv.prototype.setPerformanceDropCallbackFunction = function(minFPS, seconds, callbackFunction){
  if (mode == 0){
    return;
  }
  if (typeof minFPS == UNDEFINED){
    throw new Error("setPerformanceDropCallbackFunction error: minFPS is not defined.");
    return;
  }
  if (isNaN(minFPS)){
    throw new Error("setPerformanceDropCallbackFunction error: minFPS is not a number.");
    return;
  }
  if (!(minFPS > 0 && minFPS <= 60)){
    throw new Error("setPerformanceDropCallbackFunction error: minFPS must be between (0,60]");
    return;
  }
  if (typeof seconds == UNDEFINED){
    throw new Error("setPerformanceDropCallbackFunction error: seconds is not defined.");
    return;
  }
  if (isNaN(seconds)){
    throw new Error("setPerformanceDropCallbackFunction error: seconds is not a number.");
    return;
  }
  if (seconds <= 0){
    throw new Error("setPerformanceDropCallbackFunction error: seconds must be greater than zero.");
    return;
  }
  if (typeof callbackFunction == UNDEFINED){
    throw new Error("setPerformanceDropCallbackFunction error: callbackFunction is not defined.");
    return;
  }
  if (!(callbackFunction instanceof Function)){
    throw new Error("setPerformanceDropCallbackFunction error: callbackFunction is not a function.");
    return;
  }
  performanceDropCallbackFunction = callbackFunction;
  fpsHandler.initiatePerformanceDropMonitoring(minFPS, seconds);
}

// removePerformanceDropCallbackFunction
// Removes the callback function for performance drops.
Roygbiv.prototype.removePerformanceDropCallbackFunction = function(){
  if (mode == 0){
    return;
  }
  performanceDropCallbackFunction = 0;
  fpsHandler.reset();
}

// setUserInactivityCallbackFunction
// Sets a callback function for user inactivity. The callbackFunction is executed
// if the user does not move or press the mouse or press a key for more than maxTimeInSeconds seconds.
// The callbackFunction is reset after the execution so use this function again to create a new
// inactivity listener.
Roygbiv.prototype.setUserInactivityCallbackFunction = function(maxTimeInSeconds, callbackFunction){
  if (mode == 0){
    return;
  }
  if (typeof maxTimeInSeconds == UNDEFINED){
    throw new Error("setUserInactivityCallbackFunction error: maxTimeInSeconds is not defined.");
    return;
  }
  if (isNaN(maxTimeInSeconds)){
    throw new Error("setUserInactivityCallbackFunction error: maxTimeInSeconds is not a number.");
    return;
  }
  if (maxTimeInSeconds <= 0){
    throw new Error("setUserInactivityCallbackFunction error: maxTimeInSeconds must be greater than zero.");
    return;
  }
  if (typeof callbackFunction == UNDEFINED){
    throw new Error("setUserInactivityCallbackFunction error: callbackFunction is not defined.");
    return;
  }
  if (!(callbackFunction instanceof Function)){
    throw new Error("setUserInactivityCallbackFunction error: callbackFunction is not a function.");
    return;
  }
  inactiveCounter = 0;
  maxInactiveTime = maxTimeInSeconds;
  userInactivityCallbackFunction = callbackFunction;
}

// removeUserInactivityCallbackFunction
// Removes the user inactivity callback function.
Roygbiv.prototype.removeUserInactivityCallbackFunction = function(){
  if (mode == 0){
    return;
  }
  inactiveCounter = 0;
  userInactivityCallbackFunction = 0;
  maxInactiveTime = 0;
}

// setScreenKeydownListener
// Sets a keydown listener. The callbackFunction is executed with the pressedChar
// parameter. See the values of keyCodeToChar variable for possible pressedChar
// parameters.
Roygbiv.prototype.setScreenKeydownListener = function(callbackFunction){
  if (mode == 0){
    return;
  }
  if (typeof callbackFunction == UNDEFINED){
    throw new Error("setScreenKeydownListener error: callbackFunction is not defined.");
    return;
  }
  if (!(callbackFunction instanceof Function)){
    throw new Error("setScreenKeydownListener error: callbackFunction is not a function.");
    return;
  }
  screenKeydownCallbackFunction = callbackFunction;
}

// removeScreenKeydownListener
// Removes the keydown listener.
Roygbiv.prototype.removeScreenKeydownListener = function(){
  if (mode == 0){
    return;
  }
  screenKeydownCallbackFunction = 0;
}

// setScreenKeyupListener
// Sets a keyup listener. The callbackFunction is executed with the uppedChar
// parameter. See the values of keyCodeToChar variable for possible uppedChar
// parameters.
Roygbiv.prototype.setScreenKeyupListener = function(callbackFunction){
  if (mode == 0){
    return;
  }
  if (typeof callbackFunction == UNDEFINED){
    throw new Error("setScreenKeyupListener error: callbackFunction is not defined.");
    return;
  }
  if (!(callbackFunction instanceof Function)){
    throw new Error("setScreenKeyupListener error: callbackFunction is not a function.");
    return;
  }
  screenKeyupCallbackFunction = callbackFunction;
}

// removeScreenKeyupListener
// Removes the keyup listener.
Roygbiv.prototype.removeScreenKeyupListener = function(){
  if (mode == 0){
    return;
  }
  screenKeyupCallbackFunction = 0;
}

// onTextClick
// Sets a click listener for a text object. The callbackFunction is executed
// with textName parameter when the text object is clicked.
Roygbiv.prototype.onTextClick = function(text, callbackFunction){
  if (mode == 0){
    return;
  }
  if (typeof text == UNDEFINED){
    throw new Error("onTextClick error: text is not defined.");
    return;
  }
  if (!text.isAddedText){
    throw new Error("onTextClick error: text is not a text object.");
    return;
  }
  if (typeof callbackFunction == UNDEFINED){
    throw new Error("onTextClick error: callbackFunction is not defined.");
    return;
  }
  if (!(callbackFunction instanceof Function)){
    throw new Error("onTextClick error: callbackFunction is not a function.");
    return;
  }
  if (!text.isClickable){
    throw new Error("onTextClick error: text is not marked as clickable.");
    return;
  }
  text.clickCallbackFunction = callbackFunction;
}

// removeTextClickListener
// Removes the click listener of a text object.
Roygbiv.prototype.removeTextClickListener = function(text){
  if (mode == 0){
    return;
  }
  if (typeof text == UNDEFINED){
    throw new Error("removeTextClickListener error: text is not defined.");
    return;
  }
  if (!text.isAddedText){
    throw new Error("removeTextClickListener error: text is not a text object.");
    return;
  }
  text.clickCallbackFunction = 0;
}

// TEXT FUNCTIONS **************************************************************

//setText
// Sets a text to a text object.
Roygbiv.prototype.setText = function(textObject, text){
  if (mode == 0){
    return;
  }
  if (typeof textObject == UNDEFINED){
    throw new Error("setText error: textObject is not defined.");
    return;
  }
  if (!textObject.isAddedText){
    throw new Error("setText error: textObject is not a text object.");
    return;
  }
  if (typeof text == UNDEFINED){
    throw new Error("setText error: text is not defined.");
    return;
  }
  if (!(typeof text == "string")){
    throw new Error("setText error: text is not a string.");
    return;
  }
  textObject.setText(text, true);
}

// setTextColor
// Sets the color of a text. colorName can be a color name like red or an hex string
// like #afef54.
Roygbiv.prototype.setTextColor = function(text, colorName){
  if (mode == 0){
    return;
  }
  if (typeof text == UNDEFINED){
    throw new Error("setTextColor error: text is not defined.");
    return;
  }
  if (!text.isAddedText){
    throw new Error("setTextColor error: text is not a text object.");
    return;
  }
  if (typeof colorName == UNDEFINED){
    throw new Error("setTextColor error: colorName is not defined.");
  }
  text.setColor(colorName, true);
}

// setTextAlpha
// Sets the alpha of a text.
Roygbiv.prototype.setTextAlpha = function(text, alpha){
  if (mode == 0){
    return;
  }
  if (typeof text == UNDEFINED){
    throw new Error("setTextAlpha error: text is not defined.");
    return;
  }
  if (!text.isAddedText){
    throw new Error("setTextAlpha error: text is not a text object.");
    return;
  }
  if (typeof alpha == UNDEFINED){
    throw new Error("setTextAlpha error: alpha is not defined.");
    return;
  }
  if (isNaN(alpha)){
    throw new Error("setTextAlpha error: alpha is not a number.");
    return;
  }
  text.setAlpha(alpha, true);
}

// setTextPosition
// Sets the position of a text object.
Roygbiv.prototype.setTextPosition = function(text, x, y, z){
  if (mode == 0){
    return;
  }
  if (typeof text == UNDEFINED){
    throw new Error("setTextPosition error: text is not defined.");
    return;
  }
  if (!text.isAddedText){
    throw new Error("setTextPosition error: text is not a text object.");
    return;
  }
  if (text.is2D){
    throw new Error("setTextPosition error: Cannot set position of a 2D text.");
    return;
  }
  if (isNaN(x)){
    throw new Error("setTextPosition error: Bad x parameter");
    return;
  }
  if (isNaN(y)){
    throw new Error("setTextPosition error: Bad y parameter.");
    return;
  }
  if (isNaN(z)){
    throw new Error("setTextPosition error: Bad z parameter.");
    return;
  }
  text.mesh.position.set(x, y, z);
}

// setTextBackground
// Sets the background color/alpha of a text object.
Roygbiv.prototype.setTextBackground = function(text, colorName, alpha){
  if (mode == 0){
    return;
  }
  if (typeof text == UNDEFINED){
    throw new Error("setTextBackground error: text is not defined.");
    return;
  }
  if (!text.isAddedText){
    throw new Error("setTextBackground error: text is not a text object.");
    return;
  }
  if (!text.hasBackground){
    throw new Error("setTextBackground error: text has no background.");
    return;
  }
  if (typeof colorName == UNDEFINED){
    throw new Error("setTextBackground error: colorName is not defined.");
    return;
  }
  if (!(typeof colorName == "string")){
    throw new Error("setTextBackground error: colorName is not a string.");
    return;
  }
  if (typeof alpha == UNDEFINED){
    throw new Error("setTextBackground error: alpha is not defined.");
    return;
  }
  if (isNaN(alpha)){
    throw new Error("setTextBackground error: Bad alpha parameter.");
    return;
  }
  text.setBackground(colorName, alpha, true);
}

// removeTextBackground
// Removes the background of a text object.
Roygbiv.prototype.removeTextBackground = function(text){
  if (mode == 0){
    return;
  }
  if (typeof text == UNDEFINED){
    throw new Error("removeTextBackground error: text is not defined.");
    return;
  }
  if (!text.isAddedText){
    throw new Error("removeTextBackground error: text is not a text object.");
    return;
  }
  if (!text.hasBackground){
    throw new Error("removeBackground error: text has no background.");
    return;
  }
  text.removeBackground(true);
}

// setTextCenterPosition
// Puts the center of the given text object to given x, y, z coordinates.
Roygbiv.prototype.setTextCenterPosition = function(text, x, y, z){
  if (mode == 0){
    return;
  }
  if (typeof text == UNDEFINED){
    throw new Error("setTextCenterPosition error: text is not defined.");
    return;
  }
  if (!text.isAddedText){
    throw new Error("setTextCenterPosition error: text is not a text object.");
    return;
  }
  if (text.is2D){
    throw new Error("setTextCenterPosition error: Cannot set position of a 2D text.");
    return;
  }
  if (isNaN(x)){
    throw new Error("setTextCenterPosition error: Bad x parameter.");
    return;
  }
  if (isNaN(y)){
    throw new Error("setTextCenterPosition error: Bad y parameter.");
    return;
  }
  if (isNaN(z)){
    throw new Error("setTextCenterPosition error: Bad z parameter.");
    return;
  }
  var centerPos = text.getCenterCoordinates();
  text.mesh.position.set(
    text.mesh.position.x + (x - centerPos.x),
    text.mesh.position.y + (y - centerPos.y),
    text.mesh.position.z + (z - centerPos.z)
  );
}

// hideText
// Makes the given text object invisible. Does nothing if the text is already
// invisible.
Roygbiv.prototype.hideText = function(text){
  if (mode == 0){
    return;
  }
  if (typeof text == UNDEFINED){
    throw new Error("hideText error: text is not defined.");
    return;
  }
  if (!text.isAddedText){
    throw new Error("hideText error: text is not a text object.");
    return;
  }
  if (text.mesh.visible){
    text.hide();
  }
}

// showText
// Makes the given text object visible. Does nothing if the text is already
// visible.
Roygbiv.prototype.showText = function(text){
  if (mode == 0){
    return;
  }
  if (typeof text == UNDEFINED){
    throw new Error("showText error: text is not defined.");
    return;
  }
  if (!text.isAddedText){
    throw new Error("showText error: text is not a text object.");
    return;
  }
  if (!text.mesh.visible){
    text.show();
  }
}

// UTILITY FUNCTIONS ***********************************************************

// vector
//  Creates a new vector from x, y and z coordinates.
Roygbiv.prototype.vector = function(x, y, z){
  if (mode == 0){
    return;
  }
  if (typeof x == UNDEFINED){
    throw new Error("vector error: x is not defined.");
    return;
  }
  if (typeof y == UNDEFINED){
    throw new Error("vector error: y is not defined.");
    return;
  }
  if (typeof z == UNDEFINED){
    throw new Error("vector error: z is not defined.");
    return;
  }
  var obj = new Object();
  obj.x = x;
  obj.y = y;
  obj.z = z;

  return obj;
}

// distance
//  Returns the distance between two vectors.
Roygbiv.prototype.distance = function(vec1, vec2){
  if (mode == 0){
    return;
  }
  if (!vec1){
    throw new Error("distance error: vec1 is not defined.");
    return;
  }
  if (!vec2){
    throw new Error("distance error: vec2 is not defined.");
    return;
  }
  if (isNaN(vec1.x) || isNaN(vec1.y) || isNaN(vec1.z)){
    throw new Error("distance error: vec1 is not a vector.");
    return;
  }
  if (isNaN(vec2.x) || isNaN(vec2.y) || isNaN(vec2.z)){
    throw new Error("distance error: vec2 is not a vector.");
    return;
  }
  var dx = vec2.x - vec1.x;
  var dy = vec2.y - vec1.y;
  var dz = vec2.z - vec1.z;
  return Math.sqrt(
    Math.pow(dx, 2) + Math.pow(dy, 2) + Math.pow(dz, 2)
  );
}

// sub
//  Returns the substraction of two vectors.
Roygbiv.prototype.sub = function(vec1, vec2, targetVector){
  if (mode == 0){
    return;
  }
  if (!vec1){
    throw new Error("sub error: vec1 is not defined.");
    return;
  }
  if (!vec2){
    throw new Error("sub error: vec2 is not defined.");
    return;
  }
  if (isNaN(vec1.x) || isNaN(vec1.y) || isNaN(vec1.z)){
    throw new Error("sub error: vec1 is not a vector.");
    return;
  }
  if (isNaN(vec2.x) || isNaN(vec2.y) || isNaN(vec2.z)){
    throw new Error("sub error: vec2 is not a vector.");
    return;
  }
  if (!(typeof targetVector == UNDEFINED)){
    if (isNaN(targetVector.x) || isNaN(targetVector.y) || isNaN(targetVector.z)){
      throw new Error("sub error: Bad targetVector parameter.");
      return;
    }
    targetVector.x = vec1.x - vec2.x;
    targetVector.y = vec1.y - vec2.y;
    targetVector.z = vec1.z - vec2.z;
    return targetVector;
  }
  var obj = new Object();
  obj.x = vec1.x - vec2.x;
  obj.y = vec1.y - vec2.y;
  obj.z = vec1.z - vec2.z;
  return obj;
}

// add
//  Returns the summation of two vectors.
Roygbiv.prototype.add = function(vec1, vec2){
  if (mode == 0){
    return;
  }
  if (!vec1){
    throw new Error("add error: vec1 is not defined.");
    return;
  }
  if (!vec2){
    throw new Error("add error: vec2 is not defined.");
    return;
  }
  if (isNaN(vec1.x) || isNaN(vec1.y) || isNaN(vec1.z)){
    throw new Error("add error: vec1 is not a vector.");
    return;
  }
  if (isNaN(vec2.x) || isNaN(vec2.y) || isNaN(vec2.z)){
    throw new Error("add error: vec2 is not a vector.");
    return;
  }
  var obj = new Object();
  obj.x = vec1.x + vec2.x;
  obj.y = vec1.y + vec2.y;
  obj.z = vec1.z + vec2.z;
  return obj;
}

// moveTowards
//  Moves vec1 towards vec2 by given amount and returns the new position of vec1.
//  Amount = 1 means that vec1 goes all the way towards vec2.
Roygbiv.prototype.moveTowards = function(vec1, vec2, amount, targetVector){
  if (mode == 0){
    return;
  }
  if (!vec1){
    throw new Error("moveTowards error: vec1 is not defined.");
    return;
  }
  if (!vec2){
    throw new Error("moveTowards error: vec2 is not defined.");
    return;
  }
  if (isNaN(vec1.x) || isNaN(vec1.y) || isNaN(vec1.z)){
    throw new Error("moveTowards error: vec1 is not a vector.");
    return;
  }
  if (isNaN(vec2.x) || isNaN(vec2.y) || isNaN(vec2.z)){
    throw new Error("moveTowards error: vec2 is not a vector.");
    return;
  }
  if (typeof amount == UNDEFINED){
    throw new Error("moveTowards error: amount is not defined.");
    return;
  }
  if (isNaN(amount)){
    throw new Error("moveTowards error: amount is not a number.");
    return;
  }
  if (!(typeof targetVector == UNDEFINED)){
    if (isNaN(targetVector.x) || isNaN(targetVector.y) || isNaN(targetVector.z)){
      throw new Error("moveTowards error: Bad targetVector parameter.");
    }
    var diff = this.sub(vec2, vec1, targetVector);
    targetVector.x = vec1.x + (amount * diff.x);
    targetVector.y = vec1.y + (amount * diff.y);
    targetVector.z = vec1.z + (amount * diff.z);
    return targetVector;
  }
  var diff = this.sub(vec2, vec1);
  var newVec = this.vector(0, 0, 0);
  newVec.x = vec1.x + (amount * diff.x);
  newVec.y = vec1.y + (amount * diff.y);
  newVec.z = vec1.z + (amount * diff.z);
  return newVec;
}

// applyNoise
//  Applies Perlin noise to given vector [amount] times and returns the
//  distorted value. The default amount is 1. Setting the amount too high can
//  cause performance issues.
Roygbiv.prototype.applyNoise = function(vec, amount){
  if (mode == 0){
    return;
  }
  if (!vec){
    throw new Error("applyNoise error: vector is not defined.");
    return;
  }
  if (typeof vec.x == UNDEFINED || typeof vec.y == UNDEFINED || typeof vec.z == UNDEFINED){
    throw new Error("applyNoise error: vector format not supported.");
    return;
  }
  if (isNaN(vec.x) || isNaN(vec.y) || isNaN(vec.z)){
    throw new Error("applyNoise error: vector format not supported.");
    return;
  }

  var toNormalize = REUSABLE_VECTOR.set(vec.x, vec.y, vec.z);
  toNormalize.normalize();
  var noiseAmount = noise.perlin3(
    toNormalize.x, toNormalize.y, toNormalize.z
  );
  var vector3 = REUSABLE_VECTOR_2.set(vec.x, vec.y, vec.z);
  var toMultiplyScalar = REUSABLE_VECTOR_3.set(vec.x, vec.y, vec.z);
  toMultiplyScalar.multiplyScalar(noiseAmount);
  vector3.add(toMultiplyScalar);
  if (!amount){
    return this.vector(vector3.x, vector3.y, vector3.z);
  }else if (amount && !isNaN(amount) && amount > 1){
    var noised = this.vector(vector3.x, vector3.y, vector3.z);
    for (var i = 0; i<amount; i++){
      noised = this.applyNoise(noised);
    }
    return noised;
  }
}

// sphericalDistribution
//  Returns a vector sampled around an imaginary sphere of given radius centered
//  at (0, 0, 0)
Roygbiv.prototype.sphericalDistribution = function(radius){
  if (mode == 0){
    return;
  }
  if (!radius){
    throw new Error("sphericalDistribution error: radius is not defined.");
    return;
  }
  if (isNaN(radius)){
    throw new Error("sphericalDistribution error: radius is not numerical.");
    return;
  }
  if (radius <= 0){
    throw new Error("sphericalDistribution error: radius is not a positive number.");
    return;
  }

  REUSABLE_VECTOR.set(
    Math.random() - 0.5,
    Math.random() - 0.5,
    Math.random() - 0.5
  );

  REUSABLE_VECTOR.normalize();
  REUSABLE_VECTOR.multiplyScalar(radius);
  return this.vector(REUSABLE_VECTOR.x, REUSABLE_VECTOR.y, REUSABLE_VECTOR.z);
}

// boxDistribution
//  Returns a vector sampled on a face of a box centered at (0, 0, 0).
//  The size of the boxis specified with the parameters sizeX, sizeY and sizeZ.
//  The optional parameter side can be used to generate the point on a
//  specific face.
//  side = 1 -> UP
//  side = 2 -> DOWN
//  side = 3 -> FRONT
//  side = 4 -> BACK
//  side = 5 -> RIGHT
//  side = 6 -> LEFT
Roygbiv.prototype.boxDistribution = function(sizeX, sizeY, sizeZ, side){
  if (mode == 0){
    return;
  }
  if (typeof sizeX == UNDEFINED || typeof sizeY == UNDEFINED || typeof sizeZ == UNDEFINED){
    throw new Error("boxDistribution error: Bad parameters.");
    return;
  }
  if (isNaN(sizeX) || isNaN(sizeY) || isNaN(sizeZ)){
    throw new Error("boxDistribution error: Bad parameters.");
    return;
  }
  if (sizeX < 0 || sizeY < 0 || sizeZ < 0){
    throw new Error("boxDistribution error: Bad parameters.");
    return;
  }
  var randomSide = Math.floor(Math.random() * 6) + 1;
  if (typeof side != UNDEFINED &&!isNaN(side) && side <= 6 && side >= 1){
    randomSide = side;
  }
  var x, y, z;
  var maxX = sizeX / 2, minX = -1 * sizeX / 2;
  var maxY = sizeY / 2, minY = -1 * sizeY / 2;
  var maxZ = sizeZ / 2, minZ = -1 * sizeZ / 2;
  // 1, 2 -> XZ
  // 3, 4 -> XY
  // 5, 6 -> YZ
  switch (randomSide){
    case 1:
      y = sizeY / 2;
    break;
    case 2:
      y = -1 * sizeY / 2;
    break;
    case 3:
      z = sizeZ / 2;
    break;
    case 4:
      z = -1 * sizeZ / 2;
    break;
    case 5:
      x = sizeX / 2;
    break;
    case 6:
      x = -1 * sizeX / 2;
    break;
  }
  if (typeof x == UNDEFINED){
    x = Math.random () * (maxX - minX) + minX;
  }
  if (typeof y == UNDEFINED){
    y = Math.random () * (maxY - minY) + minY;
  }
  if (typeof z == UNDEFINED){
    z = Math.random () * (maxZ - minZ) + minZ;
  }
  return this.vector(x, y, z);
}

// color
//  Creates a new color object from the given HTML color name.
Roygbiv.prototype.color = function(colorName){
  if (mode == 0){
    return;
  }
  if (!colorName){
    throw new Error("color error: colorName is not defined.");
    return;
  }
  return new THREE.Color(colorName.toLowerCase());
}

// runScript
//  Starts a script of the given name. If parameters are provided, they may
//  be reached using this.[parameterName] within the newly started script.
Roygbiv.prototype.runScript = function(name, parameters){
  if (mode == 0){
    return;
  }
  var script = scripts[name];
  if (!script){
    throw new Error("runScript error: Script is undefined.");
    return;
  }
  if (parameters){
    for (var key in parameters){
      script[key] = parameters[key];
    }
  }
  script.start();
}

// isRunning
//  Returns whether a script of the given name is running or not.
Roygbiv.prototype.isRunning = function(name){
  if (mode == 0){
    return;
  }
  var script = scripts[name];
  if (!script){
    throw new Error("isRunning error: Script is undefined.");
    return;
  }
  return script.status == SCRIPT_STATUS_STARTED;
}

// normalizeVector
//  Normalizes the vector given in the parameter. Note that this function modifies directly the
//  parameter and returns nothing.
Roygbiv.prototype.normalizeVector = function(vector){
  if (mode == 0){
    return;
  }
  if (typeof vector == UNDEFINED){
    throw new Error("normalizeVector error: vector is not defined.");
    return;
  }
  if (isNaN(vector.x) || isNaN(vector.y) || isNaN(vector.z)){
    throw new Error("normalizeVector error: Bad vector parameter.");
    return;
  }
  var len = Math.sqrt((vector.x * vector.x) + (vector.y * vector.y) + (vector.z * vector.z));
  vector.x = vector.x / len;
  vector.y = vector.y / len;
  vector.z = vector.z / len;
}

// computeQuaternionFromVectors
//  Returns the quaternion between two vectors.
Roygbiv.prototype.computeQuaternionFromVectors = function(vec1, vec2, targetQuaternion){
  if (mode == 0){
    return;
  }
  if (typeof vec1 == UNDEFINED){
    throw new Error("computeQuaternionFromVectors error: vec1 is not defined.");
    return;
  }
  if (typeof vec2 == UNDEFINED){
    throw new Error("computeQuaternionFromVectors error: vec2 is not defined.");
    return;
  }
  if (isNaN(vec1.x) || isNaN(vec1.y) || isNaN(vec1.z)){
    throw new Error("computeQuaternionFromVectors error: Bad vec1 parameter.");
    return;
  }
  if (isNaN(vec2.x) || isNaN(vec2.y) || isNaN(vec2.z)){
    throw new Error("computeQuaternionFromVectors error: Bad vec2 parameter.");
    return;
  }
  if (!(typeof targetQuaternion == UNDEFINED)){
    if (isNaN(targetQuaternion.x) || isNaN(targetQuaternion.y) || isNaN(targetQuaternion.z) || isNaN(targetQuaternion.w)){
      throw new Error("computeQuaternionFromVectors error: Bad targetQuaternion parameter.");
      return;
    }
  }
  this.normalizeVector(vec1);
  this.normalizeVector(vec2);
  REUSABLE_VECTOR.set(vec1.x, vec1.y, vec1.z);
  REUSABLE_VECTOR_2.set(vec2.x, vec2.y, vec2.z);
  REUSABLE_QUATERNION.setFromUnitVectors(REUSABLE_VECTOR, REUSABLE_VECTOR_2);
  if (!targetQuaternion){
    return REUSABLE_QUATERNION.clone();
  }else{
    targetQuaternion.set(
      REUSABLE_QUATERNION.x, REUSABLE_QUATERNION.y, REUSABLE_QUATERNION.z, REUSABLE_QUATERNION.w
    );
    return targetQuaternion;
  }
}

// circularDistribution
//  Returns a random point sampled around an imaginary circle with given radius and given
//  quaternion in 3D space. If no quaternion is specified the circle is sampled on the XY plane.
Roygbiv.prototype.circularDistribution = function(radius, quaternion){
  if (mode == 0){
    return;
  }
  if (typeof radius == UNDEFINED){
    throw new Error("circularDistribution error: radius is not defined.");
    return;
  }
  if (isNaN(radius)){
    throw new Error("circularDistribution error: Bad radius parameter.");
    return;
  }
  if (radius <= 0){
    throw new Error("circularDistribution error: radius must be greater than zero.");
    return;
  }
  if (!(typeof quaternion == UNDEFINED)){
    if (isNaN(quaternion.x) || isNaN(quaternion.y) || isNaN(quaternion.y) || isNaN(quaternion.w)){
      throw new Error("circularDistribution error: Bad quaternion parameter.");
      return;
    }
  }
  REUSABLE_VECTOR_3.set(
    Math.random() - 0.5,
    Math.random() - 0.5,
    0
  );
  REUSABLE_VECTOR_3.normalize();
  REUSABLE_VECTOR_3.multiplyScalar(radius);
  if (!(typeof quaternion == UNDEFINED)){
    REUSABLE_VECTOR_3.applyQuaternion(quaternion);
  }
  return this.vector(REUSABLE_VECTOR_3.x, REUSABLE_VECTOR_3.y, REUSABLE_VECTOR_3.z);
}

// multiplyScalar
//  Multiplies a vector by a scalar.
Roygbiv.prototype.multiplyScalar = function(vector, scalar, targetVector){
  if (mode == 0){
    return;
  }
  if (typeof scalar == UNDEFINED){
    throw new Error("multiplyScalar error: scalar is not defined.");
    return;
  }
  if (isNaN(scalar)){
    throw new Error("multiplyScalar error: Bad scalar parameter.");
    return;
  }
  if (typeof vector == UNDEFINED){
    throw new Error("multiplyScalar error: vector is not defined.");
    return;
  }
  if (isNaN(vector.x) || isNaN(vector.y) || isNaN(vector.z)){
    throw new Error("multiplyScalar error: Bad vector parameter.");
    return;
  }
  if (!(typeof targetVector == UNDEFINED)){
    if (isNaN(targetVector.x) || isNaN(targetVector.y) || isNaN(targetVector.z)){
      throw new Error("multiplyScalar error: Bad targetVector parameter.");
      return;
    }
  }
  if (!targetVector){
    return this.vector(vector.x * scalar, vector.y * scalar, vector.z * scalar);
  }else{
    targetVector.x = vector.x * scalar;
    targetVector.y = vector.y * scalar;
    targetVector.z = vector.z * scalar;
    return targetVector;
  }
}

// setVector
// Set the x, y, z components of a vector.
Roygbiv.prototype.setVector = function(vector, x, y, z){
  if (mode == 0){
    return;
  }
  if (typeof vector == UNDEFINED){
    throw new Error("setVector error: vector is not defined.");
    return;
  }
  if (typeof x == UNDEFINED){
    throw new Error("setVector error: x is not defined.");
    return;
  }
  if (typeof y == UNDEFINED){
    throw new Error("setVector error: y is not defined.");
    return;
  }
  if (typeof z == UNDEFINED){
    throw new Error("setVector error: z is not defined.");
    return;
  }
  if (isNaN(x) || isNaN(y) || isNaN(y)){
    throw new Error("setVector error: Components must be numerical.");
    return;
  }
  vector.x = x;
  vector.y = y;
  vector.z = z;
  return vector;
}

// quaternion
// Returns a new THREE.Quaternion instance.
Roygbiv.prototype.quaternion = function(){
  return new THREE.Quaternion();
}

// requestPointerLock
// Requests pointer lock from window on the next click.
Roygbiv.prototype.requestPointerLock = function(){
  if (mode == 0){
    return;
  }
  if (!pointerLockSupported){
    throw new Error("requestPointerLock error: Pointer Lock API is not supported by this browser.");
    return;
  }
  pointerLockRequested = true;
}

// convertEulerToDegrees
// Returns the degree equivalent of an Euler angle.
Roygbiv.prototype.convertEulerToDegrees = function(eulerAngle){
  if (mode == 0){
    return;
  }
  if (typeof eulerAngle == UNDEFINED){
    throw new Error("convertEulerToDegrees error: eulerAngle is not defined.");
    return;
  }
  return ((eulerAngle * 180) / Math.PI);
}

// disableDefaultControls
// Disables or enables the default WASD camera controls. This function can be used
// before implementing manual camera controls.
Roygbiv.prototype.disableDefaultControls = function(isDisabled){
  if (mode == 0){
    return;
  }
  if (typeof isDisabled == UNDEFINED){
    throw new Error("disableDefaultControls error: isDisabled is not defined.");
    return;
  }
  if (!(typeof isDisabled == "boolean")){
    throw new Error("disableDefaultControls error: isDisabled is not a boolean.");
    return;
  }
  defaultCameraControlsDisabled = isDisabled;
}

// isKeyPressed
// Returns whether the given key is pressed or not. See the keyCodeToChar
// variable for possible key names.
Roygbiv.prototype.isKeyPressed = function(key){
  if (mode == 0){
    return;
  }
  if (typeof key == UNDEFINED){
    throw new Error("isKeyPressed error: key is not defined.");
    return;
  }
  return keyboardBuffer[key];
}

// setCameraPosition
// Sets the position of the camera.
Roygbiv.prototype.setCameraPosition = function(x, y, z){
  if (mode == 0){
    return;
  }
  if (typeof x == UNDEFINED){
    throw new Error("setCameraPosition error: x is not defined.");
    return;
  }
  if (typeof y == UNDEFINED){
    throw new Error("setCameraPosition error: y is not defined.");
    return;
  }
  if (typeof z == UNDEFINED){
    throw new Error("setCameraPosition error: z is not defined.");
    return;
  }
  if (isNaN(x)){
    throw new Error("setCameraPosition error: x is not a number.");
    return;
  }
  if (isNaN(y)){
    throw new Error("setCameraPosition error: y is not a number.");
    return;
  }
  if (isNaN(z)){
    throw new Error("setCameraPosition error: z is not a number.");
    return;
  }
  camera.position.set(x, y, z);
}

// lookAt
// Makes the camera look at specific position.
Roygbiv.prototype.lookAt = function(x, y, z){
  if (mode == 0){
    return;
  }
  if (typeof x == UNDEFINED){
    throw new Error("lookAt error: x is not defined.");
    return;
  }
  if (typeof y == UNDEFINED){
    throw new Error("lookAt error: y is not defined.");
    return;
  }
  if (typeof z == UNDEFINED){
    throw new Error("lookAt error: z is not defined.");
    return;
  }
  if (isNaN(x)){
    throw new Error("lookAt error: x is not a number.");
    return;
  }
  if (isNaN(y)){
    throw new Error("lookAt error: y is not a number.");
    return;
  }
  if (isNaN(z)){
    throw new Error("lookAt error: z is not a number.");
    return;
  }
  camera.lookAt(x, y, z);
}

// applyAxisAngle
// Rotates the vector around an axis by given angle.
Roygbiv.prototype.applyAxisAngle = function(vector, axisVector, angle, targetVector){
  if (mode == 0){
    return;
  }
  if (typeof vector == UNDEFINED){
    throw new Error("applyAxisAngle error: vector is not defined.");
    return;
  }
  if (typeof axisVector == UNDEFINED){
    throw new Error("applyAxisAngle error: axisVector is not defined.");
    return;
  }
  if (typeof angle == UNDEFINED){
    throw new Error("applyAxisAngle error: angle is not defined.");
    return;
  }
  if (isNaN(vector.x) || isNaN(vector.y) || isNaN(vector.z)){
    throw new Error("applyAxisAngle error: Bad vector parameter.");
    return;
  }
  if (isNaN(axisVector.x) || isNaN(axisVector.y) || isNaN(axisVector.z)){
    throw new Error("applyAxisAngle error: Bad axisVector parameter.");
    return;
  }
  if (isNaN(angle)){
    throw new Error("applyAxisAngle error: Bad angle parameter.");
    return;
  }
  REUSABLE_VECTOR.set(vector.x, vector.y, vector.z);
  REUSABLE_VECTOR_2.set(axisVector.x, axisVector.y, axisVector.z);
  REUSABLE_VECTOR.applyAxisAngle(REUSABLE_VECTOR_2, angle);
  if (!(typeof targetVector == UNDEFINED)){
    if (isNaN(targetVector.x) || isNaN(targetVector.y) || isNaN(targetVector.z)){
      throw new Error("applyAxisAngle error Bad targetVector parameter.");
      return;
    }
    targetVector.x = REUSABLE_VECTOR.x;
    targetVector.y = REUSABLE_VECTOR.y;
    targetVector.z = REUSABLE_VECTOR.z;
    return targetVector;
  }
  return this.vector(REUSABLE_VECTOR.x, REUSABLE_VECTOR.y, REUSABLE_VECTOR.z);
}

// trackObjectPosition
// Makes sourceObject keep its relative position to targetObject.
Roygbiv.prototype.trackObjectPosition = function(sourceObject, targetObject){
  if (mode == 0){
    return;
  }
  if (typeof sourceObject == UNDEFINED){
    throw new Error("trackObjectPosition error: sourceObject is not defined.");
    return;
  }
  if (typeof targetObject == UNDEFINED){
    throw new Error("trackObjectPosition error: targetObject is not defined.");
    return;
  }
  if (!(sourceObject.isAddedObject || sourceObject.isObjectGroup)){
    throw new Error("trackObjectPosition error: sourceObject type not supported.");
    return;
  }
  if (!(targetObject.isAddedObject || targetObject.isObjectGroup)){
    throw new Error("trackObjectPosition error: targetObject type not supported.");
    return;
  }
  if (targetObject.parentObjectName || sourceObject.parentObjectName){
    throw new Error("trackObjectPosition error: Child objects do not support this function.");
    return;
  }
  if (!targetObject.isDynamicObject){
    throw new Error("trackObjectPosition error: targetObject is not a dynamic object.");
    return;
  }
  if (sourceObject.isDynamicObject){
    throw new Error("trackObjectPosition error: sourceObject is a dynamic object.");
    return;
  }
  if (!sourceObject.isChangeable){
    throw new Error("trackObjectPosition error: sourceObject is not marked as changeable.");
    return;
  }
  sourceObject.trackedObject = targetObject;
  targetObject.isTracked = true;
  trackingObjects[sourceObject.name] = sourceObject;
  targetObject.oldPX = targetObject.physicsBody.position.x;
  targetObject.oldPY = targetObject.physicsBody.position.y;
  targetObject.oldPZ = targetObject.physicsBody.position.z;
}

// untrackObjectPosition
// Stops tracking an objects position for an object.
Roygbiv.prototype.untrackObjectPosition = function(sourceObject){
  if (mode == 0){
    return;
  }
  if (typeof sourceObject == UNDEFINED){
    throw new Error("untrackObjectPosition error: sourceObject is not defined.");
    return;
  }
  if (!(sourceObject.isAddedObject || sourceObject.isObjectGroup)){
    throw new Error("untrackObjectPosition error: sourceObject type not supported.");
    return;
  }
  delete sourceObject.trackedObject;
  delete trackingObjects[sourceObject.name];
}

// createRotationPivot
// Creates and returns a rotation pivot for an object. This function is not
// optimized for the runtime. Use this function before setRotationPivot API on
// initialization. Instead of ROYGBIV.rotate API that works on world axes, this
// function may be used with 0 offset parameters to achieve local rotation for objects.
Roygbiv.prototype.createRotationPivot = function(sourceObject, offsetX, offsetY, offsetZ){
  if (mode == 0){
    return;
  }
  if (typeof sourceObject == UNDEFINED){
    throw new Error("createRotationPivot error: sourceObject is not defined.");
    return;
  }
  if (!(sourceObject.isAddedObject || sourceObject.isObjectGroup)){
    throw new Error("createRotationPivot error: Unsupported type.");
    return;
  }
  if (isNaN(offsetX)){
    throw new Error("createRotationPivot error: offsetX is not a number.");
    return;
  }
  if (isNaN(offsetY)){
    throw new Error("createRotationPivot error: offsetY is not a number.");
    return;
  }
  if (isNaN(offsetZ)){
    throw new Error("createRotationPivot error: offsetZ is not a number.");
    return;
  }
  return sourceObject.makePivot(offsetX, offsetY, offsetZ);
}

// rotateCamera
// Rotates the camera around its axis by given radians.
Roygbiv.prototype.rotateCamera = function(axis, radians){
  if (mode == 0){
    return;
  }
  if (typeof axis == UNDEFINED){
    throw new Error("rotateCamera error: axis is not defined.");
    return;
  }
  if (typeof radians == UNDEFINED){
    throw new Error("rotateCamera error: radians is not defined.");
    return;
  }
  axis = axis.toLowerCase();
  if (axis != "x" && axis != "y" && axis != "z"){
    throw new Error("rotateCamera error: axis must be x, y or z.");
    return;
  }
  if (isNaN(radians)){
    throw new Error("rotateCamera error: radians is not a number.");
    return;
  }
  if (axis == "x"){
    cameraRotationBuffer.x += radians;
  }else if (axis == "y"){
    cameraRotationBuffer.y += radians;
  }else if (axis == "z"){
    cameraRotationBuffer.z += radians;
  }
}

// translateCamera
// Translates the camera along given axis by given amount.
Roygbiv.prototype.translateCamera = function(axis, amount){
  if (mode == 0){
    return;
  }
  if (typeof axis == UNDEFINED){
    throw new Error("translateCamera error: axis is not defined.");
    return;
  }
  if (typeof amount == UNDEFINED){
    throw new Error("translateCamera error: amount is not defined.");
    return;
  }
  axis = axis.toLowerCase();
  if (axis != "x" && axis != "y" && axis != "z"){
    throw new Error("translateCamera error: axis must be x, y or z.");
    return;
  }
  if (isNaN(amount)){
    throw new Error("translateCamera error: amount is not a number.");
    return;
  }
  if (axis == "x"){
    camera.translateX(amount * defaultAspect / camera.aspect);
  }else if (axis == "y"){
    camera.translateY(amount * defaultAspect / camera.aspect);
  }else if (axis == "z"){
    camera.translateZ(amount * defaultAspect / camera.aspect);
  }
}

// requestFullScreen
// Goes to full screen mode. on the next mouse click. Does nothing if the screen is
// already in full screen mode.
Roygbiv.prototype.requestFullScreen = function(){
  if (mode == 0){
    return;
  }
  if (onFullScreen){
    return;
  }
  fullScreenRequested = true;
}

// isMouseDown
// Returns true if the mouse is pressed, false otherwise.
Roygbiv.prototype.isMouseDown = function(){
  if (mode == 0){
    return;
  }
  return isMouseDown;
}

// intersectionTest
// Finds the first intersected object on a ray. The targetResultObject is filled with
// .x, .y, .z and .objectName parameters in case of an intersection. If there's no detected
// intersection the .objectName is set to null.
Roygbiv.prototype.intersectionTest = function(fromVector, directionVector, targetResultObject){
  if (mode == 0){
    return;
  }
  if (typeof fromVector == UNDEFINED){
    throw new Error("intersectionTest error: fromVector is not defined.");
    return;
  }
  if (isNaN(fromVector.x) || isNaN(fromVector.y) || isNaN(fromVector.z)){
    throw new Error("intersectionTest error: fromVector is not a vector.");
    return;
  }
  if (typeof directionVector == UNDEFINED){
    throw new Error("intersectionTest error: directionVector is not defined.");
    return;
  }
  if (isNaN(directionVector.x) || isNaN(directionVector.y) || isNaN(directionVector.z)){
    throw new Error("intersectionTest error: directionVector is not a vector.");
    return;
  }
  if (typeof targetResultObject == UNDEFINED){
    throw new Error("intersectionTest error: targetResultObject is not defined.");
    return;
  }
  REUSABLE_VECTOR.set(fromVector.x, fromVector.y, fromVector.z);
  REUSABLE_VECTOR_2.set(directionVector.x, directionVector.y, directionVector.z).normalize();
  rayCaster.findIntersections(REUSABLE_VECTOR, REUSABLE_VECTOR_2, false);
  if (intersectionPoint){
    targetResultObject.x = intersectionPoint.x;
    targetResultObject.y = intersectionPoint.y;
    targetResultObject.z = intersectionPoint.z;
    targetResultObject.objectName = intersectionObject;
  }else{
    targetResultObject.x = 0;
    targetResultObject.y = 0;
    targetResultObject.z = 0;
    targetResultObject.objectName = null;
  }
}

// isMobile
// Returns if the current client is a mobile client.
Roygbiv.prototype.isMobile = function(){
  if (mode == 0){
    return;
  }
  return isMobile;
}

// lerp
// Linearly interpolate between vector1 and vector2. The result is vector1 if
// amount = 0 and vector2 if amount = 1.
Roygbiv.prototype.lerp = function(vector1, vector2, amount, targetVector){
  if (mode == 0){
    return;
  }
  if (typeof vector1 == UNDEFINED){
    throw new Error("lerp error: vector1 is not defined.");
    return;
  }
  if (typeof vector2 == UNDEFINED){
    throw new Error("lerp error: vector2 is not defined.");
    return;
  }
  if (typeof amount == UNDEFINED){
    throw new Error("lerp error: amount is not defined.");
    return;
  }
  if (typeof targetVector == UNDEFINED){
    throw new Error("lerp error: targetVector is not defined.");
    return;
  }
  if (isNaN(vector1.x) || isNaN(vector1.y) || isNaN(vector1.z)){
    throw new Error("lerp error: vector1 is not a vector.");
    return;
  }
  if (isNaN(vector2.x) || isNaN(vector2.y) || isNaN(vector2.z)){
    throw new Error("lerp error: vector2 is not a vector.");
    return;
  }
  if (isNaN(targetVector.x) || isNaN(targetVector.y) || isNaN(targetVector.z)){
    throw new Error("lerp error: targetVector is not a vector.");
    return;
  }
  if (isNaN(amount)){
    throw new Error("lerp error: amount is not a number.");
    return;
  }
  if (amount < 0 || amount > 1){
    throw new Error("lerp error: amount must be between [0,1].");
    return;
  }
  REUSABLE_VECTOR.set(vector1.x, vector1.y, vector1.z);
  REUSABLE_VECTOR_2.set(vector2.x, vector2.y, vector2.z);
  REUSABLE_VECTOR.lerp(REUSABLE_VECTOR_2, amount);
  targetVector.x = REUSABLE_VECTOR.x;
  targetVector.y = REUSABLE_VECTOR.y;
  targetVector.z = REUSABLE_VECTOR.z;
  return targetVector;
}

// setBloom
// Sets the Bloom effect properties of the scene. Parameters are:
// strength (optional): The bloom strength between [0, 3]
// radius (optional): The bloom radius between [0, 1]
// threshold (optional): The bloom threshold between [0, 1]
// resolutionScale (optional): The bloom resolution scale between [0.1, 1]
Roygbiv.prototype.setBloom = function(params){
  if (mode == 0){
    return;
  }
  var hasStrength = false, hasRadius = false, hasThreshold = false, hasResolutionScale = false;
  if (!(typeof params.strength == UNDEFINED)){
    hasStrength = true;
    if (isNaN(params.strength)){
      throw new Error("setBloom error: strength parameter is not a number.");
      return;
    }
    if (params.strength < 0 || params.strength > 3){
      throw new Error("setBloom error: strength parameter must be between [0, 3].");
      return;
    }
  }
  if (!(typeof params.radius == UNDEFINED)){
    hasRadius = true;
    if (isNaN(params.radius)){
      throw new Error("setBloom error: radius parameter is not a number.");
      return;
    }
    if (params.radius < 0 || params.radius > 1){
      throw new Error("setBloom error: radius parameter must be between [0, 1].");
      return;
    }
  }
  if (!(typeof params.threshold == UNDEFINED)){
    hasThreshold = true;
    if (isNaN(params.threshold)){
      throw new Error("setBloom error: threshold parameter is not a number.");
      return;
    }
    if (params.threshold < 0 || params.threshold > 1){
      throw new Error("setBloom error: threshold parameter must be between [0, 1].");
      return;
    }
  }
  if (!(typeof params.resolutionScale == UNDEFINED)){
    hasResolutionScale = true;
    if (isNaN(params.resolutionScale)){
      throw new Error("setBloom error: resolutionScale parameter is not a number.");
      return;
    }
    if (params.resolutionScale < 0.1 || params.resolutionScale > 1){
      throw new Error("setBloom error: resolutionScale parameter must be between [0.1, 1].");
      return;
    }
  }
  bloomOn = true;
  if (hasStrength){
    bloomStrength = params.strength;
  }
  if (hasRadius){
    bloomRadius = params.radius;
  }
  if (hasThreshold){
    bloomThreshold = params.threshold;
  }
  if (hasResolutionScale){
    adjustPostProcessing(4, params.resolutionScale);
  }else{
    adjustPostProcessing(-1, null);
  }
}

// unsetBloom
// Unsets the Bloom effect.
Roygbiv.prototype.unsetBloom = function(){
  if (mode == 0){
    return;
  }
  adjustPostProcessing(5, false);
  if (!isDeployment){
    postprocessingParameters["Bloom"] = false;
  }
}

// pause
// Pauses/unpauses rendering. Note that once the rendering is paused the scripts
// also pause so in order to unpause the rendering, use callback functions such
// as ROYGBIV.setScreenClickListener or ROYGBIV.setScreenPointerLockChangeListener.
Roygbiv.prototype.pause = function(paused){
  if (mode == 0){
    return;
  }
  if (typeof paused == UNDEFINED){
    throw new Error("pause error: paused is not defined.");
    return;
  }
  if (!(typeof paused == "boolean")){
    throw new Error("pause error: paused is not a boolean.");
    return;
  }
  var oldIsPaused = isPaused;
  isPaused = paused;
  if (!paused && oldIsPaused){
    render();
  }
}

var WorldBinHandler = function(isCustom){
  this.bin = new Map();
  if (!isCustom){
    for (var objName in addedObjects){
      var object = addedObjects[objName];
      object.generateBoundingBoxes();
      if (!object.boundingBoxes){
        continue;
      }
      for (var i = 0; i<object.boundingBoxes.length; i++){
        this.insert(object.boundingBoxes[i], objName);
      }
    }
    for (var objName in objectGroups){
      var object = objectGroups[objName];
      object.generateBoundingBoxes();
      if (!object.boundingBoxes){
        continue;
      }
      for (var i = 0; i<object.boundingBoxes.length; i++){
        this.insert(object.boundingBoxes[i], object.boundingBoxes[i].roygbivObjectName, objName);
      }
    }
  }
}

WorldBinHandler.prototype.deleteObjectFromBin = function(binInfo, objName){
  for (var x of binInfo.keys()){
    for (var y of binInfo.get(x).keys()){
      for (var z of binInfo.get(x).get(y).keys()){
        if (this.bin.has(x) && this.bin.get(x).has(y) && this.bin.get(x).get(y).has(z)){
          this.bin.get(x).get(y).get(z).delete(objName);
          if (this.bin.get(x).get(y).get(z).size == 0){
            this.bin.get(x).get(y).delete(z);
          }
          if (this.bin.get(x).get(y).size == 0){
            this.bin.get(x).delete(y);
          }
          if (this.bin.get(x).size == 0){
            this.bin.delete(x);
          }
        }
      }
    }
  }
  for (var x of binInfo.keys()){
    binInfo.delete(x);
  }
}

WorldBinHandler.prototype.updateObject = function(obj){
  if (obj.isAddedObject){
    this.deleteObjectFromBin(obj.binInfo, obj.name);
    obj.mesh.updateMatrixWorld();
    obj.updateBoundingBoxes();
    for (var i = 0; i<obj.boundingBoxes.length; i++){
      this.insert(obj.boundingBoxes[i], obj.name);
    }
  }else if (obj.isObjectGroup){
    this.deleteObjectFromBin(obj.binInfo, obj.name);
    if (!obj.boundingBoxes){
      obj.generateBoundingBoxes();
    }
    obj.graphicsGroup.updateMatrixWorld();
    obj.updateBoundingBoxes();
    for (var i = 0; i<obj.boundingBoxes.length; i++){
      this.insert(obj.boundingBoxes[i], obj.boundingBoxes[i].roygbivObjectName, obj.name);
    }
  }else if (obj.isAddedText){
    this.deleteObjectFromBin(obj.binInfo, obj.name);
    if (!obj.boundingBox){
      obj.handleBoundingBox();
    }
    this.insert(obj.boundingBox, obj.name);
  }
}

WorldBinHandler.prototype.show = function(obj){
  if (obj.isAddedObject){
    for (var i = 0; i<obj.boundingBoxes.length; i++){
      this.insert(obj.boundingBoxes[i], obj.name);
    }
  }else if (obj.isObjectGroup){
    for (var i = 0; i<obj.boundingBoxes.length; i++){
      this.insert(obj.boundingBoxes[i], obj.boundingBoxes[i].roygbivObjectName, obj.name);
    }
  }
}

WorldBinHandler.prototype.hide = function(obj){
  this.deleteObjectFromBin(obj.binInfo, obj.name);
}

WorldBinHandler.prototype.update = function(){
  for (var objName in dynamicObjects){
    var obj = dynamicObjects[objName];
    if (obj.isHidden){
      continue;
    }
    this.deleteObjectFromBin(obj.binInfo, obj.name);
    obj.updateBoundingBoxes();
    for (var i = 0; i<obj.boundingBoxes.length; i++){
      this.insert(obj.boundingBoxes[i], objName);
    }
  }
  for (var objName in dynamicObjectGroups){
    var obj = dynamicObjectGroups[objName];
    if (obj.isHidden){
      continue;
    }
    this.deleteObjectFromBin(obj.binInfo, obj.name);
    obj.updateBoundingBoxes();
    for (var i = 0; i<obj.boundingBoxes.length; i++){
      this.insert(obj.boundingBoxes[i], obj.boundingBoxes[i].roygbivObjectName, objName);
    }
  }
}

WorldBinHandler.prototype.visualize = function(selectedScene, customBin){
  if (customBin){
    this.bin = customBin;
  }
  for (var minX of this.bin.keys()){
    for (var minY of this.bin.get(minX).keys()){
      for (var minZ of this.bin.get(minX).get(minY).keys()){
        for (var objName of this.bin.get(minX).get(minY).get(minZ)){
          var minX = parseInt(minX);
          var minY = parseInt(minY);
          var minZ = parseInt(minZ);
          var bb = new THREE.Box3(
            new THREE.Vector3(minX, minY, minZ), new THREE.Vector3(minX+BIN_SIZE, minY+BIN_SIZE, minZ+BIN_SIZE)
          );
          if (!this.visualObjects){
            this.visualObjects = [];
          }
          var b3h = new THREE.Box3Helper(bb, new THREE.Color("lime"));
          selectedScene.add(b3h);
          this.visualObjects.push(b3h);
        }
      }
    }
  }
}

WorldBinHandler.prototype.queryArea = function(point){
  var x = point.x;
  var y = point.y;
  var z = point.z;
  var rX = Math.round(x / BIN_SIZE) * BIN_SIZE;
  var rY = Math.round(y / BIN_SIZE) * BIN_SIZE;
  var rZ = Math.round(z / BIN_SIZE) * BIN_SIZE;
  var minX, maxX;
  if (rX <= x){
    minX = rX;
    maxX = rX + BIN_SIZE;
  }else{
    maxX = rX;
    minX = rX - BIN_SIZE;
  }
  var minY, maxY;
  if (rY <= y){
    minY = rY;
    maxY = rY + BIN_SIZE;
  }else{
    maxY = rY;
    minY = rY - BIN_SIZE;
  }
  var minZ, maxZ;
  if (rZ <= z){
    minZ = rZ;
    maxZ = rZ + BIN_SIZE;
  }else{
    maxZ = rZ;
    minZ = rZ - BIN_SIZE;
  }
  if (this.bin.has(minX) && this.bin.get(minX).has(minY)){
    var res = this.bin.get(minX).get(minY).get(minZ);
    if (res){
      for (var areaName of res.keys()){
        var area = areas[areaName];
        if (area.boundingBox.containsPoint(point)){
          return areaName;
        }
      }
    }
  }
}

WorldBinHandler.prototype.query = function(point){
  var x = point.x;
  var y = point.y;
  var z = point.z;
  var rX = Math.round(x / BIN_SIZE) * BIN_SIZE;
  var rY = Math.round(y / BIN_SIZE) * BIN_SIZE;
  var rZ = Math.round(z / BIN_SIZE) * BIN_SIZE;

  var minX, maxX;
  if (rX <= x){
    minX = rX;
    maxX = rX + BIN_SIZE;
  }else{
    maxX = rX;
    minX = rX - BIN_SIZE;
  }
  var minY, maxY;
  if (rY <= y){
    minY = rY;
    maxY = rY + BIN_SIZE;
  }else{
    maxY = rY;
    minY = rY - BIN_SIZE;
  }
  var minZ, maxZ;
  if (rZ <= z){
    minZ = rZ;
    maxZ = rZ + BIN_SIZE;
  }else{
    maxZ = rZ;
    minZ = rZ - BIN_SIZE;
  }

  var results = new Object();

  for (var xDiff = -BIN_SIZE; xDiff <= BIN_SIZE; xDiff += BIN_SIZE){
    for (var yDiff = -BIN_SIZE; yDiff <= BIN_SIZE; yDiff += BIN_SIZE){
      for (var zDiff = -BIN_SIZE; zDiff <= BIN_SIZE; zDiff += BIN_SIZE){
        var keyX = (minX + xDiff);
        var keyY = (minY + yDiff);
        var keyZ = (minZ + zDiff);
        if (this.bin.has(keyX) && this.bin.get(keyX).has(keyY)){
          var res = this.bin.get(keyX).get(keyY).get(keyZ);
          if (res){
            for (var objName of res.keys()){
              if (addedObjects[objName]){
                results[objName] = 5;
              }else if (objectGroups[objName]){
                if (!results[objName]){
                  results[objName] = new Object();
                }
                for (var childObjName of res.get(objName).keys()){
                  results[objName][childObjName] = 5;
                }
              }else if (gridSystems[objName]){
                results[objName] = 10;
              }else if (addedTexts[objName]){
                results[objName] = 20;
              }
            }
          }
        }
      }
    }
  }
  return results;
}

WorldBinHandler.prototype.insert = function(boundingBox, objName, parentName){
  if (!LIMIT_BOUNDING_BOX.containsBox(boundingBox)){
    return;
  }
  var minX = boundingBox.min.x;
  var minY = boundingBox.min.y;
  var minZ = boundingBox.min.z;
  var maxX = boundingBox.max.x;
  var maxY = boundingBox.max.y;
  var maxZ = boundingBox.max.z;

  var round = Math.round(minX / BIN_SIZE) * BIN_SIZE;
  var minXLower, minXUpper;
  if (round <= minX){
    minXLower = round;
    minXUpper = minXLower + BIN_SIZE;
  }else{
    minXUpper = round;
    minXLower = round - BIN_SIZE;
  }

  round = Math.round(maxX / BIN_SIZE) * BIN_SIZE;
  var maxXLower, maxXUpper;
  if (round < maxX){
    maxXLower = round;
    maxXUpper = maxXLower + BIN_SIZE;
  }else{
    maxXUpper = round;
    maxXLower = round - BIN_SIZE;
  }
  if (minXLower > maxXLower){
    maxXLower = minXLower;
  }

  round = Math.round(minY/BIN_SIZE) * BIN_SIZE;
  var minYLower, minYUpper;
  if (round <= minY){
    minYLower = round;
    minYUpper = minYLower + BIN_SIZE;
  }else{
    minYUpper = round;
    minYLower = round - BIN_SIZE;
  }

  round = Math.round(maxY/BIN_SIZE) * BIN_SIZE;
  var maxYLower, maxYUpper;
  if (round < maxY){
    maxYLower = round;
    maxYUpper = maxYLower + BIN_SIZE;
  }else{
    maxYUpper = round;
    maxYLower = round - BIN_SIZE;
  }
  if (minYLower > maxYLower){
    maxYLower = minYLower;
  }

  round = Math.round(minZ/BIN_SIZE) * BIN_SIZE;
  var minZLower, minZUpper;
  if (round <= minZ){
    minZLower = round;
    minZUpper = minZLower + BIN_SIZE;
  }else{
    minZUpper = round;
    minZLower = round - BIN_SIZE;
  }

  round = Math.round(maxZ/BIN_SIZE) * BIN_SIZE;
  var maxZLower, maxZUpper;
  if (round < maxZ){
    maxZLower = round;
    maxZUpper = maxZLower + BIN_SIZE;
  }else{
    maxZUpper = round;
    maxZLower = round - BIN_SIZE;
  }
  if (minZLower > maxZLower){
    maxZLower = minZLower;
  }


  for (var x = minXLower; x<= maxXLower; x+= BIN_SIZE){
    for (var y = minYLower; y<= maxYLower; y+= BIN_SIZE){
      for (var z = minZLower; z <= maxZLower; z+= BIN_SIZE){
        if (!this.bin.has(x)){
          this.bin.set(x, new Map());
        }
        if (!this.bin.get(x).has(y)){
          this.bin.get(x).set(y, new Map());
        }
        if (!this.bin.get(x).get(y).has(z)){
          this.bin.get(x).get(y).set(z, new Map());
        }
        if (!parentName){
          this.bin.get(x).get(y).get(z).set(objName, true);
        }else{
          var newMap = new Map();
          newMap.set(objName, true);
          this.bin.get(x).get(y).get(z).set(parentName, newMap);
        }
        var obj;
        if (!this.isAreaBinHandler){
          obj = addedObjects[objName];
          if (!obj){
            obj = objectGroups[parentName];
          }
          if (!obj){
            obj = addedTexts[objName];
          }
        }else{
          obj = areas[objName];
        }
        if (obj){
          if (!obj.binInfo){
            obj.binInfo = new Map();
          }
          if (!obj.binInfo.has(x)){
            obj.binInfo.set(x, new Map());
          }
          if (!obj.binInfo.get(x).has(y)){
            obj.binInfo.get(x).set(y, new Map());
          }
          obj.binInfo.get(x).get(y).set(z, true);
        }
      }
    }
  }

}

var ParticleSystemPool = function(name){
  this.isParticleSystemPool = true;
  this.name = name;
  this.particleSystems = new Object();
  this.availableParticleSystems = new Map();
}

ParticleSystemPool.prototype.add = function(particleSystem){
  this.particleSystems[particleSystem.name] = particleSystem;
  if (!particleSystem.mesh.visible){
    this.availableParticleSystems.set(particleSystem.name, particleSystem);
  }
  particleSystem.psPool = this.name;
}

ParticleSystemPool.prototype.get = function(){
  if (this.availableParticleSystems.size == 0){
    return false;
  }
  var ps = this.availableParticleSystems.values().next().value;
  this.availableParticleSystems.delete(ps.name);
  if (this.consumedCallback && this.availableParticleSystems.size == 0){
    this.consumedCallback();
  }
  return ps;
}

ParticleSystemPool.prototype.remove = function(particleSystem){
  delete this.particleSystems[particleSystem.name];
  this.availableParticleSystems.delete(particleSystem.name);
  delete particleSystem.psPool;
}

ParticleSystemPool.prototype.destroy = function(){
  for (var psName in this.particleSystems){
    delete this.particleSystems[psName].psPool;
    delete this.particleSystems[psName];
    this.availableParticleSystems.delete(psName);
  }
  delete particleSystemPools[this.name];
  this.destroyed = true;
}

ParticleSystemPool.prototype.notifyPSAvailable = function(particleSystem){
  this.availableParticleSystems.set(particleSystem.name, particleSystem);
  if (this.availableCallback && this.availableParticleSystems.size == 1){
    this.availableCallback();
  }
}

var ParticleSystemMerger = function(psObj, name){
  this.name = name;
  this.psObj = new Object();
  for (var psName in psObj){
    this.psObj[psName] = psObj[psName];
  }
  this.geometry = new THREE.BufferGeometry();

  this.activePSMap = new Map();

  this.size = Object.keys(this.psObj).length;

  var texturesObj = new Object();
  var textureCount = 0;
  var textureMergerHash = "";
  var len = 0;
  var noTargetColor = true;
  for (var psName in this.psObj){
    var ps = this.psObj[psName];
    ps.psMerger = this;
    if (!ps.noTargetColor){
      noTargetColor = false;
    }
    len += ps.particles.length;
    for (var textureName in ps.texturesObj){
      if (!texturesObj[textureName]){
        textureMergerHash += textureName + PIPE;
      }
      texturesObj[textureName] = textures[textureName];
      textureCount ++;
    }
  }
  this.noTargetColor = noTargetColor;
  var textureMerger = 0;

  if (textureCount > 0 && !(mergedTextureCache[textureMergerHash])){
    textureMerger = new TextureMerger(texturesObj);
    mergedTextureCache[textureMergerHash] = textureMerger;
  }else if (textureCount > 0 && mergedTextureCache[textureMergerHash]){
    textureMerger = mergedTextureCache[textureMergerHash];
  }

  var mvMatrixArray = [];
  var worldMatrixArray = [];
  var timeArray = [];
  var motionMatrixArray = [];
  var hiddenArray = [];
  var dissapearCoefArray = [];
  var stopInfoArray = [];

  this.mergedIndices = new Float32Array(len);
  this.positions = new Float32Array(len * 3);
  if (textureCount > 0){
    this.rgbThresholds = new Float32Array(len * 3);
    this.uvCoordinates = new Float32Array(len * 4);
  }
  this.velocities = new Float32Array(len * 3);
  this.accelerations = new Float32Array(len * 3);
  this.flags1 = new Float32Array(len * 4);
  this.flags3 = new Float32Array(len * 4);
  this.flags4 = new Float32Array(len * 4);
  if (!this.noTargetColor){
    this.targetColors = new Float32Array(len * 4);
  }
  this.angularQuaternions = new Float32Array(len * 4);
  this.expiredFlags = new Float32Array(len);
  this.flags2 = new Float32Array(len * 4);

  var offset1 = 0;
  var offset2 = 0;
  var offset3 = 0;
  var ctr = 0;
  var index = 0;
  var uvCounter = 0;
  for (var psName in this.psObj){
    var ps = this.psObj[psName];
    mvMatrixArray.push(ps.mesh.modelViewMatrix);
    worldMatrixArray.push(ps.mesh.matrixWorld);
    dissapearCoefArray.push(ps.material.uniforms.dissapearCoef.value);
    stopInfoArray.push(ps.material.uniforms.stopInfo.value);
    timeArray.push(ps.tick);
    if (ps.mesh.visible){
      hiddenArray.push(-20.0);
      this.activePSMap.set(ps.name, ps);
    }else{
      hiddenArray.push(20.0);
    }
    motionMatrixArray.push(new THREE.Matrix3());
    scene.remove(ps.mesh);
    this.positions.set(ps.positions, offset1);
    if (this.rgbThresholds){
      if (ps.rgbThresholds){
        this.rgbThresholds.set(ps.rgbThresholds, offset1);
      }else{
        var lim = ax + (ps.particles.length * 3);
        for (var ax = offset1; ax < lim; ax ++){
          this.rgbThresholds[ax] = -50;
        }
      }
    }
    this.velocities.set(ps.velocities, offset1);
    this.accelerations.set(ps.accelerations, offset1);
    this.flags1.set(ps.flags1, offset2);
    this.flags3.set(ps.flags3, offset2);
    this.flags4.set(ps.flags4, offset2);
    if (!this.noTargetColor){
      if (ps.noTargetColor){
        var lim = ax + (ps.particles.length * 4);
        for (var ax = offset2; ax<lim; ax++){
          this.targetColors[ax] = -50;
        }
      }else{
        this.targetColors.set(ps.targetColors, offset2);
      }
    }
    this.angularQuaternions.set(ps.angularQuaternions, offset2);
    this.expiredFlags.set(ps.expiredFlags, offset3);
    this.flags2.set(ps.flags2, offset2);

    ps.flags2Offset = offset2;
    ps.expiredFlagOffset = offset3;

    for (var i = 0; i<ps.particles.length; i++){
      var particle = ps.particles[i];
      this.mergedIndices[ctr] = index;
      ctr ++;
      if (textureCount > 0){
        if (particle.material.texture){
          var range = textureMerger.ranges[particle.material.texture];
          this.uvCoordinates[uvCounter++] = range.startU;
          this.uvCoordinates[uvCounter++] = range.startV;
          this.uvCoordinates[uvCounter++] = range.endU;
          this.uvCoordinates[uvCounter++] = range.endV;
        }else{
          this.uvCoordinates[uvCounter++] = -10;
          this.uvCoordinates[uvCounter++] = -10;
          this.uvCoordinates[uvCounter++] = -10;
          this.uvCoordinates[uvCounter++] = -10;
        }
      }
    }
    ps.mergedIndex = index;
    index ++;
    offset1 += ps.positions.length;
    offset2 += ps.flags2.length;
    offset3 += ps.expiredFlags.length;
    delete particleSystems[psName];
    mergedParticleSystems[this.name] = this;
  }


  var texture;
  if (textureMerger){
    texture = textureMerger.mergedTexture;
  }

  this.mergedIndicesBufferAttribute = new THREE.BufferAttribute(this.mergedIndices, 1);
  this.positionBufferAttribute = new THREE.BufferAttribute(this.positions, 3);
  if (this.rgbThresholds){
    this.rgbThresholdBufferAttribute = new THREE.BufferAttribute(this.rgbThresholds, 3);
  }
  this.expiredFlagBufferAttribute = new THREE.BufferAttribute(this.expiredFlags, 1);
  this.velocityBufferAttribute = new THREE.BufferAttribute(this.velocities, 3);
  this.accelerationBufferAttribute = new THREE.BufferAttribute(this.accelerations, 3);
  if (this.targetColors){
    this.targetColorBufferAttribute = new THREE.BufferAttribute(this.targetColors, 4);
  }
  this.flags1BufferAttribute = new THREE.BufferAttribute(this.flags1, 4);
  this.flags2BufferAttribute = new THREE.BufferAttribute(this.flags2, 4);
  this.flags3BufferAttribute = new THREE.BufferAttribute(this.flags3, 4);
  this.flags4BufferAttribute = new THREE.BufferAttribute(this.flags4, 4);
  this.angularQuaternionsBufferAttribute = new THREE.BufferAttribute(this.angularQuaternions, 4);
  if (this.uvCoordinates){
    this.uvCoordinatesBufferAttribute = new THREE.BufferAttribute(this.uvCoordinates, 4);
  }

  this.mergedIndicesBufferAttribute.setDynamic(false);
  this.positionBufferAttribute.setDynamic(false);
  if (this.rgbThresholdBufferAttribute){
    this.rgbThresholdBufferAttribute.setDynamic(false);
  }
  this.expiredFlagBufferAttribute.setDynamic(true);
  this.velocityBufferAttribute.setDynamic(false);
  this.accelerationBufferAttribute.setDynamic(false);
  if (this.targetColorBufferAttribute){
    this.targetColorBufferAttribute.setDynamic(false);
  }
  this.flags1BufferAttribute.setDynamic(false);
  this.flags2BufferAttribute.setDynamic(true);
  this.flags3BufferAttribute.setDynamic(false);
  this.flags4BufferAttribute.setDynamic(false);
  this.angularQuaternionsBufferAttribute.setDynamic(false);
  if (this.uvCoordinatesBufferAttribute){
    this.uvCoordinatesBufferAttribute.setDynamic(false);
  }

  this.geometry.addAttribute('mergedIndex', this.mergedIndicesBufferAttribute);
  this.geometry.addAttribute('position', this.positionBufferAttribute);
  if (this.rgbThresholdBufferAttribute){
    this.geometry.addAttribute('rgbThreshold', this.rgbThresholdBufferAttribute);
  }
  this.geometry.addAttribute('expiredFlag', this.expiredFlagBufferAttribute);
  this.geometry.addAttribute('velocity', this.velocityBufferAttribute);
  this.geometry.addAttribute('acceleration', this.accelerationBufferAttribute);
  if (this.targetColorBufferAttribute){
    this.geometry.addAttribute('targetColor', this.targetColorBufferAttribute);
  }
  this.geometry.addAttribute('flags1', this.flags1BufferAttribute);
  this.geometry.addAttribute('flags2', this.flags2BufferAttribute);
  this.geometry.addAttribute('flags3', this.flags3BufferAttribute);
  this.geometry.addAttribute('flags4', this.flags4BufferAttribute);
  this.geometry.addAttribute('angularQuaternion', this.angularQuaternionsBufferAttribute);
  if (this.uvCoordinatesBufferAttribute){
    this.geometry.addAttribute('uvCoordinates', this.uvCoordinatesBufferAttribute);
  }
  this.geometry.setDrawRange(0, len);

  var vertexShader = ShaderContent.particleVertexShader.replace(
    "#define OBJECT_SIZE 1", "#define OBJECT_SIZE "+this.size
  );

  this.material = new THREE.RawShaderMaterial({
    vertexShader: vertexShader,
    fragmentShader: ShaderContent.particleFragmentShader,
    transparent: true,
    side: THREE.DoubleSide,
    uniforms:{
      modelViewMatrixArray: new THREE.Uniform(mvMatrixArray),
      worldMatrixArray: new THREE.Uniform(worldMatrixArray),
      projectionMatrix: GLOBAL_PROJECTION_UNIFORM,
      viewMatrix: GLOBAL_VIEW_UNIFORM,
      timeArray: new THREE.Uniform(timeArray),
      hiddenArray: new THREE.Uniform(hiddenArray),
      dissapearCoefArray: new THREE.Uniform(dissapearCoefArray),
      stopInfoArray: new THREE.Uniform(stopInfoArray),
      parentMotionMatrixArray: new THREE.Uniform(motionMatrixArray),
    }
  });
  this.injectMacro(this.material, "IS_MERGED", true, false);
  if (fogBlendWithSkybox){
    this.material.uniforms.cameraPosition = GLOBAL_CAMERA_POSITION_UNIFORM;
    this.material.uniforms.cubeTexture = GLOBAL_CUBE_TEXTURE_UNIFORM;
    this.injectMacro(this.material, "HAS_SKYBOX_FOG", true, true);
  }
  if (fogActive){
    this.material.uniforms.fogInfo = GLOBAL_FOG_UNIFORM;
    this.injectMacro(this.material, "HAS_FOG", false, true);
  }
  if (texture){
    this.material.uniforms.texture = new THREE.Uniform(texture);
    this.injectMacro(this.material, "HAS_TEXTURE", true, true);
  }
  if (!this.noTargetColor){
    this.injectMacro(this.material, "HAS_TARGET_COLOR", true, false);
  }
  this.mesh = new THREE.Points(this.geometry, this.material);
  this.mesh.frustumCulled = false;
  scene.add(this.mesh);
  this.clean();

}

ParticleSystemMerger.prototype.destroy = function(){
  for (var psName in this.psObj){
    this.psObj[psName].destroy();
  }
  scene.remove(this.mesh);
  this.mesh.geometry.dispose();
  this.mesh.material.dispose();
  delete mergedParticleSystems[this.name];
}

ParticleSystemMerger.prototype.clean = function(){
  for (var psName in this.psObj){
    this.psObj[psName].expiredFlags = null;
    this.psObj[psName].flags2 = null;
    this.psObj[psName].positions = null;
    this.psObj[psName].rgbThresholds = null;
    this.psObj[psName].velocities = null;
    this.psObj[psName].accelerations = null;
    this.psObj[psName].flags1 = null;
    this.psObj[psName].flags3 = null;
    this.psObj[psName].flags4 = null;
    this.psObj[psName].targetColors = null;
    this.psObj[psName].angularQuaternions = null;
    this.psObj[psName].uvCoordinates = null;
    this.psObj[psName].positionBufferAttribute = null;
    this.psObj[psName].rgbThresholdBufferAttribute = null;
    this.psObj[psName].expiredFlagBufferAttribute = null;
    this.psObj[psName].velocityBufferAttribute = null;
    this.psObj[psName].accelerationBufferAttribute = null;
    this.psObj[psName].targetColorBufferAttribute = null;
    this.psObj[psName].flags1BufferAttribute = null;
    this.psObj[psName].flags2BufferAttribute = null;
    this.psObj[psName].flags3BufferAttribute = null;
    this.psObj[psName].flags4BufferAttribute = null;
    this.psObj[psName].angularQuaternionsBufferAttribute = null;
    this.psObj[psName].uvCoordinatesBufferAttribute = null;
    this.psObj[psName].mesh.geometry.dispose();
    this.psObj[psName].mesh.material.dispose();
  }
}

ParticleSystemMerger.prototype.removePS = function(ps){
  this.material.uniforms.hiddenArray.value[ps.mergedIndex] = (20.0);
  this.activePSMap.delete(ps.name);
  delete this.psObj[ps.name];
  delete ps.mergedIndex;
  if (Object.keys(this.psObj).length == 0){
    this.destroy();
  }
}

ParticleSystemMerger.prototype.notifyPSVisibilityChange = function(ps, isVisible){
  if (isVisible){
    this.activePSMap.set(ps.name, ps);
  }else{
    this.activePSMap.delete(ps.name);
  }
}

ParticleSystemMerger.prototype.updateObject = function(ps){
  ps.update();
}

ParticleSystemMerger.prototype.update = function(){
  this.activePSMap.forEach(this.updateObject);
}

ParticleSystemMerger.prototype.injectMacro = function(material, macro, insertVertexShader, insertFragmentShader){
  if (insertVertexShader){
    material.vertexShader = material.vertexShader.replace(
      "#define INSERTION", "#define INSERTION\n#define "+macro
    )
  };
  if (insertFragmentShader){
    material.fragmentShader = material.fragmentShader.replace(
      "#define INSERTION", "#define INSERTION\n#define "+macro
    )
  };
  material.needsUpdate = true;
}

ParticleSystemMerger.prototype.removeMacro = function(material, macro, removeVertexShader, removeFragmentShader){
  if (removeVertexShader){
    material.vertexShader = material.vertexShader.replace("\n#define "+macro, "");
  }
  if (removeFragmentShader){
    material.fragmentShader = material.fragmentShader.replace("\n#define "+macro, "");
  }
  material.needsUpdate = true;
}

var Crosshair = function(configurations){

  var name = configurations.name;
  var texture = configurations.texture;
  var colorR = configurations.colorR;
  var colorB = configurations.colorB;
  var colorG = configurations.colorG;
  var alpha = configurations.alpha;
  var size = configurations.size;

  this.texture = texture;
  this.name = name;
  this.sizeAmount = size;

  this.size = new Float32Array(1);
  this.size[0] = size;


  this.sizeBufferAttribute = new THREE.BufferAttribute(this.size, 1);
  this.sizeBufferAttribute.setDynamic(false);

  this.geometry = new THREE.BufferGeometry();
  this.geometry.addAttribute("size", this.sizeBufferAttribute);
  this.geometry.setDrawRange(0, 1);

  this.material = new THREE.RawShaderMaterial({
    vertexShader: ShaderContent.crossHairVertexShader,
    fragmentShader: ShaderContent.crossHairFragmentShader,
    transparent: true,
    side: THREE.DoubleSide,
    uniforms: {
      texture: new THREE.Uniform(texture),
      color: new THREE.Uniform(new THREE.Vector4(colorR, colorG, colorB, alpha)),
      uvTransform: new THREE.Uniform(new THREE.Matrix3()),
      expandInfo: new THREE.Uniform(new THREE.Vector4(0, 0, 0, 0)),
      shrinkStartSize: new THREE.Uniform(size)
    }
  });
  this.mesh = new THREE.Points(this.geometry, this.material);
  this.mesh.position.set(0, 0, 0);
  this.mesh.frustumCulled = false;
  this.mesh.visible = false;

  scene.add(this.mesh);

  crosshairs[this.name] = this;

  this.texture.center.set(0.5, 0.5);
  this.angularSpeed = 0;
  this.rotationTime = 0;
  this.expandTick = 0;
  this.shrinkTick = 0;
  this.curSize = this.sizeAmount;
  this.shrinkStartSize = this.sizeAmount;
}

Crosshair.prototype.update = function(){
  this.rotationTime += (1/60);
  this.expandTick ++;
  this.shrinkTick ++;
  if (this.rotationTime > MAX_PS_TIME){
    this.rotationTime = 0;
  }
  if (this.expandTick > MAX_PS_TIME){
    this.expandTick = 0;
  }
  if (this.shrinkTick > MAX_PS_TIME){
    this.shrinkTick = 0;
  }

  if(this.angularSpeed != 0){
    this.texture.rotation = (this.rotationTime * this.angularSpeed);
    this.texture.updateMatrix();
    this.material.uniforms.uvTransform.value.copy(this.texture.matrix);
  }
  if (this.expand){
    this.material.uniforms.expandInfo.value.set(10, this.expandTargetSize, this.expandTick, this.expandDelta);
    this.curSize = this.sizeAmount + (this.expandDelta * this.expandTick);
    if (this.curSize > this.expandTargetSize){
      this.curSize = this.expandTargetSize;
    }
  }else if (this.shrink){
    this.material.uniforms.expandInfo.value.set(-10, 0, this.shrinkTick, this.expandDelta);
    this.curSize = this.shrinkStartSize - (this.expandDelta * this.shrinkTick);
    if (this.curSize < this.sizeAmount){
      this.curSize = this.sizeAmount;
    }
  }
}

Crosshair.prototype.resetRotation = function(){
  this.texture.rotation = 0;
  this.texture.updateMatrix();
  this.material.uniforms.uvTransform.value.copy(this.texture.matrix);
}

Crosshair.prototype.destroy = function(){
  this.mesh.visible = false;
  this.mesh.geometry.dispose();
  this.mesh.material.dispose();
  this.mesh = 0;
}

var BasicMaterial = function(parameters){
  // name
  this.roygbivMaterialName = parameters.name;
  // color
  this.textColor = parameters.color;
  this.color = new THREE.Color(parameters.color);
  // alpha
  if (typeof parameters.alpha == UNDEFINED){
    this.alpha = 1;
  }else{
    this.alpha = parameters.alpha;
  }
  // aoMapIntensity
  if (typeof parameters.aoMapIntensity == UNDEFINED){
    this.aoMapIntensity = 1;
  }else{
    this.aoMapIntensity = parameters.aoMapIntensity;
  }
  // emissiveIntensity
  if (typeof parameters.emissiveIntensity == UNDEFINED){
    this.emissiveIntensity = 1;
  }else{
    this.emissiveIntensity = parameters.emissiveIntensity;
  }
  // emissiveColor
  if (typeof parameters.emissiveColor == UNDEFINED){
    this.emissiveColor = "#ffffff";
  }else{
    this.emissiveColor = parameters.emissiveColor;
  }
}

var MeshGenerator = function(geometry, material){
  this.geometry = geometry;
  this.material = material;
}

MeshGenerator.prototype.getTextureUniform = function(texture){
  if (textureUniformCache[texture.uuid]){
    return textureUniformCache[texture.uuid];
  }
  var uniform = new THREE.Uniform(texture);
  textureUniformCache[texture.uuid] = uniform;
  return uniform;
}

MeshGenerator.prototype.generateMesh = function(){
  if (this.material instanceof BasicMaterial){
    return this.generateBasicMesh();
  }
}

MeshGenerator.prototype.generateObjectTrail = function(
  trail, objectCoordinateSize, objectQuaternionSize, posit, quat, objectCoordinates, objectQuaternions){
  var vertexShaderCode = ShaderContent.objectTrailVertexShader.replace(
    "#define OBJECT_COORDINATE_SIZE 1", "#define OBJECT_COORDINATE_SIZE "+objectCoordinateSize
  ).replace(
    "#define OBJECT_QUATERNION_SIZE 1", "#define OBJECT_QUATERNION_SIZE "+objectQuaternionSize
  );
  var material = new THREE.RawShaderMaterial({
    vertexShader: vertexShaderCode,
    fragmentShader: ShaderContent.objectTrailFragmentShader,
    transparent: true,
    side: THREE.DoubleSide,
    uniforms: {
      projectionMatrix: GLOBAL_PROJECTION_UNIFORM,
      viewMatrix: GLOBAL_VIEW_UNIFORM,
      objectCoordinates: new THREE.Uniform(objectCoordinates),
      objectQuaternions: new THREE.Uniform(objectQuaternions),
      currentPosition: new THREE.Uniform(posit),
      currentQuaternion: new THREE.Uniform(quat),
      alpha: new THREE.Uniform(trail.alpha)
    }
  });
  var mesh = new THREE.Mesh(this.geometry, material);
  mesh.renderOrder = 100;
  if (fogBlendWithSkybox){
    material.uniforms.worldMatrix = new THREE.Uniform(mesh.matrixWorld);
    material.uniforms.cameraPosition = GLOBAL_CAMERA_POSITION_UNIFORM;
    material.uniforms.cubeTexture = GLOBAL_CUBE_TEXTURE_UNIFORM;
    trail.injectMacro(material, "HAS_SKYBOX_FOG", true, true);
  }
  if (fogActive){
    material.uniforms.fogInfo = GLOBAL_FOG_UNIFORM;
    trail.injectMacro(material, "HAS_FOG", false, true);
  }
  if (trail.diffuseTexture){
    material.uniforms.diffuseMap = this.getTextureUniform(trail.diffuseTexture);
    trail.injectMacro(material, "HAS_DIFFUSE", false, true);
  }
  if (trail.emissiveTexture){
    material.uniforms.emissiveMap = this.getTextureUniform(trail.emissiveTexture);
    trail.injectMacro(material, "HAS_EMISSIVE", true, true);
  }
  if (trail.displacementTexture && VERTEX_SHADER_TEXTURE_FETCH_SUPPORTED){
    material.uniforms.displacementMap = this.getTextureUniform(trail.displacementTexture);
    trail.injectMacro(material, "HAS_DISPLACEMENT", true, false);
  }
  if (trail.alphaTexture){
    material.uniforms.alphaMap = this.getTextureUniform(trail.alphaTexture);
    trail.injectMacro(material, "HAS_ALPHA", false, true);
  }
  if (trail.hasTexture){
    trail.injectMacro(material, "HAS_TEXTURE", true, true);
  }
  return mesh;
}

MeshGenerator.prototype.generateInstancedMesh = function(graphicsGroup, objectGroup){
  var diffuseTexture = objectGroup.diffuseTexture;
  var emissiveTexture = objectGroup.emissiveTexture;
  var alphaTexture = objectGroup.alphaTexture;
  var aoTexture = objectGroup.aoTexture;
  var displacementTexture = objectGroup.displacementTexture;
  var vertexShader = ShaderContent.instancedBasicMaterialVertexShader;
  var uniforms = {
    projectionMatrix: GLOBAL_PROJECTION_UNIFORM,
    modelViewMatrix: new THREE.Uniform(new THREE.Matrix4()),
    totalAlpha: new THREE.Uniform(1)
  };
  if (aoTexture){
    uniforms.aoMap = this.getTextureUniform(aoTexture);
    uniforms.totalAOIntensity = new THREE.Uniform(1);
  }
  if (emissiveTexture){
    uniforms.emissiveMap = this.getTextureUniform(emissiveTexture);
    uniforms.totalEmissiveColor = new THREE.Uniform(new THREE.Color("white"));
    uniforms.totalEmissiveIntensity = new THREE.Uniform(1);
  }
  if (diffuseTexture){
    uniforms.diffuseMap = this.getTextureUniform(diffuseTexture);
  }
  if (alphaTexture){
    uniforms.alphaMap = this.getTextureUniform(alphaTexture);
  }
  if (displacementTexture && VERTEX_SHADER_TEXTURE_FETCH_SUPPORTED){
    uniforms.displacementMap = this.getTextureUniform(displacementTexture);
  }
  var material = new THREE.RawShaderMaterial({
    vertexShader: ShaderContent.instancedBasicMaterialVertexShader,
    fragmentShader: ShaderContent.instancedBasicMaterialFragmentShader,
    transparent: objectGroup.isTransparent,
    side: THREE.DoubleSide,
    uniforms: uniforms
  });
  var mesh = new THREE.Mesh(this.geometry, material);
  mesh.renderOrder = 10;
  mesh.position.copy(graphicsGroup.position);
  material.uniforms.modelViewMatrix.value = mesh.modelViewMatrix;
  return mesh;
}

MeshGenerator.prototype.generateMergedMesh = function(graphicsGroup, objectGroup){
  var diffuseTexture = objectGroup.diffuseTexture;
  var emissiveTexture = objectGroup.emissiveTexture;
  var alphaTexture = objectGroup.alphaTexture;
  var aoTexture = objectGroup.aoTexture;
  var displacementTexture = objectGroup.displacementTexture;

  var uniforms = {
    projectionMatrix: GLOBAL_PROJECTION_UNIFORM,
    modelViewMatrix: new THREE.Uniform(new THREE.Matrix4()),
    totalAlpha: new THREE.Uniform(1)
  }
  if (aoTexture){
    uniforms.aoMap = this.getTextureUniform(aoTexture);
    uniforms.totalAOIntensity = new THREE.Uniform(1);
  }
  if (emissiveTexture){
    uniforms.emissiveMap = this.getTextureUniform(emissiveTexture);
    uniforms.totalEmissiveIntensity = new THREE.Uniform(1);
    uniforms.totalEmissiveColor = new THREE.Uniform(new THREE.Color("white"));
  }
  if (diffuseTexture){
    uniforms.diffuseMap = this.getTextureUniform(diffuseTexture);
  }
  if (alphaTexture){
    uniforms.alphaMap = this.getTextureUniform(alphaTexture);
  }
  if (displacementTexture){
    uniforms.displacementMap = this.getTextureUniform(displacementTexture);
  }

  var material = new THREE.RawShaderMaterial({
    vertexShader: ShaderContent.mergedBasicMaterialVertexShader,
    fragmentShader: ShaderContent.mergedBasicMaterialFragmentShader,
    transparent: objectGroup.isTransparent,
    side: THREE.DoubleSide,
    uniforms: uniforms
  });
  var mesh = new THREE.Mesh(this.geometry, material);
  mesh.renderOrder = 10;
  mesh.position.copy(graphicsGroup.position);
  material.uniforms.modelViewMatrix.value = mesh.modelViewMatrix;
  return mesh;
}

MeshGenerator.prototype.generateBasicMesh = function(){
  var material = new THREE.RawShaderMaterial({
    vertexShader: ShaderContent.basicMaterialVertexShader,
    fragmentShader: ShaderContent.basicMaterialFragmentShader,
    transparent: true,
    side: THREE.DoubleSide,
    uniforms:{
      projectionMatrix: GLOBAL_PROJECTION_UNIFORM,
      modelViewMatrix: new THREE.Uniform(new THREE.Matrix4()),
      color: new THREE.Uniform(this.material.color),
      alpha: new THREE.Uniform(this.material.alpha)
    }
  });
  var mesh = new THREE.Mesh(this.geometry, material);
  mesh.renderOrder = 10;
  material.uniforms.modelViewMatrix.value = mesh.modelViewMatrix;
  return mesh;
}

MeshGenerator.prototype.generateSkybox = function(skybox){
  GLOBAL_CUBE_TEXTURE_UNIFORM.value = skybox.cubeTexture;
  var material = new THREE.RawShaderMaterial({
    vertexShader: ShaderContent.skyboxVertexShader,
    fragmentShader: ShaderContent.skyboxFragmentShader,
    transparent: true,
    side: THREE.BackSide,
    uniforms: {
      projectionMatrix: GLOBAL_PROJECTION_UNIFORM,
      modelViewMatrix: new THREE.Uniform(new THREE.Matrix4()),
      cubeTexture: GLOBAL_CUBE_TEXTURE_UNIFORM,
      color: new THREE.Uniform(new THREE.Color(skybox.color)),
      alpha: GLOBAL_SKYBOX_ALPHA_UNIFORM
    }
  });
  var mesh = new THREE.Mesh(this.geometry, material);
  material.uniforms.modelViewMatrix.value = mesh.modelViewMatrix;
  return mesh;
}

var Area = function(name, boundingBox, color, gridSize){
  this.name = name;
  this.boundingBox = boundingBox;
  this.color = color;
  this.center = new THREE.Vector3();
  this.boundingBox.getCenter(this.center);
  this.gridSize = gridSize;
}

Area.prototype.export = function(){
  var exportObject = new Object();
  exportObject.name = this.name;
  exportObject.bbMinX = this.boundingBox.min.x;
  exportObject.bbMinY = this.boundingBox.min.y;
  exportObject.bbMinZ = this.boundingBox.min.z;
  exportObject.bbMaxX = this.boundingBox.max.x;
  exportObject.bbMaxY = this.boundingBox.max.y;
  exportObject.bbMaxZ = this.boundingBox.max.z;
  exportObject.color = this.color;
  exportObject.gridSize = this.gridSize;
  return exportObject;
}

Area.prototype.destroy = function(){
  if (this.helper){
    if (areasVisible){
      scene.remove(this.helper);
    }
    this.helper.geometry.dispose();
    this.helper.material.dispose();
  }
  areaBinHandler.deleteObjectFromBin(this.binInfo, this.name);
  for (var objName in addedObjects){
    if (addedObjects[objName].areaVisibilityConfigurations){
      if (!(typeof addedObjects[objName].areaVisibilityConfigurations[this.name] == UNDEFINED)){
        delete addedObjects[objName].areaVisibilityConfigurations[this.name];
      }
      if (addedObjects[objName].areaSideConfigurations){
        if (!(typeof addedObjects[objName].areaSideConfigurations[this.name] == UNDEFINED)){
          delete addedObjects[objName].areaSideConfigurations[this.name];
        }
      }
    }
  }
  for (var objName in objectGroups){
    if (objectGroups[objName].areaVisibilityConfigurations){
      if (!(typeof objectGroups[objName].areaVisibilityConfigurations[this.name] == UNDEFINED)){
        delete objectGroups[objName].areaVisibilityConfigurations[this.name];
      }
    }
    if (objectGroups[objName].areaSideConfigurations){
      if (!(typeof objectGroups[objName].areaSideConfigurations[this.name] == UNDEFINED)){
        delete objectGroups[objName].areaSideConfigurations[this.name];
      }
    }
  }
}

Area.prototype.renderToScreen = function(){
  if (isDeployment){
    return;
  }
  if (!this.helper){
    var color = new THREE.Color(this.color);
    this.helper = new THREE.Box3Helper(this.boundingBox, color);
  }
  if(!this.text){
    this.text = new AddedText(null, defaultFont, this.name, this.center, color, 1, 15);
    this.text.setMarginBetweenChars(7);
    this.text.refInnerHeight = 569;
    this.text.refCharSize = 15;
    this.text.handleResize();
  }else{
    scene.add(this.text.mesh);
  }
  scene.add(this.helper);
}

Area.prototype.hide = function(){
  if (this.helper){
    scene.remove(this.helper);
  }
  if (this.text){
    scene.remove(this.text.mesh);
  }
}

var Font = function(name, path, onLoaded, onError, customFontFace){
  this.name = name;
  this.path = path;
  this.onLoaded = onLoaded;
  this.onError = onError;
  if (!customFontFace){
    this.fontFace = new FontFace(name, "url(./"+path+")");
  }else{
    this.fontFace = customFontFace
    this.generateFontTexture();
  }
}

Font.prototype.load = function(){
  var that = this;
  this.fontFace.load().then(function(loadedFace) {
  	document.fonts.add(loadedFace);
    that.generateFontTexture();
    that.onLoaded(that);
  }).catch(function(error) {
    console.error(error);
    that.onError(that.name);
  });
}

Font.prototype.export = function(){
  var exportObject = new Object();
  exportObject.name = this.name;
  exportObject.path = this.path;
  return exportObject;
}

Font.prototype.destroy = function(){
  if (this.textureMerger){
    this.textureMerger.mergedTexture.dispose();
  }
  this.textureMerger = null;
  delete fonts[this.name];
}

Font.prototype.generateFontTexture = function(){
  var canvasSize = 64;
  var textureObjects = new Object();
  var tmpCanvas = document.createElement("canvas");
  var ctx = tmpCanvas.getContext("2d");
  var fontSize = 60;
  for (var i = 0; i<supportedFontAtlasChars.length; i++){
    ctx.textBaseline = "bottom";
    ctx.font = fontSize + "px "+this.name;
    var textWidth = ctx.measureText(supportedFontAtlasChars[i]).width;
    while (textWidth > canvasSize){
      fontSize-=15;
      ctx.font = fontSize + "px "+this.name;
      textWidth = ctx.measureText(supportedFontAtlasChars[i]).width;
    }
  }
  for (var i = 0; i<supportedFontAtlasChars.length; i++){
    tmpCanvas = document.createElement("canvas");
    tmpCanvas.width = canvasSize;
    tmpCanvas.height = canvasSize;
    ctx = tmpCanvas.getContext("2d");
    ctx.textBaseline = "middle";
    ctx.textAlign='center';
    ctx.font = fontSize + "px "+this.name;
    var textWidth = ctx.measureText(supportedFontAtlasChars[i]).width;
    ctx.fillStyle = "#ffffff";
    ctx.translate(canvasSize/2, canvasSize/2);
    ctx.rotate(Math.PI);
    ctx.scale(-1, 1);
    ctx.fillText(supportedFontAtlasChars[i] , 0, 0);
    var canvasTexture = new THREE.CanvasTexture(tmpCanvas);
    textureObjects[supportedFontAtlasChars[i]] = canvasTexture;
  }
  this.textureMerger = new TextureMerger(textureObjects);
}

var AddedText = function(name, font, text, position, color, alpha, characterSize, strlenParameter){
  this.isAddedText = true;
  this.twoDimensionalParameters = new THREE.Vector2();
  this.twoDimensionalSize = new THREE.Vector4();
  this.webglSpaceSize = new THREE.Vector2();
  this.shaderMargin = new THREE.Vector2();
  this.name = name;
  this.font = font;
  this.text = text;
  this.position = position;
  this.color = color;
  this.alpha = alpha;
  this.characterSize = characterSize;
  this.geometry = new THREE.BufferGeometry();
  this.hasBackground = false;
  var strlen = strlenParameter;
  if (typeof strlen == UNDEFINED){
    strlen = text.length;
  }
  this.strlen = strlen;

  var charIndices = new Float32Array(strlen);
  for (var i = 0; i<strlen; i++){
    charIndices[i] = i;
  }
  this.charIndices = charIndices;
  this.offsetBetweenLines = DEFAULT_OFFSET_BETWEEN_LINES;
  this.offsetBetweenChars = DEFAULT_OFFSET_BETWEEN_CHARS;

  var charIndicesBufferAttribute = new THREE.BufferAttribute(charIndices, 1);
  charIndicesBufferAttribute.setDynamic(false);
  this.geometry.addAttribute('charIndex', charIndicesBufferAttribute);
  this.geometry.setDrawRange(0, strlen);

  var xOffsetsArray = [];
  var yOffsetsArray = [];
  var uvsArray = [];
  for (var i = 0; i<strlen; i++){
    xOffsetsArray.push(0);
    yOffsetsArray.push(0);
    uvsArray.push(new THREE.Vector4());
  }

  this.material = new THREE.RawShaderMaterial({
    vertexShader: ShaderContent.textVertexShader.replace("#define STR_LEN 1", "#define STR_LEN "+strlen),
    fragmentShader: ShaderContent.textFragmentShader,
    transparent: true,
    side: THREE.DoubleSide,
    uniforms: {
      modelViewMatrix: new THREE.Uniform(new THREE.Matrix4()),
      projectionMatrix: GLOBAL_PROJECTION_UNIFORM,
      cameraQuaternion: GLOBAL_CAMERA_QUATERNION_UNIFORM,
      color: new THREE.Uniform(color),
      alpha: new THREE.Uniform(alpha),
      uvRanges: new THREE.Uniform(uvsArray),
      glyphTexture: this.getGlyphUniform(),
      xOffsets: new THREE.Uniform(xOffsetsArray),
      yOffsets: new THREE.Uniform(yOffsetsArray),
      currentViewport: GLOBAL_ADDEDTEXT_VIEWPORT_UNIFORM,
      charSize: new THREE.Uniform(this.characterSize)
    }
  });
  this.topLeft = new THREE.Vector3(0, 0, 0);
  this.bottomRight = new THREE.Vector3();
  this.bottomLeft = new THREE.Vector3();
  this.topRight = new THREE.Vector3();
  this.constructText();
  this.handleUVUniform();
  this.mesh = new THREE.Points(this.geometry, this.material);
  this.mesh.position.copy(position);
  this.mesh.frustumCulled = false;
  scene.add(this.mesh);
  this.material.uniforms.modelViewMatrix.value = this.mesh.modelViewMatrix;

  this.tmpObj = {};
  this.destroyedGrids = new Object();
  this.isClickable = false;

  this.lastUpdateQuaternion = new THREE.Quaternion().copy(camera.quaternion);
  this.lastUpdatePosition = new THREE.Vector3().copy(this.position);
  this.lastUpdateCameraPosition = new THREE.Vector3().copy(camera.position);

  this.reusableVector = new THREE.Vector3();
  this.makeFirstUpdate = true;
  this.isAffectedByFog = false;
  this.marginMode = MARGIN_MODE_2D_TEXT_TOP_LEFT;
  this.marginPercentWidth = 50;
  this.marginPercentHeight = 50;
  this.maxWidthPercent = 100;
  this.maxHeightPercent = 100;
}

AddedText.prototype.destroy = function(){
  for (var gridName in this.destroyedGrids){
    if (this.destroyedGrids[gridName].createdAddedTextName == this.name){
      delete this.destroyedGrids[gridName].createdAddedTextName;
    }
  }
  scene.remove(this.mesh);
  this.material.dispose();
  this.geometry.dispose();
  if (this.bbHelper){
    this.bbHelper.material.dispose();
    this.bbHelper.geometry.dispose();
  }
  if (this.rectangle){
    this.rectangle.material.dispose();
    this.rectangle.geometry.dispose();
  }
  rayCaster.refresh();
  delete addedTexts[this.name];
  if (this.is2D){
    delete addedTexts2D[this.name];
  }
}

AddedText.prototype.constructText = function(){
  var xOffset = 0;
  var yOffset = 0;
  var xOffsets = this.material.uniforms.xOffsets.value;
  var yOffsets = this.material.uniforms.yOffsets.value;
  var xMax = 0;
  var yMin = 0;
  var i = 0;
  var i2 = 0;
  while (i2 < this.text.length && i<this.strlen){
    if (this.text.charAt(i2) == "\n"){
      yOffset-= this.offsetBetweenLines;
      xOffset = 0;
    }else{
      xOffsets[i] = xOffset;
      yOffsets[i] = yOffset;
      if (xOffset > xMax){
        xMax = xOffset;
      }
      if (yOffset < yMin){
        yMin = yOffset;
      }
      xOffset += this.offsetBetweenChars;
      i ++;
    }
    i2 ++;
  }
  this.bottomRight.x = xMax;
  this.bottomRight.y = yMin;
  this.bottomRight.z = -1;
  this.bottomLeft.x = 0;
  this.bottomLeft.y = yMin;
  this.topRight.x = xMax;
  this.topRight.y = 0;

  this.xMax = xMax;
  this.yMin = yMin;

  this.twoDimensionalParameters.x = (xMax / screenResolution);
  this.twoDimensionalParameters.y = (yMin / screenResolution);
}

AddedText.prototype.export = function(){
  var exportObj = new Object();
  exportObj.name = this.name;
  exportObj.fontName = this.font.name;
  exportObj.text = this.text;
  exportObj.positionX = this.position.x;
  exportObj.positionY = this.position.y;
  exportObj.positionZ = this.position.z;
  exportObj.colorR = this.color.r;
  exportObj.colorG = this.color.g;
  exportObj.colorB = this.color.b;
  exportObj.alpha = this.alpha;
  exportObj.charSize = this.characterSize;
  exportObj.strlen = this.strlen;
  exportObj.offsetBetweenChars = this.offsetBetweenChars;
  exportObj.offsetBetweenLines = this.offsetBetweenLines;
  exportObj.refCharSize = this.refCharSize;
  exportObj.refInnerHeight = this.refInnerHeight;
  exportObj.hasBackground = this.hasBackground;
  exportObj.refCharOffset = this.refCharOffset;
  exportObj.refLineOffset = this.refLineOffset;
  if (this.hasBackground){
    exportObj.backgroundColorR = this.material.uniforms.backgroundColor.value.r;
    exportObj.backgroundColorG = this.material.uniforms.backgroundColor.value.g;
    exportObj.backgroundColorB = this.material.uniforms.backgroundColor.value.b;
    exportObj.backgroundAlpha = this.material.uniforms.backgroundAlpha.value;
  }
  exportObj.gsName = this.gsName;
  exportObj.isClickable = this.isClickable;
  exportObj.isAffectedByFog = this.isAffectedByFog;
  exportObj.is2D = this.is2D;
  exportObj.shaderMarginX = this.shaderMargin.x;
  exportObj.shaderMarginY = this.shaderMargin.y;
  exportObj.marginMode = this.marginMode;
  exportObj.marginPercentWidth = this.marginPercentWidth;
  exportObj.marginPercentHeight = this.marginPercentHeight;
  exportObj.maxWidthPercent = this.maxWidthPercent;
  exportObj.maxHeightPercent = this.maxHeightPercent;
  var exportDestroyedGrids = new Object();
  for (var gridName in this.destroyedGrids){
    exportDestroyedGrids[gridName] = this.destroyedGrids[gridName].export();
  }
  exportObj["destroyedGrids"] = exportDestroyedGrids;
  return exportObj;
}

AddedText.prototype.getGlyphUniform = function(){
  var uuid = this.font.textureMerger.mergedTexture.uuid;
  if (textureUniformCache[uuid]){
    return textureUniformCache[uuid];
  }
  var glyphUniform = new THREE.Uniform(this.font.textureMerger.mergedTexture);
  textureUniformCache[uuid] = glyphUniform;
  return glyphUniform;
}

AddedText.prototype.handleUVUniform = function(){
  var uvRangesArray = this.material.uniforms.uvRanges.value;
  var i2 = 0;
  for (var i = 0; i<this.text.length; i++){
    var curChar = this.text.charAt(i);
    if (curChar != "\n"){
      var curRange = this.font.textureMerger.ranges[curChar];
      if (curRange){
        uvRangesArray[i2++].set(
          curRange.startU, curRange.endU, curRange.startV, curRange.endV
        );
      }else{
        uvRangesArray[i2++].set(-500, -500, -500, -500);
      }
    }
    if (i2 >= this.strlen){
      break;
    }
  }
  for (var i = i2; i<this.strlen; i++){
    uvRangesArray[i].set(-500, -500, -500, -500);
  }
}

AddedText.prototype.setMarginBetweenChars = function(value){
  this.offsetBetweenChars = value;
  this.constructText();
  if (this.is2D){
    this.refCharOffset = value;
    this.set2DCoordinates(this.marginPercentWidth, this.marginPercentHeight);
  }else{
    this.handleBoundingBox();
  }
}

AddedText.prototype.setMarginBetweenLines = function(value){
  this.offsetBetweenLines = value;
  this.constructText();
  if (this.is2D){
    this.refLineOffset = value;
    this.set2DCoordinates(this.marginPercentWidth, this.marginPercentHeight);
  }else{
    this.handleBoundingBox();
  }
}

AddedText.prototype.setText = function(newText, fromScript){
  if (fromScript && (typeof this.oldText == UNDEFINED)){
    this.oldText = this.text;
  }
  this.text = newText;
  this.constructText();
  this.handleUVUniform();
  if (this.is2D){
    this.set2DCoordinates(this.marginPercentWidth, this.marginPercentHeight);
    this.handleResize();
  }else{
    this.handleBoundingBox();
  }
}

AddedText.prototype.setColor = function(colorString, fromScript){
  if (fromScript && (typeof this.oldColorR == UNDEFINED)){
    this.oldColorR = this.material.uniforms.color.value.r;
    this.oldColorG = this.material.uniforms.color.value.g;
    this.oldColorB = this.material.uniforms.color.value.b;
  }
  this.material.uniforms.color.value.set(colorString);
}

AddedText.prototype.setAlpha = function(alpha, fromScript){
  if (fromScript && (typeof this.oldAlpha == UNDEFINED)){
    this.oldAlpha = this.alpha;
  }
  if (alpha > 1){
    alpha = 1;
  }else if (alpha < 0){
    alpha = 0;
  }
  this.material.uniforms.alpha.value = alpha;
  this.alpha = alpha;
}

AddedText.prototype.setBackground = function(backgroundColorString, backgroundAlpha, fromScript){
  if (backgroundAlpha > 1){
    backgroundAlpha = 1;
  }else if (backgroundAlpha < 0){
    backgroundAlpha = 0;
  }
  if (fromScript && (typeof this.oldBackgroundR == UNDEFINED)){
    this.oldBackgroundR = this.material.uniforms.backgroundColor.value.r;
    this.oldBackgroundG = this.material.uniforms.backgroundColor.value.g;
    this.oldBackgroundB = this.material.uniforms.backgroundColor.value.b;
    this.oldBackgroundAlpha = this.material.uniforms.backgroundAlpha.value;
  }
  if (fromScript && (typeof this.oldBackgroundStatus == UNDEFINED)){
    this.oldBackgroundStatus = this.material.uniforms.hasBackgroundColorFlag.value;
  }
  if (!this.material.uniforms.backgroundColor){
    this.injectMacro("HAS_BACKGROUND", false, true);
    this.material.uniforms.backgroundColor = new THREE.Uniform(new THREE.Color(backgroundColorString));
    this.material.uniforms.backgroundAlpha = new THREE.Uniform(backgroundAlpha);
  }else{
    this.material.uniforms.backgroundColor.value.set(backgroundColorString);
    this.material.uniforms.backgroundAlpha.value = backgroundAlpha;
  }
  if (!fromScript){
    this.hasBackground = true;
  }
}

AddedText.prototype.removeBackground = function(fromScript){
  if (fromScript && (typeof this.oldBackgroundStatus == UNDEFINED)){
    this.oldBackgroundStatus = this.material.uniforms.hasBackgroundColorFlag.value;
  }
  if (this.material.uniforms.backgroundColor){
    this.removeMacro("HAS_BACKGROUND", false, true);
    delete this.material.uniforms.backgroundColor;
    delete this.material.uniforms.backgroundAlpha;
  }
  if (!fromScript){
    this.hasBackground = false;
  }
}

AddedText.prototype.setCharSize = function(value){
  this.material.uniforms.charSize.value = value;
  this.characterSize = value;
  if (this.is2D){
    this.set2DCoordinates(this.marginPercentWidth, this.marginPercentHeight);
  }else{
    this.handleBoundingBox();
  }
}

AddedText.prototype.handleResize = function(){
  this.setCharSize(this.refCharSize * ((renderer.getCurrentViewport().w / screenResolution)/this.refInnerHeight));
  if (this.is2D){
    if (typeof this.refCharOffset == UNDEFINED){
      this.refCharOffset = this.offsetBetweenChars;
    }
    if (typeof this.refLineOffset == UNDEFINED){
      this.refLineOffset = this.offsetBetweenLines;
    }
    this.offsetBetweenChars = this.refCharOffset * ((renderer.getCurrentViewport().w)/this.refInnerHeight);
    this.offsetBetweenLines = this.refLineOffset * ((renderer.getCurrentViewport().w)/this.refInnerHeight);
    if (renderer.getCurrentViewport().z / screenResolution < window.innerWidth){
       this.offsetBetweenChars = this.offsetBetweenChars * (window.innerWidth / (renderer.getCurrentViewport().z / screenResolution));
    }
    if (renderer.getCurrentViewport().w / screenResolution < window.innerHeight){
       this.offsetBetweenLines = this.offsetBetweenLines * (window.innerHeight / (renderer.getCurrentViewport().w / screenResolution));
    }
    this.constructText();
    this.set2DCoordinates(this.marginPercentWidth, this.marginPercentHeight);
    if (!(typeof this.maxWidthPercent == UNDEFINED)){
      var iteration = 1;
      while (this.getWidthPercent() > this.maxWidthPercent){
        var a = this.characterSize;
        this.setCharSize((this.characterSize - 0.5));
        this.offsetBetweenChars = this.offsetBetweenChars * (this.characterSize / a);
        this.constructText();
        this.set2DCoordinates(this.marginPercentWidth, this.marginPercentHeight);
        iteration ++;
        if (!isDeployment && textManipulationParameters){
          textManipulationParameters["Char size"] = this.characterSize;
          textManipulationParameters["Char margin"] = this.offsetBetweenChars;
        }
      }
    }
    if (!(typeof this.maxHeightPercent == UNDEFINED)){
      var iteration = 1;
      while (this.getHeightPercent() > this.maxHeightPercent){
        var a = this.characterSize;
        this.setCharSize((this.characterSize - 0.5));
        this.offsetBetweenLines = this.offsetBetweenLines * (this.characterSize / a);
        this.constructText();
        this.set2DCoordinates(this.marginPercentWidth, this.marginPercentHeight);
        iteration ++;
        if (!isDeployment && textManipulationParameters){
          textManipulationParameters["Char size"] = this.characterSize;
          textManipulationParameters["Line margin"] = this.offsetBetweenLines;
        }
      }
    }
  }
}

AddedText.prototype.getWidthPercent = function(){
  return (((this.webglSpaceSize.x) * (100)) / (2));
}

AddedText.prototype.getHeightPercent = function(){
  return (((this.webglSpaceSize.y) * (100)) / (2));
}

AddedText.prototype.calculateCharSize = function(){
  var currentViewport = renderer.getCurrentViewport();
  REUSABLE_VECTOR.copy(this.mesh.position);
  REUSABLE_VECTOR.applyQuaternion(this.mesh.quaternion);
  REUSABLE_VECTOR.applyMatrix4(this.mesh.modelViewMatrix);
  var pointSizePixels =  500 * this.characterSize / REUSABLE_VECTOR.length();
  var verticalFOV = THREE.Math.degToRad(camera.fov);
  var height = 2 * Math.tan(verticalFOV / 2) * this.position.distanceTo(camera.position);
  var width = height * camera.aspect;
  var w = width * pointSizePixels /(currentViewport.z / screenResolution);
  var h = height * pointSizePixels / (currentViewport.w / screenResolution);
  this.tmpObj.width = w;
  this.tmpObj.height = h;
  return this.tmpObj;
}

AddedText.prototype.intersectsLine = function(line){
  if (this.plane.intersectLine(line, REUSABLE_VECTOR)){
    if (this.triangles[0].containsPoint(REUSABLE_VECTOR) || this.triangles[1].containsPoint(REUSABLE_VECTOR)){
      return REUSABLE_VECTOR;
    }
  }
  return false;
}

AddedText.prototype.getCenterCoordinates = function(){
  this.handleBoundingBox();
  this.boundingBox.getCenter(this.reusableVector);
  return this.reusableVector;
}

AddedText.prototype.handleBoundingBox = function(){
  if (this.is2D){
    return;
  }
  if (!this.boundingBox){
    this.boundingBox = new THREE.Box3();
    this.bbHelper = new THREE.Box3Helper(this.boundingBox);
    this.plane = new THREE.Plane();
    this.triangles = [new THREE.Triangle(), new THREE.Triangle()];
  }else{
    this.boundingBox.makeEmpty();
  }
  var cSize = this.calculateCharSize();
  REUSABLE_VECTOR.copy(this.topLeft)
  REUSABLE_VECTOR_2.copy(this.bottomRight);
  REUSABLE_VECTOR_3.copy(this.topRight);
  REUSABLE_VECTOR_4.copy(this.bottomLeft);
  REUSABLE_VECTOR.x -= cSize.width / 2;
  REUSABLE_VECTOR.y += cSize.height / 2;
  REUSABLE_VECTOR_2.x += cSize.width / 2;
  REUSABLE_VECTOR_2.y -= cSize.height / 2;
  REUSABLE_VECTOR_3.x += cSize.width / 2;
  REUSABLE_VECTOR_3.y += cSize.height / 2;
  REUSABLE_VECTOR_4.x -= cSize.width / 2;
  REUSABLE_VECTOR_4.y -= cSize.height / 2;

  REUSABLE_VECTOR.applyQuaternion(camera.quaternion);
  REUSABLE_VECTOR_2.applyQuaternion(camera.quaternion);
  REUSABLE_VECTOR_3.applyQuaternion(camera.quaternion);
  REUSABLE_VECTOR_4.applyQuaternion(camera.quaternion);

  REUSABLE_VECTOR.add(this.mesh.position);
  REUSABLE_VECTOR_2.add(this.mesh.position);
  REUSABLE_VECTOR_3.add(this.mesh.position);
  REUSABLE_VECTOR_4.add(this.mesh.position);

  this.boundingBox.expandByPoint(REUSABLE_VECTOR);
  this.boundingBox.expandByPoint(REUSABLE_VECTOR_2);
  this.boundingBox.expandByPoint(REUSABLE_VECTOR_3);
  this.boundingBox.expandByPoint(REUSABLE_VECTOR_4);

  REUSABLE_VECTOR.copy(this.topLeft)
  REUSABLE_VECTOR_2.copy(this.bottomRight);
  REUSABLE_VECTOR_3.copy(this.topRight);
  REUSABLE_VECTOR_4.copy(this.bottomLeft);
  REUSABLE_VECTOR.z = 0, REUSABLE_VECTOR_2.z = 0, REUSABLE_VECTOR_3.z = 0, REUSABLE_VECTOR_4.z = 0;
  REUSABLE_VECTOR.x -= cSize.width / 2;
  REUSABLE_VECTOR.y += cSize.height / 2;
  REUSABLE_VECTOR_2.x += cSize.width / 2;
  REUSABLE_VECTOR_2.y -= cSize.height / 2;
  REUSABLE_VECTOR_3.x += cSize.width / 2;
  REUSABLE_VECTOR_3.y += cSize.height / 2;
  REUSABLE_VECTOR_4.x -= cSize.width / 2;
  REUSABLE_VECTOR_4.y -= cSize.height / 2;

  REUSABLE_VECTOR.applyQuaternion(camera.quaternion);
  REUSABLE_VECTOR_2.applyQuaternion(camera.quaternion);
  REUSABLE_VECTOR_3.applyQuaternion(camera.quaternion);
  REUSABLE_VECTOR_4.applyQuaternion(camera.quaternion);

  REUSABLE_VECTOR.add(this.mesh.position);
  REUSABLE_VECTOR_2.add(this.mesh.position);
  REUSABLE_VECTOR_3.add(this.mesh.position);
  REUSABLE_VECTOR_4.add(this.mesh.position);

  this.plane.setFromCoplanarPoints(REUSABLE_VECTOR, REUSABLE_VECTOR_2, REUSABLE_VECTOR_3);
  this.triangles[0].set(REUSABLE_VECTOR, REUSABLE_VECTOR_2, REUSABLE_VECTOR_3);
  this.triangles[1].set(REUSABLE_VECTOR, REUSABLE_VECTOR_2, REUSABLE_VECTOR_4);

  this.lastUpdateQuaternion.copy(camera.quaternion);
  this.lastUpdatePosition.copy(this.mesh.position);
  this.lastUpdateCameraPosition.copy(camera.position);
}

AddedText.prototype.needsUpdate = function(){
  if (this.makeFirstUpdate){
    this.makeFirstUpdate = false;
    return true;
  }
  return !(
    this.lastUpdateQuaternion.x == camera.quaternion.x &&
    this.lastUpdateQuaternion.y == camera.quaternion.y &&
    this.lastUpdateQuaternion.z == camera.quaternion.z &&
    this.lastUpdateQuaternion.w == camera.quaternion.w &&
    this.lastUpdatePosition.x == this.mesh.position.x &&
    this.lastUpdatePosition.y == this.mesh.position.y &&
    this.lastUpdatePosition.z == this.mesh.position.z &&
    this.lastUpdateCameraPosition.x == camera.position.x &&
    this.lastUpdateCameraPosition.y == camera.position.y &&
    this.lastUpdateCameraPosition.z == camera.position.z
  )
}

AddedText.prototype.debugTriangles = function(triangleIndex){
  this.handleBoundingBox();
  var s1 = new THREE.Mesh(new THREE.SphereGeometry(2), new THREE.MeshBasicMaterial({color: "red"}));
  var s2 = s1.clone(), s3 = s1.clone();
  var sCenter = new THREE.Mesh(new THREE.SphereGeometry(20), new THREE.MeshBasicMaterial({color: "lime"}));
  var triangle = this.triangles[triangleIndex];
  scene.add(s1);
  scene.add(s2);
  scene.add(s3);
  scene.add(sCenter);
  s1.position.copy(triangle.a);
  s2.position.copy(triangle.b);
  s3.position.copy(triangle.c);
  sCenter.position.copy(this.getCenterCoordinates());
}

AddedText.prototype.hide = function(){
  this.mesh.visible = false;
  if (mode == 0 && this.bbHelper){
    scene.remove(this.bbHelper);
  }
  if (mode == 0 && this.rectangle){
    scene.remove(this.rectangle.mesh);
  }
  if (mode == 1 && this.isClickable && !this.is2D){
    rayCaster.binHandler.deleteObjectFromBin(this.binInfo, this.name);
  }
}

AddedText.prototype.show = function(){
  this.mesh.visible = true;
  if (mode == 1 && this.isClickable){
    if (!this.boundingBox){
      this.handleBoundingBox();
    }
    if (!this.is2D){
      rayCaster.binHandler.insert(this.boundingBox, this.name);
    }
  }
}

AddedText.prototype.restore = function(){
  if (!(typeof this.oldText == UNDEFINED)){
    this.setText(this.oldText);
    delete this.oldText;
  }
  if (!(typeof this.oldColorR == UNDEFINED)){
    this.material.uniforms.color.value.setRGB(
      this.oldColorR, this.oldColorG, this.oldColorB
    );
    delete this.oldColorR;
    delete this.oldColorG;
    delete this.oldColorB;
  }
  if (!(typeof this.oldAlpha == UNDEFINED)){
    this.setAlpha(this.oldAlpha);
    delete this.oldAlpha;
  }
  if (!(typeof this.oldBackgroundStatus == UNDEFINED)){
    this.material.uniforms.hasBackgroundColorFlag.value = this.oldBackgroundStatus;
    delete this.oldBackgroundStatus;
  }
  if (!(typeof this.oldBackgroundR == UNDEFINED)){
    this.material.uniforms.backgroundColor.value.setRGB(
      this.oldBackgroundR, this.oldBackgroundG, this.oldBackgroundB
    );
    this.material.uniforms.backgroundAlpha.value = this.oldBackgroundAlpha;
    delete this.oldBackgroundR;
    delete this.oldBackgroundG;
    delete this.oldBackgroundB;
    delete this.oldBackgroundAlpha;
  }
  this.mesh.position.copy(this.position);
}

AddedText.prototype.setAffectedByFog = function(val){
  this.isAffectedByFog = val;
}

AddedText.prototype.set2DStatus = function(is2D){
  if (is2D == this.is2D){
    return;
  }
  this.is2D = is2D;
  if (is2D){
    this.injectMacro("IS_TWO_DIMENSIONAL", true, false);
    this.set2DCoordinates(this.marginPercentWidth, this.marginPercentHeight);
    if (typeof this.oldIsClickable == UNDEFINED){
      this.oldIsClickable = this.isClickable;
    }
    this.isClickable = false;
    addedTexts2D[this.name] = this;
  }else{
    this.removeMacro("IS_TWO_DIMENSIONAL", true, false);
    delete this.mesh.material.uniforms.margin2D;
    this.isClickable = this.oldIsClickable;
    delete this.oldIsClickable;
    if (!(typeof this.refCharOffset == UNDEFINED)){
      this.setMarginBetweenChars(this.refCharOffset);
      delete this.refCharOffset;
    }
    if (!(typeof this.refLineOffset == UNDEFINED)){
      this.setMarginBetweenLines(this.refLineOffset);
      delete this.refLineOffset;
    }
    delete addedTexts2D[this.name];
  }
  if (is2D){
    rayCaster.binHandler.deleteObjectFromBin(this.binInfo, this.name);
    if (this.bbHelper){
      scene.remove(this.bbHelper);
    }
  }else{
    rayCaster.binHandler.insert(this.boundingBox, this.name);
  }
}

AddedText.prototype.set2DCoordinates = function(marginPercentWidth, marginPercentHeight){
  GLOBAL_ADDEDTEXT_VIEWPORT_UNIFORM.value.set(0, 0, window.innerWidth * screenResolution, window.innerHeight * screenResolution);
  this.marginPercentWidth = marginPercentWidth;
  this.marginPercentHeight = marginPercentHeight;
  var isFromLeft = false, isFromTop = false;
  if (this.marginMode == MARGIN_MODE_2D_TEXT_TOP_LEFT){
    isFromLeft = true;
    isFromTop = true;
  }
  var curViewport = REUSABLE_QUATERNION.set(0, 0, window.innerWidth, window.innerHeight);
  if (isFromLeft){
    var tmpX = ((curViewport.z - curViewport.x) / 2.0) + curViewport.x + this.twoDimensionalParameters.x;
    var widthX = (((tmpX - curViewport.x) * 2.0) / curViewport.z) - 1.0;
    var marginX = (((marginPercentWidth) * (2)) / (100)) -1;
    var cSizeX = (this.characterSize / (renderer.getCurrentViewport().z / screenResolution));
    this.cSizeX = cSizeX;
    marginX += cSizeX;
    if (marginX + widthX > 1){
      marginX = 1 - widthX - cSizeX;
    }
    this.setShaderMargin(true, marginX);
  }else{
    marginPercentWidth = marginPercentWidth + 100;
    var tmpX = ((curViewport.z - curViewport.x) / 2.0) + curViewport.x + this.twoDimensionalParameters.x;
    var widthX = (((tmpX - curViewport.x) * 2.0) / curViewport.z) - 1.0;
    var marginX = (((marginPercentWidth) * (2)) / (100)) -1;
    var cSizeX = (this.characterSize / (renderer.getCurrentViewport().z / screenResolution));
    this.cSizeX = cSizeX;
    marginX += cSizeX + widthX;
    marginX = 2 - marginX;
    if (marginX < -1){
      marginX = -1 + cSizeX;
    }
    this.setShaderMargin(true, marginX);
  }
  if (isFromTop){
    marginPercentHeight = 100 - marginPercentHeight;
    var tmpY = ((curViewport.w - curViewport.y) / 2.0) + curViewport.y + this.twoDimensionalParameters.y;
    var heightY = (((tmpY - curViewport.y) * 2.0) / curViewport.w) - 1.0;
    var marginY = (((marginPercentHeight) * (2)) / (100)) -1;
    var cSizeY = (this.characterSize / (renderer.getCurrentViewport().w / screenResolution));
    this.cSizeY = cSizeY;
    marginY -= cSizeY;
    if (marginY + heightY < -1){
      marginY = -1 - heightY + cSizeY;
    }
    this.setShaderMargin(false, marginY);
  }else{
    var tmpY = ((curViewport.w - curViewport.y) / 2.0) + curViewport.y + this.twoDimensionalParameters.y;
    var heightY = (((tmpY - curViewport.y) * 2.0) / curViewport.w) - 1.0;
    var marginY = (((marginPercentHeight) * (2)) / (100)) -1;
    var cSizeY = (this.characterSize / (renderer.getCurrentViewport().w / screenResolution));
    this.cSizeY = cSizeY;
    marginY -= cSizeY;
    if (marginY + heightY < -1){
      marginY = -1 - heightY + cSizeY;
    }
    this.setShaderMargin(false, marginY);
  }

  // CONVERTED FROM TEXT VERTEX SHADER CODE
  var oldPosX = ((GLOBAL_ADDEDTEXT_VIEWPORT_UNIFORM.value.z - GLOBAL_ADDEDTEXT_VIEWPORT_UNIFORM.value.x) / 2.0) + GLOBAL_ADDEDTEXT_VIEWPORT_UNIFORM.value.x + this.xMax;
  var oldPosY = ((GLOBAL_ADDEDTEXT_VIEWPORT_UNIFORM.value.w - GLOBAL_ADDEDTEXT_VIEWPORT_UNIFORM.value.y) / 2.0) + GLOBAL_ADDEDTEXT_VIEWPORT_UNIFORM.value.y + this.yMin;
  var x = (((oldPosX - GLOBAL_ADDEDTEXT_VIEWPORT_UNIFORM.value.x) * 2.0) / GLOBAL_ADDEDTEXT_VIEWPORT_UNIFORM.value.z) - 1.0;
  var y = (((oldPosY - GLOBAL_ADDEDTEXT_VIEWPORT_UNIFORM.value.y) * 2.0) / GLOBAL_ADDEDTEXT_VIEWPORT_UNIFORM.value.w) - 1.0;
  this.twoDimensionalSize.z = x + this.shaderMargin.x + this.cSizeX;
  this.twoDimensionalSize.w = y + this.shaderMargin.y - this.cSizeY;
  oldPosX = ((GLOBAL_ADDEDTEXT_VIEWPORT_UNIFORM.value.z - GLOBAL_ADDEDTEXT_VIEWPORT_UNIFORM.value.x) / 2.0) + GLOBAL_ADDEDTEXT_VIEWPORT_UNIFORM.value.x;
  oldPosY = ((GLOBAL_ADDEDTEXT_VIEWPORT_UNIFORM.value.w - GLOBAL_ADDEDTEXT_VIEWPORT_UNIFORM.value.y) / 2.0) + GLOBAL_ADDEDTEXT_VIEWPORT_UNIFORM.value.y;
  x = (((oldPosX - GLOBAL_ADDEDTEXT_VIEWPORT_UNIFORM.value.x) * 2.0) / GLOBAL_ADDEDTEXT_VIEWPORT_UNIFORM.value.z) - 1.0;
  y = (((oldPosY - GLOBAL_ADDEDTEXT_VIEWPORT_UNIFORM.value.y) * 2.0) / GLOBAL_ADDEDTEXT_VIEWPORT_UNIFORM.value.w) - 1.0;
  this.twoDimensionalSize.x = x + this.shaderMargin.x - this.cSizeX;
  this.twoDimensionalSize.y = y + this.shaderMargin.y + this.cSizeY;
  this.webglSpaceSize.set(
    this.twoDimensionalSize.z - this.twoDimensionalSize.x,
    this.twoDimensionalSize.y - this.twoDimensionalSize.w
  );
  if (!this.rectangle){
    this.rectangle = new Rectangle(0, 0, 0, 0);
  }
  this.rectangle = this.rectangle.set(
    this.twoDimensionalSize.x, this.twoDimensionalSize.y,
    this.twoDimensionalSize.z, this.twoDimensionalSize.w,
    this.webglSpaceSize.x, this.webglSpaceSize.y
  );
  this.rectangle.updateMesh(0.005);
}

AddedText.prototype.debugCornerPoints = function(representativeCharacter, cornerIndex){
  this.handleResize();
  if (cornerIndex == 0){
    representativeCharacter.setShaderMargin(true, this.twoDimensionalSize.x);
    representativeCharacter.setShaderMargin(false, this.twoDimensionalSize.y);
  }else{
    representativeCharacter.setShaderMargin(true, this.twoDimensionalSize.z);
    representativeCharacter.setShaderMargin(false, this.twoDimensionalSize.w);
  }
}

AddedText.prototype.injectMacro = function(macro, insertVertexShader, insertFragmentShader){
  if (insertVertexShader){
    this.material.vertexShader = this.material.vertexShader.replace(
      "#define INSERTION", "#define INSERTION\n#define "+macro
    )
  };
  if (insertFragmentShader){
    this.material.fragmentShader = this.material.fragmentShader.replace(
      "#define INSERTION", "#define INSERTION\n#define "+macro
    )
  };
  this.material.needsUpdate = true;
}

AddedText.prototype.removeMacro = function(macro, removeVertexShader, removeFragmentShader){
  if (removeVertexShader){
    this.material.vertexShader = this.material.vertexShader.replace("\n#define "+macro, "");
  }
  if (removeFragmentShader){
    this.material.fragmentShader = this.material.fragmentShader.replace("\n#define "+macro, "");
  }
  this.material.needsUpdate = true;
}

AddedText.prototype.setShaderMargin = function(isMarginX, value){
  if (!this.mesh.material.uniforms.margin2D){
    this.mesh.material.uniforms.margin2D = new THREE.Uniform(new THREE.Vector2());
    this.mesh.material.needsUpdate = true;
  }
  if (isMarginX){
    this.shaderMargin.x = value;
    this.mesh.material.uniforms.margin2D.value.x = value;
  }else{
    this.shaderMargin.y = value;
    this.mesh.material.uniforms.margin2D.value.y = value;
  }
}

AddedText.prototype.setFog = function(){
  if (this.is2D || !this.isAffectedByFog){
    return;
  }
  if (!this.mesh.material.uniforms.fogInfo){
    this.injectMacro("HAS_FOG", false, true);
    this.mesh.material.uniforms.fogInfo = GLOBAL_FOG_UNIFORM;
  }
  if (fogBlendWithSkybox){
    if (!this.mesh.material.uniforms.cubeTexture){
      this.injectMacro("HAS_SKYBOX_FOG", true, true);
      this.mesh.material.uniforms.worldMatrix = new THREE.Uniform(this.mesh.matrixWorld);
      this.mesh.material.uniforms.cubeTexture = GLOBAL_CUBE_TEXTURE_UNIFORM;
      this.mesh.material.uniforms.cameraPosition = GLOBAL_CAMERA_POSITION_UNIFORM;
    }
  }
  this.mesh.material.needsUpdate = true;
}

AddedText.prototype.removeFog = function(){
  if (this.is2D || !this.isAffectedByFog){
    return;
  }
  this.removeMacro("HAS_FOG", false, true);
  this.removeMacro("HAS_SKYBOX_FOG", true, true);
  delete this.mesh.material.uniforms.fogInfo;
  delete this.mesh.material.uniforms.cubeTexture;
  delete this.mesh.material.uniforms.worldMatrix;
  delete this.mesh.material.uniforms.cameraPosition;
  this.mesh.material.needsUpdate = true;
}

var AreaConfigurationsHandler = function(){
  this.sideAry = ["Both", "Front", "Back"];
  this.areaDefault = "default";
  this.updateNeeded = false;
}

AreaConfigurationsHandler.prototype.handle = function(){
  var result = areaBinHandler.queryArea(camera.position);
  if (result){
    if (result != this.currentArea){
      this.currentArea = result;
      this.updateNeeded = true;
    }else{
      this.updateNeeded = false;
    }
  }else if (this.currentArea != this.areaDefault){
    this.currentArea = this.areaDefault;
    this.updateNeeded = true;
  }else{
    this.updateNeeded = false;
  }
}

AreaConfigurationsHandler.prototype.generateConfigurations = function(singleAreaName){
  this.visibilityConfigurations = new Object();
  this.sideConfigurations = new Object();
  var pseudoAreas = areas;
  if (singleAreaName){
    pseudoAreas = new Object();
    if (singleAreaName.toLowerCase() != "default"){
      pseudoAreas[singleAreaName] = areas[singleAreaName];
    }
  }
  for (var areaName in pseudoAreas){
    this.visibilityConfigurations[areaName] = new Object();
    this.sideConfigurations[areaName] = new Object();
    for (var objName in addedObjects){
      var obj = addedObjects[objName];
      this.visibilityConfigurations[areaName][objName] = {
        "Visible": obj.getVisibilityInArea(areaName)
      };
      this.sideConfigurations[areaName][objName] = {
        "Side": obj.getSideInArea(areaName)
      };
    }
    for (var objName in objectGroups){
      var obj = objectGroups[objName];
      this.visibilityConfigurations[areaName][objName] = {
        "Visible": obj.getVisibilityInArea(areaName)
      };
      this.sideConfigurations[areaName][objName] = {
        "Side": obj.getSideInArea(areaName)
      };
    }
  }

  if (!singleAreaName || (singleAreaName && singleAreaName.toLowerCase() == "default")){
    this.visibilityConfigurations["default"] = new Object();
    this.sideConfigurations["default"] = new Object();
    for (var objName in addedObjects){
      var obj = addedObjects[objName];
      this.visibilityConfigurations["default"][objName] = {
        "Visible": obj.getVisibilityInArea("default")
      };
      this.sideConfigurations["default"][objName] = {
        "Side": obj.getSideInArea("default")
      };
    }
    for (var objName in objectGroups){
      var obj = objectGroups[objName];
      this.visibilityConfigurations["default"][objName] = {
        "Visible": obj.getVisibilityInArea("default")
      };
      this.sideConfigurations["default"][objName] = {
        "Side": obj.getSideInArea("default")
      };
    }
  }
}

AreaConfigurationsHandler.prototype.show = function(singleAreaName){
  this.generateConfigurations(singleAreaName);
  datGuiAreaConfigurations = new dat.GUI();
  var pseudoAreas = areas;
  if (singleAreaName){
    pseudoAreas = new Object();
    if (singleAreaName.toLowerCase() != "default"){
      pseudoAreas[singleAreaName] = areas[singleAreaName];
    }
  }
  for (var areaName in pseudoAreas){
    var areaFolder = datGuiAreaConfigurations.addFolder(areaName);
    this.addSubFolder(areaName, areaFolder);
  }
  if (!singleAreaName || (singleAreaName && singleAreaName.toLowerCase() == "default")){
    var defaultFolder = datGuiAreaConfigurations.addFolder("default");
    this.addSubFolder("default", defaultFolder);
  }
}

AreaConfigurationsHandler.prototype.addSubFolder = function(areaName, folder){
  var areaConfigurationsHandlerContext = this;
  for (var objName in addedObjects){
    var objFolder = folder.addFolder(objName);
    var visibilityController = objFolder.add(this.visibilityConfigurations[areaName][objName], "Visible");
    var sideController = objFolder.add(this.sideConfigurations[areaName][objName], "Side", this.sideAry);
    visibilityController.onChange(function(val){
      this.object.setVisibilityInArea(this.areaName, val);
      if (areaConfigurationsHandlerContext.currentArea){
        delete areaConfigurationsHandlerContext.currentArea;
      }
    }.bind({object: addedObjects[objName], areaName: areaName}));
    sideController.onChange(function(val){
      this.object.setSideInArea(this.areaName, val);
      if (areaConfigurationsHandlerContext.currentArea){
        delete areaConfigurationsHandlerContext.currentArea;
      }
    }.bind({object: addedObjects[objName], areaName: areaName}));
  }
  for (var objName in objectGroups){
    var objFolder = folder.addFolder(objName);
    var visibilityController = objFolder.add(this.visibilityConfigurations[areaName][objName], "Visible");
    var sideController = objFolder.add(this.sideConfigurations[areaName][objName], "Side", this.sideAry);
    visibilityController.onChange(function(val){
      this.object.setVisibilityInArea(this.areaName, val);
      if (areaConfigurationsHandlerContext.currentArea){
        delete areaConfigurationsHandlerContext.currentArea;
      }
    }.bind({object: objectGroups[objName], areaName: areaName}));
    sideController.onChange(function(val){
      this.object.setSideInArea(this.areaName, val);
      if (areaConfigurationsHandlerContext.currentArea){
        delete areaConfigurationsHandlerContext.currentArea;
      }
    }.bind({object: objectGroups[objName], areaName: areaName}));
  }
}

AreaConfigurationsHandler.prototype.sphericalDistribution = function(radius){
  REUSABLE_VECTOR.set(
    Math.random() - 0.5,
    Math.random() - 0.5,
    Math.random() - 0.5
  );
  REUSABLE_VECTOR.normalize();
  REUSABLE_VECTOR.multiplyScalar(radius);
  return REUSABLE_VECTOR;
}

AreaConfigurationsHandler.prototype.getRandomPointInsideArea = function(area){
  var x = Math.random() * (area.boundingBox.max.x - area.boundingBox.min.x) + area.boundingBox.min.x;
  var y = Math.random() * (area.boundingBox.max.y - area.boundingBox.min.y) + area.boundingBox.min.y;
  var z = Math.random() * (area.boundingBox.max.z - area.boundingBox.min.z) + area.boundingBox.min.z;
  REUSABLE_VECTOR.set(x, y, z);
  return REUSABLE_VECTOR;
}

AreaConfigurationsHandler.prototype.autoConfigureArea = function(areaName){
  var area = areas[areaName];
  for (var objName in addedObjects){
    addedObjects[objName].setVisibilityInArea(areaName, false);
    if (!addedObjects[objName].defaultSide){
      addedObjects[objName].setSideInArea(areaName, SIDE_BOTH);
    }else{
      addedObjects[objName].setSideInArea(areaName, addedObjects[objName].defaultSide);
    }
  }
  for (var objName in objectGroups){
    objectGroups[objName].setVisibilityInArea(areaName, false);
    if (!objectGroups[objName].defaultSide){
      objectGroups[objName].setSideInArea(areaName, SIDE_BOTH);
    }else{
      objectGroups[objName].setSideInArea(areaName, objectGroups[objName].defaultSide);
    }
  }
  var visibleObjects = new Object();
  for (var i2 = 0; i2<200; i2++){
    var pointInsideArea = this.getRandomPointInsideArea(area);
    REUSABLE_VECTOR_5.set(pointInsideArea.x, pointInsideArea.y, pointInsideArea.z);
    for (var i = 0; i<200; i++){
      var vec = this.sphericalDistribution(1);
      REUSABLE_VECTOR_4.set(vec.x , vec.y, vec.z);
      rayCaster.findIntersections(REUSABLE_VECTOR_5, REUSABLE_VECTOR_4, false);
      if (intersectionPoint){
        visibleObjects[intersectionObject] = true;
      }
    }
  }
  delete this.currentArea;
  for (var objName in visibleObjects){
    var obj = addedObjects[objName];
    if (!obj){
      obj = objectGroups[objName];
    }
    if (obj){
      obj.setVisibilityInArea(areaName, true);
    }
  }
}

var RayCaster = function(){
  this.binHandler = new WorldBinHandler();
  this.origin = new THREE.Vector3();
  this.direction = new THREE.Vector3();
  this.oldPosition = new THREE.Vector3();
}

RayCaster.prototype.refresh = function(){
  if (!projectLoaded){
    return;
  }
  this.binHandler = new WorldBinHandler();
  if (mode == 0){
    for (var gsName in gridSystems){
      var gridSystem = gridSystems[gsName];
      this.binHandler.insert(gridSystem.boundingBox, gridSystem.name);
    }
    for (var txtName in addedTexts){
      var addedText = addedTexts[txtName];
      if (!addedText.is2D){
        this.binHandler.insert(addedText.boundingBox, txtName);
      }
    }
  }else{
    for (var txtName in addedTexts){
      var addedText = addedTexts[txtName];
      if (addedText.isClickable && !addedText.is2D){
        this.binHandler.insert(addedText.boundingBox, txtName);
      }
    }
  }
}

RayCaster.prototype.updateObject = function(obj){
  this.binHandler.updateObject(obj);
}

RayCaster.prototype.findIntersections = function(from, direction, intersectGridSystems){
  intersectionPoint = 0, intersectionObject = 0;
  this.origin.copy(from);
  this.direction.copy(direction);
  this.oldPosition.copy(this.origin);
  var iterate = true;
  while (iterate){
    REUSABLE_LINE.set(this.oldPosition, this.origin);
    var results = this.binHandler.query(this.origin);
    for (var objName in results){
      var result = results[objName];
      if (result == 5){
        var obj = addedObjects[objName];
        if (obj){
          if (!(mode == 0 && keyboardBuffer["Shift"])){
            intersectionPoint = obj.intersectsLine(REUSABLE_LINE);
            if (intersectionPoint){
              intersectionObject = objName;
              return;
            }
          }
        }
      }else if (result == 10){
        var gs = gridSystems[objName];
        if (gs && intersectGridSystems){
          intersectionPoint = gs.intersectsLine(REUSABLE_LINE);
          if (intersectionPoint){
            var selectedGrid = gs.getGridFromPoint(intersectionPoint);
            if (!(selectedGrid.sliced && gridSystems[selectedGrid.slicedGridSystemName])){
              intersectionObject = objName;
              return;
            }
            intersectionPoint = 0;
          }
        }
      }else if (result == 20){
        var addedText = addedTexts[objName];
        if (addedText && addedText.plane){
          intersectionPoint = addedText.intersectsLine(REUSABLE_LINE);
          if (intersectionPoint){
            intersectionObject = objName;
            return;
          }
        }
      }else{
        if (!(mode == 0 && keyboardBuffer["Shift"])){
          var parent = objectGroups[objName];
          if (parent){
            for (var childName in result){
              var obj = parent.group[childName];
              if (obj){
                if (!(mode == 0 && keyboardBuffer["Shift"])){
                  intersectionPoint = obj.intersectsLine(REUSABLE_LINE);
                  if (intersectionPoint){
                    intersectionObject = objName;
                    return;
                  }
                }
              }
            }
          }
        }
      }
    }
    this.oldPosition.copy(this.origin);
    this.origin.addScaledVector(this.direction, 32);
    iterate = LIMIT_BOUNDING_BOX.containsPoint(this.origin);
  }
}

var Rectangle = function(x, y, width, height){
  this.x = x;
  this.y = y;
  this.width = width;
  this.height = height;
  this.finalX = x + width;
  this.finalY = y + height;
}
Rectangle.prototype.set = function(x, y, x2, y2, width, height){
  this.x = x;
  this.y = y;
  this.finalX = x2;
  this.finalY = y2;
  this.width = width,
  this.height = height;
  return this;
}
Rectangle.prototype.handlePositionUniform = function(thicknessOffset){
  var positions = this.material.uniforms.positions.value;
  var tox = thicknessOffset;
  var toy = thicknessOffset * camera.aspect;
  // UP
  positions[0].x = this.x - tox;
  positions[0].y = this.y;
  positions[1].x = this.finalX + tox;
  positions[1].y = this.y;
  positions[2].x = this.finalX + tox;
  positions[2].y = this.y + toy;
  positions[3].x = this.finalX + tox;
  positions[3].y = this.y + toy;
  positions[4].x = this.x - tox;
  positions[4].y = this.y + toy;
  positions[5].x = this.x - tox;
  positions[5].y = this.y;
  // RIGHT
  positions[6].x = this.finalX;
  positions[6].y = this.y;
  positions[7].x = this.finalX;
  positions[7].y = this.finalY;
  positions[8].x = this.finalX + tox;
  positions[8].y = this.finalY;
  positions[9].x = this.finalX + tox;
  positions[9].y = this.finalY;
  positions[10].x = this.finalX + tox;
  positions[10].y = this.y;
  positions[11].x = this.finalX;
  positions[11].y = this.y;
  // DOWN
  positions[12].x = this.x - tox;
  positions[12].y = this.finalY;
  positions[13].x = this.finalX + tox;
  positions[13].y = this.finalY;
  positions[14].x = this.finalX + tox;
  positions[14].y = this.finalY - toy;
  positions[15].x = this.finalX + tox;
  positions[15].y = this.finalY - toy;
  positions[16].x = this.x - tox;
  positions[16].y = this.finalY - toy;
  positions[17].x = this.x - tox;
  positions[17].y = this.finalY;
  // LEFT
  positions[18].x = this.x - tox;
  positions[18].y = this.y;
  positions[19].x = this.x - tox;
  positions[19].y = this.finalY;
  positions[20].x = this.x;
  positions[20].y = this.finalY;
  positions[21].x = this.x;
  positions[21].y = this.finalY;
  positions[22].x = this.x;
  positions[22].y = this.y;
  positions[23].x = this.x - tox;
  positions[23].y = this.y;

}
Rectangle.prototype.updateMesh = function(thicknessOffset){
  if (!this.mesh){
    this.geometry = new THREE.BufferGeometry();
    var rectangleIndices = new Float32Array(24);
    var positions = [];
    for (var i = 0; i<24; i++){
      rectangleIndices[i] = i;
      positions.push(new THREE.Vector2());
    }
    var indicesBufferAttribute = new THREE.BufferAttribute(rectangleIndices, 1);
    indicesBufferAttribute.setDynamic(false);
    this.geometry.addAttribute('rectangleIndex', indicesBufferAttribute);
    this.geometry.setDrawRange(0, 24);
    this.material = new THREE.RawShaderMaterial({
      vertexShader: ShaderContent.rectangleVertexShader,
      fragmentShader: ShaderContent.rectangleFragmentShader,
      transparent: true,
      side: THREE.DoubleSide,
      uniforms: {
        color: new THREE.Uniform(new THREE.Color("yellow")),
        alpha: new THREE.Uniform(1.0),
        positions: new THREE.Uniform(positions)
      }
    });
    this.mesh = new THREE.Mesh(this.geometry, this.material);
    this.mesh.frustumCulled = false;
  }
  this.handlePositionUniform(thicknessOffset);
}
Rectangle.prototype.fits = function(texture){
  var tw = texture.image.width;
  var th = texture.image.height;
  if (tw <= this.width && th <= this.height){
    return true;
  }
  return false;
}
Rectangle.prototype.fitsPerfectly = function(texture){
  var tw = texture.image.width;
  var th = texture.image.height;
  return (tw == this.width) && (th == this.height);
}
Rectangle.prototype.overlaps = function(rect){
  return this.x < rect.x + rect.width && this.x + this.width > rect.x && this.y < rect.y + rect.height && this.y + this.height > rect.y;
}

var TextureMerger = function(texturesObj){
  if (!texturesObj){
    return;
  }
  this.dataURLs = new Object();
  for (var textureName in texturesObj){
    var txt = texturesObj[textureName];
    if (txt instanceof THREE.CompressedTexture){
      // NOT SUPPORTED FOR NOW
    }else{
      if (typeof txt.image.toDataURL == UNDEFINED){
        var tmpCanvas = document.createElement("canvas");
        tmpCanvas.width = txt.image.naturalWidth;
        tmpCanvas.height = txt.image.naturalHeight;
        tmpCanvas.getContext('2d').drawImage(txt.image, 0, 0);
        this.dataURLs[textureName] = tmpCanvas.toDataURL();
      }else{
        this.dataURLs[textureName] = txt.image.toDataURL();
      }
    }
  }
  this.canvas = document.createElement("canvas");
  this.textureCount = 0;
  this.maxWidth = 0;
  this.maxHeight = 0;
  var explanationStr = "";
  for (textureName in texturesObj){
    this.textureCount ++;
    var texture = texturesObj[textureName];
    texture.area = texture.image.width * texture.image.height;
    if (texture.image.width > this.maxWidth){
      this.maxWidth = texture.image.width;
    }
    if (texture.image.height > this.maxHeight){
      this.maxHeight = texture.image.height;
    }
    explanationStr += textureName + ",";
  }
  explanationStr = explanationStr.substring(0, explanationStr.length - 1);
  this.textureCache = new Object();
  // node
  //  |___ children: Array(2) of node
  //  |___ rectangle: Rectangle
  //  |___ textureName: String
  //  |___ upperNode: node
  this.node = new Object();
  this.node.rectangle = new Rectangle(0, 0, this.maxWidth * this.textureCount,
                                              this.maxHeight * this.textureCount);
  this.textureOffsets = new Object();
  this.allNodes = [];
  this.insert(this.node, this.findNextTexture(texturesObj), texturesObj);
  //this.debugOffsets(texturesObj);
  this.ranges = new Object();
  var imgSize = this.calculateImageSize(texturesObj);
  this.canvas.width = imgSize.width;
  this.canvas.height = imgSize.height;
  var context = this.canvas.getContext("2d");
  this.context = context;
  for (textureName in this.textureOffsets){
    var texture = texturesObj[textureName];
    var offsetX = this.textureOffsets[textureName].x;
    var offsetY = this.textureOffsets[textureName].y;
    var imgWidth = texture.image.width;
    var imgHeight = texture.image.height;
    var repeatX = texture.repeat.x;
    var repeatY = texture.repeat.y;
    if (repeatX == 0){
      repeatX = 1;
    }
    if (repeatY == 0){
      repeatY = 1;
    }
    var mirrorS = false;
    var mirrorT = false;
    if (texture.wrapS == THREE.MirroredRepeatWrapping){
      mirrorS = true;
    }
    if (texture.wrapT == THREE.MirroredRepeatWrapping){
      mirrorT = true;
    }
    var ofX = texture.offset.x;
    var ofY = texture.offset.y;
    if (ofX == 0 && ofY == 0){
      if (textureName.indexOf(",emissive") !== -1){
        var tmpTexture = texturesObj[textureName.replace(",emissive", ",diffuse")];
        if (tmpTexture){
          ofX = tmpTexture.offset.x;
          ofY = tmpTexture.offset.y;
        }
      }
    }
    while (ofX < 0){
      ofX = ofX + 100;
    }
    while (ofY < 0){
      ofY = ofY + 100;
    }
    ofX = ofX - Math.floor(ofX);
    ofY = ofY - Math.floor(ofY);
    var isCustomCanvas = false;
    if ((ofX != 0 || ofY != 0)){
      var cnvs = document.createElement("canvas");
      var ctx = cnvs.getContext("2d");
      isCustomCanvas = true;
      cnvs.width = texture.image.width * 3;
      cnvs.height = texture.image.height * 3;
      for (var f1 = 0; f1 <= 2*imgWidth; f1 += imgWidth){
        for (var f2 = 0; f2 <= 2 * imgHeight; f2 += imgHeight){
          for (var y = f2; y<f2+imgHeight; y+=imgHeight){
            for (var x = f1; x<f1+imgWidth; x+=imgWidth){
                ctx.drawImage(texture.image, x, y, imgWidth, imgHeight);
            }
          }
        }
      }
      var newStartX = imgWidth;
      if (ofX != 0){
        newStartX = newStartX + (imgWidth * ofX);
      }
      var newStartY = imgHeight;
      if (ofY != 0){
        newStartY = newStartY - (imgHeight * ofY);
      }
      this.tmpCanvas = document.createElement("canvas");
      this.tmpCanvas.width = imgWidth;
      this.tmpCanvas.height = imgHeight;
      var tmpContext = this.tmpCanvas.getContext("2d");
      tmpContext.drawImage(
        cnvs, newStartX, newStartY, imgWidth, imgHeight, 0, 0, imgWidth, imgHeight
      );
      //this.debugCanvas(this.tmpCanvas);
    }
    var mirrorStepX = 0;
    var mirrorStepY = 0;
    var flippedYOffsetX = 0;
    if (!isCustomCanvas && !(mirrorS || mirrorT)){
      for (var y = offsetY; y<offsetY+imgHeight; y+=imgHeight/repeatY){
        for (var x = offsetX; x<offsetX+imgWidth; x+=imgWidth/repeatX){
          context.drawImage(texture.image, x, y, imgWidth/repeatX, imgHeight/repeatY);
        }
      }
    }else if (!(mirrorS || mirrorT)){
      for (var y = offsetY; y<offsetY+imgHeight; y+=imgHeight/repeatY){
        for (var x = offsetX; x<offsetX+imgWidth; x+=imgWidth/repeatX){
            context.drawImage(this.tmpCanvas, 0, 0, imgWidth, imgHeight, x, y, imgWidth/repeatX, imgHeight/repeatY);
        }
      }
    }else{
      var foCanvas = document.createElement("canvas");
      foCanvas.width = imgWidth;
      foCanvas.height = imgHeight;
      var foContext = foCanvas.getContext("2d");
      var noy = 0;
      var nox = 0;
      for (var y = offsetY; y<offsetY+imgHeight; y+= imgHeight/repeatY){
        var selectedContext = foContext;
        var flippedYCanvas;
        if (mirrorT && (((mirrorStepY % 2 == 0) && (repeatY % 2 == 0)) || ((mirrorStepY % 2 == 1) && (repeatY % 2== 1)))){
          flippedYCanvas = document.createElement("canvas");
          flippedYCanvas.width = imgWidth;
          flippedYCanvas.height = imgHeight/repeatY;
          selectedContext = flippedYCanvas.getContext("2d");
          selectedContext.scale(1, -1);
        }else{
          flippedYCanvas = 0;
        }
        for (var x = offsetX; x<offsetX+imgWidth; x+= imgWidth/repeatX){
          if (mirrorStepX % 2 == 1 && mirrorS){
            var flippedCanvas = document.createElement("canvas");
            flippedCanvas.width = imgWidth/repeatX;
            flippedCanvas.height = imgHeight/repeatY;
            var flippedContext = flippedCanvas.getContext("2d");
            flippedContext.scale(-1, 1);
            flippedContext.drawImage(texture.image, 0, 0, -1*imgWidth/repeatX, imgHeight/repeatY);
            //this.debugCanvas(flippedCanvas);
            if (!flippedYCanvas){
              selectedContext.drawImage(flippedCanvas, 0, 0, imgWidth/repeatX, imgHeight/repeatY, nox, noy, imgWidth/repeatX, imgHeight/repeatY);
              nox += imgWidth/repeatX;
            }else{
              selectedContext.drawImage(flippedCanvas, 0, 0, imgWidth/repeatX, imgHeight/repeatY, flippedYOffsetX, 0, imgWidth/repeatX, -1*imgHeight/repeatY);
              flippedYOffsetX += imgWidth/repeatX;
              //this.debugCanvas(flippedYCanvas);
            }
          }else{
            if (!flippedYCanvas){
              selectedContext.drawImage(texture.image, nox, noy, imgWidth/repeatX, imgHeight/repeatY);
              nox += imgWidth/repeatX;
            }else{
              selectedContext.drawImage(texture.image, flippedYOffsetX, 0, imgWidth/repeatX, -1*imgHeight/repeatY);
              flippedYOffsetX += imgWidth/repeatX;
              //this.debugCanvas(flippedYCanvas);
            }
          }
          mirrorStepX ++;
        }
        mirrorStepX = 0;
        mirrorStepY ++;
        flippedYOffsetX = 0;
        nox = 0;
        noy += imgHeight/repeatY;
        if (flippedYCanvas){
          //this.debugCanvas(flippedYCanvas);
          foContext.drawImage(flippedYCanvas, 0, 0, imgWidth, imgHeight/repeatY, 0, y, imgWidth, imgHeight/repeatY);
          //this.debugCanvas(foCanvas);
        }
      }
      //this.debugCanvas(foCanvas);
      var layoutCanvas = document.createElement("canvas");
      layoutCanvas.width = 5 * imgWidth;
      layoutCanvas.height = 5 * imgHeight;
      var layoutContext = layoutCanvas.getContext("2d");
      var flCanvas = document.createElement("canvas");
      flCanvas.width = 5 * foCanvas.width;
      flCanvas.height = foCanvas.height;
      var flContext = flCanvas.getContext("2d");
      if (mirrorS){
        var mirrorXCanvasRight = document.createElement("canvas");
        mirrorXCanvasRight.width = foCanvas.width;
        mirrorXCanvasRight.height = foCanvas.height;
        var mirrorXContextRight = mirrorXCanvasRight.getContext("2d");
        mirrorXContextRight.scale(-1, 1);
        mirrorXContextRight.drawImage(foCanvas, 0, 0, -1 * imgWidth, imgHeight);
        //this.debugCanvas(mirrorXCanvasRight);
        //flContext.drawImage(foCanvas, 0, 0, imgWidth, imgHeight, 0, 0, imgWidth, imgHeight);
        flContext.drawImage(mirrorXCanvasRight, 0, 0, imgWidth, imgHeight, imgWidth, 0, imgWidth, imgHeight);
        flContext.drawImage(foCanvas, 0, 0, imgWidth, imgHeight, 2 * imgWidth, 0, imgWidth, imgHeight);
        flContext.drawImage(mirrorXCanvasRight, 0, 0, imgWidth, imgHeight, 3 * imgWidth, 0, imgWidth, imgHeight);
        //flContext.drawImage(foCanvas, 0, 0, imgWidth, imgHeight, 4 * imgWidth, 0, imgWidth, imgHeight);
        //this.debugCanvas(flCanvas);
      }else{
        //flContext.drawImage(foCanvas, 0, 0, imgWidth, imgHeight, 0, 0, imgWidth, imgHeight);
        flContext.drawImage(foCanvas, 0, 0, imgWidth, imgHeight, imgWidth, 0, imgWidth, imgHeight);
        flContext.drawImage(foCanvas, 0, 0, imgWidth, imgHeight, 2 * imgWidth, 0, imgWidth, imgHeight);
        flContext.drawImage(foCanvas, 0, 0, imgWidth, imgHeight, 3 * imgWidth, 0, imgWidth, imgHeight);
        //flContext.drawImage(foCanvas, 0, 0, imgWidth, imgHeight, 4 * imgWidth, 0, imgWidth, imgHeight);
        //this.debugCanvas(flCanvas);
      }
      if (mirrorT){
        var mirrorYCanvas1 = document.createElement("canvas");
        mirrorYCanvas1.width = flCanvas.width;
        mirrorYCanvas1.height = flCanvas.height;
        var mirrorYContext1 = mirrorYCanvas1.getContext("2d");
        mirrorYContext1.scale(1, -1);
        mirrorYContext1.drawImage(flCanvas, 0, 0, flCanvas.width, -1*flCanvas.height);
        //this.debugCanvas(flCanvas);
        //this.debugCanvas(mirrorYCanvas1);
        //layoutContext.drawImage(flCanvas, 0, 0, 5 * imgWidth, imgHeight, 0, 0, 5 * imgWidth, imgHeight);
        layoutContext.drawImage(mirrorYCanvas1, 0, 0, 5 * imgWidth, imgHeight, 0, imgHeight, 5 * imgWidth, imgHeight);
        layoutContext.drawImage(flCanvas, 0, 0, 5 * imgWidth, imgHeight, 0, 2 * imgHeight, 5 * imgWidth, imgHeight);
        layoutContext.drawImage(mirrorYCanvas1, 0, 0, 5 * imgWidth, imgHeight, 0, 3 * imgHeight, 5 * imgWidth, imgHeight);
        //layoutContext.drawImage(flCanvas, 0, 0, 5 * imgWidth, imgHeight, 0, 4 * imgHeight, 5 * imgWidth, imgHeight);
        //this.debugCanvas(layoutCanvas);
      }else{
        //layoutContext.drawImage(flCanvas, 0, 0, 5 * imgWidth, imgHeight, 0, 0, 5 * imgWidth, imgHeight);
        layoutContext.drawImage(flCanvas, 0, 0, 5 * imgWidth, imgHeight, 0, imgHeight, 5 * imgWidth, imgHeight);
        layoutContext.drawImage(flCanvas, 0, 0, 5 * imgWidth, imgHeight, 0, 2 * imgHeight, 5 * imgWidth, imgHeight);
        layoutContext.drawImage(flCanvas, 0, 0, 5 * imgWidth, imgHeight, 0, 3 * imgHeight, 5 * imgWidth, imgHeight);
        //layoutContext.drawImage(flCanvas, 0, 0, 5 * imgWidth, imgHeight, 0, 4 * imgHeight, 5 * imgWidth, imgHeight);
        //this.debugCanvas(layoutCanvas);
      }
      var sx = 2 * imgWidth;
      var sy = 2 * imgHeight;
      var tx = texture.offset.x % 2;
      var ty = texture.offset.y % 2;
      if (texture.offset.x == 0 && texture.offset.y == 0){
        if (textureName.indexOf(",emissive") !== -1){
          var tmpTexture = texturesObj[textureName.replace(",emissive", ",diffuse")];
          if (tmpTexture){
            tx = tmpTexture.offset.x % 2;
            ty = tmpTexture.offset.y % 2;
          }
        }
      }
      // D E B U G
      //layoutContext.beginPath();
      //layoutContext.lineWidth="6";
      //layoutContext.strokeStyle="red";
      //layoutContext.rect(sx + (imgWidth * tx / repeatX), sy - (imgHeight * ty / repeatY), imgWidth, imgHeight);
      //layoutContext.stroke();
      //layoutContext.beginPath();
      //layoutContext.strokeStyle="green";
      //layoutContext.rect(sx, sy, imgWidth, imgHeight);
      //layoutContext.stroke();
      //this.debugCanvas(layoutCanvas);
      context.drawImage(layoutCanvas, sx + (imgWidth * tx / repeatX), sy - (imgHeight * ty / repeatY), imgWidth, imgHeight, offsetX, offsetY, imgWidth, imgHeight);
    }
    var range = new Object();
    range.startU = offsetX / imgSize.width;
    range.endU = (offsetX + imgWidth) / imgSize.width;
    range.startV = 1 - (offsetY / imgSize.height);
    range.endV = 1 - ((offsetY + imgHeight) / imgSize.height);
    this.ranges[textureName] = range;
  }
  //this.debugImages(imgSize);
  if (this.canvas.width > MAX_TEXTURE_SIZE || this.canvas.height > MAX_TEXTURE_SIZE){
    throw new Error("TextureMerger error: Max texture size exceeded. ("+MAX_TEXTURE_SIZE+"x"+MAX_TEXTURE_SIZE+")");
    return;
  }
  this.mergedTexture = new THREE.CanvasTexture(this.canvas);
  this.mergedTexture.wrapS = THREE.ClampToEdgeWrapping;
  this.mergedTexture.wrapT = THREE.ClampToEdgeWrapping;
  this.mergedTexture.minFilter = THREE.NearestFilter;
  this.mergedTexture.magFilter = THREE.NearestFilter;
  this.mergedTexture.needsUpdate = true;
  //debugTexture(this.mergedTexture);
  //console.log("[*] Textures merged: "+explanationStr);
}
TextureMerger.prototype.isTextureAlreadyInserted = function(textureName, texturesObj){
  var texture = texturesObj[textureName];
  var img = this.dataURLs[textureName];
  for (var tName in texturesObj){
    if (tName == textureName){
      continue;
    }
    var txt = texturesObj[tName];
    var tImg = this.dataURLs[tName];
    if (img == tImg && (txt.offset.x == texture.offset.x) && (txt.offset.y == texture.offset.y)
                && (txt.offset.z == texture.offset.z) && (txt.repeat.x == texture.repeat.x)
                && (txt.repeat.y == texture.repeat.y) && (txt.flipX == texture.flipX) && (txt.flipY == texture.flipY)
                && (txt.wrapS == texture.wrapS) && (txt.wrapT == texture.wrapT)){
      if (this.textureOffsets[tName]){
        return this.textureOffsets[tName];
      }
    }
  }
  return false;
}
TextureMerger.prototype.insert = function(node, textureName, texturesObj){
  var texture = texturesObj[textureName];
  var res = this.isTextureAlreadyInserted(textureName, texturesObj);
  if (res){
    this.textureOffsets[textureName] = res;
    var newTextureName = this.findNextTexture(texturesObj);
    if (!(newTextureName == null)){
      this.insert(node, newTextureName, texturesObj);
    }
    return;
  }
  var tw = texture.image.width;
  var th = texture.image.height;
  if (node.upperNode){
    var minArea = ((this.maxWidth * this.textureCount) + (this.maxHeight * this.textureCount));
    var minAreaNode = 0;
    var inserted = false;
    for (var i = 0; i<this.allNodes.length; i++){
      var curNode = this.allNodes[i];
      if (!curNode.textureName && curNode.rectangle.fits(texture)){
        this.textureOffsets[textureName] = {x: curNode.rectangle.x, y: curNode.rectangle.y};
        var calculatedSize = this.calculateImageSize(texturesObj);
        var calculatedArea = calculatedSize.width + calculatedSize.height;
        if (calculatedArea < minArea && calculatedSize.width <= MAX_TEXTURE_SIZE && calculatedSize.height <= MAX_TEXTURE_SIZE){
          var overlaps = false;
          for (var tName in this.textureOffsets){
            if (tName == textureName){
              continue;
            }
            var cr = curNode.rectangle;
            var ox = this.textureOffsets[tName].x;
            var oy = this.textureOffsets[tName].y;
            var oimg = texturesObj[tName].image;
            var rect1 = new Rectangle(cr.x, cr.y, tw, th);
            var rect2 = new Rectangle(ox, oy, oimg.width, oimg.height);
            if (rect1.overlaps(rect2)){
              overlaps = true;
            }
          }
          if (!overlaps){
            minArea = calculatedArea;
            minAreaNode = this.allNodes[i];
            inserted = true;
          }
        }
        delete this.textureOffsets[textureName];
      }
    }
    if (inserted){
      this.textureOffsets[textureName] = {x: minAreaNode.rectangle.x, y: minAreaNode.rectangle.y};
      minAreaNode.textureName = textureName;
      if (!minAreaNode.children){
        var childNode1 = new Object();
        var childNode2 = new Object();
        childNode1.upperNode = minAreaNode;
        childNode2.upperNode = minAreaNode;
        minAreaNode.children = [childNode1, childNode2];
        var rx = minAreaNode.rectangle.x;
        var ry = minAreaNode.rectangle.y;
        var maxW = this.maxWidth * this.textureCount;
        var maxH = this.maxHeight * this.textureCount;
        childNode1.rectangle = new Rectangle(rx+tw, ry, maxW - (rx+tw), maxH - ry);
        childNode2.rectangle = new Rectangle(rx, ry+th, maxW - rx, maxH - (ry+th));
        this.allNodes.push(childNode1);
        this.allNodes.push(childNode2);
      }
      var newTextureName = this.findNextTexture(texturesObj);
      if (!(newTextureName == null)){
        this.insert(node, newTextureName, texturesObj);
      }
    }else{
      throw new Error("Error: Try to use smaller textures.");
    }
  }else{
    // First node
    var recW = node.rectangle.width;
    var recH = node.rectangle.height;
    node.textureName = textureName;
    var childNode1 = new Object();
    var childNode2 = new Object();
    childNode1.upperNode = node;
    childNode2.upperNode = node;
    node.children = [childNode1, childNode2];
    childNode1.rectangle = new Rectangle(tw, 0, recW - tw, th);
    childNode2.rectangle = new Rectangle(0, th, recW, recH - th);
    this.textureOffsets[textureName] = {x: node.rectangle.x, y: node.rectangle.y};
    var newNode = node.children[0];
    this.allNodes = [node, childNode1, childNode2];
    var newTextureName = this.findNextTexture(texturesObj);
    if (!(newTextureName == null)){
      this.insert(newNode, newTextureName, texturesObj);
    }
  }
}
TextureMerger.prototype.makeCanvasPowerOfTwo = function(canvas){
  var setCanvas = false;
  if (!canvas){
    canvas = this.canvas;
    setCanvas = true;
  }
  var oldWidth = canvas.width;
  var oldHeight = canvas.height;
  var newWidth = Math.pow(2, Math.round(Math.log(oldWidth) / Math.log(2)));
  var newHeight = Math.pow(2, Math.round(Math.log(oldHeight) / Math.log(2)));
  var newCanvas = document.createElement("canvas");
  newCanvas.width = newWidth;
  newCanvas.height = newHeight;
  newCanvas.getContext("2d").drawImage(canvas, 0, 0, newWidth, newHeight);
  if (setCanvas){
    this.canvas = newCanvas;
  }
}
TextureMerger.prototype.calculateImageSize = function(texturesObj){
  var width = 0;
  var height = 0;
  for (var textureName in this.textureOffsets){
    var texture = texturesObj[textureName];
    var tw = texture.image.width;
    var th = texture.image.height;
    var x = this.textureOffsets[textureName].x;
    var y = this.textureOffsets[textureName].y;
    if (x + tw > width){
      width = x + tw;
    }
    if (y + th > height){
      height = y + th;
    }
  }
  return {"width": width, "height": height};
}
TextureMerger.prototype.debugImages = function(imgSize){
  var newTab = window.open();
  var img = new Image(imgSize.width, imgSize.height);
  img.src = this.canvas.toDataURL();
  newTab.document.body.appendChild(img);
}
TextureMerger.prototype.debugCanvas = function(canvas){
  var context = canvas.getContext("2d");
  var newTab = window.open();
  var img = new Image(canvas.width, canvas.height);
  img.src = canvas.toDataURL();
  newTab.document.body.appendChild(img);
}
TextureMerger.prototype.debugOffsets = function(texturesObj){
  var canvas = document.createElement("canvas");
  canvas.width = this.maxWidth * this.textureCount;
  canvas.height = this.maxHeight * this.textureCount;
  var context = canvas.getContext("2d");
  context.font = "20px Arial";
  for (textureName in this.textureOffsets){
    var texture = texturesObj[textureName];
    var tw = texture.image.width;
    var th = texture.image.height;
    var x = this.textureOffsets[textureName].x;
    var y = this.textureOffsets[textureName].y;
    context.rect(x, y, tw, th);
    context.fillText(textureName, x+(tw/2), y+(th/2));
    context.stroke();
  }
  var newTab = window.open();
  var img = new Image(this.maxWidth * this.textureCount, this.maxHeight * this.textureCount);
  img.src = canvas.toDataURL();
  newTab.document.body.appendChild(img);
}
TextureMerger.prototype.findNextTexture = function(texturesObj){
  var maxArea = -1;
  var foundTexture;
  for (textureName in texturesObj){
    var texture = texturesObj[textureName];
    if (!this.textureCache[textureName]){
      if (texture.area > maxArea){
        maxArea = texture.area;
        foundTexture = textureName;
      }
    }
  }
  if (maxArea == -1){
    return null;
  }
  this.textureCache[foundTexture] = true;
  return foundTexture;
}
TextureMerger.prototype.rescale = function(canvas, scale){
  var resizedCanvas = document.createElement("canvas");
  resizedCanvas.width = canvas.width * scale;
  resizedCanvas.height = canvas.height * scale;
  var resizedContext = resizedCanvas.getContext("2d");
  resizedContext.drawImage(canvas, 0, 0, canvas.width, canvas.height, 0, 0, resizedCanvas.width, resizedCanvas.height);
  //this.debugCanvas(resizedCanvas);
  return resizedCanvas;
}

var ModeSwitcher = function(){
  this.loadedScriptsCounter = 0;
  this.totalScriptsToLoad = 0;
  var that = this;
  this.scriptReloadSuccessFunction = function(scriptName){
    that.loadedScriptsCounter ++;
    if (that.loadedScriptsCounter == that.totalScriptsToLoad){
      that.enableTerminal();
      that.switchFromDesignToPreview();
    }
  }
  this.scriptReloadErrorFunction = function(scriptName, filePath){
    that.enableTerminal();
    if (!isDeployment){
      terminal.printError(Text.FAILED_TO_LOAD_SCRIPT.replace(
        Text.PARAM1, scriptName
      ).replace(
        Text.PARAM2, filePath
      ));
    }
  }
  this.scriptReloadCompilationErrorFunction = function(scriptName, errorMessage){
    that.enableTerminal();
    if (!isDeployment){
      terminal.printError(Text.INVALID_SCRIPT.replace(Text.PARAM1, errorMessage).replace(Text.PARAM2, scriptName));
    }
  }
  this.enableTerminal = function(){
    canvas.style.visibility = "";
    terminal.enable();
    terminal.clear();
  }
}

ModeSwitcher.prototype.switchMode = function(){
  if (mode == 0){
    this.loadedScriptsCounter = 0;
    if (this.totalScriptsToLoad > 0){
      terminal.clear();
      if (!isDeployment){
        terminal.printInfo(Text.LOADING_SCRIPTS);
      }
      canvas.style.visibility = "hidden";
      terminal.disable();
      for (var scriptName in scripts){
        var script = scripts[scriptName];
        if (script.localFilePath){
          script.reload(
            this.scriptReloadSuccessFunction,
            this.scriptReloadErrorFunction,
            this.scriptReloadCompilationErrorFunction
          );
        }
      }
    }else{
      this.switchFromDesignToPreview();
    }
  }else if (mode == 1){
    this.switchFromPreviewToDesign();
  }
}

ModeSwitcher.prototype.commonSwitchFunctions = function(){
  if (!isDeployment){
    guiHandler.hideAll();
    if (areaConfigurationsVisible){
      guiHandler.hide(datGuiAreaConfigurations);
      areaConfigurationsVisible = false;
    }
    selectionHandler.resetCurrentSelection();
  }
  var oldIsPaused = isPaused;
  isPaused = false;
  maxInactiveTime = 0;
  inactiveCounter = 0;
  trackingObjects = new Object();
  defaultCameraControlsDisabled = false;
  initBadTV();
  rayCaster.refresh();
  if (oldIsPaused){
    render();
  }
}

ModeSwitcher.prototype.switchFromDesignToPreview = function(){
  TOTAL_OBJECT_COLLISION_LISTENER_COUNT = 0;
  TOTAL_PARTICLE_SYSTEM_COUNT = 0;
  TOTAL_PARTICLE_COLLISION_LISTEN_COUNT = 0;
  TOTAL_PARTICLE_SYSTEM_COLLISION_LISTEN_COUNT = 0;
  TOTAL_PARTICLE_SYSTEMS_WITH_PARTICLE_COLLISIONS = 0;
  originalBloomConfigurations.bloomStrength = bloomStrength;
  originalBloomConfigurations.bloomRadius = bloomRadius;
  originalBloomConfigurations.bloomThreshold = bloomThreshold;
  originalBloomConfigurations.bloomResolutionScale = bloomResolutionScale;
  originalBloomConfigurations.bloomOn = bloomOn;
  postprocessingParameters["Bloom_strength"] = bloomStrength;
  postprocessingParameters["Bloom_radius"] = bloomRadius;
  postprocessingParameters["Bloom_threshhold"] = bloomThreshold;
  postprocessingParameters["Bloom_resolution_scale"] = bloomResolutionScale;
  postprocessingParameters["Bloom"] = bloomOn;
  for (var gsName in gridSystems){
    scene.remove(gridSystems[gsName].gridSystemRepresentation);
    scene.remove(gridSystems[gsName].boundingPlane);
  }
  for (var gridName in gridSelections){
    gridSelections[gridName].removeCornerHelpers();
    scene.remove(gridSelections[gridName].mesh);
    scene.remove(gridSelections[gridName].dot);
  }
  scriptsToRun = new Object();
  for (var markedPointName in markedPoints){
    markedPoints[markedPointName].hide(true);
  }
  if (areasVisible){
    for (var areaName in areas){
      areas[areaName].hide();
    }
  }
  for (var scriptName in scripts){
    var script = scripts[scriptName];
    if (script.runAutomatically){
      var script2 = new Script(scriptName, script.script);
      script2.localFilePath = script.localFilePath;
      script2.start();
      scripts[scriptName] = script2;
      script2.runAutomatically = true;
    }
  }
  for (var textName in addedTexts){
    var addedText = addedTexts[textName];
    if (addedText.bbHelper){
      scene.remove(addedText.bbHelper);
    }
    if (addedText.rectangle){
      scene.remove(addedText.rectangle.mesh);
    }
  }
  if (selectedAddedObject){
    selectedAddedObject.removeBoundingBoxesFromScene();
  }
  if (selectedObjectGroup){
    selectedObjectGroup.removeBoundingBoxesFromScene();
  }
  dynamicObjects = new Object();
  dynamicObjectGroups = new Object();
  for (var objectName in objectGroups){
    var object = objectGroups[objectName];
    object.mesh.remove(axesHelper);
    object.removeBoundingBoxesFromScene();
    if (object.binInfo){
      object.binInfo = new Map();
    }
    object.saveState();
    if (object.isDynamicObject && !object.noMass){
      dynamicObjectGroups[objectName] = object;
    }
    if (object.initOpacitySet){
      object.updateOpacity(object.initOpacity);
      object.initOpacitySet = false;
    }
  }
  for (var objectName in addedObjects){
    var object = addedObjects[objectName];
    object.mesh.remove(axesHelper);
    object.removeBoundingBoxesFromScene();
    if (object.binInfo){
      object.binInfo = new Map();
    }
    if (object.isDynamicObject && !object.noMass){
      dynamicObjects[objectName] = object;
    }
    object.saveState();
    if (object.initOpacitySet){
      object.updateOpacity(object.initOpacity);
      object.initOpacitySet = false;
    }
  }
  if (fogActive){
    GLOBAL_FOG_UNIFORM.value.set(fogDensity, fogColorRGB.r, fogColorRGB.g, fogColorRGB.b);
    if (fogBlendWithSkybox){
      GLOBAL_FOG_UNIFORM.value.set(
        -fogDensity,
        skyboxMesh.material.uniforms.color.value.r,
        skyboxMesh.material.uniforms.color.value.g,
        skyboxMesh.material.uniforms.color.value.b
      );
    }
    for (var objName in addedObjects){
      addedObjects[objName].setFog();
    }
    for (var objName in objectGroups){
      objectGroups[objName].setFog();
    }
    for (var textName in addedTexts){
      addedTexts[textName].setFog();
    }
  }else{
    GLOBAL_FOG_UNIFORM.value.set(-100.0, 0, 0, 0);
  }
  ROYGBIV.globals = new Object();
  if (!isDeployment){
    terminal.printInfo(Text.SWITCHED_TO_PREVIEW_MODE);
  }
  $("#cliDivheader").text("ROYGBIV 3D Engine - CLI (Preview mode)");
  mode = 1;
  this.commonSwitchFunctions();
  handleViewport();
  for (var txtName in addedTexts){
    addedTexts[txtName].handleResize();
    if (addedTexts[txtName].isClickable){
      if (!addedTexts[txtName].is2D){
        clickableAddedTexts[txtName] = addedTexts[txtName];
      }else{
        clickableAddedTexts2D[txtName] = addedTexts[txtName];
      }
    }
  }
}

ModeSwitcher.prototype.switchFromPreviewToDesign = function(){
  mode = 0;
  camera.oldAspect = camera.aspect;
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  if (!isDeployment){
    terminal.printInfo(Text.SWITCHED_TO_DESIGN_MODE);
  }
  $("#cliDivheader").text("ROYGBIV 3D Engine - CLI (Design mode)");
  if (!(typeof originalBloomConfigurations.bloomStrength == UNDEFINED)){
    bloomStrength = originalBloomConfigurations.bloomStrength;
  }
  if (!(typeof originalBloomConfigurations.bloomRadius == UNDEFINED)){
    bloomRadius = originalBloomConfigurations.bloomRadius;
  }
  if (!(typeof originalBloomConfigurations.bloomThreshold == UNDEFINED)){
    bloomThreshold = originalBloomConfigurations.bloomThreshold;
  }
  if (!(typeof originalBloomConfigurations.bloomResolutionScale == UNDEFINED)){
    bloomResolutionScale = originalBloomConfigurations.bloomResolutionScale;
  }
  if (!(typeof originalBloomConfigurations.bloomOn == UNDEFINED)){
    bloomOn = originalBloomConfigurations.bloomOn;
  }
  originalBloomConfigurations = new Object();
  camera.position.set(initialCameraX, initialCameraY, initialCameraZ);
  camera.rotation.order = 'YXZ';
  camera.rotation.set(0, 0, 0);
  screenClickCallbackFunction = 0;
  screenMouseDownCallbackFunction = 0;
  screenMouseUpCallbackFunction = 0;
  screenMouseMoveCallbackFunction = 0;
  screenPointerLockChangedCallbackFunction = 0;
  screenFullScreenChangeCallbackFunction = 0;
  screenKeydownCallbackFunction = 0;
  screenKeyupCallbackFunction = 0;
  terminalTextInputCallbackFunction = 0;
  fpsDropCallbackFunction = 0;
  performanceDropCallbackFunction = 0;
  userInactivityCallbackFunction = 0;
  fpsHandler.reset();
  pointerLockRequested = false;
  fullScreenRequested = false;
  for (var gsName in gridSystems){
    scene.add(gridSystems[gsName].gridSystemRepresentation);
    scene.add(gridSystems[gsName].boundingPlane);
  }
  for (var gridName in gridSelections){
    scene.add(gridSelections[gridName].mesh);
    scene.add(gridSelections[gridName].dot);
  }
  for (var textName in addedTexts){
    var addedText = addedTexts[textName];
    addedText.show();
    addedText.handleResize();
    delete addedText.clickCallbackFunction;
  }
  collisionCallbackRequests = new Object();
  particleCollisionCallbackRequests = new Object();
  particleSystemCollisionCallbackRequests = new Object();

  for (var particleSystemName in particleSystemPool){
    particleSystemPool[particleSystemName].destroy();
  }
  for (var objectName in objectTrails){
    objectTrails[objectName].destroy();
  }
  for (var mergedParticleSystemName in mergedParticleSystems){
    mergedParticleSystems[mergedParticleSystemName].destroy();
  }

  for (var crosshairName in crosshairs){
    crosshairs[crosshairName].destroy();
  }

  for (var markedPointName in markedPoints){
    if (markedPoints[markedPointName].showAgainOnTheNextModeSwitch){
      markedPoints[markedPointName].show();
      markedPoints[markedPointName].showAgainOnTheNextModeSwitch = false;
    }
  }

  if (areasVisible){
    for (var areaName in areas){
      areas[areaName].renderToScreen();
    }
  }

  particleSystems = new Object();
  particleSystemPool = new Object();
  particleSystemPools = new Object();
  objectTrails = new Object();
  mergedParticleSystems = new Object();
  crosshairs = new Object();
  selectedCrosshair = 0;

  for (var objectName in objectGroups){
    var object = objectGroups[objectName];

    object.loadState();
    object.resetColor();

    delete object.clickCallbackFunction;

    if (!(typeof object.originalMass == "undefined")){
      object.setMass(object.originalMass);
      if (object.originalMass == 0){
        delete dynamicObjectGroups[object.name];
      }
      delete object.originalMass;
    }

    if (object.isHidden){
      object.mesh.visible = true;
      object.isHidden = false;
      if (!object.physicsKeptWhenHidden && !object.noMass){
        physicsWorld.add(object.physicsBody);
      }
    }
    if (object.initOpacitySet){
      object.updateOpacity(object.initOpacity);
      object.initOpacitySet = false;
    }
  }
  for (var objectName in addedObjects){
    var object = addedObjects[objectName];

    delete object.clickCallbackFunction;

    object.resetColor();

    if (object.isHidden){
      object.mesh.visible = true;
      object.isHidden = false;
      if (!object.physicsKeptWhenHidden && !object.noMass){
        physicsWorld.add(object.physicsBody);
      }
    }

    object.loadState();
    if (object.initOpacitySet){
      object.updateOpacity(object.initOpacity);
      object.initOpacitySet = false;
    }
    if (!(typeof object.originalMass == "undefined")){
      object.setMass(object.originalMass);
      if (object.originalMass == 0){
        delete dynamicObjects[object.name];
      }
      delete object.originalMass;
    }

  }
  var newScripts = new Object();
  for (var scriptName in scripts){
    newScripts[scriptName] = new Script(
      scriptName,
      scripts[scriptName].script
    );
    newScripts[scriptName].runAutomatically = scripts[scriptName].runAutomatically;
    newScripts[scriptName].localFilePath = scripts[scriptName].localFilePath;
  }
  for (var scriptName in newScripts){
    scripts[scriptName] =  newScripts[scriptName];
    scripts[scriptName].runAutomatically = newScripts[scriptName].runAutomatically;
  }
  newScripts = undefined;
  GLOBAL_FOG_UNIFORM.value.set(-100.0, 0, 0, 0);
  renderer.setViewport(0, 0, canvas.width / screenResolution, canvas.height / screenResolution);

  clickableAddedTexts = new Object();
  clickableAddedTexts2D = new Object();
  this.commonSwitchFunctions();
  for (var txtName in addedTexts){
    var text = addedTexts[txtName];
    text.restore();
    text.handleResize();
  }
  for (var objName in addedObjects){
    addedObjects[objName].removeFog();
  }
  for (var objName in objectGroups){
    objectGroups[objName].removeFog();
  }
  for (var textName in addedTexts){
    addedTexts[textName].removeFog();
  }
}

var ObjectPicker2D = function(){

}

ObjectPicker2D.prototype.find = function(screenSpaceX, screenSpaceY){
  var vPort = renderer.getCurrentViewport();
  var rectX = vPort.x / screenResolution;
  var rectY = vPort.y / screenResolution;
  var rectZ = vPort.z / screenResolution;
  var rectW = vPort.w / screenResolution;
  var webglSpaceX = ((screenSpaceX - rectX) / rectZ) * 2 - 1;
  var webglSpaceY = - ((screenSpaceY - rectY) / rectW) * 2 + 1;
  intersectionPoint = 0, intersectionObject = 0;
  var totalObj = addedTexts2D;
  if (mode == 1){
    totalObj = clickableAddedTexts2D;
  }
  for (var textName in totalObj){
    var textObject = addedTexts2D[textName];
    if (!textObject.mesh.visible){
      continue;
    }
    if (!textObject.twoDimensionalSize){
      textObject.handleResize();
    }
    if (webglSpaceX >= textObject.twoDimensionalSize.x && webglSpaceX <= textObject.twoDimensionalSize.z){
      if (webglSpaceY >= textObject.twoDimensionalSize.w && webglSpaceY <= textObject.twoDimensionalSize.y){
        intersectionPoint = 1;
        intersectionObject = textName;
      }
    }
  }
}

var FPSHandler = function(){
  this.fps = 0;
}

FPSHandler.prototype.onUpdate = function(newFPS){
  if (mode == 1 && newFPS < 60){
    if (fpsDropCallbackFunction){
      fpsDropCallbackFunction(60 - newFPS);
    }
    if (performanceDropCallbackFunction){
      if(newFPS < this.performanceDropMinFPS){
        this.performanceDropCounter ++;
        if (this.performanceDropCounter == this.performanceDropSeconds){
          performanceDropCallbackFunction();
          this.reset();
          performanceDropCallbackFunction = 0;
        }
      }else{
        this.performanceDropCounter = 0;
      }
    }
  }else if (mode == 1 && newFPS >= 60 && performanceDropCallbackFunction){
    this.performanceDropCounter = 0;
  }
  this.fps = newFPS;
}

FPSHandler.prototype.reset = function(){
  this.performanceDropMinFPS = 0;
  this.performanceDropSeconds = 0;
  this.performanceDropCounter = 0;
}

FPSHandler.prototype.initiatePerformanceDropMonitoring = function(minFPS, seconds){
  this.performanceDropMinFPS = minFPS;
  this.performanceDropSeconds = seconds;
  this.performanceDropCounter = 0;
}

